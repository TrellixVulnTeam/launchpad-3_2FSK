
This test demonstrates the reconnecting wrapper.  Compare and contrast to
test_disconnection.txt.

Make a TCP proxy to postgres. Note we have to match the version of
twisted we use with out version of Python.

    >>> import os, sys
    >>> import canonical.lp
    >>> from canonical.database.ftests import getDBHost
    >>> dbhost = getDBHost()
    >>> ver = sys.version[:3]
    >>> cmd = ('mktap%s portforward --port 5555 --dest_port 5432 '
    ...        '--host %s' % (ver, dbhost))
    >>> os.system(cmd)
    0
    >>> os.system('twistd%s -of portforward.tap' % ver)
    0

Wait for the proxy to start.

    >>> import time
    >>> def wait_until_proxy_is_ready():
    ...     start = time.time()
    ...     while time.time() - start < 5:  # loop for a maximum of 5 seconds
    ...         try:
    ...             if 'Starting factory' in open('twistd.log').read():
    ...                 return
    ...         except IOError:
    ...             pass
    ...     raise RuntimeError('Proxy not ready')
    >>> wait_until_proxy_is_ready()

Install the reconnector.

    >>> from canonical.database import reconnect
    >>> reconnect.install()

You can't install the reconnector twice accidentally, though.

    >>> reconnect.install()
    Traceback (most recent call last):
    ...
    AlreadyInstalledError: reconnector already installed
    
Connect to postgres via the proxy.  This will use the reconnector.

    >>> import psycopg
    >>> dsn = 'dbname=%s user=%s host=localhost port=5555' % (
    ...     canonical.lp.dbname, canonical.lp.dbuser)
    >>> conn = psycopg.connect(dsn)

Check that the connection is working normally.

    >>> cur = conn.cursor()
    >>> cur.execute("SELECT 1;")
    >>> cur.fetchone()[0]
    1

Genuine (not connection related) errors still work normally, too.

    >>> cur.execute("SELECT garbage invalid sql;")
    Traceback (most recent call last):
    ...
    ProgrammingError: ERROR:  syntax error at or near "invalid" at character 16
    <BLANKLINE>
    SELECT garbage invalid sql;

Break the connection by stopping the proxy.

    >>> os.system('kill `cat twistd.pid`')
    0

Wait for the proxy to stop.

    >>> import os.path
    >>> def wait_until_proxy_is_stopped():
    ...     start = time.time()
    ...     while time.time() - start < 5:  # loop for a maximum of 5 seconds
    ...         if not os.path.exists('twistd.pid'):
    ...             return
    ...     raise RuntimeError('Proxy would not stop')
    >>> wait_until_proxy_is_stopped()

Executing a query now blocks until the database connection can be reestablished.

    >>> import threading
    >>> thread_result = []
    >>> def foo():
    ...     print "thread start"
    ...     cur.execute('SELECT 1;')
    ...     print "thread after execute"
    ...     thread_result.append(cur.fetchone()[0])
    ...     print "thread end"
    >>> thread = threading.Thread(target=foo)
    >>> thread.start()
    >>> time.sleep(1)
    thread start
    >>> thread_result
    []
    >>> thread.isAlive()
    True

# TODO: test that the disconnection is logged -- spiv

And restart it.

    >>> os.system('twistd%s -of portforward.tap' % ver)
    0
    >>> wait_until_proxy_is_ready()

Now, our blocked thread should've finished successfully.

    >>> time.sleep(1)
    thread after execute
    thread end
    >>> thread_result
    [1]
    >>> thread.isAlive()
    False

Also, using our connection should still work.

    >>> cur.execute("SELECT 1;")
    >>> cur.fetchone()[0]
    1


XXX: Test that interrupting a transaction still fails -- spiv

Clean up the proxy.

    >>> os.system('kill `cat twistd.pid`')
    0
    >>> wait_until_proxy_is_stopped()
    >>> os.remove('twistd.log')
    >>> os.remove('portforward.tap')

Close our connection

    >>> conn.close()

Uninstall the reconnector.

    >>> reconnect.uninstall()

