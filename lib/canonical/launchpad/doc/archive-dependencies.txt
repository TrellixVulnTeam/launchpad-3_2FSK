= Archive dependencies =

`ArchiveDependencies` class models archive dependencies mechanics and
is used to provided the contents of 'sources_list' file used to build
sources in the given IBuildQueue context.

We will user Celso's PPA for testing these mechanisms.

    >>> from canonical.launchpad.interfaces import IPersonSet
    >>> cprov = getUtility(IPersonSet).getByName('cprov')
    >>> print cprov.archive.title
    PPA for Celso Providelo

`component_dependencies` contains a static map of the default ubuntu
component dependencies (known s 'ogre-model').

    >>> from canonical.launchpad.components.archivedependencies import (
    ...     component_dependencies)

    >>> def show_component_deps():
    ...     print "Component  |   Dependencies"
    ...     print "-----------+---------------"
    ...     for key, value in sorted(component_dependencies.items()):
    ...         print "%10s |" % (key,),
    ...         for dep in value:
    ...             print dep,
    ...         print

    >>> show_component_deps()
    Component  |   Dependencies
    -----------+---------------
          main | main
    multiverse | main restricted universe multiverse
       partner | partner
    restricted | main restricted
      universe | main universe

`pocket_dependencies` contains a static map of the default ubuntu
pocket dependencies.

    >>> from canonical.launchpad.components.archivedependencies import (
    ...     pocket_dependencies)

    >>> def show_pocket_deps():
    ...     print "Pocket    |   Dependencies"
    ...     print "----------+---------------"
    ...     for (key, value) in sorted(pocket_dependencies.items()):
    ...         print "%7s |" % (key.name,),
    ...         for pocket in value:
    ...             print pocket.name,
    ...         print

    >>> show_pocket_deps()
    Pocket    |   Dependencies
    ----------+---------------
      RELEASE | RELEASE
     SECURITY | RELEASE SECURITY
      UPDATES | RELEASE SECURITY UPDATES
     PROPOSED | RELEASE SECURITY UPDATES PROPOSED
    BACKPORTS | RELEASE SECURITY UPDATES BACKPORTS

We use `SoyuzTestPublisher` to generate a build candidate in Celso's
PPA content.

    >>> from canonical.launchpad.interfaces.distribution import (
    ...     IDistributionSet)
    >>> from canonical.launchpad.tests.test_publishing import (
    ...     SoyuzTestPublisher)
    >>> from canonical.launchpad.ftests import login

    >>> login('foo.bar@canonical.com')

    >>> test_publisher = SoyuzTestPublisher()

    >>> ubuntu = getUtility(IDistributionSet).getByName('ubuntu')
    >>> hoary = ubuntu.getSeries('hoary')

    >>> test_publisher.addFakeChroots(hoary)
    >>> unused = test_publisher.setUpDefaultDistroSeries(hoary)

    >>> pub_source = test_publisher.getPubSource(archive=cprov.archive)
    >>> [a_build] = pub_source.createMissingBuilds()

Now we can verify if getSourcesListForBuilding() method returns the
expected content for building the just-created source.

    >>> from canonical.launchpad.components.archivedependencies import (
    ...     getSourcesListForBuilding)

    >>> def print_building_sources_list(candidate):
    ...     sources_list = getSourcesListForBuilding(candidate)
    ...     for line in sorted(sources_list):
    ...         print line

Note that only the default ubuntu dependencies for a public PPA will be
considered when building the source candidate. That's because there is
no binary published in Celso's PPA hoary/i386, so there is
not need to request builder to load its archive indexes.

    >>> from canonical.launchpad.interfaces.publishing import (
    ...     PackagePublishingStatus)

    >>> cprov.archive.getAllPublishedBinaries(
    ...      distroarchseries=a_build.distroarchseries,
    ...      status=PackagePublishingStatus.PUBLISHED).count()
    0

    >>> print_building_sources_list(a_build)
    deb http://ftpmaster.internal/ubuntu hoary
    	main restricted universe multiverse
    deb http://ftpmaster.internal/ubuntu hoary-security
    	main restricted universe multiverse
    deb http://ftpmaster.internal/ubuntu hoary-updates
    	main restricted universe multiverse

Once we publish a test binary in Celso's PPA hoary/i386,
this archive becomes relevant for building, and thus listed in the
returned 'sources_list' content.

    >>> pub_binaries = test_publisher.getPubBinaries(
    ...     binaryname='dep-bin', archive=cprov.archive,
    ...     status=PackagePublishingStatus.PUBLISHED)

    >>> print_building_sources_list(a_build)
    deb http://ftpmaster.internal/ubuntu hoary
    	main restricted universe multiverse
    deb http://ftpmaster.internal/ubuntu hoary-security
    	main restricted universe multiverse
    deb http://ftpmaster.internal/ubuntu hoary-updates
    	main restricted universe multiverse
    deb http://ppa.launchpad.dev/cprov/ubuntu hoary main

Similarly, populated PPA dependencies are listed in the building
'sources_list'.

    >>> sabdfl = getUtility(IPersonSet).getByName('sabdfl')
    >>> pub_binaries = test_publisher.getPubBinaries(
    ...     binaryname='dep-bin', archive=sabdfl.archive,
    ...     status=PackagePublishingStatus.PUBLISHED)

    >>> from canonical.launchpad.interfaces.component import IComponentSet
    >>> from canonical.launchpad.interfaces.publishing import (
    ...      PackagePublishingPocket)

    >>> archive_dependency = cprov.archive.addArchiveDependency(
    ...     sabdfl.archive, PackagePublishingPocket.RELEASE,
    ...     getUtility(IComponentSet)['main'])

    >>> print_building_sources_list(a_build)
    deb http://ftpmaster.internal/ubuntu hoary
    	main restricted universe multiverse
    deb http://ftpmaster.internal/ubuntu hoary-security
        main restricted universe multiverse
    deb http://ftpmaster.internal/ubuntu hoary-updates
    	main restricted universe multiverse
    deb http://ppa.launchpad.dev/cprov/ubuntu hoary main
    deb http://ppa.launchpad.dev/sabdfl/ubuntu hoary main

When we make Celso's PPA private, it will be referred via the
private-ppa url including the buildd authentication information.
Additionally to the existing public PPA dependencies, only the RELEASE and
SECURITY ubuntu pockets will be considered.

    >>> cprov.archive.buildd_secret = "secret"
    >>> cprov.archive.private = True

    >>> print_building_sources_list(a_build)
    deb http://buildd:secret@private-ppa.launchpad.dev/cprov/ubuntu
    	hoary main
    deb http://ftpmaster.internal/ubuntu hoary
    	main restricted universe multiverse
    deb http://ftpmaster.internal/ubuntu hoary-security
    	main restricted universe multiverse
    deb http://ppa.launchpad.dev/sabdfl/ubuntu hoary main

The authentication information gets added for private PPA
dependencies.

    >>> sabdfl.archive.buildd_secret = "not-so-secret"
    >>> sabdfl.archive.private = True

    >>> print_building_sources_list(a_build)
    deb http://buildd:not-so-secret@private-ppa.launchpad.dev/sabdfl/ubuntu
    	hoary main
    deb http://buildd:secret@private-ppa.launchpad.dev/cprov/ubuntu
    	hoary main
    deb http://ftpmaster.internal/ubuntu hoary
    	main restricted universe multiverse
    deb http://ftpmaster.internal/ubuntu hoary-security
    	main restricted universe multiverse


== 'Ogre' components ==

The ubuntu 'ogre-model' ensures that build dependencies are
consistently spread according the source target component, i.e. a
source published in 'main' component is only allowed to depend on
binaries also published in 'main', on the other hand a source
published in 'universe' is allowed to depend on binaries published in
'main' and 'universe' components.

A proper name for this "model" would be 'cross-component-dependency'.

    >>> from canonical.launchpad.interfaces import IComponentSet
    >>> from canonical.launchpad.ftests import syncUpdate
    >>> from canonical.database.sqlbase import flush_database_caches

    >>> login('foo.bar@canonical.com')

    >>> ubuntu_components = [
    ...     'main', 'restricted', 'universe', 'multiverse', 'partner']

    >>> from canonical.launchpad.components.archivedependencies import (
    ...     getComponentsForBuilding)

    >>> def testOgreComponents():
    ...     print " Component | Ogre-Model"
    ...     print "-----------+---------------"
    ...     for component in ubuntu_components:
    ...         component = getUtility(IComponentSet)[component]
    ...         pub_source.secure_record.component = component
    ...         syncUpdate(pub_source.secure_record)
    ...         flush_database_caches()
    ...         components_term = " ".join(getComponentsForBuilding(a_build))
    ...         print '%10s | %s' % (a_build.current_component.name,
    ...                              components_term)

    >>> testOgreComponents()
     Component | Ogre-Model
    -----------+---------------
          main | main
    restricted | main restricted
      universe | main universe
    multiverse | main restricted universe multiverse
       partner | partner

As reported in bug #198936, builds for the BACKPORTS pocket are
allowed to use any component available, independently of the component they are
currently published. This special-case is important because it
avoids changes to accommodate the backported source in the already
released series.

    >>> from zope.security.proxy import removeSecurityProxy
    >>> naked_build = removeSecurityProxy(a_build)
    >>> naked_build.pocket = PackagePublishingPocket.BACKPORTS
    >>> syncUpdate(a_build)

Ultimately, it means that a build targeted to the BACKPORTS pocket
will behave as if it were published in the multiverse component,
despite the component it is actually published in.

    >>> testOgreComponents()
     Component | Ogre-Model
    -----------+---------------
          main | main restricted universe multiverse
    restricted | main restricted universe multiverse
      universe | main restricted universe multiverse
    multiverse | main restricted universe multiverse
       partner | main restricted universe multiverse

