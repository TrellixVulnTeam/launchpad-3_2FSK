= An example of EnumCol with EnumeratedTypes =

EnumCol is a type of column that is used in SQLBase classes where the
database representation is an integer and the code uses an enumerated
type.

Firstly we need an example table.

    >>> from canonical.database.sqlbase import cursor
    >>> cur = cursor()
    >>> cur.execute('''
    ...     CREATE TABLE FooTest (
    ...         id serial NOT NULL,
    ...         foo integer DEFAULT 1 NOT NULL
    ...     );
    ... ''')
    >>> cur.execute('GRANT ALL ON TABLE FooTest TO launchpad;')
    >>> cur.execute('GRANT ALL ON footest_id_seq TO launchpad;')
    >>> import transaction
    >>> transaction.commit()

The enumerated type that is used with the EnumCol must be a
DBEnumeratedType, with items that are instances of DBItem.

Attempting to use a normal enumerated type for an enumcol will
result in an error.

    >>> from canonical.lazr import EnumeratedType, Item
    >>> class PlainFooType(EnumeratedType):
    ...     """Enumerated type for the foo column."""
    ...     ONE = Item("One")
    ...     TWO = Item("Two")

    >>> from canonical.database.constants import DEFAULT
    >>> from canonical.database.enumcol import EnumCol
    >>> from canonical.database.sqlbase import SQLBase
    >>> class BadFooTest(SQLBase):
    ...     foo = EnumCol(enum=PlainFooType, default=DEFAULT)
    Traceback (most recent call last):
    ...
    TypeError: enum must be a DBEnumeratedType:
    <class 'canonical.lazr.enum.MetaEnum'>

    >>> from canonical.lazr import DBEnumeratedType, DBItem
    >>> class FooType(DBEnumeratedType):
    ...     """Enumerated type for the foo column."""
    ...     ONE = DBItem(1, """
    ...         One
    ...
    ...         Number one.
    ...         """)
    ...
    ...     TWO = DBItem(2, """
    ...         Two
    ...
    ...         Number two.
    ...         """)

The database implementation class then refers to the enumerated type.

    >>> class FooTest(SQLBase):
    ...     foo = EnumCol(enum=FooType, default=DEFAULT)

Create a row in the table.

    >>> t = FooTest()

The value of the foo column has been set to the default defined in the
database, because we didn't specify one in the constructor.

    >>> t.foo == FooType.ONE
    True

You cannot use integers or strings as EnumCol values:

    >>> t.foo = 2
    Traceback (most recent call last):
    ...
    TypeError: Need to set an EnumeratedType Enum column to an Item, not an int

    >>> t.foo = "TWO"
    Traceback (most recent call last):
    ...
    TypeError: Not a DBItem: <type 'str'>

You can of course use items from FooType.

    >>> t.foo = FooType.TWO
    >>> t.foo
    <DBItem FooType.TWO, (2) Two>

But not items from another schema.

    >>> class AnotherType(DBEnumeratedType):
    ...     ONE = DBItem(1, """
    ...         One
    ...
    ...         Number one.
    ...         """)
    >>> t.foo = AnotherType.ONE
    Traceback (most recent call last):
    ...
    TypeError: DBItem from wrong type, 'FooType' != 'AnotherType'

The type assigned in must be the exact type, not a derived types.

    >>> class DerivedType(FooType):
    ...     """A derived DB enumerated type."""

    >>> item = DerivedType.ONE
    >>> t.foo = item
    Traceback (most recent call last):
    ...
    TypeError: DBItem from wrong type, 'FooType' != 'DerivedType'

A simple way to assign in the correct item is to use the name of the derived
item to access the correct item from the base type.

    >>> t.foo = FooType.items[item.name]
