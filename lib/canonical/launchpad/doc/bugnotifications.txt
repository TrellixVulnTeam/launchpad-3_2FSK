Malone Bug Notifications
========================

What is a bug notification?
---------------------------

A bug notification gets added when something interesting happens to the
bug. It's stored in a a table, and later on a cronscript constructs an
email and sends the notification to the bug's subscribers.

When do bug notifications get added?
-----------------------------------

Not *every* change on a bug causes a notification to be added. This
section will give a rundown of the things that do cause notifications to
be sent. To start with, let's login:

    >>> login("test@canonical.com")

Here are the things that cause bug notifications to be add, and what
those notifications look like.

1. Filing a new bug

    >>> from zope.event import notify
    >>> from zope.publisher.browser import TestRequest
    >>> from canonical.launchpad.event.sqlobjectevent import (
    ...     SQLObjectModifiedEvent, SQLObjectToBeModifiedEvent,
    ...     SQLObjectCreatedEvent)
    >>> from canonical.launchpad.interfaces import (
    ...     IProductSet, IPersonSet, IDistributionSet, IDistroReleaseSet,
    ...     ISourcePackageNameSet, IBugSet, CreateBugParams)

    >>> bug_submitter = getUtility(IPersonSet).get(12)
    >>> firefox = getUtility(IProductSet).get(4)

    >>> params = CreateBugParams(
    ...     title="firefox crashes all the time",
    ...     comment="this is a comment", owner=bug_submitter)
    >>> firefox_crashes = firefox.createBug(params)
    >>> notify(SQLObjectCreatedEvent(firefox_crashes))

    >>> from canonical.launchpad.database import BugNotification
    >>> latest_notification = BugNotification.selectFirst(orderBy='-id')
    >>> print latest_notification.message.owner.displayname
    Sample Person

    >>> latest_notification.is_comment
    True
    >>> print latest_notification.message.text_contents
    this is a comment

2. Editing a bug

    >>> from zope.interface import implements
    >>> from canonical.launchpad.interfaces import IBug

    >>> class MockObject(object):
    ...     implements(IBug)

    >>> bug_before_modification = MockObject()
    >>> for name in IBug.names(all=True):
    ...     setattr(bug_before_modification, name,
    ...             getattr(firefox_crashes, name))
    >>> firefox_crashes.description = "a new description"
    >>> firefox_crashes_modified = SQLObjectModifiedEvent(
    ...     firefox_crashes, bug_before_modification,
    ...     ["description"])
    >>> notify(firefox_crashes_modified)

    >>> latest_notification = BugNotification.selectFirst(orderBy='-id')
    >>> print latest_notification.message.owner.displayname
    Sample Person

    >>> latest_notification.is_comment
    False
    >>> print latest_notification.message.text_contents
    ** Description changed:
    ...

3. Filing a new task on an existing bug

There are three kinds of tasks that can be added to an existing
bug. Let's take a look at each type.

  3.1 Distro Task

    A task that says this bug must be fixed in a certain distro. Because no
    specific release is specified, the developer will assume that the fix
    belongs in the current development release. For backporting a fix to a
    specific distro release, see 3.2.

    >>> from canonical.launchpad.interfaces import IBugTaskSet
    >>> debian = getUtility(IDistributionSet).get(3)
    >>> firefox_source = getUtility(ISourcePackageNameSet).get(1)
    >>> firefox_crashes_in_debian = getUtility(IBugTaskSet).createTask(
    ...     bug=firefox_crashes, distribution=debian,
    ...     sourcepackagename=firefox_source,
    ...     owner=bug_submitter)
    >>> notify(SQLObjectCreatedEvent(firefox_crashes_in_debian))

    >>> latest_notification = BugNotification.selectFirst(orderBy='-id')
    >>> print latest_notification.message.owner.displayname
    Sample Person

    >>> latest_notification.is_comment
    False
    >>> print latest_notification.message.text_contents
    ** Also affects: mozilla-firefox (Debian)
    ...

  3.2 Distro Release Task

    Similar to a distro task, except that a task filed on a specific
    distro release is meant to be used for backport fixes (critical data
    loss or security bugs), or tasks targeted to current and future
    releases. Tasks filed on specific distro releases are not listed in
    the more generic, distro-wide bug task listings.

    >>> sid = getUtility(IDistroReleaseSet).get(8)
    >>> firefox_crashes_in_sid = getUtility(IBugTaskSet).createTask(
    ...     bug=firefox_crashes, distrorelease=sid,
    ...     sourcepackagename=firefox_source, owner=bug_submitter)
    >>> notify(SQLObjectCreatedEvent(firefox_crashes_in_sid))

    >>> latest_notification = BugNotification.selectFirst(orderBy='-id')
    >>> print latest_notification.message.owner.displayname
    Sample Person

    >>> latest_notification.is_comment
    False
    >>> print latest_notification.message.text_contents
    ** Also affects: mozilla-firefox (Debian Sid)
    ...

  3.3 Upstream Task

    An upstream tasks notes that a bug needs to be fixed upstream. "Upstream"
    is a somewhat ambiguous term -- it can have different meanings in the eyes
    of an Ubuntu maintainer vs. a maintainer of a package from an Ubuntu
    derivative. At the moment, "upstream" means "the distro-agnostic place from
    which we procured a source tarball to create a source package for a distro."
    The common case will be that bugs filed in distros bubble up to upstream,
    and are fixed there then bubble back down (via patches) to the various
    distros via patches.

    >>> evolution = getUtility(IProductSet).get(5)
    >>> evolution_crashes_too = getUtility(IBugTaskSet).createTask(
    ...     bug=firefox_crashes, product=evolution, owner=bug_submitter)
    >>> notify(SQLObjectCreatedEvent(evolution_crashes_too))

    >>> latest_notification = BugNotification.selectFirst(orderBy='-id')
    >>> print latest_notification.message.owner.displayname
    Sample Person

    >>> latest_notification.is_comment
    False
    >>> print latest_notification.message.text_contents
    ** Also affects: evolution (upstream)
    ...

  3.4 ProductSeries Task

    Similar to an upstream task, except that a task filed on a specific
    product series is meant to target a bug to a specific release.

    >>> trunk = evolution.getSeries('trunk')
    >>> firefox_crashes_in_trunk = getUtility(IBugTaskSet).createTask(
    ...     bug=firefox_crashes, productseries=trunk, owner=bug_submitter)
    >>> notify(SQLObjectCreatedEvent(firefox_crashes_in_trunk))

    >>> latest_notification = BugNotification.selectFirst(orderBy='-id')
    >>> print latest_notification.message.owner.displayname
    Sample Person

    >>> latest_notification.is_comment
    False
    >>> print latest_notification.message.text_contents
    ** Also affects: evolution trunk (upstream)
    ...


4. Commenting on a bug

    >>> from canonical.launchpad.interfaces import IBugMessageSet

    >>> bugmessageset = getUtility(IBugMessageSet)
    >>> current_user = getUtility(ILaunchBag).user
    >>> comment_on_firefox_crashes_in_debian = bugmessageset.createMessage(
    ...     subject="some title", content="just a test comment",
    ...     bug=firefox_crashes, owner=current_user)
    >>> notify(SQLObjectCreatedEvent(comment_on_firefox_crashes_in_debian))

    >>> latest_notification = BugNotification.selectFirst(orderBy='-id')
    >>> print latest_notification.message.owner.displayname
    Sample Person

    >>> latest_notification.is_comment
    True
    >>> print latest_notification.message.text_contents
    just a test comment

5. Editing a task.

Let's demonstrate a notification email where Sample Person marks a
task Fixed, and assigns himself to it.

    >>> from canonical.launchpad.interfaces import IDistroBugTask
    >>> from canonical.lp.dbschema import BugTaskStatus
    >>> from canonical.launchpad.webapp.snapshot import Snapshot

    >>> bugtask_before_modification = Snapshot(
    ...     firefox_crashes_in_debian, providing=IDistroBugTask)
    >>> firefox_crashes_in_debian.transitionToStatus(BugTaskStatus.FIXRELEASED)
    >>> firefox_crashes_in_debian.transitionToAssignee(bug_submitter)
    >>> debian_task_modified = SQLObjectModifiedEvent(
    ...     firefox_crashes_in_debian, bugtask_before_modification,
    ...     ["status", "assignee"])
    >>> notify(debian_task_modified)

    >>> latest_notification = BugNotification.selectFirst(orderBy='-id')
    >>> print latest_notification.message.owner.displayname
    Sample Person

    >>> latest_notification.is_comment
    False
    >>> print latest_notification.message.text_contents
    ** Changed in: mozilla-firefox (Debian)
    ...

    >>> from canonical.launchpad.interfaces import IProductSeriesBugTask
    >>> bugtask_before_modification = Snapshot(
    ...     firefox_crashes_in_trunk, providing=IProductSeriesBugTask)
    >>> firefox_crashes_in_trunk.transitionToStatus(BugTaskStatus.FIXRELEASED)
    >>> firefox_crashes_in_trunk.transitionToAssignee(bug_submitter)
    >>> firefox_task_modified = SQLObjectModifiedEvent(
    ...     firefox_crashes_in_trunk, bugtask_before_modification,
    ...     ["status", "assignee"])
    >>> notify(firefox_task_modified)

    >>> latest_notification = BugNotification.selectFirst(orderBy='-id')
    >>> print latest_notification.message.owner.displayname
    Sample Person

    >>> latest_notification.is_comment
    False
    >>> print latest_notification.message.text_contents
    ** Changed in: evolution trunk (upstream)
    ...


6. Adding and editing a bug watch.

A bug watch can be added to a bug to watch the status of this bug in a
remote bug tracker. A notification is sent out to the bug notification
recipients when a bug watch is added to a bug. Let's demonstrate by
pretending we've just added a watch to a bug.

    >>> from canonical.launchpad.interfaces import IBugWatchSet
    >>> bugwatch = getUtility(IBugWatchSet).get(2)
    >>> bugwatch_added = SQLObjectCreatedEvent(bugwatch)
    >>> notify(bugwatch_added)

    >>> add_notification = BugNotification.select(orderBy='id')[-1]
    >>> print add_notification.message.owner.displayname
    Sample Person
    >>> add_notification.is_comment
    False
    >>> print add_notification.message.text_contents
    ** Bug watch added: The Mozilla.org Bug Tracker #2000
    https://bugzilla.mozilla.org/show_bug.cgi?id=2000

If the bug watch is modified, a notification is sent out describing
the changes made:

    >>> bugwatch_before_modification = MockObject()
    >>> bugwatch_before_modification.bugtracker = bugwatch.bugtracker
    >>> bugwatch_before_modification.remotebug = bugwatch.remotebug
    >>> bugwatch_before_modification.url = bugwatch.url
    >>> bugwatch.remotebug = "2001"
    >>> bugwatch_modified = SQLObjectModifiedEvent(
    ...     object = bugwatch,
    ...     object_before_modification = bugwatch_before_modification,
    ...     edited_fields = ["remotebug"])

    >>> notify(bugwatch_modified)

    >>> latest_notifications = BugNotification.select(orderBy='id')
    >>> add_notification = latest_notifications[-1]
    >>> remove_notification = latest_notifications[-2]
    >>> print add_notification.message.owner.displayname
    Sample Person
    >>> print remove_notification.message.owner.displayname
    Sample Person

    >>> add_notification.is_comment
    False
    >>> remove_notification.is_comment
    False
    >>> print add_notification.message.text_contents
    ** Bug watch added: The Mozilla.org Bug Tracker #2001
    https://bugzilla.mozilla.org/show_bug.cgi?id=2001
    >>> print remove_notification.message.text_contents
    ** Bug watch removed: The Mozilla.org Bug Tracker #2000
    https://bugzilla.mozilla.org/show_bug.cgi?id=2000

7. Adding and editing a CVE ref.

Adding a CVE reference to a bug also causes a notification email to go
out to the bug notification recipient list. Let's create a CVE ref and
attach it to the firefox_crashes bug that we've been using throughout
this document:

    >>> from canonical.launchpad.interfaces import ICveSet
    >>> from canonical.lp.dbschema import CveStatus
    >>> cve = getUtility(ICveSet).new(sequence="2004-0276",
    ...     description="a brief CVE description", status=CveStatus.ENTRY)
    >>> from canonical.launchpad.database import Bug
    >>> bug = Bug.get(1)
    >>> bugcve = cve.linkBug(bug) # note this creates the event and notifies

    >>> latest_notification = BugNotification.selectFirst(orderBy='-id')
    >>> print latest_notification.message.owner.displayname
    Sample Person

    >>> latest_notification.is_comment
    False
    >>> print latest_notification.message.text_contents
    ** CVE added: http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=2004-0276

8. Adding an external URL reference.

When someone adds a web link to a bug report (e.g. to a related
mailing list discussion), an email is sent to the notification
recipients. We'll demonstrate by creating an external link and
publishing an object created event.

    >>> from canonical.launchpad.interfaces import IBugExternalRefSet
    >>> extref = getUtility(IBugExternalRefSet).createBugExternalRef(
    ...     bug=1, url="http://www.example.com", title="test",
    ...     owner=12)
    >>> extref_added = SQLObjectCreatedEvent(extref)
    >>> notify(extref_added)

    >>> latest_notification = BugNotification.selectFirst(orderBy='-id')
    >>> print latest_notification.message.owner.displayname
    Sample Person

    >>> latest_notification.is_comment
    False
    >>> print latest_notification.message.text_contents
    ** Web link added: http://www.example.com

When a link is edited, the notification will look as follows:

    >>> extref_before_modification = MockObject()
    >>> extref_before_modification.url = extref.url
    >>> extref_before_modification.title = extref.title
    >>> extref.url = "http://www.example.com/somewhere.html"

    >>> extref_changed = SQLObjectModifiedEvent(
    ...     object_before_modification=extref_before_modification,
    ...     object=extref,
    ...     edited_fields=["url"])
    >>> notify(extref_changed)

    >>> remove_notification, add_notification = BugNotification.select(
    ...     orderBy='id')[-2:]
    >>> print remove_notification.message.owner.displayname
    Sample Person

    >>> add_notification.is_comment
    False
    >>> print remove_notification.message.text_contents
    ** Web link removed: http://www.example.com
    >>> print add_notification.message.text_contents
    ** Web link added: http://www.example.com/somewhere.html

9. Marking a bug as a duplicate

When a bug is marked as a duplicate, its subscribers are notified.

    >>> from canonical.launchpad.webapp.snapshot import Snapshot
    >>> bug_one = getUtility(IBugSet).get(1)
    >>> bug_two = getUtility(IBugSet).get(2)
    >>> bug_two_unmodified = Snapshot(bug_two, providing=IBug)
    >>> bug_two.duplicateof = bug_one
    >>> marked_duplicate = SQLObjectModifiedEvent(
    ...     bug_two, bug_two_unmodified, edited_fields=['duplicateof'])
    >>> notify(marked_duplicate)

    >>> latest_notification = BugNotification.selectFirst(orderBy='-id')
    >>> print latest_notification.message.owner.displayname
    Sample Person

    >>> latest_notification.is_comment
    False
    >>> latest_notification.bug.id
    2
    >>> print latest_notification.message.text_contents
    ** This bug has been marked a duplicate of bug 1
       Firefox does not support SVG

Let's change the target of a bug that's already marked as a dupe to show
that the correct notification message is sent.

    >>> bug_six = getUtility(IBugSet).get(6)
    >>> bug_three = getUtility(IBugSet).get(3)
    >>> bug_six_unmodified = Snapshot(bug_six, providing=IBug)
    >>> bug_six.duplicateof = bug_three
    >>> marked_duplicate = SQLObjectModifiedEvent(
    ...     bug_six, bug_six_unmodified, edited_fields=['duplicateof'])
    >>> notify(marked_duplicate)

    >>> latest_notifications = BugNotification.select(orderBy='id')
    >>> dupe_notification = latest_notifications[-1]
    >>> no_dupe_notification = latest_notifications[-2]
    >>> print no_dupe_notification.message.owner.displayname
    Sample Person
    >>> print dupe_notification.message.owner.displayname
    Sample Person

    >>> no_dupe_notification.is_comment
    False
    >>> dupe_notification.is_comment
    False
    >>> no_dupe_notification.bug.id
    6
    >>> dupe_notification.bug.id
    6
    >>> print no_dupe_notification.message.text_contents
    ** This bug is no longer a duplicate of bug 5
       Firefox install instructions should be complete

    >>> print dupe_notification.message.text_contents
    ** This bug has been marked a duplicate of bug 3
       Bug Title Test

Let's unduplicate the above bug and check if the correct notification
message is sent.

    >>> bug_six = getUtility(IBugSet).get(6)
    >>> bug_six_unmodified = Snapshot(bug_six, providing=IBug)
    >>> bug_six.duplicateof = None
    >>> marked_duplicate = SQLObjectModifiedEvent(
    ...     bug_six, bug_six_unmodified, edited_fields=['duplicateof'])
    >>> notify(marked_duplicate)

    >>> latest_notification = BugNotification.selectFirst(orderBy='-id')
    >>> print latest_notification.message.owner.displayname
    Sample Person

    >>> latest_notification.is_comment
    False
    >>> latest_notification.bug.id
    6
    >>> print latest_notification.message.text_contents
    ** This bug is no longer a duplicate of bug 3
       Bug Title Test


10. Expiring Notifications

During bulk imports or changes of bugs, we often want to suppress
email notifications.  Due to the previous operation, there are pending
bug notifications for bug six:

    >>> notifications = BugNotification.select(bug=6, date_emailed=None)
    >>> notifications.count()
    3

These notifications can be expired using the expireNotifications()
method:

    >>> bug_six.expireNotifications()
    >>> notifications = BugNotification.select(bug=6, date_emailed=None)
    >>> notifications.count()
    0


