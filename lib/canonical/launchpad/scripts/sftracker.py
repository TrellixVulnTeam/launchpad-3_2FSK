# Copyright 2006 Canonical Ltd.  All rights reserved.

"""Sourceforge.net Tracker import logic.

This code relies on the output of Frederik Lundh's Sourceforge tracker
screen-scraping tools:

  http://effbot.org/zone/sandbox-sourceforge.htm
"""

__metaclass__ = type

__all__ = []

import datetime
import os
import sys
import time

import pytz

# use cElementTree if it is available ...
try:
    import cElementTree as ET
except:
    import elementtree.ElementTree as ET

# when accessed anonymously, Sourceforge returns dates in this timezone:
SOURCEFORGE_TZ = pytz.timezone('US/Pacific')
UTC = pytz.timezone('UTC')

def _parse_date(datestr):
    year, month, day, hour, minute = time.strptime(datestr,
                                                   '%Y-%m-%d %H:%M')[:5]
    return datetime.datetime(year, month, day, hour, minute,
                             tzinfo=SOURCEFORGE_TZ).astimezone(UTC)


class TrackerAttachment:
    """An attachment associated with a SF tracker item"""

    def __init__(self, attachment_node):
        self.file_id = attachment_node.get('file_id')
        self.content_type = attachment_node.find('content_type').text
        self.title = attachment_node.find('description').text
        self.filename = attachment_node.find('title').text
        self.date = _parse_date(attachment_node.find('date').text)
        self.sender = attachment_node.find('sender').text
        self.data = attachment_node.find('data').text.decode('base-64')

    @property
    def is_patch(self):
        return (self.filename.endswith('patch') or
                self.filename.endswith('diff'))


class TrackerItem:
    """An SF tracker item"""

    def __init__(self, item_node, summary_node):
        self.item_id = item_node.get('id')
        self.datecreated = _parse_date(item_node.find('date_submitted').text)
        self.date_last_updated = _parse_date(
            item_node.find('date_last_updated').text)
        self.title = item_node.find('summary').text
        self.description = item_node.find('description').text
        self.category = item_node.find('category').text
        self.group = item_node.find('group').text
        self.priority = item_node.find('priority').text
        self.resolution = item_node.find('resolution').text
        self.status = item_node.find('status').text
        # We get these two from the summary file because it contains user IDs
        self.reporter = summary_node.find('submitted_by').text
        self.assignee = summary_node.find('assigned_to').text
        # initial comment:
        self.comments = [(self.datecreated, self.reporter, self.description)]
        # remaining comments ...
        for comment_node in item_node.findall('comment'):
            dt = _parse_date(comment_node.find('date').text)
            sender = comment_node.find('sender').text
            description = comment_node.find('description').text
            # does this comment have headers?
            if description.startswith('Date:'):
                headers, description = description.split('\n\n', 1)
            self.comments.append((dt, sender, description))
        # attachments
        self.attachments = [TrackerAttachment(node)
                            for node in item_node.findall('attachment')]


class Tracker:
    """An SF tracker"""

    def __init__(self, dumpfile, dumpdir=None):
        """Create a Tracker instance.

        Dumpfile is a dump of the tracker as generated by xml-export.py
        Dumpdir contains the individual tracker item XML files.
        """
        self.data = ET.parse(dumpfile).getroot()
        if dumpdir is None:
            self.dumpdir = os.path.join(os.path.dirname(dumpfile),
                                        self.data.get('id'))
        else:
            self.dumpdir = dumpdir

    def __iter__(self):
        for item_node in self.data.findall('item'):
            # open the summary file
            summary_file = os.path.join(self.dumpdir,
                                        'item-%s.xml' % item_node.get('id'))
            summary_node = ET.parse(summary_file)
            yield TrackerItem(item_node, summary_node)
