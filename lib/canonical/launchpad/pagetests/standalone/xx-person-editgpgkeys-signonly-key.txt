
Setup the stub KeyServer

  >>> from canonical.zeca.ftests.harness import ZecaTestSetup
  >>> z = ZecaTestSetup()
  >>> z.setUp()
  
Sign only keys are registered on the standard +editgpgkeys page.

  >>> print (http(r"""
  ... GET /people/name12/+editgpgkeys HTTP/1.1
  ... Authorization: Basic dGVzdEBjYW5vbmljYWwuY29tOnRlc3Q=
  ... """))
  HTTP/1.1 200 Ok
  Content-Length: ...
  Content-Type: text/html;charset=utf-8
  ...
    <head>
      <title>Sample Person's OpenPGP keys</title>
  ...

Claim a sign-only OpenPGP key:

  >>> print http(r"""
  ... POST /people/name12/+editgpgkeys HTTP/1.1
  ... Authorization: Basic dGVzdEBjYW5vbmljYWwuY29tOnRlc3Q=
  ... Content-Length: ...
  ... Content-Type: application/x-www-form-urlencoded
  ... 
  ... action=claim_gpg&fingerprint=447DBF38C4F9C4ED752246B77D88913717B05A8F""")
  HTTP/1.1 200 Ok
  Content-Length: ...
  Content-Type: text/html;charset=utf-8
  ...
  ...1024D/17B05A8F...
  ...  

Recover Token URL

  >>> import email, re
  >>> from canonical.launchpad.mail import stub
  >>> from_addr, to_addrs, raw_msg = stub.test_emails.pop()
  >>> msg = email.message_from_string(raw_msg)

Get the message content, and verify that it is not encrypted (we can't
encrypt to sign-only keys):
  
  >>> body = msg.get_payload(decode=True)
  >>> '-----BEGIN PGP MESSAGE-----' in body
  False

Do the usual procedure to extract the token URL
 
  >>> link = re.findall(r'http.*/token/.*', body)[0]
  >>> token = re.sub(r'.*token/', '', link)

Ensure token is ascii to avoid utf-8 mess in URL  

  >>> base_path = '/token/%s' % token.encode('ascii')


When processing a sign-only key, the user is asked to sign some
content that includes the date of the request (to avoid replay
attacks).  To make this testable, we set the date of the token in the
database to a fixed value:

  >>> import pytz, datetime
  >>> from canonical.launchpad.database import LoginToken
  >>> logintoken = LoginToken.selectOneBy(token=token)
  >>> logintoken.created = datetime.datetime(2005,04,01, 12,00,00,
  ...                                        tzinfo=pytz.timezone('UTC'))
  >>> logintoken.sync()


Go to the link given in the email.  Note that we get redirected to the
sign-only key validation page instead of the regular sign-up page.

  >>> print http(r"""
  ... GET %s HTTP/1.1
  ... Authorization: Basic dGVzdEBjYW5vbmljYWwuY29tOnRlc3Q=
  ... """ % base_path)
  HTTP/1.1 303 See Other
  Content-Length: ...
  Content-Type: text/html;charset=utf-8
  Location: .../+validatesignonlygpg
  ...
  ...<h1>You're being redirected</h1>
  ...


We get redirected to the sign-only OpenPGP key validation page, which
includes a phrase that must be signed by the user.  Some things to
note about the phrase:
 * Includes the Launchpad user name, key fingerprint and request time.
 * consists of only ASCII characters

This should make us immune to replay attacks and encoding issues.

  >>> path = '%s/+validatesignonlygpg' % base_path
  >>> print http(r"""
  ... GET %s HTTP/1.1
  ... Authorization: Basic dGVzdEBjYW5vbmljYWwuY29tOnRlc3Q=
  ... """ % path)
  HTTP/1.1 200 Ok
  Content-Length: ...
  Content-Type: text/html;charset=utf-8
  ...
  <title>Confirm sign-only OpenPGP key</title>
  ...
  <pre>Please register 447DBF38C4F9C4ED752246B77D88913717B05A8F to the
  Launchpad user name12.  2005-04-01 12:00:00 UTC</pre>
  ...


Below is a clear-signed version signed with a different key (DFD20543):

  >>> signedcontent = """
  ... -----BEGIN PGP SIGNED MESSAGE-----
  ... Hash: SHA1
  ... 
  ... Please register 447DBF38C4F9C4ED752246B77D88913717B05A8F to the
  ... Launchpad user name12.  2005-04-01 12:00:00 UTC
  ... -----BEGIN PGP SIGNATURE-----
  ... Version: GnuPG v1.4.1 (GNU/Linux)
  ... 
  ... iD8DBQFDcLOh2yWXVgK6XvYRAkpWAKDFHRpVJc2flFwpQMMxub4cl+TcCACgyciu
  ... s7GH1fQGOQMqpvpinwOjGto=
  ... =w7/b
  ... -----END PGP SIGNATURE-----
  ... """

The key validation does not succeed with this key:

  >>> import urllib
  >>> print http(r"""
  ... POST %s HTTP/1.1
  ... Authorization: Basic dGVzdEBjYW5vbmljYWwuY29tOnRlc3Q=
  ... Content-Length: ...
  ... Content-Type: application/x-www-form-urlencoded
  ...
  ... password=test&signedcontent=%s&SUBMIT_CHANGES=Submit"""
  ... % (path, urllib.quote(signedcontent)))
  HTTP/1.1 200 Ok
  Content-Length: ...
  Content-Type: text/html;charset=utf-8
  ...
  <title>Confirm sign-only OpenPGP key</title>
  ...
  ...The key used to sign the content (A419AE861E88BC9E04B9C26FBA2B9389DFD20543) is not the key you were registering...
  ...



Next we try proceeding using a message with an invalid signature (in
this case, a truncated signature):

  >>> signedcontent = """
  ... -----BEGIN PGP SIGNED MESSAGE-----
  ... Hash: SHA1
  ... 
  ... Please register 447DBF38C4F9C4ED752246B77D88913717B05A8F to the
  ... Launchpad user name12.  2005-04-01 12:00:00 UTC
  ... -----BEGIN PGP SIGNATURE-----
  ... Version: GnuPG v1.4.1 (GNU/Linux)
  ... 
  ... """

The key validation does not succeed with this key:

  >>> import urllib
  >>> print http(r"""
  ... POST %s HTTP/1.1
  ... Authorization: Basic dGVzdEBjYW5vbmljYWwuY29tOnRlc3Q=
  ... Content-Length: ...
  ... Content-Type: application/x-www-form-urlencoded
  ...
  ... password=test&signedcontent=%s&SUBMIT_CHANGES=Submit"""
  ... % (path, urllib.quote(signedcontent)))
  HTTP/1.1 200 Ok
  Content-Length: ...
  Content-Type: text/html;charset=utf-8
  ...
  <title>Confirm sign-only OpenPGP key</title>
  ...
  ...Launchpad could not verify your signature: Invocation of op_verify: No data...
  ...


Below is the clear-signed version of the message we are required to
sign, signed with the correct key:

  >>> signedcontent = """
  ... -----BEGIN PGP SIGNED MESSAGE-----
  ... Hash: SHA1
  ... 
  ... Please register 447DBF38C4F9C4ED752246B77D88913717B05A8F to the
  ... Launchpad user name12.  2005-04-01 12:00:00 UTC
  ... -----BEGIN PGP SIGNATURE-----
  ... Version: GnuPG v1.4.1 (GNU/Linux)
  ... 
  ... iD8DBQFDb8MIfYiRNxewWo8RAhtJAJ0TsZWBG9lDZEgterdNQxLI0F9ajACgmx+M
  ... fe5bet4x/Y8R576T9/VFso8=
  ... =JL4/
  ... -----END PGP SIGNATURE-----
  ... """


Confirm the OpenPGP key by proving that we can sign the given phrase with
the key:

  >>> print http(r"""
  ... POST %s HTTP/1.1
  ... Authorization: Basic dGVzdEBjYW5vbmljYWwuY29tOnRlc3Q=
  ... Content-Length: ...
  ... Content-Type: application/x-www-form-urlencoded
  ...
  ... password=test&signedcontent=%s&SUBMIT_CHANGES=Submit"""
  ... % (path, urllib.quote(signedcontent)))
  HTTP/1.1 303 See Other
  Content-Length: ...
  Content-Type: text/html;charset=utf-8
  Location: http://localhost:9000/people/name12?lpnotification=...
  ...
  <title>Confirm sign-only OpenPGP key</title>
  ...
  ...1024D/17B05A8F...
  ...


Check that the key has been imported:

  >>> print http(r"""
  ... GET /people/name12/+editgpgkeys HTTP/1.1
  ... Authorization: Basic dGVzdEBjYW5vbmljYWwuY29tOnRlc3Q=
  ... """)
  HTTP/1.1 200 Ok
  Content-Length: ...
  Content-Type: text/html;charset=utf-8
  ...
  <title>Sample Person's OpenPGP keys</title>
  ...
  1024D/17B05A8F
  (sign only)
  ...


Now that the key has been validated, the login token is removed:

  >>> print LoginToken.selectOneBy(token=token)
  None


Kill stub KeyServer
  
  >>> z.tearDown()
