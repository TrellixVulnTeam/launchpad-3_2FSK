= The 'affects' path in the Bugs e-mail interface =

When choosing which bugtask certain e-mail commands should modify, the
'affects' command is used. It accepts a single argument, the name of the
bug target the bugtask should target. The conversion of a name to an
IBugTarget is done by the AffectsEmailCommand.getBugTarget method.

    >>> from canonical.launchpad.mail.commands import AffectsEmailCommand

It accepts a single parameter, the name/path of the bugtarget. If a
non-existant name/path is given an exception is raised with an
appropriate error message

    >>> AffectsEmailCommand.getBugTarget('non-existant')
    Traceback (most recent call last):
    ...
    BugTargetNotFound: There is no project named 'non-existant'
                       registered in Launchpad.

The same exception is raised also when the name contains slashes:

    >>> AffectsEmailCommand.getBugTarget('non-existant/dapper/evolution')
    Traceback (most recent call last):
    ...
    BugTargetNotFound: There is no project named 'non-existant'
                       registered in Launchpad.

Even though a Project is an IBugTarget, it's not possible to file bugs
on it, so an exception with an appropriate error message is raised.

    >>> AffectsEmailCommand.getBugTarget('gnome')
    Traceback (most recent call last):
    ...
    BugTargetNotFound: It's not possible to file bugs on 'gnome'.

== Getting a product ==

Getting a product is done by specifying the name of the product.

    >>> from canonical.launchpad.interfaces import IProduct
    >>> evolution = AffectsEmailCommand.getBugTarget('evolution')
    >>> IProduct.providedBy(evolution)
    True
    >>> evolution.name
    u'evolution'

Inactive products are treated like non-existant ones.

    >>> from canonical.launchpad.interfaces import IProductSet
    >>> unassigned = getUtility(IProductSet).getByName('unassigned')
    >>> unassigned.active
    False
    >>> AffectsEmailCommand.getBugTarget(unassigned.name)
    Traceback (most recent call last):
    ...
    BugTargetNotFound: There is no project named 'unassigned'
                       registered in Launchpad.

== Getting a product series ==

A product series is a part of a product, so both the product and series
name have to be given, separated with a slash.

    >>> from canonical.launchpad.interfaces import IProductSeries
    >>> evolution_trunk = AffectsEmailCommand.getBugTarget('evolution/trunk')
    >>> IProductSeries.providedBy(evolution_trunk)
    True
    >>> evolution_trunk.product.name
    u'evolution'
    >>> evolution_trunk.name
    u'trunk'

If a non-existant product series is given, an exception is raised with
an appropriate error message.

    >>> AffectsEmailCommand.getBugTarget('evolution/non-existant')
    Traceback (most recent call last):
    ...
    BugTargetNotFound: Evolution doesn't have a series named 'non-existant'.

If some additional path component is included after the series, an
exception with an appropriate error is raised.

    >>> AffectsEmailCommand.getBugTarget('evolution/trunk/foo')
    Traceback (most recent call last):
    ...
    BugTargetNotFound: Unexpected path components: foo

== Getting a distribution ==

Getting a distribution is done by specifying the name of the
distribution.

    >>> from canonical.launchpad.interfaces import IDistribution
    >>> ubuntu = AffectsEmailCommand.getBugTarget('ubuntu')
    >>> IDistribution.providedBy(ubuntu)
    True
    >>> ubuntu.name
    u'ubuntu'

=== Getting a source package in a distribution ===

A distribution source package is a part of a distribution, so both the
distribution and package name has to be specified when getting such a
package.

    >>> from canonical.launchpad.interfaces import IDistributionSourcePackage
    >>> ubuntu_evolution = AffectsEmailCommand.getBugTarget('ubuntu/evolution')
    >>> IDistributionSourcePackage.providedBy(ubuntu_evolution)
    True
    >>> ubuntu_evolution.name
    u'evolution'
    >>> ubuntu_evolution.distribution.name
    u'ubuntu'

If a non-existant source package is given, an exception is raised with
an appropriate error message.

    >>> AffectsEmailCommand.getBugTarget('ubuntu/non-existant')
    Traceback (most recent call last):
    ...
    BugTargetNotFound: Ubuntu doesn't have a release or source package
                       named 'non-existant'.

If some additional path component is included after the package, an
exception with an appropriate error is raised.

    >>> AffectsEmailCommand.getBugTarget('ubuntu/evolution/foo')
    Traceback (most recent call last):
    ...
    BugTargetNotFound: Unexpected path components: foo

== Getting a distribution release ==

A distribution release is a part of a distribution, so both the
distribution and release has to be specified.

    >>> from canonical.launchpad.interfaces import IDistroRelease
    >>> ubuntu_warty = AffectsEmailCommand.getBugTarget('ubuntu/warty')
    >>> IDistroRelease.providedBy(ubuntu_warty)
    True
    >>> ubuntu_warty.name
    u'warty'
    >>> ubuntu_warty.distribution.name
    u'ubuntu'

The path structure for a distribution release is the same as for a
distribution source package, so the same error handling is used for
both.


== Getting a source package in a distribution release ==

When getting a source package within a distribution release, the source
package is given after the distribution release.

    >>> from canonical.launchpad.interfaces import ISourcePackage
    >>> warty_evolution = AffectsEmailCommand.getBugTarget(
    ...     'ubuntu/warty/evolution')
    >>> ISourcePackage.providedBy(warty_evolution)
    True
    >>> warty_evolution.name
    u'evolution'
    >>> warty_evolution.distrorelease.name
    u'warty'
    >>> warty_evolution.distrorelease.distribution.name
    u'ubuntu'

If a non-existant source package is given, an exception is raised with
an appropriate error message.

    >>> AffectsEmailCommand.getBugTarget('ubuntu/warty/non-existant')
    Traceback (most recent call last):
    ...
    BugTargetNotFound: Warty doesn't have a release or source package
                       named 'non-existant'.

If some additional path component is included after the package, an
exception with an appropriate error is raised.

    >>> AffectsEmailCommand.getBugTarget('ubuntu/warty/evolution/foo')
    Traceback (most recent call last):
    ...
    BugTargetNotFound: Unexpected path components: foo

== Error correction ==

Previously the affects path was resolved in the same way, except that
either /distros/ or /products/ was needed in the front. Since people are
used to this syntax, we accept it as well.

    >>> ubuntu = AffectsEmailCommand.getBugTarget('/distros/ubuntu')
    >>> IDistribution.providedBy(ubuntu)
    True
    >>> ubuntu.name
    u'ubuntu'

    >>> evolution = AffectsEmailCommand.getBugTarget('/products/evolution')
    >>> IProduct.providedBy(evolution)
    True
    >>> evolution.name
    u'evolution'
