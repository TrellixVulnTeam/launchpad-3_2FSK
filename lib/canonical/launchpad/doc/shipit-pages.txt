ShipIt Pages
============

    >>> from canonical.launchpad.database import ShippingRequest
    >>> jordis_request = ShippingRequest.get(16)

Let's define a helper function to make it easier to construct a view.

    >>> from zope.component import getView
    >>> from zope.publisher.browser import TestRequest
    >>> from canonical.launchpad.layers import ShipItUbuntuLayer, setFirstLayer
    >>> def create_view(context, name, form=None):
    ...     request = TestRequest(form=form)
    ...     request.notifications = []
    ...     setFirstLayer(request, ShipItUbuntuLayer)
    ...     view = getView(context, name, request)
    ...     return view


/shipit/myrequest
-----------------

This is the only page that normal users have access to. Here they can make new
requests, change/cancel existing ones and see the previous one that were
shipped already.

When a new version of Ubuntu is released, we usually rollout a new shipit
code, but we need to keep it closed until everything is ready. It's a good
thing to do this through the web UI, so we don't depend on a new rollout to
open it. To achieve this we rely on the predefined quantities of CDs that
people can choose when making a request. That is, if there's no predefined
quantities, shipit is considered closed, otherwise it's considered open.

    >>> from canonical.launchpad.ftests import login
    >>> login('test@canonical.com')
    >>> from canonical.launchpad.systemhomes import ShipItApplication
    >>> shipit = ShipItApplication()
    >>> myrequest_view = create_view(shipit, 'myrequest')
    >>> html = myrequest_view.render()
    >>> 'How many CDs would you like?' in html
    True
    >>> 'ShipIt is currently closed' in html
    False

    >>> myrequest_view.standardShipItRequests = lambda: []
    >>> html = myrequest_view.render()
    >>> 'How many CDs would you like?' in html
    False
    >>> 'ShipIt is currently closed' in html
    True


/shipit/requests/XX
-----------------

This is the page where shipit admins go to approve, deny or change an existing
request.

In this page we display a table of Flavours X Architectures, containing the
widgets for the quantities of requested CDs of a given flavour and arch. These
widgets must always be ordered according to the order we use in the table
headers, or we'll start shipping wrong CDs to people. This order is specified
by the ordered_flavours and ordered_architectures attributes of the view
class.

    >>> review_request_view = create_view(jordis_request, '+edit')
    >>> [flavour.title for flavour in review_request_view.ordered_flavours]
    ['Ubuntu', 'Kubuntu', 'Edubuntu']

    >>> [arch.title for arch in review_request_view.ordered_architectures]
    ['PC', '64-bit PC', 'Mac']

And this is the order we use when generating the widgets matrix.

    >>> matrix = review_request_view.widgetsMatrixWithFlavours()
    >>> for row in matrix:
    ...     newrow = []
    ...     for cel in row:
    ...         if isinstance(cel, basestring) or cel is None:
    ...             newrow.append(cel)
    ...         else:
    ...             newrow.append(cel.label)
    ...     print newrow
    ['Ubuntu', u'PC', u'64-bit PC', u'Mac']
    ['Kubuntu', u'PC', u'64-bit PC', None]
    ['Edubuntu', u'PC', None, None]

Similarly to the quantity widgets, we use a table to display the quantities
requested by the user. But in this case, the shipit admins are not supposed to
change these values, so we don't need widgets.

    >>> for row in review_request_view.quantities_matrix:
    ...     print row
    ['Kubuntu', 5]
    ['Edubuntu', 5]

