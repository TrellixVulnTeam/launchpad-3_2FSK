= The Queue Builder =

QueueBuilder is a script to sanely initialize new build jobs. It
verifies each DistroArchSeries that is available for which we are
able to:

 * Build packages,
 * Repair broken Build entries, if it makes sense to do so,
 * Verify the packages pending to build,
 * Install the jobs in the BuildQueue table, and
 * Score the build according to a set of parameters, which will be
   discussed later.


== Setting up ==

    >>> import tempfile, os, operator
    >>> from canonical.buildmaster.master import (
    ...   BuilddMaster, determineArchitecturesToBuild)

Import the bunch of required database classes:

    >>> from canonical.launchpad.database import (
    ...      Build, BuildQueue, DistroArchSeries, DistroSeries,
    ...      PocketChroot, SecureSourcePackagePublishingHistory,
    ...      SourcePackagePublishingHistory)

    >>> from canonical.launchpad.interfaces import (
    ...      PackagePublishingPocket, PackagePublishingStatus)

The Master side of Buildd requires access to Launchpad Database, the
user designed for this kind of access is 'fiera', see
test_system_documentation.py for more information.

    >>> import logging
    >>> logger = logging.getLogger()

Now that we have satisfied all of the needs for BuildMaster, let's
instantiate it.

    >>> build_master = BuilddMaster(logger, transaction)

Emulate a PocketChroot entry to validate the following
distroarchseries:

 * Ubuntu/Warty/i386/RELEASE
 * Ubuntu/Hoary/i386/RELEASE
 * Debian/Woody/i386/RELEASE

    >>> warty = DistroSeries.selectOneBy(name="warty")
    >>> unused = PocketChroot(distroarchseries=warty['i386'], chroot=1)

    >>> hoary = DistroSeries.selectOneBy(name='hoary')
    >>> unsused = PocketChroot(distroarchseries=hoary['i386'], chroot=1)
    >>> unused = PocketChroot(distroarchseries=hoary['hppa'], chroot=2)

    >>> woody = DistroSeries.selectOneBy(name='woody')
    >>> unused = PocketChroot(distroarchseries=woody['i386'], chroot=3)

Produce a set of available DistroArchSeries, for which the
build jobs will be created.

    >>> distroserieses = set()

    >>> for archseries in DistroArchSeries.select():
    ...     distroserieses.add(archseries.distroseries)
    ...     build_master.addDistroArchSeries(archseries)

    >>> distroserieses = sorted(
    ...     distroserieses, key=operator.attrgetter('name'))

Among all the available distroarchseries only the one with chroot will
be considered.

    >>> valid_archs = sorted(build_master._archserieses.keys(),
    ...                      key=operator.attrgetter('id'))
    >>> for arch in valid_archs:
    ...     print arch.title
    The Warty Warthog Release for i386 (x86)
    The Hoary Hedgehog Release for i386 (x86)
    WOODY for i386 (x86)
    The Hoary Hedgehog Release for hppa (hppa)


== Ensure sampledata is processed ==

Kick off any pending builds we have to avoid any misleading result in
our tests (there are a couple that will be created based on our
sampledata).

This is to allow us to study carefully what is being added as we add
new series and builds.

    >>> for series in distroserieses:
    ...      build_master.createMissingBuilds(series)

Add the missing build queue entries.

    >>> build_master.addMissingBuildQueueEntries()

Store current status of the database:

    >>> old_build_ids = [build.id for build in Build.select()]
    >>> old_job_ids = [build_queue.id for build_queue in BuildQueue.select()]


== Create some series and publications ==

Define a helper function to create series and publications for those
series.

We need to publish the source in order to get it visible to the
createMissingBuilds() method. Additionally if the target is an already
released distroseries it can only be visible if published in special
pocket (UPDATES, SECURITY, PROPOSED or BACKPORTS)

    >>> from canonical.launchpad.interfaces import IPersonSet
    >>> cprov = getUtility(IPersonSet).getByName('cprov')

    >>> from canonical.database.sqlbase import commit
    >>> from canonical.launchpad.tests.test_publishing import (
    ...     SoyuzTestPublisher)
    >>> from canonical.testing.layers import LaunchpadZopelessLayer

    >>> commit()
    >>> LaunchpadZopelessLayer.switchDbUser('launchpad')

We will use SoyuzTestPublisher to create a set of publications used to
test the 'queue-builder' component.

    >>> test_publisher = SoyuzTestPublisher()
    >>> test_publisher.prepareBreezyAutotest()

A source published in warty/UPDATES, a stable release update, we
expect it to result in a build.

    >>> pub_updates = test_publisher.getPubSource(
    ...     sourcename='test-updates', version='665', distroseries=warty,
    ...     status=PackagePublishingStatus.PUBLISHED,
    ...     pocket=PackagePublishingPocket.UPDATES)

A source published in warty/RELEASE, it will be ignored.

    >>> pub_ignored = test_publisher.getPubSource(
    ...     sourcename='test-buildd', version='666', distroseries=warty,
    ...     status=PackagePublishingStatus.PUBLISHED,
    ...     pocket=PackagePublishingPocket.RELEASE)

Several source publications for ubuntu/hoary/RELEASE, which is in
DEVELOPMENT state, so we expect builds to be created respecting
architecturehintlist and PAS.

    >>> pub_all = test_publisher.getPubSource(
    ...     sourcename='test-buildd', version='667', distroseries=hoary,
    ...     status=PackagePublishingStatus.PUBLISHED,
    ...     pocket=PackagePublishingPocket.RELEASE)

    >>> pub_any = test_publisher.getPubSource(
    ...     sourcename='test-buildd-2', version='668', distroseries=hoary,
    ...     architecturehintlist="any",
    ...     status=PackagePublishingStatus.PUBLISHED,
    ...     pocket=PackagePublishingPocket.RELEASE)

    >>> pub_three = test_publisher.getPubSource(
    ...     sourcename='test-buildd-3', version='669', distroseries=hoary,
    ...     architecturehintlist="i386 hppa amd64",
    ...     status=PackagePublishingStatus.PUBLISHED,
    ...     pocket=PackagePublishingPocket.RELEASE)

    >>> pub_one = test_publisher.getPubSource(
    ...     sourcename='test-buildd-4', version='670', distroseries=hoary,
    ...     architecturehintlist="hppa",
    ...     status=PackagePublishingStatus.PUBLISHED,
    ...     pocket=PackagePublishingPocket.RELEASE)

Source publication for debian/woody, it won't result in a new build
because this distroseries lacks 'nominatedarchindep'.

    >>> pub_woody = test_publisher.getPubSource(
    ...     sourcename='test-buildd-5', version='671', distroseries=woody,
    ...     architecturehintlist="hppa",
    ...     status=PackagePublishingStatus.PUBLISHED,
    ...     pocket=PackagePublishingPocket.RELEASE)

Other sources publications to hoary, they use the extended
architecturehintlist kernel notation, see below.

    >>> pub_any_foo = test_publisher.getPubSource(
    ...     sourcename='test-buildd-6', version='672', distroseries=hoary,
    ...     architecturehintlist="any-hppa",
    ...     status=PackagePublishingStatus.PUBLISHED,
    ...     pocket=PackagePublishingPocket.RELEASE)

    >>> pub_linux_foo = test_publisher.getPubSource(
    ...     sourcename='test-buildd-7', version='673', distroseries=hoary,
    ...     architecturehintlist="linux-i386",
    ...     status=PackagePublishingStatus.PUBLISHED,
    ...     pocket=PackagePublishingPocket.RELEASE)

Finally a publication in Celso's PPA, a build will be created for it
respecting only 'architecturehintlist' and PPA-supported architecture,
it won't be submitted to PAS.

    >>> pub_hoary_ppa = test_publisher.getPubSource(
    ...     sourcename='test-ppa', version='674', distroseries=hoary,
    ...     architecturehintlist="i386 hppa", archive=cprov.archive,
    ...     status=PackagePublishingStatus.PUBLISHED,
    ...     pocket=PackagePublishingPocket.RELEASE)

    >>> commit()
    >>> LaunchpadZopelessLayer.switchDbUser(test_dbuser)


== Package Architecture Specific ==

The Package-Architecture-Specific (PAS) module is a parser to a set
of restrictions to build packages based on archive-admin experiences.

Those restrictions overlap the metadata information from the source
packages (architecturehintlist).


=== Source PAS ===

    >>> from canonical.buildmaster.pas import BuildDaemonPackagesArchSpecific

Write a harness that lets us easily test PAS statements:

    >>> def getPASVerifier(pas_string, series=hoary):
    ...   """Build and return a PAS verifier based on the string provided."""
    ...   temp_dir = tempfile.mkdtemp()
    ...   pas_filename = os.path.join(temp_dir, "Packages-arch-specific")
    ...   pas_file = file(pas_filename, "w")
    ...   pas_file.write(pas_string)
    ...   pas_file.close()
    ...   pas_verify = BuildDaemonPackagesArchSpecific(temp_dir, series)
    ...   os.unlink(pas_filename)
    ...   return pas_verify

    >>> legal_archs = set(hoary.architectures)

First check a positive source listing:

    >>> pas_verify = getPASVerifier("%test-buildd-3: i386")
    >>> [arch.architecturetag for arch in
    ...  determineArchitecturesToBuild(pub_three, legal_archs, hoary,
    ...                                pas_verify)]
    [u'i386']

And now a negative source listing:

    >>> pas_verify = getPASVerifier("%test-buildd-3: !i386")
    >>> [arch.architecturetag for arch in
    ...  determineArchitecturesToBuild(pub_three, legal_archs, hoary,
    ...                                pas_verify)]
    [u'hppa']

And a source listing which causes us to produce no builds:

    >>> pas_verify = getPASVerifier("%test-buildd-3: sparc")
    >>> [arch.architecturetag for arch in
    ...  determineArchitecturesToBuild(pub_three, legal_archs, hoary,
    ...                                pas_verify)]
    []

PPA builds are not affected by PAS restrictions, i.e., they will
build for all requested architectures currently supported in the PPA
subsystem.

    >>> pas_verify = getPASVerifier("%test-ppa: hppa")
    >>> [arch.architecturetag for arch in
    ...  determineArchitecturesToBuild(pub_hoary_ppa, legal_archs,
    ...                                hoary, pas_verify)]
    [u'i386']

    >>> pas_verify = getPASVerifier("%test-ppa: !i386")
    >>> [arch.architecturetag for arch in
    ...  determineArchitecturesToBuild(pub_hoary_ppa, legal_archs,
    ...                                hoary, pas_verify)]
    [u'i386']


== Binary PAS ==

To check binary PAS listings we'll use a source publication for
iceweasel which produces mozilla-firefox binaries in warty and already
has its data set up.

    >>> firefox_pub = SecureSourcePackagePublishingHistory.get(28)
    >>> print firefox_pub.sourcepackagerelease.title
    iceweasel - 1.0
    >>> print firefox_pub.sourcepackagerelease.architecturehintlist
    any
    >>> iceweasel_binaries = warty.getSourcePackage(
    ...     'iceweasel')['1.0'].binaries
    >>> [binary.title for binary in iceweasel_binaries]
    [u'mozilla-firefox-1.0']

    >>> legal_archs = set(warty.architectures)
    >>> sorted([arch.architecturetag
    ...         for arch in legal_archs], reverse=True)
    [u'i386', u'hppa']

Restrict iceweasel targets to i386 and sparc, since the latter is not
present in warty, we will only create a build for i386:

    >>> pas_verify = getPASVerifier(
    ...     "mozilla-firefox: i386 sparc", series=warty)
    >>> permitted_archs = determineArchitecturesToBuild(
    ...      firefox_pub, legal_archs, warty, pas_verify)
    >>> [arch.architecturetag for arch in permitted_archs]
    [u'i386']

And a binary PAS listing that tries to exclude i386 and hppa from an
arch-any build. The exclusion of i386 is ignored; see comment in
pas.py:_handleBinaryPAS for more information on why.

    >>> pas_verify = getPASVerifier(
    ...     "mozilla-firefox: !i386 !hppa", series=warty)
    >>> permitted_archs = determineArchitecturesToBuild(
    ...      firefox_pub, legal_archs, warty, pas_verify)
    >>> [arch.architecturetag for arch in permitted_archs]
    [u'i386']

XXX cprov 20071211: we can't properly test PPA binary-PAS right now
because there is no binary package published in PPA. The way the PAS
component is completely ignored for PPAs indicates that we are safe,
however, for now, we have to rely on the previous primary-archive tests.
See bug 189025.

== Check the architectures ==

See if the code which determines archs to build does the right thing for
each of these options:

    >>> legal_archs = set(hoary.architectures)
    >>> [arch.architecturetag for arch in
    ...  determineArchitecturesToBuild(pub_all, legal_archs, hoary)]
    [u'i386']
    >>> [arch.architecturetag for arch in
    ...  determineArchitecturesToBuild(pub_any, legal_archs, hoary)]
    [u'hppa', u'i386']
    >>> [arch.architecturetag for arch in
    ...  determineArchitecturesToBuild(pub_three, legal_archs, hoary)]
    [u'hppa', u'i386']
    >>> [arch.architecturetag for arch in
    ...  determineArchitecturesToBuild(pub_one, legal_archs, hoary)]
    [u'hppa']

== Check any-foo and linux-foo notation in architecture hint list ==

See bug 73761.

    >>> [arch.architecturetag for arch in
    ...  determineArchitecturesToBuild(pub_any_foo, legal_archs, hoary)]
    [u'hppa']
    >>> [arch.architecturetag for arch in
    ...  determineArchitecturesToBuild(pub_linux_foo, legal_archs, hoary)]
    [u'i386']


== PPA architectures ==

Only the architecture with established support for PPA will be
considered when creating PPA builds. See distroarchseries.txt for
further information.

    >>> legal_archs = set(hoary.architectures)
    >>> [arch.architecturetag for arch in
    ...  determineArchitecturesToBuild(pub_hoary_ppa, legal_archs, hoary)]
    [u'i386']


== Create and verify the new builds ==

Create missing builds (packages w/o build entry) for those distroserieses.
We expect to have a couple of new builds for the sane Hoary and a warning about
the absence of nominatedarchindep field for Woody:

    >>> for series in distroserieses:
    ...      build_master.createMissingBuilds(series)

Check that we only created new Build entries for the new hoary releases:

    >>> new_builds = [build for build in Build.select()
    ...               if build.id not in old_build_ids]
    >>> for build in sorted(new_builds, key=operator.attrgetter('id')):
    ...   print build.title
    i386 build of test-buildd 667 in ubuntu hoary RELEASE
    hppa build of test-buildd-2 668 in ubuntu hoary RELEASE
    i386 build of test-buildd-2 668 in ubuntu hoary RELEASE
    hppa build of test-buildd-3 669 in ubuntu hoary RELEASE
    i386 build of test-buildd-3 669 in ubuntu hoary RELEASE
    hppa build of test-buildd-4 670 in ubuntu hoary RELEASE
    hppa build of test-buildd-6 672 in ubuntu hoary RELEASE
    i386 build of test-buildd-7 673 in ubuntu hoary RELEASE
    i386 build of test-ppa 674 in ubuntu hoary RELEASE
    i386 build of test-updates 665 in ubuntu warty UPDATES

And have a look at our architecture-independent-source's build:

    >>> arch_indep_build = Build.selectOneBy(
    ...     sourcepackagerelease=pub_all.sourcepackagerelease)

    >>> print arch_indep_build.title
    i386 build of test-buildd 667 in ubuntu hoary RELEASE


== Create and verify the new queue entries ==

BuildQueue records corresponding to the build records in NEEDSBUILD
state are immediately created.

    >>> active_jobs = [
    ...     build_queue for build_queue in BuildQueue.select(orderBy='id')
    ...     if build_queue.id not in old_job_ids]
    >>> len(active_jobs)
    10

The BuildQueue entries created are already 'scored', meaning the job
can be dispatched once operation is committed, i.e. dispatching can
happen in parallel with build creation.

    >>> build_queue = active_jobs[0]
    >>> print build_queue.build.title
    i386 build of test-buildd 667 in ubuntu hoary RELEASE
    >>> build_queue.lastscore
    1005

Check the published component name retriever, they might be different,
i.e., the published component can be different than the original component.

    >>> print build_queue.build.current_component.name
    main
    >>> print build_queue.build.sourcepackagerelease.component.name
    main

Missing BuildQueue records, resulting from given-back builds, are
created in the last stage of the queue-builder script.

    >>> given_back_build = build_queue.build
    >>> build_queue.destroySelf()
    >>> flush_database_updates()

    >>> print given_back_build.buildqueue_record
    None

    >>> build_master.addMissingBuildQueueEntries()

    >>> given_back_build.buildqueue_record is not None
    True
