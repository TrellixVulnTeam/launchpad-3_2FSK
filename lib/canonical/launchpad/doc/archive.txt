= Personal Package Archives =

An Archive models a Debian Archive ...

  >>> from zope.interface.verify import verifyObject
  >>> from canonical.lp.dbschema import ArchivePurpose
  >>> from canonical.launchpad.interfaces import (
  ...     IPerson, IPersonSet, IArchiveSet, IArchive,
  ...     IDistributionSet)

Let get the IArchiveSet utility:

  >>> archive_set = getUtility(IArchiveSet)

A new Archive can be created by passing a name and an owner

  >>> name16 = getUtility(IPersonSet).getByName('name16')
  >>> sandbox_archive = archive_set.new(purpose=ArchivePurpose.PPA, 
  ...     owner=name16)

  >>> verifyObject(IArchive, sandbox_archive)
  True

  >>> sandbox_archive.owner == name16
  True

An archive is also associated with a distribution.  This can be queried on
the distribution property.  The default distribution is "ubuntu":

  >> sandbox_archive.distribution.name
  u'ubuntu'

An Archive can be retrieved via IPerson.archive SingleJoin:

  >>> name16.archive == sandbox_archive
  True

Alter the distribution for name16's archive before continuing (ubuntutest
has a working LucilleConfig):

  >>> from zope.security.proxy import removeSecurityProxy
  >>> ubuntutest = getUtility(IDistributionSet)['ubuntutest']
  >>> removeSecurityProxy(sandbox_archive).distribution = ubuntutest

IArchive has a method to provide a modified Publisher Configuration (see
lib/archivepublisher/config.py), which provides the right paths for its
publication according to the given distribution:

  >>> proxied_pubconfig = sandbox_archive.getPubConfig()

XXX cprov 20061127: Publisher Config is missing interface.

  >>> pubconfig = removeSecurityProxy(proxied_pubconfig)

The base Archive publication location is set in the current Launchpad
configuration file:

  >>> from canonical.config import config
  >>> pubconfig.distroroot == config.personalpackagearchive.root
  True

Then, the archive topology will follow:

<PPA_BASE_DIR>/<PERSONNAME>/<DISTRIBUTION>

  >>> pubconfig.archiveroot
  u'/var/tmp/ppa.test/name16/ubuntutest'

  >>> pubconfig.poolroot
  u'/var/tmp/ppa.test/name16/ubuntutest/pool'

  >>> pubconfig.distsroot
  u'/var/tmp/ppa.test/name16/ubuntutest/dists'

Path not used in *personal* archives publication workflow are set to
None, so they won't get created:

  >>> pubconfig.overrideroot is None
  True
  >>> pubconfig.cacheroot is None
  True
  >>> pubconfig.miscroot is None
  True

Usual methods from Publisher Configuration are preserved:

  >>> pubconfig.distroSeriesNames()
  ['breezy-autotest', 'hoary-test']

  >>> pubconfig.archTagsForSeries('breezy-autotest')
  []

  >>> pubconfig.componentsForSeries('breezy-autotest')
  ['main', 'restricted', 'universe', 'multiverse']


IArchiveSet.getAllPPAs provides all present *personal* archive:

  >>> [archive.owner.name for archive in archive_set.getAllPPAs()]
  [u'cprov', u'sabdfl', u'name16']


IArchiveSet.getByDistroPurpose retrieves an IArchive given a distribution
and an ArchivePurpose:

  >>> from canonical.lp.dbschema import ArchivePurpose
  >>> commercial_archive = getUtility(IArchiveSet).getByDistroPurpose(
  ...     ubuntutest, ArchivePurpose.COMMERCIAL)
  >>> commercial_archive.description
  u'Commercial archive'


IArchive.archive_url will return a URL for the archive that the builder can
use to retrieve files from it.

  >>> commercial_archive.archive_url
  u'http://launchpad.dev/ubuntutest-commercial'

  >>> sandbox_archive.archive_url
  u'http://ppa.launchpad.dev/name16/ubuntu'

  >>> getUtility(IArchiveSet).getByDistroPurpose(ubuntutest,
  ...     ArchivePurpose.PRIMARY).archive_url
  u'http://launchpad.dev/ubuntutest'


The publisher config for COMMERCIAL contains only 'commercial' in its
components.  This prevents non-commercial being published in the commercial
archive.

  >>> comm_pubconf = removeSecurityProxy(
  ...     commercial_archive.getPubConfig())
  >>> for distroseries in comm_pubconf._distroserieses.keys():
  ...     components = set(
  ...         comm_pubconf._distroserieses[distroseries]['components'])
  ...     print components
  set(['commercial'])
  set(['commercial'])

IArchiveSet.getByDistroComponent retrieves an IArchive given a distribution
and a component name.  This is used when you want to override the archive
based on the component.  If the component is unknown, None is returned.

  >>> commercial_archive = getUtility(IArchiveSet).getByDistroComponent(
  ...     ubuntutest, 'commercial')
  >>> commercial_archive.description
  u'Commercial archive'

  >>> other_archive = getUtility(IArchiveSet).getByDistroComponent(
  ...     ubuntutest, 'dodgycomponent')
  >>> print other_archive
  None


Iteration over the own utility is performed against all archives,
including the *main_archives*:

  >>> main_archives = 0
  >>> ppas = 0
  >>> for archive in archive_set:
  ...     if archive.owner is None:
  ...          main_archives += 1
  ...     else:
  ...          ppas += 1
  >>> main_archives, ppas
  (9, 3)

