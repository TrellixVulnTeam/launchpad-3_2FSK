= Buildd Slave Scanner =

The Buildd Slave scanner is able to run over the build jobs being
processed in the current BuildFarm and collect information about the
status of the process, collect the results of finished jobs and
automatically dispatch new jobs to idle slaves.

The Master side of Buildd requires access to Launchpad Database, the
user designed for this kind of access is 'fiera', as in all test the
transaction should be retrieved.

    >>> from canonical.database.sqlbase import ZopelessTransactionManager
    >>> local_transaction = ZopelessTransactionManager._installed

We check for sent mails in some places, so load the stub mailer:

    >>> from lp.services.mail import stub
    >>> from canonical.database.sqlbase import commit

And create a utility function to make tests easier to read.

    >>> def check_mail_sent(last_stub_mail_count):
    ...    commit()
    ...    return len(stub.test_emails) == last_stub_mail_count + 3

The master also requires an 'logging' instance to not compromise the
standard output with noisily output.

    >>> import logging
    >>> logger = logging.getLogger()

Import MockBuilder and a series of MockSlaves to be used in this test.

    >>> from lp.buildmaster.tests.mock_slaves import (
    ...    AbortedSlave, AbortingSlave, BuildingSlave,
    ...    MockBuilder, OkSlave, WaitingSlave)



The Builddmaster should crash when collecting builds which are denied in
the given distroseries/pocket. Anytime it happens we need to manually
investigate why this build end up built. (should never happen in real
cases, and even so should be refused when we try to upload it.)

    >>> bqItem12 = getUtility(IBinaryPackageBuildSet).getByBuildID(
    ...     2).queueBuild()
    >>> setupBuildQueue(bqItem12, a_builder)
    >>> last_stub_mail_count = len(stub.test_emails)

Create a mock slave so the builder gets the right responses for this test.

    >>> bqItem12.builder.setSlaveForTesting(WaitingSlave('BuildStatus.OK'))
    >>> a_builder.updateBuild(bqItem12)
    Traceback (most recent call last):
    ...
    AssertionError: i386 build of mozilla-firefox 0.9 in ubuntu warty RELEASE (2) can not be built for pocket RELEASE: illegal status

We need 'a_builder' released (from 'bqItem12') so it can be associated with
'bqItem10' below.

    >>> bqItem12.builder = None


== Setup chroots ==

Retrieve a known DistroArchSeries

    >>> from canonical.launchpad.interfaces import IDistributionSet
    >>> hoary_i386 = getUtility(IDistributionSet)['ubuntu']['hoary']['i386']
    >>> warty_i386 = getUtility(IDistributionSet)['ubuntu']['warty']['i386']

Create a totally bogus CHROOT

    >>> from canonical.launchpad.database import LibraryFileAlias
    >>> fake_chroot = LibraryFileAlias.get(1)
    >>> unused = hoary_i386.addOrUpdateChroot(fake_chroot)
    >>> unused = warty_i386.addOrUpdateChroot(fake_chroot)


== Build Dispatching ==

Build dispatching can be entirely done via IBuilder content class
using the findAndStartJob method.

We will use SoyuzTestPublisher to simulate the required context in the
next tests. Let's initialise it.

    >>> from lp.soyuz.tests.test_publishing import (
    ...     SoyuzTestPublisher)
    >>> from canonical.testing.layers import LaunchpadZopelessLayer

    >>> test_publisher = SoyuzTestPublisher()

    >>> commit()
    >>> LaunchpadZopelessLayer.switchDbUser('launchpad')

    >>> test_publisher.prepareBreezyAutotest()

    >>> commit()
    >>> LaunchpadZopelessLayer.switchDbUser(config.builddmaster.dbuser)

Helper function to create binary publications in this test.

    >>> def create_binary_publication_for(archive, distroseries, status):
    ...     commit()
    ...     LaunchpadZopelessLayer.switchDbUser('launchpad')
    ...     login('foo.bar@canonical.com')
    ...     pub_binaries = test_publisher.getPubBinaries(
    ...         archive=archive, distroseries=distroseries,
    ...         status=status)
    ...     commit()
    ...     LaunchpadZopelessLayer.switchDbUser(config.builddmaster.dbuser)
    ...     login(ANONYMOUS)

We will reset the sampledata building job before continue with the
tests.

    >>> current_job = a_builder.currentjob
    >>> resurrect_build = getUtility(IBinaryPackageBuildSet).getByQueueEntry(
    ...     current_job)
    >>> resurrect_build.status = BuildStatus.NEEDSBUILD
    >>> current_job.builder = None
    >>> current_job.setDateStarted(None)
    >>> current_job.lastscore = 0

IBuilder.findCandidate also identifies if there are builds for
superseded source package releases in the queue and marks the
corresponding build record as SUPERSEDED.

    >>> old_candidate = removeSecurityProxy(a_builder)._findBuildCandidate()
    >>> build = getUtility(IBinaryPackageBuildSet).getByQueueEntry(
    ...     old_candidate)
    >>> print build.status.name
    NEEDSBUILD

The 'candidate' is constant until we dispatch it.

    >>> new_candidate = removeSecurityProxy(a_builder)._findBuildCandidate()
    >>> new_candidate.id == old_candidate.id
    True

Now let's disable the archive of the associated build record and see
whether the candidate will still be found.

    >>> build.archive.disable()
    >>> new_candidate = removeSecurityProxy(a_builder)._findBuildCandidate()
    >>> new_candidate is None
    True

The build candidate was not found because builds associated with disabled
archives are ignored. Now let's re-enable that archive and the build
candidate will be found again.

    >>> build.archive.enable()
    >>> new_candidate = removeSecurityProxy(a_builder)._findBuildCandidate()
    >>> new_candidate.id == old_candidate.id
    True

In order to make the current candidate be considered 'superseded' we
need to tweak the status of the current publication directly, as a
permissive database user.

    >>> from canonical.config import config
    >>> from lp.soyuz.enums import PackagePublishingStatus
    >>> from canonical.testing.layers import LaunchpadZopelessLayer

    >>> spr = build.source_package_release
    >>> pub = removeSecurityProxy(build).current_source_publication
    >>> commit()
    >>> LaunchpadZopelessLayer.switchDbUser('launchpad')
    >>> pub.status = PackagePublishingStatus.SUPERSEDED
    >>> commit()
    >>> LaunchpadZopelessLayer.switchDbUser(config.builddmaster.dbuser)

Now, there we have another build candidate.

    >>> new_candidate = removeSecurityProxy(a_builder)._findBuildCandidate()
    >>> new_candidate.id != old_candidate.id
    True

Because the 'previous' candidate was marked as superseded, so it's not
part of the candidates list anymore.

    >>> print build.status.name
    SUPERSEDED

If the candidate is for a private build whose source has not been
published yet, it will be temporarily skipped until the source is
published.  We need to tweak the status of the publishing record again
to demonstrate this, and also make the archive private:

XXX Michael Nelson 2010-02-19 bug=394276 Please let's put some time
aside to convert these to unit-tests.

    >>> naked_build = removeSecurityProxy(
    ...     getUtility(IBinaryPackageBuildSet).getByQueueEntry(new_candidate))
    >>> original_archive = naked_build.archive
    >>> secure_pub = naked_build.current_source_publication
    >>> commit()
    >>> LaunchpadZopelessLayer.switchDbUser('launchpad')
    >>> private_ppa = factory.makeArchive(private=True)
    >>> naked_build.archive = private_ppa
    >>> secure_pub.archive = private_ppa
    >>> secure_pub.status = PackagePublishingStatus.PENDING
    >>> commit()
    >>> LaunchpadZopelessLayer.switchDbUser(config.builddmaster.dbuser)

Let's try to find a new build candidate:

    >>> another_candidate = removeSecurityProxy(
    ...     a_builder)._findBuildCandidate()

Since there are no more candidates at all, _findBuildCandidate()
returned None:

    >>> print another_candidate
    None

If we publish the source, the build candidate will be found again:

    >>> LaunchpadZopelessLayer.switchDbUser('launchpad')
    >>> secure_pub.status = PackagePublishingStatus.PUBLISHED
    >>> commit()
    >>> LaunchpadZopelessLayer.switchDbUser(config.builddmaster.dbuser)

    >>> another_candidate = removeSecurityProxy(
    ...     a_builder)._findBuildCandidate()
    >>> another_candidate.id == new_candidate.id
    True

If the source is subsequently deleted or superseded before the build
starts it is also returned as a candidate so that the build can be
superseded.  We can supersede this publication which will have the effect of
making the build be superseded and no candidate is returned.

    >>> LaunchpadZopelessLayer.switchDbUser('launchpad')
    >>> secure_pub = naked_build.current_source_publication
    >>> secure_pub.status = PackagePublishingStatus.DELETED
    >>> secure_pub.status = PackagePublishingStatus.SUPERSEDED
    >>> commit()
    >>> LaunchpadZopelessLayer.switchDbUser(config.builddmaster.dbuser)

    >>> build = getUtility(IBinaryPackageBuildSet).getByQueueEntry(
    ...     current_job)
    >>> print build.status.name
    NEEDSBUILD

    >>> another_candidate = removeSecurityProxy(
    ...     a_builder)._findBuildCandidate()
    >>> print another_candidate
    None

    >>> print build.status.name
    SUPERSEDED

We'll reset the archive back to non-private for further tests:

    >>> commit()
    >>> LaunchpadZopelessLayer.switchDbUser('launchpad')
    >>> naked_build.archive = original_archive
    >>> secure_pub.archive = original_archive
    >>> commit()
    >>> LaunchpadZopelessLayer.switchDbUser(config.builddmaster.dbuser)

Partner archive builds will set up the 'archives' argument such that it
references all the required pockets/components in the primary archive, in
addition to a reference to the release pocket in the partner archive itself.

    >>> ubuntu = getUtility(IDistributionSet)['ubuntu']
    >>> partner_archive = ubuntu.getArchiveByComponent('partner')
    >>> removeSecurityProxy(a_build).archive = partner_archive
    >>> commit()
    >>> a_builder.setSlaveForTesting(OkSlave())

The partner archive won't be passed to the builder unless it has at
least one published binary availble in the target distroarchseries.
This feature fixes bug #196782, when archive/suites got passed to
builders before they get published on disk, i.e. the first build on
any PPA/suite will fail during the first 20 minutes because no empty
indexes are published.

Since this is a build in a private archive, the log was uploaded to
the restricted librarian.

    >>> removeSecurityProxy(build).archive = private_ppa
    >>> commit()
    >>> candidate = build.queueBuild()
    >>> setupBuildQueue(candidate, a_builder)
    >>> build.upload_log = None
    >>> candidate.builder.setSlaveForTesting(WaitingSlave('BuildStatus.OK'))
    >>> a_builder.updateBuild(candidate)
    >>> local_transaction.commit()

    >>> build.archive.private
    True

    >>> lfa = build.log
    >>> lfa.restricted
    True
    >>> print lfa.filename
    buildlog_ubuntu-warty-i386.mozilla-firefox_0.9_BUILDING.txt.gz

The attempt to fetch the buildlog from the common librarian will fail
since this is a build in a private archive and the buildlog was thus
uploaded to the restricted librarian.

    >>> from canonical.librarian.interfaces import ILibrarianClient
    >>> getUtility(ILibrarianClient).getFileByAlias(lfa.id)
    Traceback (most recent call last):
      ...
    DownloadFailed: Alias ... cannot be downloaded from this client.

Accessing the log via the restricted librarian will work as expected.

    >>> import urlparse
    >>> from canonical.librarian.interfaces import IRestrictedLibrarianClient
    >>> lfa2 = removeSecurityProxy(
    ...     getUtility(IRestrictedLibrarianClient).getFileByAlias(lfa.id))
    >>> url_parts = urlparse.urlsplit(lfa2.file.geturl())
    >>> print os.path.basename(url_parts[2])
    buildlog_ubuntu-warty-i386.mozilla-firefox_0.9_BUILDING.txt.gz

A PPA can depend on another PPA. We can make Celso's PPA depend on
Mark's PPA:

    >>> commit()
    >>> LaunchpadZopelessLayer.switchDbUser('launchpad')
    >>> login('foo.bar@canonical.com')


Clean up before continuing:

    >>> a_builder.virtualized = False
    >>> removeSecurityProxy(a_build).archive = ubuntu.main_archive
    >>> commit()


== Builder Status Handler ==

IBuilder.slaveStatus should return a dict containing the following
items:

 * slave status string:  'BuilderStatus.IDLE'
 * job identifier string: '1-1'
 * job status string: 'BuildStatus.OK' or None
 * logtail (last 1K output of the ongoing build) as xmlrpclib.Binary or None
 * result file list: {'foo.deb', 'foo.changes'} or None
 * dependencies string: 'bar baz zaz' or None

    # Define a helper to print the slave status dict.
    >>> from collections import defaultdict
    >>> def printSlaveStatus(status_dict):
    ...     status_dict = defaultdict(lambda:None, status_dict)
    ...     print (
    ...         "builder_status: %(builder_status)s\n"
    ...         "build_status: %(build_status)s\n"
    ...         "logtail: %(logtail)r\n"
    ...         "filemap: %(filemap)s\n"
    ...         "dependencies: %(dependencies)s\n" % status_dict)

    >>> a_builder.setSlaveForTesting(OkSlave())
    >>> printSlaveStatus(a_builder.slaveStatus())
    builder_status: BuilderStatus.IDLE
    build_status: None
    logtail: None
    filemap: None
    dependencies: None

    >>> a_builder.setSlaveForTesting(BuildingSlave())
    >>> printSlaveStatus(a_builder.slaveStatus())
    builder_status: BuilderStatus.BUILDING
    build_status: None
    logtail: <xmlrpclib.Binary ...>
    filemap: None
    dependencies: None

    >>> a_builder.setSlaveForTesting(WaitingSlave(state='BuildStatus.OK'))
    >>> printSlaveStatus(a_builder.slaveStatus())
    builder_status: BuilderStatus.WAITING
    build_status: BuildStatus.OK
    logtail: None
    filemap: {}
    dependencies: None

    >>> a_builder.setSlaveForTesting(AbortingSlave())
    >>> printSlaveStatus(a_builder.slaveStatus())
    builder_status: BuilderStatus.ABORTING
    build_status: None
    logtail: None
    filemap: None
    dependencies: None

    >>> a_builder.setSlaveForTesting(AbortedSlave())
    >>> printSlaveStatus(a_builder.slaveStatus())
    builder_status: BuilderStatus.ABORTED
    build_status: None
    logtail: None
    filemap: None
    dependencies: None

