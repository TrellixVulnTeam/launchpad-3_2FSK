= Bugs in Malone =

This document describes what a Bug is in Malone, and provides some (currently
rather incomplete) info on how to poke at bugs through the Component
Architecture.

== Working with Bugs ==

Bugs are created and retrieved via IBugSet.

    >>> from zope.component import getUtility
    >>> from canonical.launchpad.interfaces import IBugSet, IBug
    >>> bugset = getUtility(IBugSet)

To retrieve a specific Bug, use IBugSet.get:

    >>> firefox_crashes = bugset.get(6)
    >>> print firefox_crashes.title
    Firefox crashes when Save As dialog for a nonexistent window is closed

Or you can use IBugSet.getByNameOrID to get it by its nickname:

    >>> blackhole_bug = bugset.getByNameOrID('blackhole')
    >>> print blackhole_bug.title
    Blackhole Trash folder

If the bug can't be found, a zope.exceptions.NotFoundError will be
raised:

    >>> bugset.get(123456)
    Traceback (most recent call last):
      ...
    NotFoundError: 'Unable to locate bug with ID 123456.'

    >>> bugset.getByNameOrID('+bugs')
    Traceback (most recent call last):
      ...
    NotFoundError: 'Unable to locate bug with nickname +bugs.'

== Interface check ==

It is guaranteed to implement the correct interface, too:

    >>> from canonical.launchpad.webapp.testing import verifyObject
    >>> verifyObject(IBug, firefox_crashes)
    True

(We grab the object directly from the database here to avoid it being
security proxied, which doesn't make sense to test here.)

== Searching for Bugs ==

To search for bugs matching specific criteria, use IBugSet.searchAsUser:

    >>> from canonical.database.sqlbase import flush_database_updates
    >>> from canonical.launchpad.interfaces import ILaunchBag

    >>> def current_user():
    ...     return getUtility(ILaunchBag).user

    >>> login("foo.bar@canonical.com")

    >>> firefox_test_bug = bugset.get(3)
    >>> firefox_test_bug.duplicateof = firefox_crashes.id
    >>> flush_database_updates()

    >>> dups_of_bug_six = bugset.searchAsUser(
    ...     duplicateof=firefox_crashes, user=current_user())
    >>> print dups_of_bug_six.count()
    1
    >>> dups_of_bug_six[0].id
    3

    >>> firefox_test_bug.duplicateof = None
    >>> flush_database_updates()
    >>> dups_of_bug_six = bugset.searchAsUser(
    ...     duplicateof=firefox_crashes, user=current_user())
    >>> print dups_of_bug_six.count()
    0

    >>> login(ANONYMOUS)

== Absolute URLs ==

For things like bug notification emails, it's handy to be able to
include a URL to the bug inside the email.

    >>> from canonical.launchpad.webapp import canonical_url
    >>> print canonical_url(firefox_crashes)
    http://.../bugs/6

== Bug Privacy ==

A Bug has a "private" field. If Bug.private is False, the bug is
publicly visible. If Bug.private is True, only people who are directly
subscribed to the bug can see it. Launchpad admins can always view and
modify private bugs.

=== Marking Bugs Private ===

For the purposes of demonstration, we'll make the firefox crashing bug
private. A bug cannot be made private by an anonymous user.

    >>> firefox_crashes.private = True
    Traceback (most recent call last):
      ...
    ForbiddenAttribute: ('private', ...)

    >>> firefox_crashes.setPrivate(True, current_user())
    Traceback (most recent call last):
      ...
    Unauthorized: (..., 'setPrivate', 'launchpad.Edit')

We have to be logged in, so let's do that:

    >>> login("test@canonical.com")

There are currently no people subscribed to this bug:

    >>> print firefox_crashes.subscriptions.count()
    0

The rule with private bugs is that only direct subscribers can view the
bug after it's been marked private. So, if Sample Person is to mark the
firefox_crashes bug private, we must first ensure that Sample Person is
subscribed to the bug!

    >>> sample_person = current_user()
    >>> subscription = firefox_crashes.subscribe(sample_person, sample_person)

Even though we are logged in and subscribed to the bug, we are
prevented from using the private attribute to mark bug #6 private:

    >>> firefox_crashes.private = True
    Traceback (most recent call last):
      ...
    ForbiddenAttribute: ('private', ...)

We must use setPrivate:

    >>> from zope.event import notify
    >>> from lazr.lifecycle.event import (
    ...     ObjectModifiedEvent, ObjectCreatedEvent)
    >>> from lazr.lifecycle.snapshot import Snapshot

    >>> old_state = Snapshot(firefox_crashes, providing=IBug)
    >>> firefox_crashes.setPrivate(True, current_user())
    True
    >>> bug_set_private = ObjectModifiedEvent(
    ...     firefox_crashes, old_state,
    ...     ["id", "title", "private"])

    >>> notify(bug_set_private)
    >>> flush_database_updates()

Trying to mark a private bug as private is a no-op, as is marking a
non-private bug as non-private. The return value from setPrivate is an
indicator that it modified the bug.

    >>> firefox_crashes.setPrivate(False, current_user())
    True
    >>> firefox_crashes.setPrivate(False, current_user())
    False
    >>> firefox_crashes.setPrivate(True, current_user())
    True
    >>> firefox_crashes.setPrivate(True, current_user())
    False

=== How Privacy Affects Access to a Bug ===

Once a bug is made private, it can only be accessed by the users that
are directly subscribed to the bug and Launchpad admins.

So, remembering that we're still logged in as Sample Person (ID 12 in
the Person table), and that Sample Person is a direct subscriber to the
firefox_crashes bug, we can still access properties of this bug:

    >>> firefox_crashes.title
    u'Firefox crashes when Save As dialog for a nonexistent window is closed'

Note that a search will return all public bugs, omitting bug 14 which is
private:

    >>> all_bugs = bugset.searchAsUser(
    ...     user=current_user(), orderBy="id")
    >>> [bug.id for bug in all_bugs]
    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 15]

(This test breaks if you add a new public bug to sampledata; rely on it
to ensure it worked!)

Likewise Foo Bar, an admin, can access the bug.

    >>> login("foo.bar@canonical.com")

    >>> old_title = firefox_crashes.title
    >>> firefox_crashes.title = "new title"
    >>> firefox_crashes.title
    u'new title'
    >>> firefox_crashes.title = old_title
    >>> firefox_crashes.title
    u'Firefox crashes when Save As dialog for a nonexistent window is closed'

Bug 14, which is private, is  returned by the search results for an
admin as well:

    >>> all_bugs = bugset.searchAsUser(
    ...     user=current_user(), orderBy="id")
    >>> [bug.id for bug in all_bugs]
    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]

(This test breaks if you add any bug to sampledata.)

As one would expect, the permissions are team aware. So, let's retrieve a bug
and set it private (as Foo Bar again who, of course, is an admin.)

    >>> blackhole_trash_folder = bugset.get(2)

And again, let's fake setting the bug private:

    >>> old_state = Snapshot(blackhole_trash_folder, providing=IBug)
    >>> blackhole_trash_folder.setPrivate(True, current_user())
    True
    >>> bug_set_private = ObjectModifiedEvent(
    ...     blackhole_trash_folder, old_state,
    ...     ["id", "title", "private"])

    >>> notify(bug_set_private)
    >>> flush_database_updates()

Then let's permit the Ubuntu Team to access this bug by adding them to
the Cc list:

    >>> from canonical.launchpad.interfaces import IPersonSet
    >>> personset = getUtility(IPersonSet)

    >>> ubuntu_team = personset.get(17)
    >>> subscription = blackhole_trash_folder.subscribe(
    ...     ubuntu_team, ubuntu_team)

Jeff Waugh, a member of the Ubuntu Team, is able to access this bug:

    >>> login("jeff.waugh@ubuntulinux.com")

    >>> old_title = blackhole_trash_folder.title
    >>> blackhole_trash_folder.title = "new title"
    >>> blackhole_trash_folder.title
    u'new title'
    >>> blackhole_trash_folder.title = old_title
    >>> blackhole_trash_folder.title
    u'Blackhole Trash folder'

and see it (bug #2) in searches:

    >>> all_bugs = bugset.searchAsUser(
    ...     user=current_user(), orderBy="id")
    >>> [bug.id for bug in all_bugs]
    [1, 2, 3, 4, 5, 7, 8, 9, 10, 11, 12, 13, 15]

If we login as someone who *isn't* a member of the Ubuntu Team (and
isn't otherwise someone who should be allowed to access the properties
of this bug) though:

    >>> login("no-priv@canonical.com")

Trying to access a property of this bug will again raise an
Unauthorized:

    >>> blackhole_trash_folder.title
    Traceback (most recent call last):
      ...
    Unauthorized: (..., 'title', 'launchpad.View')

And, as you might have guessed, is once again invisible in searches
(notice that bug #6 is also invisible to No Privileges Person):

    >>> all_bugs = bugset.searchAsUser(
    ...     user=current_user(), orderBy="id")
    >>> [bug.id for bug in all_bugs]
    [1, 3, 4, 5, 7, 8, 9, 10, 11, 12, 13, 15]

=== Filing Public vs. Private Bugs ===

Let's log back in as Foo Bar to continue our examples:

    >>> login("foo.bar@canonical.com")

When a public bug is filed:

    >>> from canonical.launchpad.interfaces import (
    ...     IProductSet, IBugSet, CreateBugParams)
    >>> productset = getUtility(IProductSet)
    >>> bugset = getUtility(IBugSet)

    >>> firefox = productset.get(4)
    >>> foobar = personset.get(16)
    >>> params = CreateBugParams(
    ...     title="test firefox bug", comment="blah blah blah", owner=foobar)
    >>> params.setBugTarget(product=firefox)
    >>> added_bug = getUtility(IBugSet).createBug(params)
    >>> notify(ObjectCreatedEvent(added_bug))
    >>> public_bug = bugset.get(added_bug.id)

the submitter and the maintainer are directly subscribed. Note that
passing both a comment /and/ a msg would have raised an AssertionError:

    >>> params = CreateBugParams(
    ...     title="test firefox bug", comment="blah blah blah",
    ...     msg="foo foo foo", owner=foobar)
    >>> params.setBugTarget(product=firefox)
    >>> added_bug = getUtility(IBugSet).createBug(params)
    Traceback (most recent call last):
      ...
    AssertionError: Expected either a comment or a msg, but got both.


So, let's continue:

    >>> [subscription.person.name for subscription in public_bug.subscriptions]
    [u'name16']

The first comment made (this is submitted in the bug report) is set to
the description of the bug:

    >>> public_bug.description
    u'blah blah blah'

The bug description can also be accessed through the task:

    >>> public_bug.bugtasks[0].bug.description
    u'blah blah blah'
    >>> public_bug.description = 'a new description'
    >>> public_bug.bugtasks[0].bug.description
    u'a new description'

When a private bug is filed:

    >>> params = CreateBugParams(
    ...     title="test firefox bug", comment="blah blah blah", owner=foobar,
    ...     private=True)
    >>> params.setBugTarget(product=firefox)
    >>> added_bug = getUtility(IBugSet).createBug(params)
    >>> notify(ObjectCreatedEvent(added_bug))
    >>> private_bug = bugset.get(added_bug.id)

*only* the submitter is directly subscribed:

    >>> [subscriber.name for subscriber in private_bug.getDirectSubscribers()]
    [u'name16']

Since it's private, there are no indirect subscribers.

    >>> private_bug.getIndirectSubscribers()
    []

It's up to the submitter to subscribe the maintainer, if they so choose.

This works similarly for distributions; in this case the
"maintainer" is considered the person who maintains the applicable
sourcepackage. E.g.

    >>> from canonical.launchpad.interfaces import (
    ...     IDistributionSet, ISourcePackageNameSet)
    >>> distributionset = getUtility(IDistributionSet)
    >>> spnset = getUtility(ISourcePackageNameSet)
    >>> ubuntu = distributionset.get(1)
    >>> evolution = spnset.get(9)
    >>> params = CreateBugParams(
    ...     title="test firefox bug", comment="blah blah blah",
    ...     owner=foobar, private=True)
    >>> params.setBugTarget(distribution=ubuntu, sourcepackagename=evolution)
    >>> added_bug = getUtility(IBugSet).createBug(params)
    >>> notify(ObjectCreatedEvent(added_bug))
    >>> private_bug = bugset.get(added_bug.id)
    >>> [subscriber.name for subscriber in private_bug.getDirectSubscribers()]
    [u'name16']
    >>> private_bug.getIndirectSubscribers()
    []


== Prevent reporter from being subscribed to filed bugs ==

If necessary, subscriber_reporter may be specified when creating a bug,
to prevent the reporter from being subscribed to the bug. This is useful
when importing bugs.

    >>> params = CreateBugParams(
    ...     owner=current_user(), title="test", comment="test",
    ...     subscribe_reporter=False)
    >>> bug = ubuntu.createBug(params)
    >>> [person.name for person in bug.getDirectSubscribers()]
    []


== Date Last Updated ==

Malone tracks the last time a change was made to a
bug. IBug.date_last_updated stores the date when anything is changed or
added to a bug, i.e., an IBug or IBugTask is added or changed, or an
IHasBug object is added or changed. The sole exception to this is
subscribing/unsubscribing (which create/delete IBugSubscription
objects.) Let's look at an example of each.

When a bug is created, its date_last_updated is set right away, to
ensure that new bugs sort appropriately.

    >>> params = CreateBugParams(
    ...     title="a test firefox bug",
    ...     comment="a description of the bug",
    ...     owner=current_user())
    >>> firefox_bug = firefox.createBug(params)

    >>> firefox_bug.datecreated == firefox_bug.date_last_updated
    True

Adding a comment.

    >>> current_date_last_updated = firefox_bug.date_last_updated

    >>> comment = firefox_bug.newMessage(
    ...     owner=current_user(),
    ...     subject="blah blah blah",
    ...     content="blah blah blah")

    >>> firefox_bug.date_last_updated > current_date_last_updated
    True

Changing the bug summary.

    >>> from canonical.launchpad.interfaces import IBug

    >>> bug_before_modification = Snapshot(firefox_bug, providing=IBug)

    >>> firefox_bug.title = "a new title"

    >>> bug_summary_changed = ObjectModifiedEvent(
    ...     firefox_bug, bug_before_modification, ["title"])

    >>> current_date_last_updated = firefox_bug.date_last_updated

    >>> notify(bug_summary_changed)

    >>> firefox_bug.date_last_updated > current_date_last_updated
    True

Changing the description.

    >>> bug_before_modification = Snapshot(firefox_bug, providing=IBug)

    >>> firefox_bug.description = "a new description"

    >>> bug_description_changed = ObjectModifiedEvent(
    ...     firefox_bug, bug_before_modification, ["description"])

    >>> current_date_last_updated = firefox_bug.date_last_updated

    >>> notify(bug_description_changed)

    >>> firefox_bug.date_last_updated > current_date_last_updated
    True

Modifying a bugtask will update IBug.date_last_updated.

    >>> from canonical.launchpad.interfaces import (
    ...     BugTaskImportance, BugTaskStatus, IUpstreamBugTask)

    >>> firefox_task = firefox_bug.bugtasks[0]

    >>> print firefox_task.bugtargetdisplayname
    Mozilla Firefox

    >>> print firefox_task.importance.title
    Undecided
    >>> print firefox_task.status.title
    New

    >>> bugtask_before_modification = Snapshot(
    ...     firefox_task, providing=IUpstreamBugTask)

    >>> firefox_task.transitionToImportance(
    ...     BugTaskImportance.CRITICAL, current_user())
    >>> firefox_task.transitionToStatus(
    ...     BugTaskStatus.CONFIRMED, current_user())

    >>> bugtask_modified = ObjectModifiedEvent(
    ...     firefox_task, bugtask_before_modification,
    ...     ["status", "importance"])

    >>> current_date_last_updated = firefox_bug.date_last_updated

    >>> notify(bugtask_modified)

    >>> firefox_bug.date_last_updated > current_date_last_updated
    True

Adding a new task.

    >>> from canonical.launchpad.interfaces import IBugTaskSet

    >>> thunderbird = productset.getByName("thunderbird")

    >>> print thunderbird.name
    thunderbird

    >>> thunderbird_task = getUtility(IBugTaskSet).createTask(
    ...     bug=firefox_bug, owner=foobar, product=thunderbird)

    >>> current_date_last_updated = firefox_bug.date_last_updated

    >>> notify(ObjectCreatedEvent(thunderbird_task))

    >>> firefox_bug.date_last_updated > current_date_last_updated
    True

A new task can also be added using IBug.addTask(), which takes an
IBugTarget parameter and works out what parameters to pass to
createTask(), above.

    >>> redfish = getUtility(IProductSet).getByName('redfish')
    >>> redfish_task = firefox_bug.addTask(
    ...     owner=foobar, target=redfish)

    >>> current_date_last_updated = firefox_bug.date_last_updated

    >>> notify(ObjectCreatedEvent(redfish_task))

    >>> firefox_bug.date_last_updated > current_date_last_updated
    True

You can also add bugs for a specific distro.

    >>> from canonical.launchpad.interfaces import IDistributionSet
    >>> ubuntu = getUtility(IDistributionSet).getByName('ubuntu')
    >>> ubuntu_task = firefox_bug.addTask(
    ...     owner=foobar, target=ubuntu)
    >>> notify(ObjectCreatedEvent(ubuntu_task))

    >>> print ubuntu_task.distribution.title
    Ubuntu Linux

And for a specific distribution series.

    >>> warty = ubuntu.getSeries('warty')
    >>> warty_task = firefox_bug.addTask(
    ...     owner=foobar, target=warty)
    >>> notify(ObjectCreatedEvent(warty_task))

    >>> print warty_task.distroseries.title
    The Warty Warthog Release

Also for a specific distribution source package.

    >>> linux_source = ubuntu.getSourcePackage('linux-source-2.6.15')
    >>> linux_task = firefox_bug.addTask(
    ...     owner=foobar, target=linux_source)
    >>> notify(ObjectCreatedEvent(linux_task))

    >>> print linux_task.bugtargetname
    linux-source-2.6.15 (Ubuntu)

And for a distro series source package.

    >>> from canonical.launchpad.database import SourcePackage
    >>> firefox_package = ubuntu.getSourcePackage('mozilla-firefox')
    >>> warty_fox_package = SourcePackage(
    ...     distroseries=warty,
    ...     sourcepackagename=firefox_package.sourcepackagename)
    >>> warty_fox_task = firefox_bug.addTask(
    ...     owner=foobar, target=warty_fox_package)
    >>> notify(ObjectCreatedEvent(warty_fox_task))

    >>> print warty_fox_task.bugtargetname
    mozilla-firefox (Ubuntu Warty)

    >>> print warty_fox_task.distroseries.name
    warty

    >>> print warty_fox_task.sourcepackagename.name
    mozilla-firefox

The first task is available as default_bugtask. Launchpad often views
bugs in the context of a bugtask, and the default choice is the first
or oldest bugtask.

    >>> print firefox_bug.default_bugtask.bugtargetdisplayname
    Mozilla Firefox

Changing bug visibility.

    >>> bug_before_modification = Snapshot(firefox_bug, providing=IBug)

    >>> firefox_bug.private
    False
    >>> firefox_bug.setPrivate(True, current_user())
    True

    >>> bug_visibility_changed = ObjectModifiedEvent(
    ...     firefox_bug, bug_before_modification, ["private"])

    >>> current_date_last_updated = firefox_bug.date_last_updated

    >>> notify(bug_visibility_changed)

    >>> firefox_bug.date_last_updated > current_date_last_updated
    True

Changing bug security.

    >>> bug_before_modification = Snapshot(firefox_bug, providing=IBug)

    >>> firefox_bug.security_related
    False
    >>> firefox_bug.security_related = True

    >>> bug_security_changed = ObjectModifiedEvent(
    ...     firefox_bug, bug_before_modification, ["security_related"])

    >>> current_date_last_updated = firefox_bug.date_last_updated

    >>> notify(bug_security_changed)

    >>> firefox_bug.date_last_updated > current_date_last_updated
    True

Marking as duplicate.

    >>> bug_before_modification = Snapshot(firefox_bug, providing=IBug)

    >>> print firefox_bug.duplicateof
    None
    >>> firefox_bug.duplicateof = firefox_crashes

    >>> bug_duplicateof_changed = ObjectModifiedEvent(
    ...     firefox_bug, bug_before_modification, ["duplicateof"])

    >>> current_date_last_updated = firefox_bug.date_last_updated

    >>> notify(bug_duplicateof_changed)

    >>> firefox_bug.date_last_updated > current_date_last_updated
    True

Adding an attachment.

    >>> from StringIO import StringIO
    >>> from canonical.launchpad.interfaces import (
    ...     IBugAttachmentSet, ILibraryFileAliasSet, IMessageSet)

    >>> firefox_bug.attachments.count()
    0

(Upload a file to the Librarian.)

    >>> filecontent = 'Some useful information.'
    >>> filealias = getUtility(ILibraryFileAliasSet).create(
    ...     name='foo.txt', size=len(filecontent),
    ...     file=StringIO(filecontent), contentType='text/plain')

(Attach it to the bug.)

    >>> message = getUtility(IMessageSet).fromText(
    ...     subject="title", content="added an attachment.")
    >>> attachmentset = getUtility(IBugAttachmentSet)
    >>> attachment = attachmentset.create(
    ...     bug=firefox_bug, filealias=filealias, title='Some info.',
    ...     message=message)

    >>> current_date_last_updated = firefox_bug.date_last_updated

    >>> notify(ObjectCreatedEvent(attachment))

    >>> firefox_bug.attachments.count()
    1

    >>> firefox_bug.date_last_updated > current_date_last_updated
    True

Editing an attachment.

    >>> from canonical.launchpad.interfaces import IBugAttachment

    >>> attachment_before_modification = Snapshot(
    ...     attachment, providing=IBugAttachment)

    >>> attachment.title = "a new title"

    >>> attachment_changed = ObjectModifiedEvent(
    ...     attachment, attachment_before_modification,
    ...     ["title"])

    >>> current_date_last_updated = firefox_bug.date_last_updated

    >>> notify(attachment_changed)

    >>> firefox_bug.date_last_updated > current_date_last_updated
    True

Adding a branch.

    >>> from lp.code.interfaces.branchlookup import IBranchLookup
    >>> firefox_bug.bug_branches.count()
    0

    >>> branch_one = getUtility(IBranchLookup).get(1)
    >>> current_date_last_updated = firefox_bug.date_last_updated

    >>> bug_branch = firefox_bug.addBranch(branch_one, foobar)

    >>> firefox_bug.bug_branches.count()
    1
    >>> firefox_bug.date_last_updated > current_date_last_updated
    True

Editing a branch.

    >>> from canonical.launchpad.interfaces import BugBranchStatus, IBugBranch

    >>> branch_before_modification = Snapshot(
    ...     bug_branch, providing=IBugBranch)

    >>> print bug_branch.status.title
    Fix In Progress

    >>> bug_branch.status = BugBranchStatus.BESTFIX

    >>> bug_branch_changed = ObjectModifiedEvent(
    ...     bug_branch, branch_before_modification, ["status"])

    >>> current_date_last_updated = firefox_bug.date_last_updated

    >>> notify(bug_branch_changed)

    >>> firefox_bug.date_last_updated > current_date_last_updated
    True

Linking to a CVE.

    >>> from canonical.launchpad.interfaces import ICveSet

    >>> firefox_bug.cve_links.count()
    0

    >>> cveref = getUtility(ICveSet)["1999-8979"]
    >>> bug_cveref = firefox_bug.linkCVE(cveref, sample_person)

    >>> current_date_last_updated = firefox_bug.date_last_updated

    >>> notify(ObjectCreatedEvent(bug_cveref))

    >>> firefox_bug.cve_links.count()
    1

    >>> firefox_bug.date_last_updated > current_date_last_updated
    True

Linking to an external bug tracker.

    >>> from canonical.launchpad.interfaces import (
    ...     IBugWatchSet, IBugTrackerSet)

    >>> firefox_bug.watches.count()
    0

    >>> mozilla_bugtracker = getUtility(IBugTrackerSet)['mozilla.org']
    >>> bugwatch = getUtility(IBugWatchSet).createBugWatch(
    ...     bug=firefox_bug, owner=current_user(),
    ...     bugtracker=mozilla_bugtracker, remotebug='1234')

    >>> current_date_last_updated = firefox_bug.date_last_updated

    >>> notify(ObjectCreatedEvent(bugwatch))

    >>> firefox_bug.watches.count()
    1

    >>> firefox_bug.date_last_updated > current_date_last_updated
    True

Editing the external bug watch.

    >>> from canonical.launchpad.interfaces import IBugWatch

    >>> bugwatch_before_modification = Snapshot(
    ...     bugwatch, providing=IBugWatch)

    >>> print bugwatch.remotebug
    1234

    >>> bugwatch.remotebug = '5678'

    >>> bugwatch_changed = ObjectModifiedEvent(
    ...     bugwatch, bugwatch_before_modification, ["remotebug"],
    ...     bugwatch.bug.owner)

    >>> current_date_last_updated = firefox_bug.date_last_updated

    >>> notify(bugwatch_changed)

    >>> firefox_bug.date_last_updated > current_date_last_updated
    True

Adding a comment imported from an external bugtracker.

    >>> remote_comment = firefox_bug.newMessage(
    ...     owner=current_user(),
    ...     subject="blah blah blah again",
    ...     content="blah blah blah blah remotely",
    ...     bugwatch=bugwatch,
    ...     remote_comment_id='blah'
    ...     )

    >>> imported_message = bugwatch.getImportedBugMessages()[0]
    >>> print imported_message.message.text_contents
    blah blah blah blah remotely

Subscribing and unsubscribing does *not* trigger an update of
IBug.date_last_updated.

    >>> current_date_last_updated = firefox_bug.date_last_updated

    >>> firefox_bug.unsubscribe(ubuntu_team, ubuntu_team)

    >>> firefox_bug.date_last_updated == current_date_last_updated
    True

    >>> firefox_bug.isSubscribed(ubuntu_team)
    False

    >>> subscription = firefox_bug.subscribe(ubuntu_team, ubuntu_team)

    >>> notify(ObjectCreatedEvent(subscription))

    >>> firefox_bug.date_last_updated == current_date_last_updated
    True


== Bug Completeness ==

A bug is considered "complete" iff all of its bugtasks are themselves
complete. The definition of completeness for a bugtask is that the bug
has been marked invalid or a fix has been released.

    >>> b8 = bugset.get(8)
    >>> b8.is_complete
    True
    >>> b9 = bugset.get(9)
    >>> b9.is_complete
    False

Let's add a new task to b8 to see if that affects the completeness.

    >>> newtask = getUtility(IBugTaskSet).createTask(
    ...     bug=b8, product=firefox, owner=b8.owner)
    >>> newtask.status.name
    'NEW'
    >>> b8.is_complete
    False

Now, let's iterate over the bug tasks, some complete and others
incomplete, and show the status of each of the tasts:

    >>> for task in b8.bugtasks:
    ...     print task.bugtargetdisplayname, task.is_complete
    Mozilla Firefox False
    mozilla-firefox (Debian) True


== Bug Tasks ==

A bug can be targeted to more than one product, distribution, or source
package. A BugTask is used to represent a target, which has its own
status, importance, assignee, and so on.

You can get the set of bugtasks for at bug with the 'bugtasks' attribute:

    >>> bug_two = bugset.get(2)
    >>> for task in bug_two.bugtasks: print task.target.displayname
    Tomcat
    Ubuntu
    Hoary
    mozilla-firefox in debian
    Debian Woody mozilla-firefox

You can also get a list of the "LP pillars" affected by a particular bug.

    >>> for pillar in bug_two.affected_pillars:
    ...     print pillar.displayname
    Tomcat
    Ubuntu
    Debian

Yes, this is TERRIBLE sample data, but it serves to illustrate the point.

If you are interested in bugtask targeted to a specific target, you can
use getBugTask() to get it.

    >>> tomcat = getUtility(IProductSet).getByName('tomcat')
    >>> tomcat_task = bug_two.getBugTask(tomcat)
    >>> tomcat_task.target.name
    u'tomcat'

    >>> ubuntu = getUtility(IDistributionSet).getByName('ubuntu')
    >>> ubuntu_task = bug_two.getBugTask(ubuntu)
    >>> ubuntu_task.target.name
    u'ubuntu'

    >>> ubuntu_hoary = ubuntu.getSeries('hoary')
    >>> ubuntu_hoary_task = bug_two.getBugTask(ubuntu_hoary)
    >>> ubuntu_hoary_task.target.name
    u'hoary'

    >>> debian = getUtility(IDistributionSet).getByName('debian')
    >>> mozilla_in_debian = debian.getSourcePackage('mozilla-firefox')
    >>> mozilla_in_debian_task = bug_two.getBugTask(mozilla_in_debian)
    >>> mozilla_in_debian_task.target.displayname
    u'mozilla-firefox in debian'

    >>> debian_woody = debian.getSeries('woody')
    >>> mozilla_in_woody = debian_woody.getSourcePackage('mozilla-firefox')
    >>> mozilla_in_woody_task = bug_two.getBugTask(mozilla_in_woody)
    >>> mozilla_in_woody_task.target.displayname
    u'Debian Woody mozilla-firefox'

If the bug isn't targeted to the target, None is returned.

    >>> bug_two.getBugTask(debian) is None
    True


== Bug Expiration ==

Incomplete bug reports may expire when they become inactive. Expiration
is only available to projects that use Launchpad to track bugs. There
two properties related to expiration. IBug.permits_expiration tests
that the state of the bug permits expiration, and returns True or False.
IBug.can_expire property returns True or False as to whether the bug
will expire if it becomes inactive because of a bugtask.

`bugtask-expiration.txt` outlines the complete list of constraints that
govern expiration. In general, a bug that is not valid anywhere,
that has a single unattended Incomplete bugtask whose pillar has enabled
bug expiration. Once an bug is recognised to be valid for one bugtask
(confirmed), or attended (is assigned or has a milestone), the bug will
not permit expiration.

The thunderbird project does not use Launchpad to track bugs.
Incomplete, unattended bug reports cannot ever expire for this project.

    >>> # create_old_bug creates an bug with a bugtask that is eligible for
    >>> # expiration, so long as the pillar object has enabled bug expiration.
    >>> # Every change to a bug or bugtask must be synced back to the
    >>> # database to test can_expire.
    >>> from canonical.launchpad.ftests.bug import (
    ...     create_old_bug, sync_bugtasks)

    >>> upstream_bugtask = create_old_bug('bug a', 1, thunderbird)
    >>> sync_bugtasks(upstream_bugtask)
    >>> upstream_bugtask.status.name
    'INCOMPLETE'
    >>> upstream_bugtask.pillar.enable_bug_expiration
    False
    >>> upstream_bugtask.bug.permits_expiration
    False
    >>> upstream_bugtask.bug.can_expire
    False

Ubuntu has enabled bug expiration. Incomplete, unattended bugs can
expired.

    >>> expirable_bugtask = create_old_bug(
    ...     'bug c', 1, ubuntu, with_message=False)
    >>> sync_bugtasks(expirable_bugtask)

    >>> expirable_bugtask.status.name
    'INCOMPLETE'
    >>> expirable_bugtask.pillar.enable_bug_expiration
    True
    >>> expirable_bugtask.bug.permits_expiration
    True
    >>> expirable_bugtask.bug.can_expire
    True

When the expirable_bugtask assigned, the bugtask is no longer in
an expirable state, thus the bug cannot expire even though
bug permits expiration.

    >>> expirable_bugtask.transitionToAssignee(sample_person)
    >>> sync_bugtasks(expirable_bugtask)
    >>> expirable_bugtask.bug.permits_expiration
    True
    >>> expirable_bugtask.bug.can_expire
    False

Changing the status of the bug's single bugtask to any value other
than Incomplete, will cause the bug to not permit expiration.

    >>> expirable_bugtask.transitionToStatus(
    ...     BugTaskStatus.CONFIRMED, sample_person)
    >>> sync_bugtasks(expirable_bugtask)
    >>> expirable_bugtask.bug.permits_expiration
    False
    >>> expirable_bugtask.bug.can_expire
    False

See `bugtask-expiration.txt` for a more comprehensive set of bugs
that can or cannot expire.


== Bug Comments ==

A bug comment is actually made up of a number of chunks. The
IBug.getMessageChunks() method allows you to retreive these chunks in a
single shot.

    >>> from canonical.ftests.pgsql import CursorWrapper
    >>> CursorWrapper.record_sql = True
    >>> queries = len(CursorWrapper.last_executed_sql)

    >>> chunks = bug_two.getMessageChunks()
    >>> for chunk in sorted(chunks, key=lambda x:x.id):
    ...    chunk.id, chunk.message.id, chunk.message.owner.id, chunk.content[:30]
    (4, 1, 16, u'Problem exists between chair a')
    (7, 5, 12, u'This would be a real killer fe')
    (8, 6, 12, u'Oddly enough the bug system se')

It's done in a way that we only issue two queries to fetch all this
information, too:

    >>> len(CursorWrapper.last_executed_sql) - queries
    2

Bugs have a special attribute, `indexed_messages` which returns the collection
of messages, each decorated with the index of that message in its context
(the bug) and the primary bug task. This is used for providing an efficient
implementation of the canonical url resolution for messages when they are
exported using the webservice API.

    >>> for indexed_message in bug_two.indexed_messages:
    ...     print '%s\t%s\t%s' % (
    ...         indexed_message.index, indexed_message.subject,
    ...         indexed_message.inside.title)
    0 PEBCAK                                      Bug #2 in Tomcat: "Blackhole Trash folder"
    1 Fantastic idea, I'd really like to see this Bug #2 in Tomcat: "Blackhole Trash folder"
    2 Strange bug with duplicate messages.        Bug #2 in Tomcat: "Blackhole Trash folder"


== Affected users ==

Users can mark bugs as affecting or not affecting them. For each bug we
then keep a count of the number of users affected by it, as well as the
number of users not affected by it.

    >>> test_bug = factory.makeBug()
    >>> affected_user = factory.makePerson()
    >>> unaffected_user = factory.makePerson()

Initially, users are neither marked as affected nor as unaffected.

    >>> print test_bug.isUserAffected(affected_user)
    None

When we mark a bug as affecting a new user, the affected_users_count
increments.

    >>> test_bug.markUserAffected(affected_user, affected=True)
    >>> test_bug.isUserAffected(affected_user)
    True
    >>> test_bug.users_affected_count
    1

A bug can only affect a user once. Calling markUserAffect() with the
same user more than once does not increment users_affect_count.

    >>> test_bug.markUserAffected(affected_user, affected=True)
    >>> test_bug.users_affected_count
    1

We can mark a user as unaffected by a bug.

    >>> print test_bug.isUserAffected(unaffected_user)
    None
    >>> test_bug.markUserAffected(unaffected_user, affected=False)
    >>> test_bug.isUserAffected(unaffected_user)
    False
    >>> test_bug.users_unaffected_count
    1

And we can change whether a user is marked as affected or unaffected.

    >>> test_bug.markUserAffected(unaffected_user, affected=True)
    >>> test_bug.isUserAffected(unaffected_user)
    True
    >>> test_bug.users_unaffected_count
    0
    >>> test_bug.users_affected_count
    2

We can also get the collection of users affected by a bug.

    >>> for user in test_bug.users_affected:
    ...     print user.name
    person-name14
    person-name17

    >>> unaffecting_bug = factory.makeBug()
    >>> print unaffecting_bug.users_affected
    []

