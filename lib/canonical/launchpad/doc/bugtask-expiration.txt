= Bugtask Expiration =

Old unattended Incomplete bugtasks clutter the search results of
Launchpad Bugs making the bug staff's job difficult. A script is run
daily to locate unattended Incomplete bugtasks that have not been
updated in 2 months, and sets their status to Invalid. Only bugtasks
for projects that use Launchpad to track bugs and have
enable_bug_expiration set to True will be expired; this rule does not
apply to Bugs imported from upstream bug trackers. The preconditions
are:

1. The bugtask belongs to a project with enable_bug_expiration is True.
2. The bugtask has the status Incomplete.
3. The last update of the bug is older than 60 days.
4. The bug is not a duplicate.
5. The bug does not have any other valid bugtasks.
6. The bugtask is not assigned to anyone.
7. The bugtask does not have a milestone.

Bugtasks cannot transition to Invalid automatically unless they meet
all the rules stated above.


== findExpirableBugTasks() Part 1 ==

BugTaskSet provides findExpirableBugTasks() to find bugtasks that
qualify for expiration. The bugtasks must must meet all the
preconditions stated in this tests introduction.

findExpirableBugTasks() requires a parameter for the minimum days old
(min_days_old) that the bugtask has been in the unattended Incomplete
status. It also requires specifying the user that is doing the search.

    >>> from canonical.launchpad.interfaces import (
    ...     BugTaskStatus, IBugTaskSet)
    >>> bugtaskset = getUtility(IBugTaskSet)

    >>> expirable_bugtasks = bugtaskset.findExpirableBugTasks()
    Traceback (most recent call last):
    ...
    TypeError: findExpirableBugTasks() takes at least 3 arguments (1 given)

Looking back 9,999 days, findExpirableBugTasks() reports that there are
no expirable bugtasks in the sampledata.

    >>> expirable_bugtasks = bugtaskset.findExpirableBugTasks(9999, None)
    >>> expirable_bugtasks.count()
    0


== Setup ==

Let's make some bugtasks that qualify for expiration. A Jokosher
bugtask and a conjoined pair of ubuntu_hoary and ubuntu bugtasks
will suffice.

The test harness provides create_old_bug() and summarize_bugtask()
for creating old bugs and printing a summary of their state.

    >>> from canonical.launchpad.interfaces import (
    ...     IDistributionSet, IPersonSet, IProductSet)
    >>> ubuntu = getUtility(IDistributionSet).getByName('ubuntu')
    >>> jokosher = getUtility(IProductSet).getByName('jokosher')
    >>> sample_person = getUtility(IPersonSet).getByEmail(
    ...     'test@canonical.com')

    # A expirable bugtask. It will be expired because its conjoined
    # master can be expired.
    >>> ubuntu_bugtask = create_old_bug('expirable_distro', 351, ubuntu)
    >>> ubuntu_bugtask.bug.permits_expiration
    True
    >>> sync_bugtasks(ubuntu_bugtask)
    >>> ubuntu_bugtask.bug.can_expire
    True

    # An expirable bugtask, a distroseries. The ubuntu bugtask is its
    # conjoined slave.
    >>> hoary_bugtask = bugtaskset.createTask(
    ...     bug=ubuntu_bugtask.bug, owner=sample_person,
    ...     distroseries=ubuntu.currentseries)
    >>> ubuntu_bugtask.conjoined_master == hoary_bugtask
    True
    >>> ubuntu_bugtask.bug.permits_expiration
    True
    >>> sync_bugtasks([ubuntu_bugtask, hoary_bugtask])
    >>> ubuntu_bugtask.bug.can_expire
    True

    # A bugtask for a product that is expirable.
    >>> jokosher_bugtask = create_old_bug('jokosher', 61, jokosher)
    >>> jokosher_bugtask.bug.permits_expiration
    True
    >>> sync_bugtasks(jokosher_bugtask)
    >>> jokosher_bugtask.bug.can_expire
    True

A bugtask for a product with a bug watch. Note that this bugtask
has otherwise the same parameters as jokosher_bugtask. The 
bugwatch prevents expiration, hence this bugtask will not appear
in the listings of expirable bugtasks below.

    >>> from canonical.launchpad.interfaces import IBugTrackerSet
    >>> mozilla_bugtracker = getUtility(IBugTrackerSet)['mozilla.org']
    >>> jokosher_bugtask_watched = create_old_bug('jokosher watched', 
    ...     61, jokosher, external_bugtracker=mozilla_bugtracker)
    >>> jokosher_bugtask_watched.bug.can_expire
    False

Let's also make some bugs that almost qualify for expiration.

    # A bugtask whose status is not Incomplete is not expirable.
    # This one's status is New.
    >>> thunderbird = getUtility(IProductSet).getByName('thunderbird')
    >>> new_bugtask = bugtaskset.createTask(
    ...     bug=ubuntu_bugtask.bug, owner=sample_person,
    ...     product=thunderbird)
    >>> new_bugtask.status.title
    'New'
    >>> new_bugtask.bug.permits_expiration
    False
    >>> new_bugtask.bug.can_expire
    False

    # A bugtask that is not expirable because it is assigned.
    >>> assigned_bugtask = create_old_bug('assigned', 61, ubuntu)
    >>> assigned_bugtask.transitionToAssignee(sample_person)
    >>> assigned_bugtask.bug.permits_expiration
    True
    >>> assigned_bugtask.bug.can_expire
    False

    # A bug with two Ubuntu tasks, one assigned Incomplete, and one
    # Invalid task, is not expirable.
    >>> another_assigned_bugtask = create_old_bug('assigned', 61, ubuntu)
    >>> another_assigned_bugtask.transitionToAssignee(sample_person)
    >>> ubuntu_evolution = ubuntu.getSourcePackage('evolution')
    >>> invalid_bugtask = bugtaskset.createTask(
    ...     bug=another_assigned_bugtask.bug, owner=sample_person,
    ...     distribution=ubuntu,
    ...     sourcepackagename=ubuntu_evolution.sourcepackagename,
    ...     status=BugTaskStatus.INVALID)
    >>> sync_bugtasks([another_assigned_bugtask, invalid_bugtask])
    >>> another_assigned_bugtask.bug.permits_expiration
    True
    >>> another_assigned_bugtask.bug.can_expire
    False

    # A bugtask that is not expirable because its status is CONFIRMED.
    >>> confirmed_bugtask = create_old_bug(
    ...     'confirmed', 61, ubuntu, status=BugTaskStatus.CONFIRMED)
    >>> confirmed_bugtask.bug.permits_expiration
    False
    >>> confirmed_bugtask.bug.can_expire
    False

    # A bugtask that is not expirable because it is a duplicate.
    >>> duplicate_bugtask = create_old_bug('duplicate', 61, ubuntu)
    >>> duplicate_bugtask.bug.duplicateof = confirmed_bugtask.bug
    >>> duplicate_bugtask.bug.permits_expiration
    True
    >>> duplicate_bugtask.bug.can_expire
    False

    # A bugtask that is not expirable because it does not use
    # Launchpad Bugs.
    >>> external_bugtask = create_old_bug('external', 61, thunderbird)
    >>> external_bugtask.bug.permits_expiration
    False
    >>> thunderbird.enable_bug_expiration
    False
    >>> external_bugtask.bug.can_expire
    False

    # A bugtask that is not expirable because it has a milestone.
    >>> milestone_bugtask = create_old_bug('milestone', 61, ubuntu)
    >>> milestone_bugtask.milestone = ubuntu.currentseries.newMilestone("0.1")
    >>> milestone_bugtask.bug.permits_expiration
    True
    >>> milestone_bugtask.bug.can_expire
    False

    # A bugtask that is not expirable because it less than the
    # min_days_old.
    >>> recent_bugtask = create_old_bug('recent', 31, ubuntu)
    >>> recent_bugtask.bug.permits_expiration
    True
    >>> recent_bugtask.bug.can_expire
    False

    # A bugtask that is not expirable; while the product uses Launchpad to
    # track bugs, enable_bug_expiration is set to False
    >>> firefox = getUtility(IProductSet).getByName('firefox')
    >>> no_expiration_bugtask = create_old_bug('no_expire', 61, firefox)
    >>> no_expiration_bugtask.bug.permits_expiration
    False
    >>> firefox.enable_bug_expiration
    False
    >>> no_expiration_bugtask.bug.can_expire
    False

The ubuntu, hoary, and jokosher bugs are the only ones that can be
expired. The other bugs do not meet one of the preconditions.

    >>> bugtasks = [ubuntu_bugtask, hoary_bugtask, jokosher_bugtask,
    ...     jokosher_bugtask_watched, new_bugtask, assigned_bugtask,
    ...     confirmed_bugtask, duplicate_bugtask, external_bugtask, 
    ...     milestone_bugtask, recent_bugtask, no_expiration_bugtask]

    # Sync the bugs and bugtasks defined above with their modified DB values.
    >>> sync_bugtasks(bugtasks)

    >>> summarize_bugtasks(bugtasks)
    ROLE             EXPIRE  AGE  STATUS      ASSIGNED  DUP    MILE   REPLIES
    ubuntu           True    351  Incomplete  False     False  False  False
    hoary            True    351  Incomplete  False     False  False  False
    jokosher         True     61  Incomplete  False     False  False  False
    jokosher watched True     61  Incomplete  False     False  False  False
    thunderbird      False   351  New         False     False  False  False
    assigned         True     61  Incomplete  True      False  False  False
    confirmed        True     61  Confirmed   False     False  False  False
    duplicate        True     61  Incomplete  False     True   False  False
    external         False    61  Incomplete  False     False  False  False
    milestone        True     61  Incomplete  False     False  True   False
    recent           True     31  Incomplete  False     False  False  False
    no_expire        False    61  Incomplete  False     False  False  False


== findExpirableBugTasks() Part 2 ==

The value of the min_days_old controls the bugtasks that are
returned. The oldest bug in this test is 351 days old, the youngest is
31 days old. There are no bugs older than 351 days.

    >>> expirable_bugtasks = bugtaskset.findExpirableBugTasks(351, None)
    >>> expirable_bugtasks.count()
    0

While there are bugtasks older than 350 days in the data, the hoary
bugtask does not display because its bug has other bugtasks that are
valid.

    >>> expirable_bugtasks = bugtaskset.findExpirableBugTasks(350, None)
    >>> expirable_bugtasks.count()
    0

    >>> hoary_bugtask.bug.can_expire
    False
    >>> summarize_bugtasks(hoary_bugtask.bug.bugtasks)
    ROLE         EXPIRE  AGE  STATUS      ASSIGNED  DUP    MILE   REPLIES
    ubuntu       True    351  Incomplete  False     False  False  False
    hoary        True    351  Incomplete  False     False  False  False
    thunderbird  False   351  New         False     False  False  False

If the valid bugtask becomes Invalid or Won't Fix, the hoary bugtask
will be expirable.

    >>> new_bugtask.transitionToStatus(BugTaskStatus.WONTFIX, sample_person)
    >>> sync_bugtasks(new_bugtask)
    >>> hoary_bugtask.bug.can_expire
    True
    >>> summarize_bugtasks(hoary_bugtask.bug.bugtasks)
    ROLE         EXPIRE  AGE  STATUS      ASSIGNED  DUP    MILE   REPLIES
    ubuntu       True    351  Incomplete  False     False  False  False
    hoary        True    351  Incomplete  False     False  False  False
    thunderbird  False   351  Won't Fix   False     False  False  False

    >>> expirable_bugtasks = bugtaskset.findExpirableBugTasks(350, None)
    >>> summarize_bugtasks(expirable_bugtasks)
    ROLE         EXPIRE  AGE  STATUS      ASSIGNED  DUP    MILE   REPLIES
    ubuntu       True    351  Incomplete  False     False  False  False
    hoary        True    351  Incomplete  False     False  False  False

The ubuntu bugtask is never returned; it is a conjoined slave to the
hoary bugtask. Slave bugtasks cannot be directly expired, so they are
not returned by findExpirableBugTasks().

    >>> ubuntu_bugtask.status.title
    'Incomplete'
    >>> ubuntu_bugtask.conjoined_master == hoary_bugtask
    True

Reducing the age to 60 days old, both hoary and jokosher bugtasks
are returned.

    >>> expirable_bugtasks = bugtaskset.findExpirableBugTasks(60, None)
    >>> summarize_bugtasks(expirable_bugtasks)
    ROLE         EXPIRE  AGE  STATUS      ASSIGNED  DUP    MILE   REPLIES
    ubuntu       True    351  Incomplete  False     False  False  False
    hoary        True    351  Incomplete  False     False  False  False
    jokosher     True     61  Incomplete  False     False  False  False


When a bug is passed as an argument to findExpirableBugTasks(), it
returns that bug's expirable BugTasks, or an empty list. Passing the bug
that has the hoary and ubuntu bugtasks with 0 min_days_old returns just
the hoary bugtask.

    >>> expirable_bugtasks = bugtaskset.findExpirableBugTasks(
    ...     0, None, bug=hoary_bugtask.bug)
    >>> summarize_bugtasks(expirable_bugtasks)
    ROLE         EXPIRE  AGE  STATUS      ASSIGNED  DUP    MILE   REPLIES
    ubuntu       True    351  Incomplete  False     False  False  False
    hoary        True    351  Incomplete  False     False  False  False

When a BugTarget is passed as an argument to findExpirableBugTasks(), it
returns all the target's expirable bugtasks, or an empty list. If the
target's pillar has not enabled bug expiration, None is always returned.
Passing ubuntu with 0 min_days_old shows that the distribution has two
bugtasks that can expire if they are not confirmed.

    >>> expirable_bugtasks = bugtaskset.findExpirableBugTasks(
    ...     0, None, target=ubuntu)
    >>> summarize_bugtasks(expirable_bugtasks)
    ROLE         EXPIRE  AGE  STATUS      ASSIGNED  DUP    MILE   REPLIES
    ubuntu       True    351  Incomplete  False     False  False  False
    hoary        True    351  Incomplete  False     False  False  False
    recent       True     31  Incomplete  False     False  False  False

Thunderbird has not enabled bug expiration. Even when the min_days_old
is set to 0, no bugtasks are replaced.

    >>> expirable_bugtasks = bugtaskset.findExpirableBugTasks(
    ...     0, None, target=thunderbird)
    >>> summarize_bugtasks(expirable_bugtasks)
    ROLE         EXPIRE  AGE  STATUS      ASSIGNED  DUP    MILE   REPLIES


== Privacy ==

The user parameter indicates which user is performing the search. Only
bugs that the user has permission to view are returned. A value of None
indicates the anonymous user.

    >>> expirable_bugtasks = bugtaskset.findExpirableBugTasks(
    ...     0, user=None, target=ubuntu)
    >>> visible_bugs = set(bugtask.bug for bugtask in expirable_bugtasks)
    >>> print sorted(bug.title for bug in visible_bugs)
    [u'expirable_distro', u'recent']

If one of the bugs is set to private, anonymous users can no longer see
it as being marked for expiration.

    >>> from canonical.launchpad.ftests import syncUpdate
    >>> private_bug = ubuntu_bugtask.bug
    >>> private_bug.title
    u'expirable_distro'
    >>> private_bug.setPrivate(True, sample_person)
    True
    >>> syncUpdate(private_bug)

    >>> expirable_bugtasks = bugtaskset.findExpirableBugTasks(
    ...     0, user=None, target=ubuntu)
    >>> visible_bugs = set(bugtask.bug for bugtask in expirable_bugtasks)
    >>> print sorted(bug.title for bug in visible_bugs)
    [u'recent']

No Privileges Person can't see the bug either...

    >>> no_priv = getUtility(IPersonSet).getByName('no-priv')
    >>> private_bug.unsubscribe(no_priv)
    >>> expirable_bugtasks = bugtaskset.findExpirableBugTasks(
    ...     0, user=no_priv, target=ubuntu)
    >>> visible_bugs = set(bugtask.bug for bugtask in expirable_bugtasks)
    >>> print sorted(bug.title for bug in visible_bugs)
    [u'recent']

... unless he's subscribed to the bug.

    >>> private_bug.subscribe(no_priv, sample_person)
    <BugSubscription at ...>
    >>> expirable_bugtasks = bugtaskset.findExpirableBugTasks(
    ...     0, user=no_priv, target=ubuntu)
    >>> visible_bugs = set(bugtask.bug for bugtask in expirable_bugtasks)
    >>> print sorted(bug.title for bug in visible_bugs)
    [u'expirable_distro', u'recent']

The Janitor needs to be able to access all bugs, even private ones, in
order to be able to expire them. If the Janitor is passed as the user,
even the private bugs are returned.

    >>> from canonical.launchpad.interfaces import ILaunchpadCelebrities
    >>> janitor = getUtility(ILaunchpadCelebrities).janitor
    >>> private_bug.isSubscribed(janitor)
    False

    >>> expirable_bugtasks = bugtaskset.findExpirableBugTasks(
    ...     0, user=janitor, target=ubuntu)
    >>> visible_bugs = set(bugtask.bug for bugtask in expirable_bugtasks)
    >>> print sorted(bug.title for bug in visible_bugs)
    [u'expirable_distro', u'recent']

    >>> private_bug.setPrivate(False, sample_person)
    True


== The default expiration age ==

The expiration age is set using the
config.malone.days_before_expiration configuration variable. It
defaults to 60 days. The period is measured from the date_incomplete
field. We expire bugtasks that are Incomplete and unattended for 60
days or more.

    >>> from canonical.config import config
    >>> old_age_days = config.malone.days_before_expiration
    >>> old_age_days
    60


== Running the script ==

There is one Invalid Bugtasks in sampledata, from the tests above.

    >>> from canonical.launchpad.database import BugTask
    >>> BugTask.selectBy(status=BugTaskStatus.INVALID).count()
    1

    >>> # We want to check the hoary bugtask messages later.
    >>> starting_bug_messages_count = (hoary_bugtask.bug.messages.count())

The script 'expire-bugtasks.py' writes its report to stdout. It makes
its database changes as the user configured in
config.malone.expiration_dbuser.

    >>> config.malone.expiration_dbuser
    'bugnotification'

    # Commit the current transaction because the script will run in
    # another transaction, and thus it won't see the changes done on
    # this test unless we commit.
    >>> commit()

    >>> import subprocess
    >>> process = subprocess.Popen(
    ...     'cronscripts/expire-bugtasks.py', shell=True,
    ...     stdin=subprocess.PIPE, stdout=subprocess.PIPE,
    ...     stderr=subprocess.PIPE)
    >>> (out, err) = process.communicate()
    >>> print err
    INFO    creating lockfile
    INFO    Expiring unattended, INCOMPLETE bugtasks older than
            60 days for projects that use Launchpad Bugs.
    INFO    Found 3 bugtasks to expire.
    INFO    Expired 2 bugtasks.
    INFO    Finished expiration run.
    <BLANKLINE>
    >>> print out
    <BLANKLINE>
    >>> process.returncode
    0

    >>> sync_bugtasks(bugtasks)


== After the script has run ==

There are three Invalid bugtasks. Jokosher, hoary and ubuntu were
expired by the expiration process. Although ubuntu was never returned
by findExpirableBugTasks(), it was expired because its master (hoary)
was expired. The remaining bugtasks are unchanged.

    >>> summarize_bugtasks(bugtasks)
    ROLE             EXPIRE  AGE  STATUS      ASSIGNED  DUP    MILE   REPLIES
    ubuntu           True      0  Invalid     False     False  False  False
    hoary            True      0  Invalid     False     False  False  False
    jokosher         True      0  Invalid     False     False  False  False
    jokosher watched True     61  Incomplete  False     False  False  False
    thunderbird      False     0  Won't Fix   False     False  False  False
    assigned         True     61  Incomplete  True      False  False  False
    confirmed        True     61  Confirmed   False     False  False  False
    duplicate        True     61  Incomplete  False     True   False  False
    external         False    61  Incomplete  False     False  False  False
    milestone        True     61  Incomplete  False     False  True   False
    recent           True     31  Incomplete  False     False  False  False
    no_expire        False    61  Incomplete  False     False  False  False

Only the three test bugtasks were expired in the entire database. The
evolution task was already Invalid.

    >>> invalid_bugtasks = BugTask.selectBy(status=BugTaskStatus.INVALID)
    >>> summarize_bugtasks(invalid_bugtasks)
    ROLE         EXPIRE  AGE  STATUS      ASSIGNED  DUP    MILE   REPLIES
    ubuntu       True      0  Invalid     False     False  False  False
    hoary        True      0  Invalid     False     False  False  False
    jokosher     True      0  Invalid     False     False  False  False
    evolution    True     61  Invalid     False     False  False  False

The bugtasks statusexplanation was updated to explain the change in
status.

    >>> print hoary_bugtask.statusexplanation
    [Expired for Ubuntu Hoary because there has been no activity for 60 days.]

The message explaining the reason for the expiration was posted by the
Launchpad Janitor celebrity. Only one message was created for when the
master and slave bugtasks were expired.

    >>> starting_bug_messages_count
    2
    >>> hoary_bugtask.bug.messages.count()
    3

    >>> message =  hoary_bugtask.bug.messages[-1]
    >>> print message.owner.name
    janitor

    >>> print message.text_contents
    [Expired for Ubuntu Hoary because there has been no activity for 60 days.]

The bug's activity log was updated too with the statusexplanation and
status changes.

    >>> for activity in hoary_bugtask.bug.activity:
    ...     print "%s %s %s %s" % (
    ...         activity.person.displayname,
    ...         activity.whatchanged, activity.oldvalue, activity.newvalue)
    Launchpad Janitor  None: status             Incomplete  Invalid
    Launchpad Janitor  None: statusexplanation  None        [Expired for...


== enable_bug_expiration ==

The bugtask no_expiration_bugtask has not been expired because it does
not participate in bug expiration. When uses_bug_expiration is set to
True for a project, old bugs will be expired the next time the bugs are
expired.

    >>> no_expiration_bugtask.pillar.enable_bug_expiration = True
    >>> from canonical.launchpad.ftests import sync
    >>> sync(no_expiration_bugtask.pillar)

    >>> no_expiration_bugtask.bug.permits_expiration
    True
    >>> no_expiration_bugtask.bug.can_expire
    True
    >>> expirable_bugtasks = bugtaskset.findExpirableBugTasks(60, None)
    >>> summarize_bugtasks(expirable_bugtasks)
    ROLE         EXPIRE  AGE  STATUS      ASSIGNED  DUP    MILE   REPLIES
    no_expire    True    61   Incomplete  False     False  False  False

