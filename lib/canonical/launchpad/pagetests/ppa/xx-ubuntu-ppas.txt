= Ubuntu PPAs =

The Ubuntu Linux page contains a link to get to the Personal Package Archives.

    >>> browser.open("http://launchpad.dev/ubuntu")
    >>> browser.getLink("Personal Package Archives").click()
    >>> browser.title
    'Ubuntu Linux Personal Package Archives'

== PPA main page ==

The PPA page contains a search box and a table of known PPAs with columns
Owner, Description, Sources and Binaries, the latter two being a count.

The sample data contains three PPAs.  Only Celso has any packages, with two
sources and one binary.

== Searching PPAs ==

By default only active (those with, at least one, PENDING or PUBLISHED
source record) PPAs are presented.

    >>> for ppa_row in find_tags_by_class(browser.contents, 'ppa_batch_row'):
    ...    print extract_text(ppa_row)
    Celso Providelo
    packages to help my friends.
    3
    3
    Mark Shuttleworth
    packages to help the humanity (you know, ubuntu)
    1
    1

We have a checkbox to allow inactive PPA results.

    >>> browser.getControl(name="show_inactive").value = True
    >>> browser.getControl("Search").click()

    >>> for ppa_row in find_tags_by_class(browser.contents, 'ppa_batch_row'):
    ...    print extract_text(ppa_row)
    Celso Providelo
    packages to help my friends.
    3
    3
    No Privileges Person
    I am not allowed to say, I have no privs.
    0
    0
    Mark Shuttleworth
    packages to help the humanity (you know, ubuntu)
    1
    1

This checkbox value is propagated to subsequent searches:

    >>> browser.getControl(name="show_inactive").value
    True

No data matches the non-existent search string "bustmybuffers".

    >>> field = browser.getControl("PPAs containing:")
    >>> field.value = 'bustmybuffers'
    >>> browser.getControl("Search").click()
    >>> len(find_tags_by_class(browser.contents, 'ppa_batch_row'))
    0

In the three sample data PPAs, only one matches the search string "Celso".

    >>> field = browser.getControl("PPAs containing:")
    >>> field.value = 'Celso'
    >>> browser.getControl("Search").click()
    >>> len(find_tags_by_class(browser.contents, 'ppa_batch_row'))
    1

== Owner's PPA pages ==

Let's start by adding an extra package to Celso's archive:

    >>> import transaction
    >>> from canonical.database.sqlbase import flush_database_updates
    >>> from canonical.launchpad.ftests.ppa import publishToPPA
    >>> from canonical.launchpad.ftests import ANONYMOUS, login, logout
    >>> login(ANONYMOUS)
    >>> publishToPPA("cprov", "warty", "commercialpackage", "1.0-1")
    >>> logout()
    >>> transaction.commit()
    >>> flush_database_updates()

And now on to the page itself. In the table rows, the "Owner" is a
clickable link to his PPA page:

    >>> browser.getLink("Celso Providelo").click()
    >>> browser.title
    'PPA for Celso Providelo'

Let's see his sources.list entries:

    >>> results = find_tag_by_id(browser.contents, 'sources-list-entries')
    >>> text = extract_text(results)
    >>> print text
    deb http://ppa.launchpad.dev/cprov/ubuntu hoary main
    deb-src http://ppa.launchpad.dev/cprov/ubuntu hoary main

and the select control that lets you update them:

    >>> print find_tag_by_id(browser.contents, 'series-widget-div')
    <div id="series-widget-div">
    ...
        <select id="field.series" name="field.series" size="1" onchange="updateSeries(this);">
            <option value="breezy-autotest">Breezy Badger Autotest</option>
            <option value="warty">The Warty Warthog Release</option>
        </select>
    ...

The page also shows some stats about Celso's PPA (number of sources. binaries
and estimated size).

    >>> results = find_tag_by_id(browser.contents, 'package_counters')
    >>> text = extract_text(results)
    >>> print text
    4 source packages
    (9.5 MiB)
    3 binary packages
    (3 bytes)
    Estimated archive size:
    9.5 MiB

The sample data has two packages belonging to Celso. Two table rows
will be presented to user containing:

 * SourcePackageRelease title (<source_name> - <source-version>),
 * Date Published,
 * target DistroSeries,
 * original Section

The headings:

    >>> print find_tag_by_id(browser.contents, 'packages_list')
    <table class="listing" id="packages_list">
    <thead>
    <tr>
    <th colspan="2">Source</th>
    <th>Published</th>
    <th>Status</th>
    <th>Series</th>
    <th>Section</th>
    </tr>
    </thead>
    ...

The data:

    >>> for ppa_row in find_tags_by_class(browser.contents, 'ppa_package_row'):
    ...    print extract_text(ppa_row)
    cdrkit - 1.0
    2007-07-09
    Published
    breezy-autotest
    editors
    commercialpackage - 1.0-1
    (changes)
    Pending
    warty
    devel
    iceweasel - 1.0
    2007-07-09
    Published
    warty
    editors
    pmount - 0.1-1
    2007-07-09
    Published
    warty
    editors


== Searching an archive ==

We can search a PPA for a particular package.  A non-existent package shows
no results.

    >>> field = browser.getControl(name='field.name_filter')
    >>> field.value = 'nonexistentpackage'
    >>> browser.getControl("Search").click()
    >>> len(find_tags_by_class(browser.contents, 'ppa_package_row'))
    0

Searching for the package "iceweasel" show's that Celso is providing this.

    >>> field = browser.getControl(name='field.name_filter')
    >>> field.value = 'iceweasel'
    >>> browser.getControl("Search").click()
    >>> len(find_tags_by_class(browser.contents, 'ppa_package_row'))
    1

In order to have a wider coverage in search status filter we will
modify some publication in Celso's PPA to SUPERSEDED and DELETED
states.

    >>> from canonical.launchpad.interfaces import (
    ...     IPersonSet, PackagePublishingStatus)
    >>> from zope.component import getUtility
    >>> login('foo.bar@canonical.com')
    >>> cprov = getUtility(IPersonSet).getByName('cprov')
    >>> iceweasel_pub = cprov.archive.getPublishedSources(name='iceweasel')[0]
    >>> iceweasel_pub.secure_record.status = PackagePublishingStatus.SUPERSEDED
    >>> pmount_pub = cprov.archive.getPublishedSources(name='pmount')[0]
    >>> pmount_pub.secure_record.status = PackagePublishingStatus.DELETED
    >>> logout()
    >>> transaction.commit()
    >>> flush_database_updates()

The default status filter is 'published', which means that, by
default, PPA pages will only present PUBLISHED or PENDING packages.

    >>> field = browser.getControl(name='field.name_filter')
    >>> field.value = ''
    >>> browser.getControl("Search").click()
    >>> len(find_tags_by_class(browser.contents, 'ppa_package_row'))
    2

    >>> for ppa_row in find_tags_by_class(browser.contents, 'ppa_package_row'):
    ...    print extract_text(ppa_row)
    cdrkit - 1.0               2007-07-09  Published  breezy-autotest  editors
    commercialpackage - 1.0-1  (changes)   Pending    warty            devel

Use can explicitly select 'published' filter and will get the same result.

    >>> field = browser.getControl(name='field.status_filter')
    >>> field.value = ['published']
    >>> browser.getControl("Search").click()
    >>> len(find_tags_by_class(browser.contents, 'ppa_package_row'))
    2

    >>> for ppa_row in find_tags_by_class(browser.contents, 'ppa_package_row'):
    ...    print extract_text(ppa_row)
    cdrkit - 1.0               2007-07-09  Published  breezy-autotest  editors
    commercialpackage - 1.0-1  (changes)   Pending    warty            devel

When needed the users can select the 'superseded' filter and the
result will only contain packages SUPERSEDED or DELETED.

    >>> field = browser.getControl(name='field.status_filter')
    >>> field.value = ['superseded']
    >>> browser.getControl("Search").click()
    >>> len(find_tags_by_class(browser.contents, 'ppa_package_row'))
    2

    >>> for ppa_row in find_tags_by_class(browser.contents, 'ppa_package_row'):
    ...    print extract_text(ppa_row)
    iceweasel - 1.0   2007-07-09   Superseded    warty    editors
    pmount - 0.1-1    2007-07-09   Deleted       warty    editors

The 'Any Status' filter is also available, so the user can search over
any package ever published in the context PPA.

    >>> field = browser.getControl(name='field.status_filter')
    >>> field.value = ['any']
    >>> browser.getControl("Search").click()
    >>> len(find_tags_by_class(browser.contents, 'ppa_package_row'))
    4

    >>> for ppa_row in find_tags_by_class(browser.contents, 'ppa_package_row'):
    ...    print extract_text(ppa_row)
    cdrkit - 1.0               2007-07-09  Published  breezy-autotest  editors
    commercialpackage - 1.0-1  (changes)   Pending    warty            devel
    iceweasel - 1.0            2007-07-09  Superseded warty            editors
    pmount - 0.1-1             2007-07-09  Deleted    warty            editors


== Single-publication PPAs ==

Just quickly check if the singular form of this section is handled
properly.

    >>> anon_browser.open("http://launchpad.dev/~sabdfl/+archive")
    >>> anon_browser.title
    'PPA for Mark Shuttleworth'

    >>> results = find_tag_by_id(anon_browser.contents, 'package_counters')
    >>> text = extract_text(results)
    >>> print text
    1 source package
    (9.5 MiB)
    1 binary package
    (0 bytes)
    Estimated archive size:
    9.5 MiB

Mark has sources only published in one archive, so he has no
series-widget-div control to update them:

    >>> print find_tag_by_id(anon_browser.contents, 'series-widget-div')
    None


== Other Distribution PPAs ==

PPAs are targeted to a specific distribution and currently we only
allow Ubuntu PPAs, thus 'ubuntutest' PPAs page should be empty:

    >>> browser.open("http://launchpad.dev/ubuntutest")
    >>> browser.getLink("Personal Package Archives").click()
    >>> browser.title
    'Ubuntu Test Personal Package Archives'

    >>> len(find_tags_by_class(browser.contents, 'ppa_batch_row'))
    0

== Team PPA pages ==

Team PPA pages contain an extra column showing which team member uploaded
the package. First we need to set up a team PPA and publish something to it.

    >>> browser = setupBrowser(auth="Basic foo.bar@canonical.com:test")
    >>> browser.open("http://launchpad.dev/~ubuntu-team/+activate-ppa")
    >>> browser.getControl(name="field.accepted").value = True
    >>> browser.getControl('Activate').click()
    >>> ubuntu_ppa_url = browser.url

Publish mozilla-firefox to ubuntu-team's PPA and ensure that it is signed
by name16 (Foo Bar) who is a member - the signer is presented as the uploader
in the list.

    >>> from canonical.launchpad.ftests.ppa import publishToTeamPPA
    >>> login(ANONYMOUS)
    >>> publishToTeamPPA(team_name="ubuntu-team")
    >>> logout()
    >>> transaction.commit()
    >>> flush_database_updates()

Access ubuntu-team's PPA page:

    >>> browser.open(ubuntu_ppa_url)

The package row headings show an Uploader column:

    >>> print find_tag_by_id(browser.contents, 'packages_list')
    <table class="listing" id="packages_list">
    <thead>
    <tr>
    <th colspan="2">Source</th>
    <th>Uploader</th>
    <th>Published</th>
    <th>Status</th>
    <th>Series</th>
    <th>Section</th>
    </tr>
    </thead>
    ...

The package row data shows the uploader:

    >>> for ppa_row in find_tags_by_class(browser.contents, 'ppa_package_row'):
    ...    print extract_text(ppa_row)
    mozilla-firefox - 0.9
    name16
    Pending
    hoary
    base

Links from files go to their on-archive locations:

    >>> browser.getLink("orig").url
    'http://.../firefox-0.9.2.orig.tar.gz'

The uploader name is linkified to that user's home page:

    >>> browser.getLink(url="~name16").click()
    >>> browser.url
    'http://launchpad.dev/~name16'

