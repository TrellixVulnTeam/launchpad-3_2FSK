PO Imports
----------

The tale of a PO template and a PO file and how they get imported into
Rosetta.

    >>> from zope.app import datetimeutils

Here are some imports we need to get this test running.

    >>> from canonical.launchpad.ftests import syncUpdate
    >>> from canonical.launchpad.interfaces import ITranslationImportQueue
    >>> from canonical.launchpad.interfaces import IPersonSet
    >>> from canonical.launchpad.interfaces import ILaunchpadCelebrities
    >>> from canonical.launchpad.database import (
    ...     POTemplateSubset, SourcePackageName)
    >>> from canonical.launchpad.scripts.po_import import (
    ...     AutoApproveProcess, ImportProcess)
    >>> import datetime
    >>> import pytz
    >>> UTC = pytz.timezone('UTC')

We need this for the Librarian to work properly.

    >>> import transaction

And also, the DBSchema to change the imports status

    >>> from canonical.launchpad.interfaces import RosettaImportStatus

Here's a fake logger to capture any errors that happen.

    >>> from canonical.launchpad.scripts import FakeLogger

Login as an admin to be able to do changes to the import queue.

    >>> login('carlos@canonical.com')

Now, is time to create the new potemplate

    >>> from canonical.launchpad.database import ProductRelease
    >>> release = ProductRelease.get(3)
    >>> release.productseries.product.name
    u'firefox'
    >>> series = release.productseries
    >>> subset = POTemplateSubset(productseries=series)

Here's the person who'll be doing the import.

    >>> person_set = getUtility(IPersonSet)
    >>> person = person_set.getByName('sabdfl')

And this is the POTemplate where the import will be done.

    >>> potemplate = subset.new(
    ...     name='firefox',
    ...     translation_domain='firefox',
    ...     path='po/firefox.pot',
    ...     owner=person)

This is the file that'll get imported.

    >>> potemplate_contents = r'''
    ... msgid ""
    ... msgstr ""
    ... "POT-Creation-Date: 2004-07-11 16:16+0900\n"
    ... "Content-Type: text/plain; charset=CHARSET\n"
    ... "Plural-Forms: nplurals=INTEGER; plural=EXPRESSION;\n"
    ... "X-Rosetta-Export-Date: %s\n"
    ...
    ... msgid "foo"
    ... msgstr ""
    ...
    ... msgid "bar"
    ... msgstr ""
    ...
    ... #: test.c:13
    ... msgid "baz"
    ... msgstr ""
    ...
    ... #, c-format
    ... msgid "Foo %%s"
    ... msgstr ""
    ...
    ... #, c-format
    ... msgid "Singular %%d"
    ... msgid_plural "Plural %%d"
    ... msgstr[0] ""
    ... msgstr[1] ""
    ... ''' % datetime.datetime.now(UTC).isoformat()

Attach the import to the translations import queue:

    >>> translation_import_queue = getUtility(ITranslationImportQueue)
    >>> entry = translation_import_queue.addOrUpdateEntry(
    ...     potemplate.path, potemplate_contents, True, potemplate.owner,
    ...     productseries=series, potemplate=potemplate)

The file data is stored in the Librarian, so we have to commit the transaction
to make sure it's stored properly.

    >>> transaction.commit()

The entry gets approved, so it can be imported.

    >>> entry.status = RosettaImportStatus.APPROVED

    >>> import datetime
    >>> import pytz
    >>> UTC = pytz.timezone('UTC')
    >>> saved_date = datetime.datetime.now(UTC)


Now, we tell the PO template to import from the file data it has.

    >>> (subject, body) = potemplate.importFromQueue(entry, FakeLogger())

Our request has now been serviced.

    >>> print entry.status.name
    IMPORTED

The last update date is the one we got.

    >>> potemplate.date_last_updated > saved_date
    True

A successful import is confirmed by email.

    >>> subject
    u'Translation template import - firefox in Mozilla Firefox trunk'
    >>> print body
    Hello Mark Shuttleworth,
    <BLANKLINE>
    On ..., you uploaded a translation
    template for firefox in Mozilla Firefox trunk in Launchpad.
    <BLANKLINE>
    The template has now been imported successfully.
    <BLANKLINE>
    Thank you,
    <BLANKLINE>
    The Launchpad team

The correct message IDs now show up in the template.

    >>> potmsgsets = list(potemplate.getPOTMsgSets())
    >>> [potmsgset.msgid_singular.msgid for potmsgset in potmsgsets]
    [u'foo', u'bar', u'baz', u'Foo %s', u'Singular %d']

The file references field should be there

    >>> potmsgsets[2].filereferences
    u'test.c:13'

Now let's get a PO file to import.

    >>> pofile = potemplate.newPOFile('cy')
    >>> pofile_id = pofile.id

By default, we got a safe path to prevent collisions with other IPOFile.

    >>> pofile.path
    u'po/firefox-cy.po'

Let's override the default good path with one we know is the right one.

    >>> pofile.path = u'po/cy.po'

It's newly created, so it has no translated messages yet.

    >>> pofile.getPOTMsgSetTranslated().count()
    0

And the statistics reflect it.

    >>> pofile.currentCount()
    0

Here are the contents of the file we'll be importing. It has some validation
errors.

    >>> pofile_with_errors = r'''
    ... msgid ""
    ... msgstr ""
    ... "PO-Revision-Date: 2005-06-03 19:41+0100\n"
    ... "Last-Translator: Carlos Perello Marin <carlos@canonical.com>\n"
    ... "Content-Type: text/plain; charset=UTF-8\n"
    ... "Plural-Forms: nplurals=4; plural=n==1) ? 0 : n==2 ? 1 : (n != 8 || n != 11) ? 2 : 3;\n"
    ... "X-Rosetta-Export-Date: %s\n"
    ...
    ... msgid "foo"
    ... msgstr "blah"
    ...
    ... #, fuzzy
    ... msgid "bar"
    ... msgstr "heffalump"
    ...
    ... msgid "balloon"
    ... msgstr "blah"
    ...
    ... #, c-format
    ... msgid "Foo %%s"
    ... msgstr "blah %%i"
    ...
    ... #, c-format
    ... msgid "Singular %%d"
    ... msgid_plural "Plural %%d"
    ... msgstr[0] "Foos %%d"
    ... msgstr[1] "Bars %%d"
    ... msgstr[2] "Welsh power! %%d"
    ... msgstr[3] "We have four! %%d"
    ... ''' % datetime.datetime.now(UTC).isoformat()

This is the dbschema that controls the validation of a translation.
    >>> from canonical.launchpad.interfaces import TranslationValidationStatus

The process of importing a PO file is much like that of importing a PO
template. Remember, we need to tell the system that this po file is an
"imported" one.

    >>> entry = translation_import_queue.addOrUpdateEntry(
    ...     pofile.path, pofile_with_errors, True, person,
    ...     productseries=series, potemplate=potemplate)
    >>> transaction.commit()

The guess IPOFile should be the same we already had.

    >>> entry.getGuessedPOFile().id == pofile.id
    True

Set it as the place where the entry should be imported.

    >>> entry.pofile = entry.getGuessedPOFile()

We must approve the entry to be able to import it.

    >>> entry.status = RosettaImportStatus.APPROVED

And we do the import.

    >>> (subject, body) = pofile.importFromQueue(entry, FakeLogger())
    >>> flush_database_updates()

The status is now IMPORTED:

    >>> print entry.status.name
    IMPORTED

And the statistics reflect it.

    >>> pofile.currentCount()
    3

Here's a current message: i.e. it has a corresponding current message
set in the PO template. It was not marked as fuzzy the last time it was
imported.

    >>> message = pofile.translation_messages[0]
    >>> message.potmsgset.msgid_singular.msgid
    u'foo'
    >>> message.was_fuzzy_in_last_import
    False

And should be accepted by our validator.

    >>> published = message.potmsgset.getImportedTranslationMessage(
    ...     pofile.language)
    >>> published.validation_status == TranslationValidationStatus.OK
    True

This message set should be fuzzy, however.

    >>> message = pofile[u'bar']
    >>> message.was_fuzzy_in_last_import
    True

And as we don't have a translation for it over the web, it should
be the same for the active translation.

    >>> message.is_fuzzy
    True

We can also get the ones that have validation errors.

    >>> potmsgsets = pofile.getPOTMsgSetWithErrors()
    >>> potmsgsets.count()
    1
    >>> for potmsgset in potmsgsets:
    ...     translationmessages = potmsgset.getLocalTranslationMessages(
    ...         pofile.language)
    ...     for translationmessage in translationmessages:
    ...         assert (
    ...             translationmessage.validation_status ==
    ...             TranslationValidationStatus.UNKNOWNERROR), (
    ...             "Doesn't have a validation error")

Check that the plural form was imported correctly.

    >>> potmsgset = pofile.potemplate.getPOTMsgSetByMsgIDText(
    ...     key=u'Singular %d')
    >>> imported_translationmessage = potmsgset.getImportedTranslationMessage(
    ...     pofile.language)
    >>> print imported_translationmessage.validation_status.name
    OK
    >>> imported_translationmessage.translations
    [u'Foos %d', u'Bars %d', u'Welsh power! %d', u'We have four! %d']

The owner for those translations should be Carlos, instead of the person
that did the upload, because the imported file states that Carlos is the
translator.

    >>> imported_translationmessage.submitter.displayname
    u'Carlos Perell\xf3 Mar\xedn'

The import process produces an emailwarning us of partial failure.

    >>> subject
    u'Translation problems - Welsh (cy) - firefox in Mozilla Firefox trunk'
    >>> print body
    Hello Mark Shuttleworth,
    <BLANKLINE>
    On ..., you uploaded 5
    Welsh (cy) translations for firefox in Mozilla Firefox trunk in Launchpad.
    <BLANKLINE>
    There were problems with 1 of these translations.
    <BLANKLINE>
    4. "format specifications in 'msgid' and 'msgstr' for argument 1 are not the same":
    <BLANKLINE>
    #, c-format
    msgid "Foo %s"
    msgstr "blah %i"
    <BLANKLINE>
    <BLANKLINE>
    <BLANKLINE>
    The other 4 translations have been accepted.
    <BLANKLINE>
    ...

Now, let's import one without errors.

    >>> rosetta_experts = getUtility(ILaunchpadCelebrities).rosetta_experts
    >>> pofile_without_errors = r'''
    ... msgid ""
    ... msgstr ""
    ... "PO-Revision-Date: 2005-06-03 20:41+0100\n"
    ... "Last-Translator: Foo <no-priv@canonical.com>\n"
    ... "Content-Type: text/plain; charset=UTF-8\n"
    ... "Plural-Forms: nplurals=4; plural=n==1) ? 0 : n==2 ? 1 : (n != 8 || n != 11) ? 2 : 3;\n"
    ... "X-Rosetta-Export-Date: %s\n"
    ...
    ... msgid "foo"
    ... msgstr "blah"
    ... ''' % datetime.datetime.now(UTC).isoformat()
    >>> entry = translation_import_queue.addOrUpdateEntry(
    ...     pofile.path, pofile_without_errors, True, rosetta_experts,
    ...     productseries=series, potemplate=potemplate)
    >>> transaction.commit()

The guess IPOFile should be the same we already had.

    >>> entry.getGuessedPOFile().id == pofile.id
    True

Set it as the place where the entry should be imported.

    >>> entry.pofile = entry.getGuessedPOFile()

We must approve the entry to be able to import it.

    >>> entry.status = RosettaImportStatus.APPROVED

At this point, the statistics note that we have 3 translations coming from
imported files (currentCount), and none updated or added in Launchpad
Translations.

    >>> pofile.currentCount()
    3
    >>> pofile.updatesCount()
    0
    >>> pofile.rosettaCount()
    0

We do the import.

    >>> (subject, body) = pofile.importFromQueue(entry, FakeLogger())

The status is now IMPORTED:

    >>> print entry.status.name
    IMPORTED

Now, the statistics note that we have only 1 translation coming from
imported files (currentCount), which is the translation we just
imported, and the other two translation that was coming from imported
files are now counted as coming from Launchpad translations
(rosettaCount) because latest imported file doesn't have them anymore.

    >>> pofile.currentCount()
    1
    >>> pofile.updatesCount()
    0
    >>> pofile.rosettaCount()
    1

This time, our notification email reports complete success.

    >>> subject
    u'Translation import - Welsh (cy) - firefox in Mozilla Firefox trunk'
    >>> print body
    Hello Rosetta Administrators,
    <BLANKLINE>
    ...

Check to be sure that we notify when a msgid_plural is changed without touch
the msgid

    >>> pofile_content = r'''
    ... msgid ""
    ... msgstr ""
    ... "PO-Revision-Date: 2005-06-04 20:41+0100\n"
    ... "Last-Translator: Foo <no-priv@canonical.com>\n"
    ... "Content-Type: text/plain; charset=UTF-8\n"
    ... "Plural-Forms: nplurals=2; plural=n==1 ? 0;\n"
    ... "X-Rosetta-Export-Date: %s\n"
    ...
    ... #, c-format
    ... msgid "Singular %%d"
    ... msgid_plural "Plurals %%d"
    ... msgstr[0] ""
    ... msgstr[1] ""
    ... ''' % datetime.datetime.now(UTC).isoformat()
    >>> entry = translation_import_queue.addOrUpdateEntry(
    ...     pofile.path, pofile_content, True, rosetta_experts,
    ...     productseries=series, potemplate=potemplate)
    >>> transaction.commit()
    >>> entry.pofile = entry.getGuessedPOFile()
    >>> entry.status = RosettaImportStatus.APPROVED
    >>> (subject, body) = pofile.importFromQueue(entry, FakeLogger())
    >>> print entry.status.name
    IMPORTED

The email notification mentions the oddity:

    >>> subject
    u'Translation problems - Welsh (cy) - firefox in Mozilla Firefox trunk'
    >>> print body
    Hello Rosetta Administrators,
    <BLANKLINE>
    ...
    5. "The msgid_plural field has changed since the last time this file was
    generated, please report this error to ...
    <BLANKLINE>
    #, c-format
    msgid "Singular %d"
    msgid_plural "Plurals %d"
    msgstr[0] ""
    msgstr[1] ""
    ...

We tested already that the functionality works. Now it's time to know if the
cronscript has any problem.

First, we are going to reactivate the entries that were already imported or
failed. Note that we'll only reactivate the entries we use in this test;
We don't touch entries that were in the queue previously.

    >>> for entry in translation_import_queue:
    ...     if (entry.status == RosettaImportStatus.IMPORTED or
    ...         entry.status == RosettaImportStatus.FAILED) and (
    ...         entry.productseries == series):
    ...         entry.status = RosettaImportStatus.APPROVED
    ...     syncUpdate(entry)
    >>> transaction.commit()

And run the import script.

    >>> import email
    >>> from canonical.launchpad.mail import stub
    >>> process = ImportProcess(transaction, FakeLogger())
    >>> process.run()
    INFO    Importing: Template "firefox" in Mozilla Firefox trunk
    INFO    Importing: Welsh (cy) translation of firefox in Mozilla Firefox trunk
    WARNING Got an old version for Welsh (cy) translation of firefox in Mozilla Firefox trunk
    INFO    Importing: Welsh (cy) translation of firefox in Mozilla Firefox trunk
    INFO    Import requests completed.

The import script also generates the emails similar to the ones we saw
composed before, but also sends them.

    >>> len(stub.test_emails)
    3
    >>> from_addr, to_addrs, raw_message = stub.test_emails.pop()
    >>> msg = email.message_from_string(raw_message)
    >>> msg["Subject"]
    'Translation problems - Welsh (cy) - firefox in Mozilla Firefox trunk'
    >>> print msg.get_payload(decode=True)
    Hello Rosetta Administrators,
    <BLANKLINE>
    ...
    5. "The msgid_plural field has changed since the last time this file was
    generated, please report this error to ...
    <BLANKLINE>
    #, c-format
    msgid "Singular %d"
    msgid_plural "Plurals %d"
    msgstr[0] ""
    msgstr[1] ""
    ...

    >>> from_addr, to_addrs, raw_message = stub.test_emails.pop()
    >>> msg = email.message_from_string(raw_message)
    >>> msg["Subject"]
    'Import problem - Welsh (cy) - firefox in Mozilla Firefox trunk'

    >>> print msg.get_payload(decode=True)
    Hello Mark Shuttleworth,
    <BLANKLINE>
    ...

    >>> from_addr, to_addrs, raw_message = stub.test_emails.pop()
    >>> msg = email.message_from_string(raw_message)
    >>> msg["Subject"]
    'Translation template import - firefox in Mozilla Firefox trunk'

    >>> print msg.get_payload(decode=True)
    Hello Mark Shuttleworth,
    <BLANKLINE>
    On ..., you uploaded a translation
    template for firefox in Mozilla Firefox trunk in Launchpad.
    <BLANKLINE>
    The template has now been imported successfully.
    <BLANKLINE>
    Thank you,
    <BLANKLINE>
    The Launchpad team


Now the auto-approval script runs.  This can happen anytime, since it's
asynchronous to the po-import script.  The script tries to approve any entries
that have not been approved, but look like they could be, without human
intervention.  This involves a bit of guesswork about what the imported file
is and where it belongs.  It similarly blocks entries that it thinks should be
blocked, and also purges deleted or complted entries from the queue.  Running
at this point, all it does is purge the two hand-approved Welsh translations
that have just been imported.

    >>> process = AutoApproveProcess(transaction, FakeLogger())
    >>> process.run()
    INFO    Removed 2 entries from the queue.
    >>> transaction.commit()

It's time to test the import queue.

Here, we are going to test that if a file is imported twice, both are imported
following the order the users uploaded them.

    >>> first_pofile_content = r'''
    ... msgid ""
    ... msgstr ""
    ... "PO-Revision-Date: 2005-06-04 20:41+0100\n"
    ... "Last-Translator: Foo <no-priv@canonical.com>\n"
    ... "Content-Type: text/plain; charset=UTF-8\n"
    ... "X-Rosetta-Export-Date: %s\n"
    ...
    ... msgid "Foo"
    ... msgstr "Bar"
    ... ''' % datetime.datetime.now(UTC).isoformat()

    >>> second_pofile_content = r'''
    ... msgid ""
    ... msgstr ""
    ... "PO-Revision-Date: 2005-06-04 21:41+0100\n"
    ... "Last-Translator: Jordi Mallach <jordi@canonical.com>\n"
    ... "Content-Type: text/plain; charset=UTF-8\n"
    ... "X-Rosetta-Export-Date: %s\n"
    ...
    ... msgid "Foo"
    ... msgstr "Bars"
    ... ''' % datetime.datetime.now(UTC).isoformat()

We flush the entry contents.

    >>> for entry in translation_import_queue:
    ...     translation_import_queue.remove(entry)
    >>> translation_import_queue.entryCount()
    0

Attach the first version of the file.

    >>> entry = translation_import_queue.addOrUpdateEntry(
    ...     pofile.path, first_pofile_content, False, rosetta_experts,
    ...     sourcepackagename=pofile.potemplate.sourcepackagename,
    ...     distroseries=pofile.potemplate.distroseries,
    ...     productseries=pofile.potemplate.productseries)
    >>> transaction.commit()

It's in the queue now.

    >>> translation_import_queue.entryCount()
    1

For the second version, we need a new importer, in this case, Jordi.

    >>> jordi = person_set.getByName('jordi')

Attach the second version of the file.

    >>> entry = translation_import_queue.addOrUpdateEntry(
    ...     pofile.path, second_pofile_content, False, jordi,
    ...     sourcepackagename=pofile.potemplate.sourcepackagename,
    ...     distroseries=pofile.potemplate.distroseries,
    ...     productseries=pofile.potemplate.productseries)
    >>> transaction.commit()

It's in the queue now.

    >>> translation_import_queue.entryCount()
    2
    >>> print entry.status.name
    NEEDS_REVIEW

The auto-approval script runs again.  This time it sees the two submitted
translations and approves them for import based on some heuristic
intelligence.

    >>> process = AutoApproveProcess(transaction, FakeLogger())
    >>> process.run()
    INFO    The automatic approval system approved some entries.
    >>> print entry.status.name
    APPROVED
    >>> syncUpdate(entry)

Now that these submissions have been approved, the next run of the import
script picks them up and processes them.

    >>> process = ImportProcess(transaction, FakeLogger())
    >>> process.run()
    INFO    Importing: Welsh (cy) translation of firefox in Mozilla Firefox trunk
    INFO    Importing: Welsh (cy) translation of firefox in Mozilla Firefox trunk
    INFO    Import requests completed.

    >>> print entry.status.name
    IMPORTED
    >>> syncUpdate(entry)

And there are no more entries to import

    >>> translation_import_queue.getFirstEntryToImport() is None
    True

Imports so far have been associated with a product series.  We can also submit
translations for a distroseries.

    >>> from canonical.launchpad.interfaces.distribution import (
    ...     IDistributionSet)
    >>> ubuntu = getUtility(IDistributionSet).getByName('ubuntu')
    >>> warty = ubuntu.getSeries('warty')
    >>> print warty.name
    warty
    >>> firefox_name = SourcePackageName.byName('mozilla-firefox')
    >>> subset = POTemplateSubset(sourcepackagename=firefox_name,
    ...     distroseries=warty)
    >>> potemplate = subset.new(
    ...     name='firefox-warty',
    ...     translation_domain='firefox-warty',
    ...     path='po/firefox.pot',
    ...     owner=person)


As it happens, the administrator has blocked imports to warty, e.g. because an
in-database update of its translations has been scheduled and we don't want
interference from queued imports while that happens.  It doesn't really matter
whether entries still get auto-approved, but we can't accept new translation
imports just now.

    >>> warty.defer_translation_imports = True
    >>> syncUpdate(warty)

Nevertheless, someone submits an import request for warty, not knowing or
caring that imports are deferred.  The entry still gets approved as normal:

    >>> entry = translation_import_queue.addOrUpdateEntry(
    ...     potemplate.path, potemplate_contents, True, potemplate.owner,
    ...     sourcepackagename=firefox_name, distroseries=warty,
    ...     potemplate=potemplate)
    >>> entry.status = RosettaImportStatus.APPROVED
    >>> syncUpdate(entry)
    >>> transaction.commit()

Since imports for warty are suspended, and the only entry we happen to have
waiting right now is for warty, the queue has no importable entries for us.

    >>> warty.getFirstEntryToImport() is None
    True

So if we try to import now, nothing happens.  Our request remains on the queue,
but doesn't become a candidate for processing until warty imports are resumed.

    >>> process = ImportProcess(transaction, FakeLogger())
    >>> process.run()
    INFO No requests pending.

    >>> print entry.status.name
    APPROVED

Once imports are allowed again, the import is done after all.

    >>> warty.defer_translation_imports = False
    >>> syncUpdate(warty)
    >>> (subject, body) = potemplate.importFromQueue(entry, FakeLogger())

    >>> print entry.status.name
    IMPORTED

== Plural forms handling ==

Apart from the basic plural form handling, which is documented above as
part of the import process, there are some peculiarities with importing
plural forms we want documented as well.

For a language such as Divehi, which has no plural forms defined, we
default to two plural forms (the most common value for the number of
plural forms).

    >>> from canonical.launchpad.interfaces import ILanguageSet, IProductSet
    >>> divehi = getUtility(ILanguageSet)['dv']
    >>> print divehi.pluralforms
    None

    >>> firefox = getUtility(IProductSet).getByName('firefox')
    >>> firefox_trunk = firefox.getSeries('trunk')
    >>> firefox_potemplate = firefox_trunk.getPOTemplate('firefox')
    >>> firefox_dv = firefox_potemplate.newPOFile(divehi.code)
    >>> firefox_dv.plural_forms
    2

We'll import a POFile with 3 plural forms into Divehi POFile:

    >>> pofile_with_plurals = r'''
    ... msgid ""
    ... msgstr ""
    ... "PO-Revision-Date: 2005-06-03 19:41+0100\n"
    ... "Last-Translator: Carlos Perello Marin <carlos@canonical.com>\n"
    ... "Content-Type: text/plain; charset=UTF-8\n"
    ... "Plural-Forms: nplurals=3; plural=(n==0) ? 0 : ((n==1) ? 1 : 2);\n"
    ... "X-Rosetta-Export-Date: %s\n"
    ...
    ... #, c-format
    ... msgid "Singular %%d"
    ... msgid_plural "Plural %%d"
    ... msgstr[0] "First form %%d"
    ... msgstr[1] "Second form %%d"
    ... msgstr[2] "Third form %%d"
    ... ''' % datetime.datetime.now(UTC).isoformat()

We now import this POFile as Divehi translation of Firefox trunk:

    >>> entry = translation_import_queue.addOrUpdateEntry(
    ...     firefox_dv.path, pofile_with_plurals, True, person,
    ...     productseries=firefox_trunk, potemplate=firefox_potemplate)
    >>> transaction.commit() # For Librarian to pick the file up.
    >>> entry.pofile = firefox_dv
    >>> entry.status = RosettaImportStatus.APPROVED
    >>> (subject, body) = firefox_dv.importFromQueue(entry, FakeLogger())
    >>> flush_database_updates()
    >>> print entry.status.name
    IMPORTED

If we get a current translation for this PO file, it will list only two
translations (which is a default when the language has no plural forms
specified):

    >>> potmsgset_plural = firefox_potemplate.getPOTMsgSetByMsgIDText(
    ...     key=u'Singular %d')
    >>> current_dv = potmsgset_plural.getCurrentTranslationMessage(divehi)
    >>> current_dv.translations
    [u'First form %d', u'Second form %d']

However, even the third form will be imported into database (this is useful
for when we finally define the number of plural forms for the language, we
should not have to reimport all translations):

    >>> current_dv.msgstr2.translation
    u'Third form %d'
