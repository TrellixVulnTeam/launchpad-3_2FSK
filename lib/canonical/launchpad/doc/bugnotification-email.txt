== Bug Notification Email ==

This document describes the internal workings of how bug notification
emails are generated and how said emails are formatted. It does not
cover the various rules and semantics surrounding the notifications
themselves; for that, see bugnotifications.txt.

The reference spec associated with this document is available on the
Launchpad wiki. <https://launchpad.canonical.com/FormattingBugNotifications>

You need to be logged in to edit bugs in Malone, so let's get started:

    >>> from canonical.launchpad.ftests import login
    >>> login("test@canonical.com")

To avoid having one gargantuan super function that formats any kind of
object it gets passed, the formatting logic has been cut into two
pieces: get_bug_edit_notification_texts and generate_bug_add_email.

    >>> from canonical.launchpad.mailnotification import (
    ...     generate_bug_add_email, get_bug_edit_notification_texts)

Let's demonstrate what the bugmails will look like, by going through
the various events that can happen that would cause a notification to
be sent. We'll start by importing some things we'll need for the
examples that follow:

    >>> from zope.component import getUtility
    >>> from canonical.launchpad.interfaces import (
    ...     IBugDelta, IBugSet, IPersonSet, IBugMessageSet, IBugTaskSet,
    ...     ICve, IEmailAddressSet)
    >>> from canonical.launchpad.components.bug import BugDelta

= Filing a bug =

generate_bug_add_email accepts one argument: the IBug that was just
added. With that, it generates an appropriately-formatted notification
message, and returns it as a (subject, body) tuple.

So, let's pretend that we filed bug 4 just now:

    >>> bug_four = getUtility(IBugSet).get(4)
    >>> bug_four.tags = []

Let's take a look at what the notification email looks like:

    >>> subject, body = generate_bug_add_email(bug_four)
    >>> subject
    u'[Bug 4] Reflow problems with complex page layouts'
    >>> print body
    Public bug reported:
    <BLANKLINE>
    Malone pages that use more complex layouts with portlets and fancy CSS
    are sometimes not getting properly reflowed after rendering.
    <BLANKLINE>
    ** Affects: firefox
         Importance: Medium
             Status: New

(In reality, the importance of a newly-reported bug would not have been
decided yet, so it would appear as Undecided.)

If the filed bug would have tags, these are included in the notification
as well.

    >>> bug_four.tags = [u'foo', u'bar']

    >>> subject, body = generate_bug_add_email(bug_four)
    >>> subject
    u'[Bug 4] Reflow problems with complex page layouts'
    >>> print body
    Public bug reported:
    <BLANKLINE>
    Malone pages that use more complex layouts with portlets and fancy CSS
    are sometimes not getting properly reflowed after rendering.
    <BLANKLINE>
    ** Affects: firefox
         Importance: Medium
             Status: New
    <BLANKLINE>
    ** Tags: bar foo


= Editing a bug =

get_bug_edit_notification_texts accepts an object that provides
IBugDelta, and returns a list of text representations of the changes
made to the bug.

    >>> sample_person = getUtility(IPersonSet).get(12)
    >>> edited_bug = getUtility(IBugSet).get(2)

    >>> old_title = edited_bug.title
    >>> edited_bug.title = "the new title"
    >>> old_description = edited_bug.description
    >>> edited_bug.description = (
    ...     "The Trash folder seems to have significant problems! At the"
    ...     " moment, dragging an item to the Trash results in immediate"
    ...     " deletion. The item does not appear in the Trash, it is just"
    ...     " deleted from my hard disk. There is no undo or ability to"
    ...     " recover the deleted file. Help!")

    >>> bug_delta = BugDelta(
    ...     bug=edited_bug,
    ...     bugurl="http://www.example.com/bugs/2",
    ...     user=sample_person,
    ...     title={'new': edited_bug.title, 'old': old_title},
    ...     description={'new': edited_bug.description,
    ...                  'old': old_description})
    >>> IBugDelta.providedBy(bug_delta)
    True

    >>> for text_representation in get_bug_edit_notification_texts(bug_delta):
    ...     print text_representation #doctest: -NORMALIZE_WHITESPACE
    ...     print "-----------------------------"
    ** Summary changed:
    <BLANKLINE>
    - Blackhole Trash folder
    + the new title
    -----------------------------
    ** Description changed:
    <BLANKLINE>
      The Trash folder seems to have significant problems! At the moment,
    - dragging an item to the trash results in immediate deletion. The item
    + dragging an item to the Trash results in immediate deletion. The item
      does not appear in the Trash, it is just deleted from my hard disk.
      There is no undo or ability to recover the deleted file. Help!
    -----------------------------


Another edit, this time a long description, showing that the description
is wrapped properly:

    >>> old_description = edited_bug.description
    >>> edited_bug.description = """\
    ... a new description that is quite long. but the nice thing is that the edit notification email generator knows how to indent and wrap descriptions, so this will appear quite nice in the actual email that gets sent.\n\nit's also smart enough to preserve whitespace, finally!"""

    >>> bug_delta = BugDelta(
    ...     bug=edited_bug,
    ...     bugurl="http://www.example.com/bugs/2",
    ...     user=sample_person,
    ...     description={'new': edited_bug.description,
    ...                  'old': old_description})
    >>> for text_representation in get_bug_edit_notification_texts(bug_delta):
    ...     print text_representation #doctest: -NORMALIZE_WHITESPACE
    ...     print "-----------------------------"
    ** Description changed:
    <BLANKLINE>
    - The Trash folder seems to have significant problems! At the moment,
    - dragging an item to the Trash results in immediate deletion. The item
    - does not appear in the Trash, it is just deleted from my hard disk.
    - There is no undo or ability to recover the deleted file. Help!
    + a new description that is quite long. but the nice thing is that the
    + edit notification email generator knows how to indent and wrap
    + descriptions, so this will appear quite nice in the actual email that
    + gets sent.
    + 
    + it's also smart enough to preserve whitespace, finally!
    -----------------------------


Let's make the bug security-related, and private (we need to switch
logins to a user that is explicitly subscribed to this bug):

    >>> login("steve.alexander@ubuntulinux.com")

    >>> edited_bug.private = True
    >>> edited_bug.security_related = True
    >>> bug_delta = BugDelta(
    ...     bug=edited_bug,
    ...     bugurl="http://www.example.com/bugs/2",
    ...     user=sample_person,
    ...     private={'old': False, 'new': edited_bug.private},
    ...     security_related={'old': False, 'new': edited_bug.security_related})
    >>> for text_representation in get_bug_edit_notification_texts(bug_delta):
    ...     print text_representation #doctest: -NORMALIZE_WHITESPACE
    ...     print "-----------------------------"
    ** Visibility changed to: Private
    -----------------------------
    ** This bug has been flagged as a security issue
    -----------------------------

Now we set the bug public, and not security-related and check if the
e-mail sent changed as well.

    >>> edited_bug.private = False
    >>> edited_bug.security_related = False
    >>> bug_delta = BugDelta(
    ...     bug=edited_bug,
    ...     bugurl="http://www.example.com/bugs/2",
    ...     user=sample_person,
    ...     private={'old': True, 'new': edited_bug.private},
    ...     security_related={'old': True, 'new': edited_bug.security_related})
    >>> for text_representation in get_bug_edit_notification_texts(bug_delta):
    ...     print text_representation #doctest: -NORMALIZE_WHITESPACE
    ...     print "-----------------------------"
    ** Visibility changed to: Public
    -----------------------------
    ** This bug is no longer flagged as a security issue
    -----------------------------

Let's add some tags to a bug:

    >>> old_tags = []
    >>> edited_bug.tags = [u'foo', u'bar']
    >>> bug_delta = BugDelta(
    ...     bug=edited_bug,
    ...     bugurl="http://www.example.com/bugs/2",
    ...     user=sample_person,
    ...     tags={'old': old_tags, 'new': edited_bug.tags})
    >>> for text_representation in get_bug_edit_notification_texts(bug_delta):
    ...     print text_representation #doctest: -NORMALIZE_WHITESPACE
    ...     print "-----------------------------"
    ** Tags added: bar foo
    -----------------------------

If we change one tag, it's basically removing one and adding another:

    >>> old_tags = edited_bug.tags
    >>> edited_bug.tags = [u'foo', u'baz']
    >>> bug_delta = BugDelta(
    ...     bug=edited_bug,
    ...     bugurl="http://www.example.com/bugs/2",
    ...     user=sample_person,
    ...     tags={'old': old_tags, 'new': edited_bug.tags})
    >>> for text_representation in get_bug_edit_notification_texts(bug_delta):
    ...     print text_representation #doctest: -NORMALIZE_WHITESPACE
    ...     print "-----------------------------"
    ** Tags added: baz
    -----------------------------
    ** Tags removed: bar
    -----------------------------

= Adding a new bug task =

Because adding a new task is sort of like "editing" a bug,
get_bug_edit_notification_texts generates text representations when a
new task is added to a bug. To demonstrate what they look like, let's
pretend we had just added task five:

    >>> ubuntu_mozilla_task = getUtility(IBugTaskSet).get(17)
    >>> bug_one = getUtility(IBugSet).get(1)

    >>> bug_delta = BugDelta(
    ...     bug = bug_one,
    ...     bugurl = "http://www.example.com/bugs/1",
    ...     user = sample_person,
    ...     added_bugtasks = ubuntu_mozilla_task)
    >>> for text_representation in get_bug_edit_notification_texts(bug_delta):
    ...     print text_representation #doctest: -NORMALIZE_WHITESPACE
    ...     print "-----------------------------"
    ** Also affects: mozilla-firefox (Ubuntu)
       Importance: Medium
           Status: New
    -----------------------------

= Editing a bug task =

As you might expect, get_bug_edit_notification_texts handles generating the
text representations of the changes when a bug task is edited.

    >>> from canonical.launchpad.interfaces import (
    ...     BugTaskStatus, IBugTaskDelta, IBugTaskSet)
    >>> from canonical.launchpad.database.bugtask import BugTaskDelta

    >>> edited_bugtask = getUtility(IBugTaskSet).get(3)
    >>> edited_bugtask.transitionToStatus(
    ...     BugTaskStatus.CONFIRMED, getUtility(ILaunchBag).user)
    >>> edited_bugtask.transitionToAssignee(sample_person)
    >>> bugtask_delta = BugTaskDelta(
    ...     bugtask=edited_bugtask,
    ...     status={'old' : BugTaskStatus.NEW, 'new' : edited_bugtask.status},
    ...     assignee={'old' : None, 'new' : edited_bugtask.assignee})
    >>> bug_delta = BugDelta(
    ...     bug=edited_bug,
    ...     bugurl="http://www.example.com/bugs/2",
    ...     user=sample_person,
    ...     bugtask_deltas=bugtask_delta)
    >>> for text_representation in get_bug_edit_notification_texts(bug_delta):
    ...     print text_representation #doctest: -NORMALIZE_WHITESPACE
    ...     print "-----------------------------"
    ** Changed in: tomcat
         Assignee: (unassigned) => Sample Person (name12)
           Status: New => Confirmed
    -----------------------------

Let's take a look at how it looks like when a distribution task is
edited:

    >>> debian_bugtask = getUtility(IBugTaskSet).get(5)
    >>> print debian_bugtask.bugtargetname
    mozilla-firefox (Debian)
    >>> debian_bugtask.transitionToAssignee(None)
    >>> bugtask_delta = BugTaskDelta(
    ...     bugtask=debian_bugtask,
    ...     assignee={'old' : sample_person, 'new' : None})
    >>> bug_delta = BugDelta(
    ...     bug=edited_bug,
    ...     bugurl="http://www.example.com/bugs/2",
    ...     user=sample_person,
    ...     bugtask_deltas=bugtask_delta)
    >>> for text_representation in get_bug_edit_notification_texts(bug_delta):
    ...     print text_representation #doctest: -NORMALIZE_WHITESPACE
    ...     print "-----------------------------"
    ** Changed in: mozilla-firefox (Debian)
         Assignee: Sample Person (name12) => (unassigned)
    -----------------------------

= Adding and editing web links =

Adding a web link can be seen as "editing" a bug.

    >>> from zope.interface import implements
    >>> from canonical.launchpad.interfaces import IBugExternalRef
    >>> class MockBugExtRef:
    ...     implements(IBugExternalRef)
    ...     def __init__(self, bug, url, title, owner):
    ...         self.bug = bug
    ...         self.url = url
    ...         self.title = title
    ...         self.owner = owner
    >>> mock_ext_ref = MockBugExtRef(
    ...     bug = edited_bug,
    ...     url = "http://www.example.com/foo/bar",
    ...     title = "some title",
    ...     owner = sample_person.id)

    >>> bug_delta = BugDelta(
    ...     bug = edited_bug,
    ...     bugurl = "http://www.example.com/bugs/2",
    ...     user = sample_person,
    ...     external_reference = {'new': mock_ext_ref})
    >>> for text_representation in get_bug_edit_notification_texts(bug_delta):
    ...     print text_representation #doctest: -NORMALIZE_WHITESPACE
    ...     print "-----------------------------"
    ** Web link added: http://www.example.com/foo/bar
    -----------------------------

Editing a web link shows the previous link as "Removed" and the newly
modified link as having been "Added" (though no actual "adding" or
"deleting" is actually taking place in the database.)

    >>> mock_ext_ref_edited = MockBugExtRef(
    ...     bug = edited_bug,
    ...     url = "http://www.example.com/foo/bar",
    ...     title = "some better title",
    ...     owner = sample_person.id)

    >>> bug_delta = BugDelta(
    ...     bug = edited_bug,
    ...     bugurl = "http://www.example.com/bugs/2",
    ...     user = sample_person,
    ...     external_reference = {
    ...         'old' : mock_ext_ref, 'new': mock_ext_ref_edited})
    >>> for text_representation in get_bug_edit_notification_texts(bug_delta):
    ...     print text_representation #doctest: -NORMALIZE_WHITESPACE
    ...     print "-----------------------------"
    ** Web link removed: http://www.example.com/foo/bar
    -----------------------------
    ** Web link added: http://www.example.com/foo/bar
    -----------------------------

= Adding and editing bug watches =

Here's an example that demonstrates the notification email that gets
generated when a bug watch is added:

    >>> from canonical.launchpad.interfaces import IBugWatch, IBugTrackerSet
    >>> bugtrackerset = getUtility(IBugTrackerSet)

    >>> class MockBugWatch:
    ...     implements(IBugWatch)
    ...     def __init__(self, bug, bugtracker, remotebug):
    ...         self.bug = bug
    ...         self.bugtracker = bugtracker
    ...         self.remotebug = remotebug
    ...         self.url = "%sshow_bug.cgi?id=%s" % (
    ...             bugtracker.baseurl, remotebug)
    >>> mock_bug_watch = MockBugWatch(
    ...     bug=edited_bug,
    ...     bugtracker=getUtility(IBugTrackerSet)["mozilla.org"],
    ...     remotebug="123")

    >>> bug_delta = BugDelta(
    ...     bug=edited_bug,
    ...     bugurl="http://www.example.com/bugs/2",
    ...     user=sample_person,
    ...     bugwatch={'new' : mock_bug_watch})
    >>> for text_representation in get_bug_edit_notification_texts(bug_delta):
    ...     print text_representation #doctest: -NORMALIZE_WHITESPACE
    ...     print "-----------------------------"
    ** Bug watch added: The Mozilla.org Bug Tracker #123
       https://bugzilla.mozilla.org/show_bug.cgi?id=123
    -----------------------------

When edited, we display the change to a bug watch as though the
previous data was "removed" and the new, current data was "added."
Let's demonstrate with an example:

    >>> mock_bug_watch_edited = MockBugWatch(
    ...     bug=edited_bug,
    ...     bugtracker=getUtility(IBugTrackerSet)["mozilla.org"],
    ...     remotebug="12")

    >>> bug_delta = BugDelta(
    ...     bug=edited_bug,
    ...     bugurl="http://www.example.com/bugs/2",
    ...     user=sample_person,
    ...     bugwatch={'old' : mock_bug_watch, 'new' : mock_bug_watch_edited})
    >>> for text_representation in get_bug_edit_notification_texts(bug_delta):
    ...     print text_representation #doctest: -NORMALIZE_WHITESPACE
    ...     print "-----------------------------"
    ** Bug watch removed: The Mozilla.org Bug Tracker #123
       https://bugzilla.mozilla.org/show_bug.cgi?id=123
    -----------------------------
    ** Bug watch added: The Mozilla.org Bug Tracker #12
       https://bugzilla.mozilla.org/show_bug.cgi?id=12
    -----------------------------

We can also add a bugwatch while adding a new bugtask.

    >>> from canonical.launchpad.interfaces import IBugWatchSet
    >>> mozilla_bug_watch = getUtility(IBugWatchSet).get(1)
    >>> mozilla_bugtask = getUtility(IBugTaskSet).get(15)
    >>> mozilla_bugtask.bugwatch = mozilla_bug_watch 

    >>> bug_delta = BugDelta(
    ...     bug=edited_bug,
    ...     bugurl="http://www.example.com/bugs/2",
    ...     user=sample_person,
    ...     added_bugtasks=mozilla_bugtask)
    >>> for text_representation in get_bug_edit_notification_texts(bug_delta):
    ...     print text_representation #doctest: -NORMALIZE_WHITESPACE
    ...     print "-----------------------------"
    ** Also affects: firefox via
       https://bugzilla.mozilla.org/show_bug.cgi?id=42
       Importance: High
           Status: New
    -----------------------------


= Adding and editing CVE relationships =

Adding a CVE will generate a notification that looks as follows:

    >>> from canonical.launchpad.interfaces import IBugCve
    >>> from canonical.lp.dbschema import CveStatus

    >>> class MockCVE:
    ...     implements(ICve)
    ...     def __init__(self, sequence, status, url, description):
    ...         self.sequence = sequence
    ...         self.status = status
    ...         self.displayname = 'CVE-' + sequence
    ...         self.description = description
    ...         self.url = url
    ...     @property
    ...     def title(self):
    ...         return '%s (%s)' % (self.displayname, self.status.title)
    >>> mock_cve = MockCVE(
    ...     sequence="2004-0718",
    ...     status=CveStatus.CANDIDATE,
    ...     url='http://cve.mitre.org/whatsit?id=CVE-2004-0718',
    ...     description="a test cve ref")

    >>> bug_delta = BugDelta(
    ...     bug=edited_bug,
    ...     bugurl="http://www.example.com/bugs/2",
    ...     user=sample_person,
    ...     cve={'new' : mock_cve})
    >>> for text_representation in get_bug_edit_notification_texts(bug_delta):
    ...     print text_representation #doctest: -NORMALIZE_WHITESPACE
    ...     print "-----------------------------"
    ** CVE added: http://cve.mitre.org/whatsit?id=CVE-2004-0718
    -----------------------------

Similarly, removing a CVE ref will result in an email:

    >>> mock_cve_ref_removed = MockCVE(
    ...     sequence="2004-0719",
    ...     status=CveStatus.CANDIDATE,
    ...     url='http://cve.mitre.org/whatsit?id=CVE-2004-0719',
    ...     description="a test cve ref")

    >>> bug_delta = BugDelta(
    ...     bug=edited_bug,
    ...     bugurl="http://www.example.com/bugs/2",
    ...     user=sample_person,
    ...     cve={'old' : mock_cve_ref_removed})
    >>> for text_representation in get_bug_edit_notification_texts(bug_delta):
    ...     print text_representation #doctest: -NORMALIZE_WHITESPACE
    ...     print "-----------------------------"
    ** CVE removed: http://cve.mitre.org/whatsit?id=CVE-2004-0719
    -----------------------------

= Adding attachments =

Adding an attachment will generate a notification that looks as follows:

    >>> class MockLibraryFile:
    ...     def __init__(self, url):
    ...         self.http_url = url
    >>> class MockAttachment:
    ...     def __init__(self, title, libraryfile):
    ...         self.title = title
    ...         self.libraryfile = libraryfile
    >>> attachment = MockAttachment(
    ...     title="A screenshot of the problem",
    ...     libraryfile=MockLibraryFile('http://foo.com/screenshot.png'))

    >>> bug_delta = BugDelta(
    ...     bug=edited_bug,
    ...     bugurl="http://www.example.com/bugs/2",
    ...     user=sample_person,
    ...     attachment={'new' : attachment})
    >>> for text_representation in get_bug_edit_notification_texts(bug_delta):
    ...     print text_representation #doctest: -NORMALIZE_WHITESPACE
    ...     print "-----------------------------"
    ** Attachment added: "A screenshot of the problem"
       http://foo.com/screenshot.png
    -----------------------------

= Generation of From: and Reply-To: addresses =

The Reply-To: and From: addresses used to send email are generated in a
pair of handy functions defined in mailnotification.py:

    >>> from canonical.launchpad.mailnotification import (
    ...     get_bugmail_from_address, get_bugmail_replyto_address)

The Reply-To address generation is straightforward:

    >>> get_bugmail_replyto_address(bug_four)
    u'Bug 4 <4@bugs.launchpad.net>'

The From address generator handles a few special cases. The trivial case
is, well, trivial. Stuart has four email addresses:

    >>> stub = getUtility(IPersonSet).getByName("stub")
    >>> [(email.email, email.status.name) for email 
    ...  in getUtility(IEmailAddressSet).getByPerson(stub)]
    [(u'stuart.bishop@canonical.com', 'PREFERRED'),
     (u'stuart@stuartbishop.net', 'VALIDATED'),
     (u'stub@fastmail.fm', 'NEW'),
     (u'zen@shangri-la.dropbear.id.au', 'OLD')]

But we use his preferred one:

    >>> get_bugmail_from_address(stub, bug_four)
    'Stuart Bishop <stuart.bishop@canonical.com>'

Now, mpo doesn't have a validated email address, but we pick out the
first address we find:

    >>> mpo = getUtility(IPersonSet).getByName("mpo")
    >>> get_bugmail_from_address(mpo, bug_four)
    '=?utf-8?b?TWF0dGkgUMO2bGzDpA==?= <mpo@iki.fi>'

(As you can see in the above example, get_bugmail_from_address() takes
care of encoding the person's displayname correctly.)

The team janitor doesn't have an email address at all!

    >>> janitor = getUtility(IPersonSet).getByName("team-membership-janitor")
    >>> get_bugmail_from_address(janitor, bug_four)
    'Team Membership Janitor <4@bugs.launchpad.net>'

