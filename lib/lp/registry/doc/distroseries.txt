= Distro Releases =

From the DerivationOverview spec
<https://launchpad.canonical.com/DerivationOverview>:

    A distribution of GNU/Linux comprises a set of packages, an installer,
    possibly a live-CD, some amount of metadata associated with the arrangement
    of those elements and also a lot of information on managing it.

A distro series is a given version of a distribution. So, for Ubuntu, there
are releases (or planned releases) like "warty", "hoary" and "bendy".

Distro releases are retrieved with the IDistroSeriesSet utility, much like
people are retrieved with the IPersonSet utility, or bug tasks are retrieved
with the IBugTaskSet utility.

The IDistroSeriesSet utility is accessed in the usual fashion:


    >>> from zope.component import getUtility
    >>> from canonical.database.sqlbase import flush_database_updates
    >>> from canonical.launchpad.webapp.testing import verifyObject
    >>> from canonical.launchpad.interfaces import (
    ...     IDistroSeries, IDistroSeriesSet, IDistributionSet,
    ...     IHasTranslationImports)
    >>> distroseriesset = getUtility(IDistroSeriesSet)

To retrieve a specific release of a distribution, use IDistroSeriesSet.get:

    >>> warty = distroseriesset.get(1)
    >>> print warty.name
    warty
    >>> print warty.fullseriesname
    Ubuntu Warty

Or IDistroSeriesSet.findByName:

    >>> for distroseries in distroseriesset.findByName("warty"):
    ...     print distroseries.name
    warty

To get one specific release by name, use queryByName:

    >>> ubuntu = getUtility(IDistributionSet).getByName("ubuntu")

    >>> warty = distroseriesset.queryByName(ubuntu, "warty")
    >>> warty.name
    u'warty'

If the release by that name doesn't exist, None will be returned:

    >>> foobar = distroseriesset.queryByName(ubuntu, "foobar")
    >>> print foobar
    None

Or IDistroSeriesSet.findByVersion:

    >>> for distroseries in distroseriesset.findByVersion("5.04"):
    ...     print distroseries.name
    hoary

We verify that a distroseries does in fact fully provide IDistroSeries:

    >>> verifyObject(IDistroSeries, warty)
    True
    >>> IDistroSeries.providedBy(warty)
    True

And IHasTranslationImports:

    >>> verifyObject(IHasTranslationImports, warty)
    True
    >>> IHasTranslationImports.providedBy(warty)
    True

To search the set of IDistroSeriess, use IDistroSeriesSet.search:

    >>> ubuntu_releases = distroseriesset.search(
    ...     distribution=ubuntu, isreleased=True, orderBy="-datereleased")
    >>> [release.name for release in ubuntu_releases]
    [u'warty']

    >>> all_ubuntu_releases = distroseriesset.search(distribution=ubuntu)
    >>> all_ubuntu_releases.count()
    4

DistroSeries.getPublishedReleases:

    >>> from canonical.launchpad.database import SourcePackageName, DistroSeries
    >>> warty2 = DistroSeries.get(1)

Passing a ISourcePackageName as argument:

    >>> prs = warty2.getPublishedReleases(
    ...       SourcePackageName.byName('mozilla-firefox'))
    >>> print len(prs)
    1
    >>> print prs[0].sourcepackagerelease.sourcepackagename.name
    mozilla-firefox

Passing a string name:

    >>> print len(warty2.getPublishedReleases('mozilla-firefox'))
    1

Including pending publication records in the result:

    >>> print len(warty2.getPublishedReleases('mozilla-firefox',
    ...           include_pending=True))
    2

Not found as empty list:

    >>> print len(warty2.getPublishedReleases('nosuchpackage'))
    0

See distroseries-publishing-lookups.txt for more information.

canUploadToPocket method helps us to decide if an upload is allowed or
not, according the distroseries status and the upload target pocket.

   >>> from canonical.launchpad.interfaces import IDistributionSet
   >>> ubuntu = getUtility(IDistributionSet)['ubuntu']
   >>> breezy_autotest = ubuntu['breezy-autotest']
   >>> hoary = ubuntu['hoary']

   >>> from canonical.launchpad.interfaces import PackagePublishingPocket
   >>> from canonical.launchpad.interfaces import DistroSeriesStatus

   >>> warty.status.name
   'CURRENT'
   >>> warty.canUploadToPocket(PackagePublishingPocket.RELEASE)
   False
   >>> warty.canUploadToPocket(PackagePublishingPocket.SECURITY)
   True

   >>> breezy_autotest.status.name
   'EXPERIMENTAL'
   >>> breezy_autotest.canUploadToPocket(PackagePublishingPocket.RELEASE)
   True
   >>> breezy_autotest.canUploadToPocket(PackagePublishingPocket.SECURITY)
   False

The FROZEN status is special.  Uploads are allowed for all pockets as
the upload will have to wait for manual approval anyway:

   >>> from zope.security.proxy import removeSecurityProxy
   >>> removeSecurityProxy(hoary).status = DistroSeriesStatus.FROZEN

   >>> hoary.status.name
   'FROZEN'
   >>> hoary.canUploadToPocket(PackagePublishingPocket.RELEASE)
   True
   >>> hoary.canUploadToPocket(PackagePublishingPocket.SECURITY)
   True


== Package searching ==

You can search through binary packages publishing in a distribution
release by using the searchPackages method, which uses magical fti:

    >>> warty.searchPackages("pmount").count()
    1

This also works for small or weirdly named packages that don't work
through fti, and even for substrings:

    >>> warty.searchPackages("linux-2.6.12").count()
    1
    >>> warty.searchPackages("at").count()
    1
    >>> pkgs = warty.searchPackages('a')
    >>> for dsbp in pkgs:
    ...     print "%s: %s" % (dsbp.__class__.__name__, dsbp.name)
    DistroSeriesBinaryPackage: foobar
    DistroSeriesBinaryPackage: mozilla-firefox
    DistroSeriesBinaryPackage: at


== DistroSeriess have components and sections ==

A distroseries has some number of components and/or sections which
are valid for that distroseries. These selections are used by (among
other things) the uploader for validating incoming uploads.

   >>> hoary = distroseriesset.get(3)
   >>> for c in hoary.components:
   ...     print c.name
   main
   restricted
   >>> for s in hoary.sections:
   ...     print s.name
   base
   web
   editors
   admin
   devel
   translations

   >>> from canonical.launchpad.interfaces import (
   ...    IComponentSet, ISectionSet)
   >>> python = getUtility(ISectionSet).ensure('python')

   >>> hoary.addSection(python)

   >>> for c in hoary.components:
   ...     print c.name
   main
   restricted

   >>> for s in hoary.sections:
   ...     print s.name
   base
   web
   editors
   admin
   devel
   python
   translations

Breezy-autotest has got a partner component, which is not reported:

    >>> breezyautotest = distroseriesset.queryByName(ubuntu, "breezy-autotest")
    >>> for c in breezyautotest.components:
    ...     print c.name
    main
    restricted
    universe
    multiverse

The upload_components property, however, reports all the available
components since partner is allowed for upload:

    >>> for c in breezyautotest.upload_components:
    ...     print c.name
    main
    restricted
    universe
    multiverse
    partner


== DistroSeries can be initialised from their parents ==

When a distroseries is derived from another distroseries (be it a
derivative distribution, or simply the next release in a sequence from
Ubuntu) we need to initialise the new release with quite a lot of
information. Not least of which is the section and component
selections and the publishing information for the distroseries.

DistroSeries provides us with a method for doing this which carefully
goes behind the back of sqlobject to copy potentially tens of
thousands of rows around in order to set up a distroseries.

IDistroSeries lists a series of preconditions for performing an
initialisation. In particular the initialiser won't overwrite
publishing records etc. Essentially this is a "Do not push this button
again" type set of assertions.

   >>> login("foo.bar@canonical.com")
   >>> humpy = ubuntu.newSeries('humpy', 'Humpy Hippo',
   ...                          'The Humpy Hippo', 'Fat', 'Yo Momma',
   ...                          '99.2',hoary, hoary.owner)
   >>> humpy_i386 = humpy.newArch('i386', hoary['i386'].processorfamily,
   ...                            True, humpy.owner)
   >>> humpy.nominatedarchindep = humpy_i386
   >>> humpy.initialiseFromParent()
   >>> len(hoary.getPublishedReleases('pmount'))
   1
   >>> len(humpy.getPublishedReleases('pmount'))
   1
   >>> len(hoary['i386'].getReleasedPackages('pmount'))
   1
   >>> len(humpy_i386.getReleasedPackages('pmount'))
   1

Check if the attributes of an DRSPR instance for the just initialised
distroseries are sane. A DRSPR instance should filter attributes of
a SPR according the distroseries in question (practically according
what is published in this distrorelelase)

Since the initialise-from-parent procedure copies the latest
publications from the parent IDRSPR.builds should be empty, reflecting
that there are no builds for this SPR in this DistroSeries.
IDRSPR.builds will be non-empty after a developer submits a new SPR
for the  DistroSeries.

In other hand IDRSPR.binaries should return the binaries resulted of
the SPRs inheritance by joining BPP->BPR->BUILD->SPR, i.e, binaries
published in this distroseries (in fact, in one of its architectures)
resulted of the sourcepackagerelease in question, but built anywhere.
(fix bug #52938)

Initialise a new distroseries based on warty (since it has, at least
one coherent published source + binary, mozilla-firefox)

   >>> bumpy = ubuntu.newSeries('bumpy', 'Bumpy',
   ...                          'The Bumpy', 'Fat', 'Boom',
   ...                          '99.3', warty, warty.owner)

   >>> bumpy_i386 = bumpy.newArch('i386', warty['i386'].processorfamily,
   ...                            True, bumpy.owner)
   >>> bumpy.nominatedarchindep = bumpy_i386
   >>> bumpy.initialiseFromParent()

Build a new ISourcePackage based in the new distroseries:

   >>> bumpy_firefox_sp = bumpy.getSourcePackage('mozilla-firefox')

Check the content IDRSPR binaries & builds attributes:

'binaries' should be inherited from parent release.

   >>> bumpy_firefox_sp.currentrelease.binaries.count()
   2

   >>> for bin in bumpy_firefox_sp.currentrelease.binaries:
   ...     print bin.id, bin.title, bin.build.distroarchseries.title
   27 mozilla-firefox-data-0.9 The Warty Warthog Release for i386 (x86)
   12 mozilla-firefox-0.9 The Warty Warthog Release for i386 (x86)


'builds' should be empty since it was built in parent (warty), not in this
distroseries (bumby.

   >>> len(bumpy_firefox_sp.currentrelease.builds)
   0

the SPR returns all build records for it.

   >>> bumpy_firefox_sp.currentrelease.sourcepackagerelease.builds.count()
   4


== Hiding translations ==

The hide_all_translations flag, if set, hides a distroseries'
translations in the user interface.  The check for visibility happens in
checkTranslationsViewable.

    >>> untranslatable_series = factory.makeDistroRelease()
    >>> untranslatable_series.hide_all_translations = False

When translations are visible, checkTranslationsViewable() completes
normally.

    >>> from canonical.launchpad.webapp.interfaces import (
    ...     TranslationUnavailable)
    >>> def get_visibility_notice(series):
    ...     """Print the notice about series' translations being hidden."""
    ...     try:
    ...         series.checkTranslationsViewable()
    ...     except TranslationUnavailable, e:
    ...         return str(e)
    ...     return None

    >>> print get_visibility_notice(untranslatable_series)
    None

But when translations are hidden, it raises TranslationUnavailable.

    >>> untranslatable_series.hide_all_translations = True
    >>> print get_visibility_notice(untranslatable_series)
    Translations for this release series...

Exactly what message is displayed depends on the series' status.

    >>> untranslatable_series.status = DistroSeriesStatus.EXPERIMENTAL
    >>> print get_visibility_notice(untranslatable_series)
    Translations for this release series are not available yet.

    >>> untranslatable_series.status = DistroSeriesStatus.DEVELOPMENT
    >>> print get_visibility_notice(untranslatable_series)
    Translations for this release series are not available yet.

    >>> untranslatable_series.status = DistroSeriesStatus.FROZEN
    >>> print get_visibility_notice(untranslatable_series)
    Translations for this release series are not currently available.
    Please come back soon.

    >>> untranslatable_series.status = DistroSeriesStatus.CURRENT
    >>> print get_visibility_notice(untranslatable_series)
    Translations for this release series are not currently available.
    Please come back soon.

    >>> untranslatable_series.status = DistroSeriesStatus.SUPPORTED
    >>> print get_visibility_notice(untranslatable_series)
    Translations for this release series are not currently available.
    Please come back soon.

    >>> untranslatable_series.status = DistroSeriesStatus.OBSOLETE
    >>> print get_visibility_notice(untranslatable_series)
    This release series is obsolete.  Its translations are no longer
    available.

    >>> untranslatable_series.status = DistroSeriesStatus.FUTURE
    >>> print get_visibility_notice(untranslatable_series)
    Translations for this release series are not available yet.


== Translatable Packages and Packaging ==

You can easily find out what packages are translatable in a
distribution release:

   >>> translatables = hoary.getTranslatableSourcePackages()
   >>> for translatable in translatables:
   ...    print translatable.name
   evolution
   mozilla
   pmount

Packages can be linked to upstream productseries in specific
distribution releases. IDistroSeries offers a way to query translatable
packages that are linked to upstream productseries.

   >>> unlinked_translatables = hoary.getUnlinkedTranslatableSourcePackages()
   >>> for translatable in unlinked_translatables:
   ...    print translatable.name
   pmount
   mozilla

The links to upstream product series can be verified using the
packagings property:

    >>> packagings = hoary.packagings
    >>> for packaging in packagings:
    ...     print packaging.sourcepackagename.name, \
    ...           packaging.productseries.product.displayname
    evolution Evolution
    mozilla-firefox Mozilla Firefox
    netapplet NetApplet

From the results above you can notice that neither mozilla-firefox nor
netapplet are translatable in Hoary.


== DistroSeries can build meta objects for packages ==

   >>> from canonical.launchpad.interfaces import (
   ...     ISourcePackage,
   ...     IDistroSeriesBinaryPackage,
   ...     IDistroSeriesSourcePackageRelease,
   ...     ISourcePackagePublishingHistory)


   >>> pmount_src_name =  SourcePackageName.byName('pmount')
   >>> pmount_source = hoary.getSourcePackage(pmount_src_name)
   >>> ISourcePackage.providedBy(pmount_source)
   True

   >>> from lp.soyuz.model.binarypackagename import (
   ...                                       BinaryPackageName)
   >>> pmount_bin_name =  BinaryPackageName.byName('pmount')
   >>> pmount_drbp = hoary.getBinaryPackage(pmount_bin_name)
   >>> IDistroSeriesBinaryPackage.providedBy(pmount_drbp)
   True
   >>> len(pmount_drbp.current_publishings)
   3

   >>> from lp.soyuz.model.sourcepackagerelease import (
   ...                                           SourcePackageRelease)
   >>> pmount_rel = SourcePackageRelease.selectOneBy(
   ...     sourcepackagenameID=pmount_src_name.id, version='0.1-1')
   >>> pmount_rel.sourcepackagename.name
   u'pmount'

   >>> pmount_srcrel = hoary.getSourcePackageRelease(pmount_rel)
   >>> IDistroSeriesSourcePackageRelease.providedBy(pmount_srcrel)
   True

Check some properties of DRSPR meta class

Entire publishing history:

   >>> pmount_srcrel.publishing_history.count()
   1

Most recent published history row:

   >>> pmount_srcrel.current_published is None
   True

   >>> netapplet_srcrel =  hoary.getSourcePackage('netapplet').currentrelease
   >>> spph = netapplet_srcrel.current_published
   >>> verifyObject(ISourcePackagePublishingHistory, spph)
   True

   >>> spph.section.name
   u'web'

The changesfile attribute contains the package changelog. It is provided as
an ILibraryFileAlias:

   >>> firefox_srcrel =  warty.getSourcePackage(
   ...    'mozilla-firefox').currentrelease
   >>> firefox_srcrel.title
   u'mozilla-firefox 0.9 (source) in ubuntu warty'

   >>> firefox_srcrel.changesfile
   <LibraryFileAlias at ...>

If the package changelog is not available, that attribute is None:

   >>> netapplet_srcrel.changesfile is None
   True

Perform `post publication` override:

   >>> new_section = getUtility(ISectionSet)['base']

   >>> override = netapplet_srcrel.current_published.changeOverride(
   ...     new_section=new_section)

   >>> override.section == new_section
   True

   >>> print override.status.name
   PENDING

   >>> netapplet_srcrel.publishing_history.count()
   2

Override information about 'pmount' is pending publication:

   >>> print netapplet_srcrel.current_published.status.name
   PENDING

   >>> print netapplet_srcrel.current_published.section.name
   base

Supersede previous netapplet publication:

   >>> last_published = netapplet_srcrel.publishing_history[1]
   >>> superseded_netapplet = last_published.supersede()
   >>> flush_database_updates()

   >>> netapplet_srcrel.publishing_history.count()
   2

   >>> print superseded_netapplet.status.name
   SUPERSEDED

   >>> from canonical.database.sqlbase import get_transaction_timestamp
   >>> superseded_netapplet.datesuperseded == get_transaction_timestamp()
   True


== SourcePackagePublishingHistory ==

IDistroSeries.getSourcePackagePublishing returns all the ISPPH
records for a given status in a given pocket. It makes easy to
generate a list of currently published sources for override-check, for
instance. it can also be used to generate the archive packages list in
the future.

   >>> ubuntu = getUtility(IDistributionSet)['ubuntu']
   >>> hoary = ubuntu['hoary']

   >>> from canonical.launchpad.interfaces import (
   ...    PackagePublishingPocket, PackagePublishingStatus)

   >>> hoary_pub_sources = hoary.getSourcePackagePublishing(
   ...     PackagePublishingStatus.PUBLISHED,
   ...     PackagePublishingPocket.RELEASE)

   >>> hoary_pub_sources.count()
   6

   >>> for pub in hoary_pub_sources:
   ...     print pub.displayname
   alsa-utils 1.0.9a-4ubuntu1 in hoary
   cnews cr.g7-37 in hoary
   evolution 1.0 in hoary
   libstdc++ b8p in hoary
   linux-source-2.6.15 2.6.15.3 in hoary
   pmount 0.1-2 in hoary

   >>> hoary_pub_source = hoary_pub_sources[0]

   >>> from canonical.launchpad.interfaces import (
   ...     ISourcePackagePublishingHistory)
   >>> verifyObject(ISourcePackagePublishingHistory, hoary_pub_source)
   True

   >>> hoary_pub_source.sourcepackagerelease.name
   u'alsa-utils'

   >>> hoary_pub_source.sourcepackagerelease.version
   u'1.0.9a-4ubuntu1'

   >>> hoary_pub_source.component.name
   u'main'

   >>> hoary_pub_source.section.name
   u'base'

   >>> hoary.getSourcePackagePublishing(
   ...     PackagePublishingStatus.PUBLISHED,
   ...     PackagePublishingPocket.UPDATES).count()
   0

This method also allow us to restrict the results to a given
component:

   >>> component_main = getUtility(IComponentSet)['main']
   >>> hoary.getSourcePackagePublishing(
   ...     PackagePublishingStatus.PUBLISHED,
   ...     PackagePublishingPocket.RELEASE,
   ...     component=component_main).count()
   5

   >>> component_multiverse = getUtility(IComponentSet)['multiverse']
   >>> hoary.getSourcePackagePublishing(
   ...     PackagePublishingStatus.PUBLISHED,
   ...     PackagePublishingPocket.RELEASE,
   ...     component=component_multiverse).count()
   0

By default the IDistribution 'main_archive' is considered, but It also
allows the callsite to specify one and then the result will be
restricted to it.

   >>> debian_archive = getUtility(IDistributionSet)['debian'].main_archive
   >>> print debian_archive.purpose.title
   Primary Archive

   >>> hoary.getSourcePackagePublishing(
   ...     PackagePublishingStatus.PUBLISHED,
   ...     PackagePublishingPocket.RELEASE,
   ...     component=component_main, archive=debian_archive).count()
   0

ISPP.getPublishedBinaries returns all the binaries generated by the
publication in question:

   >>> warty = ubuntu['warty']
   >>> warty_pub_sources = warty.getSourcePackagePublishing(
   ...     PackagePublishingStatus.PUBLISHED,
   ...     PackagePublishingPocket.RELEASE)

   >>> warty_pub_source = warty_pub_sources[4]
   >>> warty_pub_source.sourcepackagerelease.name
   u'mozilla-firefox'
   >>> warty_pub_source.sourcepackagerelease.version
   u'0.9'
   >>> warty_pub_source.component.name
   u'main'
   >>> warty_pub_source.section.name
   u'web'

   >>> warty_mozilla_pub_binaries = warty_pub_source.getPublishedBinaries()
   >>> len(warty_mozilla_pub_binaries)
   4
   >>> warty_mozilla_pub_bin = warty_mozilla_pub_binaries[0]

   >>> from canonical.launchpad.interfaces import (
   ...    IBinaryPackagePublishingHistory)
   >>> verifyObject(IBinaryPackagePublishingHistory, warty_mozilla_pub_bin)
   True

   >>> warty_mozilla_pub_bin.binarypackagerelease.name
   u'mozilla-firefox'
   >>> warty_mozilla_pub_bin.binarypackagerelease.version
   u'0.9'
   >>> warty_mozilla_pub_bin.component.name
   u'main'
   >>> warty_mozilla_pub_bin.section.name
   u'base'

DistroSeries.getBinaryPackagePublishing will return
BinaryPackagePublishingHistory objects for the DistroSeries:

    >>> warty = ubuntu['warty']
    >>> bpphs = warty.getBinaryPackagePublishing()
    >>> bpphs.count()
    10
    >>> 'mozilla-firefox' in set(
    ...     pkgpub.binarypackagerelease.binarypackagename.name
    ...     for pkgpub in bpphs)
    True

It also allows us to pass wanted strings like: name, version, archtag and
sourcename.

    >>> warty.getBinaryPackagePublishing(
    ...     name="nosuchpackage").count()
    0
    >>> warty.getBinaryPackagePublishing(
    ...     version="nosuchversion").count()
    0
    >>> warty.getBinaryPackagePublishing(
    ...     archtag="nosucharch").count()
    0
    >>> warty.getBinaryPackagePublishing(
    ...     sourcename="nosuchsource").count()
    0

We can restrict the results by component:

    >>> warty.getBinaryPackagePublishing(
    ...     component=component_main).count()
    10
    >>> warty.getBinaryPackagePublishing(
    ...     component=component_multiverse).count()
    0

By pocket:

    >>> warty.getBinaryPackagePublishing(
    ...     pocket=PackagePublishingPocket.RELEASE).count()
    10
    >>> warty.getBinaryPackagePublishing(
    ...     pocket=PackagePublishingPocket.BACKPORTS).count()
    0

Or any combination of them:

    >>> warty.getBinaryPackagePublishing(
    ...     sourcename="alsa", pocket=PackagePublishingPocket.RELEASE,
    ...     component=component_main).count()
    0

    >>> warty.getBinaryPackagePublishing(
    ...     name="mozilla-firefox", archtag='i386',
    ...     component=component_main).count()
    2

As getSourcePackagePublishing, getBinaryPublishing accepts 'archive'
parameter for result restriction:

    >>> warty.getBinaryPackagePublishing(
    ...     name="mozilla-firefox", archtag='i386',
    ...     component=component_main, archive=debian_archive).count()
    0

getAllPublishedSources will return all publications with status PUBLISHED
and in the main archives for this distroseries:

    >>> sources = warty.getAllPublishedSources()
    >>> for source in sources:
    ...     print(
    ...         source.sourcepackagerelease.sourcepackagename.name,
    ...         source.sourcepackagerelease.version)
    (u'netapplet', u'0.99.6-1')
    (u'alsa-utils', u'1.0.8-1ubuntu1')
    (u'alsa-utils', u'1.0.9a-4')
    (u'mozilla-firefox', u'0.9')
    (u'cdrkit', u'1.0')
    (u'iceweasel', u'1.0')

Similarly for binary publications:

    >>> binaries = warty.getAllPublishedBinaries()
    >>> for binary in binaries:
    ...     print(
    ...         binary.binarypackagerelease.binarypackagename.name,
    ...         binary.binarypackagerelease.version)
    (u'mozilla-firefox', u'0.9')
    (u'pmount', u'0.1-1')
    (u'linux-2.6.12', u'2.6.12.20')
    (u'pmount', u'2:1.9-1')
    (u'at', u'3.14156')
    (u'cdrkit', u'1.0')
    (u'mozilla-firefox', u'1.0')
    (u'mozilla-firefox', u'0.9')
    (u'mozilla-firefox-data', u'0.9')
    (u'mozilla-firefox-data', u'0.9')


= Specification Listings =

We should be able to get lists of specifications in different states
related to a distroseries.

Basically, we can filter by completeness, and by whether or not the spec is
informational.

    >>> distroset = getUtility(IDistributionSet)
    >>> kubuntu = distroset.getByName("kubuntu")
    >>> krunch = kubuntu.getSeries("krunch")
    >>> from canonical.launchpad.interfaces import SpecificationFilter

First, there should be one informational specs for krunch:

    >>> filter = [SpecificationFilter.INFORMATIONAL]
    >>> krunch.specifications(filter=filter).count()
    1


There are 2 completed specs for Krunch:

    >>> filter = [SpecificationFilter.COMPLETE]
    >>> for spec in kubuntu.specifications(filter=filter):
    ...    print spec.name, spec.is_complete
    thinclient-local-devices True
    usplash-on-hibernation True


And there are 2 incomplete specs:

    >>> filter = [SpecificationFilter.INCOMPLETE]
    >>> for spec in krunch.specifications(filter=filter):
    ...     print spec.name, spec.is_complete
    cluster-installation False
    revu False


If we ask for all specs, we get them in the order of priority.

    >>> filter = [SpecificationFilter.ALL]
    >>> for spec in krunch.specifications(filter=filter):
    ...    print spec.priority.title, spec.name
    Essential cluster-installation
    High revu
    Medium thinclient-local-devices
    Low usplash-on-hibernation
    Undefined kde-desktopfile-langpacks
    Not krunch-desktop-plan


With a distroseries, we can ask for ACCEPTED, PROPOSED and DECLINED specs:

    >>> filter=[SpecificationFilter.ACCEPTED]
    >>> for spec in krunch.specifications(filter=filter):
    ...     print spec.name, spec.goalstatus.title
    cluster-installation Accepted
    revu Accepted
    thinclient-local-devices Accepted
    usplash-on-hibernation Accepted

    >>> filter=[SpecificationFilter.PROPOSED]
    >>> for spec in krunch.specifications(filter=filter):
    ...     print spec.name, spec.goalstatus.title
    kde-desktopfile-langpacks Proposed

    >>> filter=[SpecificationFilter.DECLINED]
    >>> for spec in krunch.specifications(filter=filter):
    ...     print spec.name, spec.goalstatus.title
    krunch-desktop-plan Declined


And if we ask just for specs, we get BOTH the incomplete and the complete
ones that have been accepted.

    >>> for spec in krunch.specifications():
    ...     print spec.name, spec.is_complete, spec.goalstatus.title
    cluster-installation False Accepted
    revu False Accepted
    thinclient-local-devices True Accepted
    usplash-on-hibernation True Accepted

We can filter for specifications that contain specific text:

    >>> for spec in krunch.specifications(filter=['usb']):
    ...     print spec.name
    thinclient-local-devices


= Drivers =

Distributions have drivers, who are people that have permission to approve
bugs and features for specific releases. The rules are that:

 1. a "driver" can be set on either Distribution or DistroSeries
 2. drivers are only actually relevant on a DistroSeries, because thats the
    granularity at which we track spec/bug targeting
 3. the important attribute is ".drivers" on a distroseries, it is
    calculated based on the combination of owners and drivers in the
    distribution and the distroseries. It is a LIST of drivers, which might
    be empty, or have one or two people/teams in it.
 4. If the release has a driver, then that driver is in the list.
 5. If the distribution has a driver then that is in the list too, otherwise
 6. If neither the release nor the distribution has a driver, then the
    distribution registrant is the driver.

We test these rules below.


First, we look at a release where both the distribution and release have
drivers. Kubuntu should be a good example.

    >>> kubuntu.driver.name
    u'jblack'
    >>> krunch.driver.name
    u'edgar'
    >>> for d in krunch.drivers:
    ...     print d.name
    edgar
    jblack


Now, we look at a release where there is a driver on the release but not on
the distribution.

    >>> debian = distroset.getByName('debian')
    >>> print debian.driver
    None
    >>> print debian.owner.name
    sabdfl
    >>> sarge = debian.getSeries('sarge')
    >>> print sarge.driver.name
    jdub
    >>> for d in sarge.drivers:
    ...     print d.name
    jdub
    sabdfl


Now, a release where there is no driver on the release but there is a driver
on the distribution.

    >>> redhat = distroset.getByName('redhat')
    >>> print redhat.driver.name
    jblack
    >>> six = redhat.getSeries('six')
    >>> print six.driver
    None
    >>> for d in six.drivers:
    ...     print d.name
    jblack

Finally, on a release where neither the distribution nor the release have a
driver. Here, we expect the driver to be the owner of the distribution
(because this is the "commonest fallback").

    >>> sid = debian.getSeries('sid')
    >>> print debian.driver
    None
    >>> print debian.owner.name
    sabdfl
    >>> print sid.driver
    None
    >>> print sid.owner.name
    jdub

    >>> for d in sid.drivers:
    ...     print d.name
    sabdfl


== Lastest Uploads ==

IDistroSeries provides the 'getLatestUpload' method which returns a
list of the last 5 (five) IDistroSeriesSourcePackageRelease (IDRSPR)
uploaded and published in its context.

    >>> warty = ubuntu['warty']
    >>> latest_uploads = warty.getLatestUploads()

Each element is an IDistroSeriesSourcePackageRelease instance:

    >>> for upload in latest_uploads:
    ...     print upload.title
    mozilla-firefox 0.9 (source) in ubuntu warty

Also, empty results (caused obviously by lack of sample data or very
earlier development state of a distroseries) are possible:

    >>> ubuntutest = getUtility(IDistributionSet)['ubuntutest']
    >>> breezy_autotest = ubuntutest['breezy-autotest']
    >>> latest_uploads = breezy_autotest.getLatestUploads()

    >>> len(latest_uploads)
    0
