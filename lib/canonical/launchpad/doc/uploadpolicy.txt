== The uploader policies ==

When the uploader is invoked, it is given a policy to work in. This
governs such things as what tests get run at what stages of the
upload, and whether or not there is a build to be created, or one in
existence to be used. These policies are in the
canonical.archiveuploader package, in the uploadpolicy module. They
are accessed by calling findPolicyByName which will either return a
policy instance or else raise a KeyError.

XXX: dsilvers: 20051019: Get rid of this registration/lookup system
when we've fixed bug 3137

  >>> from canonical.archiveuploader.uploadpolicy import findPolicyByName

There are two policies defined so far. They are the insecure and
buildd policies.

  >>> insecure_policy = findPolicyByName('insecure')
  >>> insecure_policy.name == 'insecure'
  True
  >>> buildd_policy = findPolicyByName('buildd')
  >>> buildd_policy.name == 'buildd'
  True
  >>> abstract_policy = findPolicyByName('abstract')
  Traceback (most recent call last):
  ...
  KeyError: 'abstract'

There is a bunch of attributes which we expect to have and which can vary
from policy to policy.

  >>> insecure_policy.unsigned_changes_ok
  False
  >>> buildd_policy.unsigned_changes_ok
  True
  >>> insecure_policy.unsigned_dsc_ok
  False
  >>> buildd_policy.unsigned_dsc_ok
  True

The policies require certain values to be present in the options at times...

  >>> class MockAbstractOptions:
  ...     distro = 'ubuntu'
  ...     distroseries = None
  >>> class MockOptions(MockAbstractOptions):
  ...     buildid = 1

  >>> ab_opts = MockAbstractOptions()
  >>> bd_opts = MockOptions()

  >>> insecure_policy.setOptions(ab_opts)
  >>> insecure_policy.options is ab_opts
  True
  >>> insecure_policy.distro.name
  u'ubuntu'
  >>> buildd_policy.setOptions(ab_opts)
  Traceback (most recent call last):
  ...
  UploadPolicyError: BuildID required for buildd context
  >>> buildd_policy.setOptions(bd_opts)
  >>> buildd_policy.options is bd_opts
  True
  >>> buildd_policy.distro.name
  u'ubuntu'

Policies can think about distroseriess...

  >>> buildd_policy.setDistroSeriesAndPocket("hoary")
  >>> print buildd_policy.distroseries.name
  hoary
  >>> print buildd_policy.announcelist
  hoary-changes@ubuntu.com

Policies can make decisions based on whether or not they want to
approve an upload automatically (I.E. move it straight to ACCEPTED
instead of UNAPPROVED)

  >>> from canonical.launchpad.interfaces import (
  ...     DistroSeriesStatus, IDistributionSet)
  >>> ubuntu = getUtility(IDistributionSet)['ubuntu']
  >>> hoary = ubuntu['hoary']

  >>> class FakeUpload:
  ...   def __init__(self, ppa=False):
  ...       self.is_ppa = ppa

  >>> print hoary.status.name
  DEVELOPMENT

Uploads to the RELEASE pocket of not FROZEN distroseries are approved
by the insecure policy:

  >>> insecure_policy.setDistroSeriesAndPocket('hoary')
  >>> insecure_policy.autoApprove(FakeUpload())
  True

  >>> insecure_policy.autoApprove(FakeUpload(ppa=True))
  True

When the distroseries is FROZEN the uploads should wait in UNAPPROVED queue:

  >>> login('foo.bar@canonical.com')
  >>> hoary.status = DistroSeriesStatus.FROZEN
  >>> from canonical.database.sqlbase import flush_database_updates
  >>> flush_database_updates()

  >>> insecure_policy.autoApprove(FakeUpload())
  False

PPA uploads continue to be auto-approved:

  >>> insecure_policy.autoApprove(FakeUpload(ppa=True))
  True

Reset the policy so that we can try again...

  >>> insecure_policy.policy = None
  >>> insecure_policy.distroseries = None

Uploads to the UPDATES pocket are not auto-approved by the insecure policy

  >>> insecure_policy.setDistroSeriesAndPocket('hoary-updates')
  >>> insecure_policy.autoApprove(FakeUpload())
  False

Despite of not being allowed yet (see UploadPolicy.checkUpload) PPA
uploads to post-release pockets would also be auto-approved:

  >>> insecure_policy.autoApprove(FakeUpload(ppa=True))
  True
