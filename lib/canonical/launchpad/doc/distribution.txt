Distributions
=============

From the DerivationOverview spec
<https://launchpad.canonical.com/DerivationOverview>:

    A distribution of GNU/Linux comprises a set of packages, an installer,
    possibly a live-CD, some amount of metadata associated with the arrangement
    of those elements and also a lot of information on managing it.

In Launchpad, one distribution is mapped to one row in the Distribution table.
To retrieve a distribution, use the IDistributionSet utility. If you've already
used IPersonSet to retrieve a Person, or IBugTaskSet to retrieve a task, this
syntax should look familiar.

The IDistributionSet utility is accessed in the usual fashion:

    >>> from zope.component import getUtility
    >>> from canonical.launchpad.interfaces import IDistributionSet
    >>> from canonical.lp.dbschema import (
    ...     PackagePublishingPocket, MirrorSpeed, MirrorContent,
    ...     MirrorPulseType)
    >>> distroset = getUtility(IDistributionSet)

To retrieve a specific distribution, use IDistributionSet.get:

    >>> ubuntu = distroset.get(1)
    >>> print ubuntu.name
    ubuntu

Or, to grab one by name, use:

    >>> gentoo = distroset.getByName("gentoo")

Once you've got a distribution, you can retrieve a source package if you
have a SourcePackageName object for it.

    >>> from canonical.launchpad.database.sourcepackagename import (
    ...                                          SourcePackageName)
    >>> from canonical.launchpad.interfaces import (
    ...     IDistributionSourcePackage,
    ...     IDistributionSourcePackageRelease)

    >>> evo = SourcePackageName.byName("evolution")
    >>> evo_ubuntu = ubuntu.getSourcePackage(evo)
    >>> print evo_ubuntu.name
    evolution

    >>> IDistributionSourcePackage.providedBy(evo_ubuntu)
    True

    >>> from canonical.launchpad.database.sourcepackagerelease import (
    ...                                           SourcePackageRelease)
    >>> sourcepackagerelease = SourcePackageRelease.selectOneBy(
    ...     sourcepackagenameID=evo.id, version='1.0')
    >>> sourcepackagerelease.name
    u'evolution'

    >>> evo_ubuntu_rel = ubuntu.getSourcePackageRelease(
    ...                    sourcepackagerelease)
    >>> IDistributionSourcePackageRelease.providedBy(evo_ubuntu_rel)
    True

You can also get a release by name:

    >>> hoary = ubuntu.getRelease("hoary")
    >>> print hoary.name
    hoary

Or by version:

    >>> v504 = ubuntu.getRelease("5.04")
    >>> print v504.name
    hoary

You can list development distroreleases:

    >>> devdists = ubuntu.getDevelopmentReleases()
    >>> for devdist in devdists:
    ...     print devdist.name
    hoary

Retrieving packages by name, returns a tuple of
Source/BinaryPackageName instancefound within this distribution:

    >>> from canonical.launchpad.interfaces import (
    ...     ISourcePackageName, IBinaryPackageName)
    >>> source_name, bin_name = ubuntu.guessPackageNames('pmount')
    >>> ISourcePackageName.providedBy(source_name)
    True
    >>> IBinaryPackageName.providedBy(bin_name)
    True
    >>> source_name.name, bin_name.name
    (u'pmount', u'pmount')

Prevents wrong usage by and assertion error:

    >>> name_tuple = ubuntu.guessPackageNames(ubuntu)
    Traceback (most recent call last):
    ...
    AssertionError: Expected string. Got: <Distribution ...>

Raises NotFoundError for following conditions:

    >>> name_tuple = ubuntu.guessPackageNames('@#$')
    Traceback (most recent call last):
    ...
    NotFoundError: 'Invalid package name: @#$'

    >>> name_tuple = ubuntu.guessPackageNames('zeca')
    Traceback (most recent call last):
    ...
    NotFoundError: 'Unknown package: zeca'

    >>> name_tuple = ubuntu.guessPackageNames('1234')
    Traceback (most recent call last):
    ...
    NotFoundError: 'Unknown package: 1234'

It also raises NotFoundError on distributions with no releases:

    >>> source_name, bin_name = gentoo.guessPackageNames('pmount')
    Traceback (most recent call last):
    ...
    NotFoundError: "Distribution has no releases; 'pmount' was never published in it"

Even if we add a release to Gentoo, no packages have ever been published
in it, and therefore guessPackageNames will still fail:

    >>> from canonical.launchpad.interfaces import IDistroReleaseSet
    >>> from canonical.database.sqlbase import flush_database_updates
    >>> distroreleaseset = getUtility(IDistroReleaseSet)
    >>> gentoo_two = distroreleaseset.new(gentoo, 'gentoo-two', 'Gentoo Two',
    ...                                   'Gentoo Two Dot Oh', 'Gentoo 2', 'G2',
    ...                                   '2.0', None, gentoo.owner)
    >>> source_name, bin_name = gentoo.guessPackageNames('pmount')
    Traceback (most recent call last):
    ...
    NotFoundError: 'Unpublished binary package: pmount'

Distribution Sorting
====================

If you ask for all the distributions in the DistributionSet you should get
Ubuntu first and the rest alphabetically:

    >>> for item in distroset:
    ...     print item.name
    ubuntu
    kubuntu
    debian
    gentoo
    guadalinex
    redhat
    ubuntutest


Searching for DistributionSourcePackages
----------------------------------------

The distribution also allows you to look for source packages that match
a certain string through the magic of fti. For instance:

    >>> packages = ubuntu.searchSourcePackages("mozilla")
    >>> print len(packages)
    1

The search also matches on exact package names which fti doesn't like,
and even on substrings:

    >>> packages = ubuntu.searchSourcePackages("linux-source-2.6.15")
    >>> print len(packages)
    1
    >>> packages = ubuntu.searchSourcePackages("nux-sour")
    >>> print len(packages)
    1


CVE BugTasks on a Distribution
------------------------------

A distribution should know what CVE-related bug tasks exist on it, and what
state they are in. We should be able to find open, and closed, bugtasks,
using this API. Based on the sample data we know the following about Ubuntu:

    >>> tasks = ubuntu.open_cve_bugtasks
    >>> for task in tasks:
    ...     print task.id
    17
    26

There should be NO resolved CVE tasks:

    >>> tasks = ubuntu.resolved_cve_bugtasks
    >>> print len(tasks)
    0


Finding distroreleases and pockets from distribution names
----------------------------------------------------------

A distribution knows what distroreleases it has. Those distroreleases have
pockets which have suffixes used by the archive publisher. Because we sometimes
need to talk about distroreleases such as ubuntu/hoary-security we need some
way to decompose that into the distrorelease and the pocket. Distribution
can do that for us.

If we ask for a totally unknown distrorelease, we raise NotFoundError
    >>> ubuntu.getDistroReleaseAndPocket('unknown')
    Traceback (most recent call last):
    ...
    NotFoundError: 'unknown'

If we ask for a plain distrorelease, it should come back with the RELEASE
pocket as the pocket.
    >>> dr, pocket = ubuntu.getDistroReleaseAndPocket('hoary')
    >>> print dr.name
    hoary
    >>> print pocket.name
    RELEASE

If we ask for a security pocket in a known distrorelease it should come out
on the other side.
    >>> dr, pocket = ubuntu.getDistroReleaseAndPocket('hoary-security')
    >>> print dr.name
    hoary
    >>> print pocket.name
    SECURITY

Find the backports pocket, too:
    >>> dr, pocket = ubuntu.getDistroReleaseAndPocket('hoary-backports')
    >>> print dr.name
    hoary
    >>> print pocket.name
    BACKPORTS

If we ask for a valid distrorelease which doesn't have a given pocket it should
raise NotFoundError for us
    >>> ubuntu.getDistroReleaseAndPocket('hoary-bullshit')
    Traceback (most recent call last):
    ...
    NotFoundError: 'hoary-bullshit'



Upload related stuff
--------------------

When uploading to a distribution we need to query its uploaders. Each
uploader record is in fact a DistroComponentUploader record which
tells us what component is uploadable to by what person or group of
people.

   >>> for dcu in sorted(ubuntu.uploaders,
   ...                   key=lambda dcu: dcu.component.name):
   ...     assert dcu.distribution == ubuntu
   ...     print dcu.component.name
   ...     print dcu.uploader.displayname
   main
   Ubuntu Team
   restricted
   Ubuntu Team
   universe
   Ubuntu Team

When processing an upload we may want to find a file (E.g. if an
incomplete source is uploaded).

    >>> ubuntu.getFileByName('mozilla-firefox_0.9_i386.deb').url
    'http://localhost:58000/40/mozilla-firefox_0.9_i386.deb'
    >>> ubuntu.getFileByName('mozilla-firefox_0.9_i386.deb', source=False).url
    'http://localhost:58000/40/mozilla-firefox_0.9_i386.deb'
    >>> ubuntu.getFileByName('mozilla-firefox_0.9_i386.deb', binary=False)
    Traceback (most recent call last):
    ...
    NotFoundError: 'mozilla-firefox_0.9_i386.deb'
    >>> ubuntu.getFileByName('', source=False, binary=False)
    Traceback (most recent call last):
    ...
    AssertionError: searching in an explicitly empty space is pointless


Launchpad Usage
---------------

A distribution can specify if it uses Malone or Rosetta officially.
Ubuntu uses both Malone and Rosetta:

    >>> from canonical.launchpad.interfaces import ILaunchpadCelebrities
    >>> ubuntu = getUtility(ILaunchpadCelebrities).ubuntu
    >>> ubuntu.official_malone
    True
    >>> ubuntu.official_rosetta
    True

While Debian uses neither:

    >>> debian = getUtility(ILaunchpadCelebrities).debian
    >>> debian.official_malone
    False
    >>> debian.official_rosetta
    False

Gentoo only uses Malone

    >>> print gentoo.official_malone
    True
    >>> print gentoo.official_rosetta
    False



Specification Listings
======================

We should be able to get lists of specifications in different states
related to a distro.

Basically, we can filter by completeness, and by whether or not the spec is
informational.

 >>> kubuntu = distroset.getByName("kubuntu")

 >>> from canonical.lp.dbschema import SpecificationFilter

First, there should be one informational spec for kubuntu, but it is
complete so it will not show up unless we explicitly ask for complete specs:

 >>> filter = [SpecificationFilter.INFORMATIONAL]
 >>> kubuntu.specifications(filter=filter).count()
 0
 >>> filter = [SpecificationFilter.INFORMATIONAL,
 ...           SpecificationFilter.COMPLETE]
 >>> kubuntu.specifications(filter=filter).count()
 1


There are 2 completed specs for Kubuntu:

 >>> filter = [SpecificationFilter.COMPLETE]
 >>> for spec in kubuntu.specifications(filter=filter):
 ...    print spec.name, spec.is_complete
 thinclient-local-devices True
 usplash-on-hibernation True


And there are four incomplete specs:

 >>> filter = [SpecificationFilter.INCOMPLETE]
 >>> for spec in kubuntu.specifications(filter=filter):
 ...    print spec.name, spec.is_complete
 cluster-installation False
 revu False
 kde-desktopfile-langpacks False
 krunch-desktop-plan False


If we ask for all specs, we get them in the order of priority.

 >>> filter = [SpecificationFilter.ALL]
 >>> for spec in kubuntu.specifications(filter=filter):
 ...    print spec.priority.title, spec.name
 Essential cluster-installation
 High revu
 Medium thinclient-local-devices
 Low usplash-on-hibernation
 Undefined kde-desktopfile-langpacks
 Not krunch-desktop-plan


And if we ask just for specs, we get the incomplete ones.

 >>> for spec in kubuntu.specifications():
 ...     print spec.name, spec.is_complete
 cluster-installation False
 revu False
 kde-desktopfile-langpacks False
 krunch-desktop-plan False

We can filter for specifications that contain specific text:

 >>> for spec in kubuntu.specifications(filter=['package']):
 ...     print spec.name
 revu

We can get only valid specs (those that are not obsolete or superseded):

 >>> from canonical.lp.dbschema import SpecificationStatus
 >>> from canonical.launchpad.ftests import login
 >>> login('mark@hbd.com')
 >>> for spec in kubuntu.specifications():
 ...     if spec.name in ['cluster-installation', 'revu']:
 ...         spec.status = SpecificationStatus.OBSOLETE
 ...     if spec.name in ['krunch-desktop-plan']:
 ...         spec.status = SpecificationStatus.SUPERSEDED
 ...     shim = spec.updateCompletionBy(spec.owner)
 >>> flush_database_updates()
 >>> for spec in kubuntu.valid_specifications:
 ...     print spec.name
 kde-desktopfile-langpacks


