Team mailing list subscriptions
===============================

Members of a team, either direct or indirect, may subscribe to that team's
mailing list, if it has one.  To illustrate, we'll first create a bunch of
people, a team and its team mailing list.

    # login() as an admin so that we can call join() on anyone
    # and change their mailing list auto-subscription settings.
    >>> login('foo.bar@canonical.com')

    >>> from lp.registry.tests.mailinglists_helper import (
    ...     get_alternative_email, print_addresses)
    >>> anne = factory.makePersonByName('Anne')

Anne gets two email addresses.  One is her preferred address...

    >>> anne.preferredemail.email
    u'anne.person@example.com'

...and the other is her alternative address.

    >>> get_alternative_email(anne).email
    u'aperson@example.org'

    >>> team_owner = 'no-priv'
    >>> bart = factory.makePersonByName('Bart')
    >>> team_one, list_one = factory.makeTeamAndMailingList(
    ...     'team-one', team_owner)
    >>> team_names = [team_one.name]

Once Anne and Bart join team one, they can post to the mailing list, but they
will not get deliveries.

    >>> anne.join(team_one)
    >>> bart.join(team_one)

    # The IMailingListSet APIs use the SLAVE_FLAVOR since they are read-only.
    # Commit the transaction so that the changes are visible there.
    >>> transaction.commit()

    # No Privileges Person shows up as a team member because he created the
    # team (in the doctest infrastructure).
    >>> sorted(member.displayname for member in team_one.allmembers)
    [u'Anne Person', u'Bart Person', u'No Privileges Person']

The list of sender addresses, i.e. those that are allowed to send emails to a
mailing list, are available both through the mailing list object and through
the mailing list set.

    >>> sorted(list_one.getSenderAddresses())
    [u'anne.person@example.com', u'aperson@example.org',
     u'bart.person@example.com', u'bperson@example.org',
     u'no-priv@canonical.com']

    >>> from lp.registry.interfaces.mailinglist import IMailingListSet
    >>> mailinglist_set = getUtility(IMailingListSet)
    >>> print_addresses(mailinglist_set.getSenderAddresses(team_names))
    team-one
        anne.person@example.com, aperson@example.org,
        bart.person@example.com, bperson@example.org,
        no-priv@canonical.com

No one is yet subscribed to the mailing list though.

    >>> list(list_one.getSubscribedAddresses())
    []
    >>> list(list_one.getSubscribers())
    []
    >>> mailinglist_set.getSubscribedAddresses([team_one.name])
    {}

Anne subscribes to the mailing list for team one.  Because Anne does not
provide an email address when she subscribes, her preferred address is used.

    >>> list_one.subscribe(anne)
    >>> transaction.commit()

    >>> sorted(list_one.getSubscribedAddresses())
    [u'anne.person@example.com']
    >>> sorted(person.displayname for person in list_one.getSubscribers())
    [u'Anne Person']

    >>> print_addresses(mailinglist_set.getSubscribedAddresses(team_names))
    team-one
        anne.person@example.com

Now Bart also subscribes to the mailing list, but he does so with something
other than his preferred email address.

    >>> alternative_email = get_alternative_email(bart)
    >>> alternative_email.email
    u'bperson@example.org'
    >>> list_one.subscribe(bart, alternative_email)
    >>> transaction.commit()

    >>> sorted(list_one.getSubscribedAddresses())
    [u'anne.person@example.com', u'bperson@example.org']
    >>> sorted(person.displayname for person in list_one.getSubscribers())
    [u'Anne Person', u'Bart Person']

    >>> print_addresses(mailinglist_set.getSubscribedAddresses(team_names))
    team-one
        anne.person@example.com, bperson@example.org

A team can not subscribe to a mailing list.

    >>> list_one.subscribe(team_one)
    Traceback (most recent call last):
    ...
    CannotSubscribe: Teams cannot be mailing list members: Team One

A user's subscribed address is the address to which they'll receive posted
messages.  However, the user may post a message from any of the addresses
they've confirmed with Launchpad.

    >>> sorted(list_one.getSenderAddresses())
    [u'anne.person@example.com', u'aperson@example.org',
     u'bart.person@example.com', u'bperson@example.org',
     u'no-priv@canonical.com']

However, should Anne register a new, but not-validated email address, she may
not post from it.

    >>> from lp.services.identity.interfaces.emailaddress import IEmailAddressSet
    >>> address_set = getUtility(IEmailAddressSet)
    >>> alternative = address_set.new(
    ...     'anne.x.person@example.net', anne)
    >>> alternative.email
    u'anne.x.person@example.net'

    >>> sorted(list_one.getSenderAddresses())
    [u'anne.person@example.com', u'aperson@example.org',
     u'bart.person@example.com', u'bperson@example.org',
     u'no-priv@canonical.com']

Once Anne validates her new address, she can post from it.

    >>> from lp.services.identity.interfaces.emailaddress import EmailAddressStatus
    >>> alternative.status = EmailAddressStatus.VALIDATED
    >>> transaction.commit()

    >>> sorted(list_one.getSenderAddresses())
    [u'anne.person@example.com', u'anne.x.person@example.net',
     u'aperson@example.org',
     u'bart.person@example.com', u'bperson@example.org',
     u'no-priv@canonical.com']

    >>> print_addresses(mailinglist_set.getSenderAddresses(team_names))
    team-one
        anne.person@example.com, anne.x.person@example.net,
        aperson@example.org,
        bart.person@example.com, bperson@example.org,
        no-priv@canonical.com

    # Reverse the validation so that it doesn't affect subsequent tests.
    >>> alternative.status = EmailAddressStatus.NEW


MailingListSubscription objects
-------------------------------

MailingListSubscription objects make it possible to see under which
address (if any) a user is subscribed. That information is available
as the email_address member.

    >>> from lp.services.webapp.testing import verifyObject
    >>> from lp.registry.interfaces.mailinglist import IMailingListSubscription
    >>> subscription = list_one.getSubscription(bart)
    >>> verifyObject(IMailingListSubscription, subscription)
    True

    >>> print subscription.email_address.email
    bperson@example.org

Every subscription has a corresponding MailingListSubscription object,
but not every MailingListSubscription object names a specific email
address. If a user is subscribed under their preferred address, the
corresponding MailingListSubscription object will exist but not be
associated with any specific address.

    >>> print list_one.getSubscription(anne).email_address
    None


Nested teams
------------

Indirect members can subscribe to a team's mailing list.  To illustrate this,
we first create team-two as a subteam of team-one.

    >>> team_two = factory.makeTeam(name='team-two', owner=team_owner)
    >>> team_names.append(team_two.name)

    >>> from lp.registry.interfaces.person import IPersonSet
    >>> salgado = getUtility(IPersonSet).getByName('salgado')
    >>> team_two.join(team_one, salgado)
    >>> sorted(member.displayname for member in team_one.allmembers)
    [u'Anne Person', u'Bart Person', u'No Privileges Person', u'Team Two']

Cris joins team-two, becoming a direct member of team-two and an indirect
member of team-one.

    >>> cris = factory.makePersonByName('Cris')
    >>> cris.join(team_two)
    >>> sorted(member.displayname for member in team_two.allmembers)
    [u'Cris Person', u'No Privileges Person']
    >>> sorted(member.displayname for member in team_one.allmembers)
    [u'Anne Person', u'Bart Person', u'Cris Person', u'No Privileges Person',
     u'Team Two']

Now, by virtue of her indirect membership in team-one, Cris can subscribe to
team-one's mailing list.

    >>> list_one.subscribe(cris)
    >>> transaction.commit()

    >>> sorted(list_one.getSubscribedAddresses())
    [u'anne.person@example.com', u'bperson@example.org',
     u'cris.person@example.com']
    >>> [person.displayname for person in list_one.getSubscribers()]
    [u'Anne Person', u'Bart Person', u'Cris Person']

    >>> print_addresses(mailinglist_set.getSubscribedAddresses(team_names))
    team-one
        anne.person@example.com, bperson@example.org,
        cris.person@example.com

Cris may post to the mailing list using any of her registered and validated
email addresses.

    >>> sorted(list_one.getSenderAddresses())
    [u'anne.person@example.com', u'aperson@example.org',
     u'bart.person@example.com', u'bperson@example.org',
     u'cperson@example.org', u'cris.person@example.com',
     u'no-priv@canonical.com']

    >>> print_addresses(mailinglist_set.getSenderAddresses(team_names))
    team-one
        anne.person@example.com, aperson@example.org,
        bart.person@example.com, bperson@example.org,
        cperson@example.org, cris.person@example.com,
        no-priv@canonical.com

Any new address that Cris registers but does not validate may not yet be used
to post to the mailing list.

    >>> alternative = address_set.new(
    ...     'cris.x.person@example.net', cris)
    >>> alternative.email
    u'cris.x.person@example.net'

    >>> sorted(list_one.getSenderAddresses())
    [u'anne.person@example.com', u'aperson@example.org',
     u'bart.person@example.com', u'bperson@example.org',
     u'cperson@example.org', u'cris.person@example.com',
     u'no-priv@canonical.com']

Once Cris validates her new address, she can post from it.

    >>> alternative.status = EmailAddressStatus.VALIDATED
    >>> transaction.commit()

    >>> sorted(list_one.getSenderAddresses())
    [u'anne.person@example.com', u'aperson@example.org',
     u'bart.person@example.com', u'bperson@example.org',
     u'cperson@example.org', u'cris.person@example.com',
     u'cris.x.person@example.net',
     u'no-priv@canonical.com']

    >>> print_addresses(mailinglist_set.getSenderAddresses(team_names))
    team-one
        anne.person@example.com, aperson@example.org,
        bart.person@example.com, bperson@example.org,
        cperson@example.org, cris.person@example.com,
        cris.x.person@example.net,
        no-priv@canonical.com

    # Reverse the validation so that it doesn't affect subsequent tests.
    >>> alternative.status = EmailAddressStatus.NEW
    >>> transaction.commit()

