#!/usr/bin/python2.4
from string import split
from time import sleep
from re import sub
from datetime import datetime
from optparse import OptionParser
import sys
import os

#local imports
from database import Doap

#Morgan's import
import sourceforge 
import rdfproj


def clean_list():
    print """Cleaning 'Not Found' File List"""
    f = open(LIST, 'w')
    timestamp = datetime.isoformat(datetime.utcnow())
    f.write('Generated by Nicole at UTC %s\n' % timestamp)
    f.close()

def append_list(data):
    print """@\tAppending %s in 'Not Found' File List""" % data
    f = open(LIST, 'a')
    f.write('%s\n' % data)
    f.close()


def merge_data(pref, sup):
    ##iter through the suplementar keys 
    for key in sup.keys():
        ## if there is something new, add new key
        if key not in pref.keys():
            pref[key] = sup[key]
        ## if the preffered value is None 
        elif sup[key] and not pref[key] :
            pref[key] = sup[key]
        ## Otherwise keep the preffered
        else:
            pass

    return pref

def grab_web_info(name):
    datas = {}

#     repositories = (('sf', 'Sourceforge'),
#                     ('fm', 'Freshmeat'))

    repositories = (('fm', 'Freshmeat'),)

    for short, desc in repositories:

        print '@ Looking for %s on %s in WEB' % (name, desc)
        try:
            data = sourceforge.getProductSpec(name, short)
            print '@\tFound at %s' % desc        
        except sourceforge.Error:
            data = {}
            print '@\tNot Found'
        datas[short] = data

    return datas['fm']
#    return merge_data(datas['fm'], datas['sf'])

def grab_rdf_info(path, name):
    print '@ Looking for %s on FM RDF' % (name)
    data = rdfproj.getProductSpec(path, name)

    if data is None:
        print '@\tNot Found'
        return

    print '@\tFound at FM RDF'
    return data
    
def createorupdate(doap, productname, source, path, packagename=None,
                   distroname=None, ownername=None, force=None):

    if source == 'web':
        data = grab_web_info(productname)
    else:
        data = grab_rdf_info(path, productname)

    if data or force:
        doap.ensureProduct(data, productname, ownername=ownername)

        if packagename:
            if not doap.ensurePackaging(productname, packagename, distroname):
                print '@\tNo Package Found for %s' % packagename
                append_list('No Package ' + packagename)                
                
    else:
        print '@\tNo Product Found for %s' % productname
        append_list('No Product ' + productname)                


if __name__ == "__main__":
    # Parse the commandline...
    parser = OptionParser()
    ## Select the available Mode to run nicole
    ## Create -> create from a given name list
    ## Update -> update products with AutoUpdate & Reviewed ON
    parser.add_option("-m", "--mode", dest="mode",
                      help="Operation mode ['create', 'update']",
                      metavar="MODE",
                      default="")
    ## Initial file list containing suggested product names
    ## line by line
    parser.add_option("-f", "--file", dest="filename",
                      help="Product Name List",
                      metavar="FILE",
                      default="source_list")
    ## Data source WEB (HTML parser) or RDF (splited RDF files)
    parser.add_option("-s", "--source", dest="source",
                      help="Data Source ['web', 'rdf']",
                      metavar="SRC",
                      default="rdf")
    ## DOAP is inside our current Launchpad production DB
    parser.add_option("-d", "--database", dest="doapdb",
                      help="DOAP Database name",
                      metavar="DBNAME",
                      default="launchpad_dev")
    ## DOAP DB host 
    parser.add_option("-H", "--host", dest="dbhost",
                      help="DOAP Database Host",
                      metavar="HOST",
                      default="localhost")
    ## Web search interval avoiding to be blocked by high threshould
    ## of requests reached by second
    parser.add_option("-w", "--wait", dest="wait",
                      help="Interval in seconds",
                      metavar="TIME",
                      default="10")
    ## Where Not Found Entries will be stored
    parser.add_option("-l", "--list", dest="listfile",
                      help="Not Found list file",
                      metavar="FILE",
                      default="nicole_notfound")
    ## Commit in DB or not
    parser.add_option("-n", "--dry-run", dest="dry_run",
                      help="don't commit changes to database",
                      default=False, action='store_true')

    parser.add_option("-F", "--force", dest="force",
                      help="Force the creation of the Objects",
                      default=False, action='store_true')

    parser.add_option("-p", "--package", dest="package",
                      help="Two columms format list",
                      default=False, action='store_true')
    ## Provide a distribution name for packaging
    parser.add_option("-D", "--distro", dest="distro",
                      help="Distribution name for Packaging",
                      metavar="DISTRO",
                      default="ubuntu")
    ## Provide a default owner name
    parser.add_option("-o", "--owner", dest="owner",
                      help="Default product owner name",
                      metavar="OWNER",
                      default="doap")
    ## set the xml directory
    parser.add_option("-P", "--path", dest="path",
                      help="Directory containing the xml files",
                      metavar="PATH",
                      default="freshmeat")

    
    (options,args) = parser.parse_args()

    mode = options.mode
    filename = options.filename
    source = options.source
    DOAPDB = options.doapdb
    DBHOST = options.dbhost
    DISTRO = options.distro
    WAIT = int(options.wait)
    LIST = options.listfile
    DRY = options.dry_run
    FORCE = options.force
    PKG = options.package
    OWNER = options.owner
    PATH = options.path
    
    # get the DB abstractors
    doap = Doap(DBHOST, DOAPDB)

    print '=================================='
    print 'Nicole: Product Information Finder'
    print '=================================='
    print '\tMode:', mode
    if mode == 'create':
        print '\tList:', filename
    print '\tSource:', source
    print '\tDOAP:', DOAPDB
    print '\tDISTRO:', DISTRO
    print '\tWait:', WAIT, 's'
    print '\tNotFOUND:', LIST
    print '\tDRY-RUN:', DRY
    print '\tFORCE:', FORCE
    print '\tPKG:', PKG
    print '\tPATH:', PATH
    print '=================================='
    print ''
    
    if mode == 'create':
        # test file list 
        if not os.access(filename, os.F_OK):
            print "Source list not found:", filename
            sys.exit(1)
            
        f = open(filename, 'r')
        products = f.read().strip().split('\n')
        #print products
        tries = len(products)
        
    elif mode == 'update':
        tries, products = doap.getProductsForUpdate()
        #print products

    elif not mode:
        # clean exit 
        print 'No MODE select'
        sys.exit(0)        
    else:
        # clean exit 
        print 'MODE not implemented: ', mode
        sys.exit(0)

    if not os.access(PATH, os.F_OK):
        print 'PATH is wrong: ', PATH
        sys.exit(0)

    index = 0
    clean_list()

    # main looping
    for product in products:
        index += 1

        if PKG:
            try:                
                productname, packagename = product.split()
            except ValueError:
                print 'Wrong List Format use:'
                print 'PRODUCT SRC'
                print 'PRODUCT SRC'
                print '...'
                sys.exit(1)
        else:
            # get always the first token, so the list format is compatible
            # for both procedures (do packaging or not)
            productname =  product.split()[0]
            packagename = None

        print ' '
        print '@ Search for "%s" (%d/%d)' % (productname,
                                             index,
                                             tries)
    
        createorupdate(doap, productname, source, PATH,
                       packagename=packagename, distroname=DISTRO,
                       ownername=OWNER, force=FORCE)

        ## If permitted, partially Commit DB Product Info
        if not DRY:
            doap.commit()            

        ## We sleep to avoid overloading SF or FM servers
        sleep(WAIT)
 
    doap.close()
    print 'Thanks for using Nicole'
