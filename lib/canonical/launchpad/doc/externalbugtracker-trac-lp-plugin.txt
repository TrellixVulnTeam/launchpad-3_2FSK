= ExternalBugTracker: TracLPPlugin =

This covers the implementation of the ExternalBugTracker class for Trac
instances having the LP XML-RPC plugin installed.

For testing purposes, a custom XML-RPC transport can be passed to it,
so that we can avoid network traffic in tests.

    >>> from canonical.launchpad.components.externalbugtracker import (
    ...     TracLPPlugin)
    >>> from canonical.launchpad.ftests.externalbugtracker import (
    ...     TestTracXMLRPCTransport)
    >>> test_transport = TestTracXMLRPCTransport()
    >>> trac = TracLPPlugin(
    ...     'http://example.com/', xmlrpc_transport=test_transport)
    >>> trac.xmlrpc_transport is test_transport
    True


== Authentication ==

Before any XML-RPC methods can be used, we need to authenticate with the
Trac instance.

    >>> class FakeResponse:
    ...     def __init__(self):
    ...         self.headers = {}

    >>> from canonical.launchpad.webapp.url import urlappend
    >>> from canonical.launchpad.interfaces import ILoginTokenSet
    >>> class TestTracLPPlugin(TracLPPlugin):
    ...     def urlopen(self, url):
    ...         base_auth_url = urlappend(self.baseurl, 'launchpad-auth')
    ...         if not url.startswith(base_auth_url + '/'):
    ...             raise AssertionErrror("Unexpected URL: %s" % url)
    ...         token_text = url.split('/')[-1]
    ...         token = getUtility(ILoginTokenSet)[token_text]
    ...         if token.tokentype.name != 'BUGTRACKER':
    ...             raise AssertionError(
    ...                 'Invalid token type: %s' % token.tokentype.name)
    ...         if token.date_consumed is not None:
    ...             raise AssertionError("Token as already been consumed.")
    ...         token.consume()
    ...         print "Successfully validated the token."
    ...         response = FakeResponse()
    ...         response.headers['Set-Cookie'] = 'trac_auth=random_token'
    ...         return response

    >>> trac = TestTracLPPlugin(
    ...     'http://example.com/', xmlrpc_transport=test_transport)
    >>> trac._authenticate()
    Successfully validated the token.

    >>> test_transport.auth_cookie
    'trac_auth=random_token'

The cookie is set by the transport used.

    >>> trac = TracLPPlugin('http://example.com/')
    >>> transport = trac.xmlrpc_transport
    >>> transport.auth_cookie = 'trac_auth=random_token'

    >>> class FakeConnection:
    ...     def putheader(self, header, value):
    ...         print "%s: %s" % (header, value)
    >>> transport.send_host(FakeConnection(), 'example.com')
    Host: example.com
    Cookie: trac_auth=random_token

== Current time ==

The current time is always returned in UTC, no matter if the Trac
instance returns another time zone.

    >>> trac = TestTracLPPlugin(
    ...     'http://example.com/', xmlrpc_transport=test_transport)

    >>> import time
    >>> from datetime import datetime
    >>> trac_time = datetime(2008, 4, 9, 3, 2, 1)
    >>> test_transport.seconds_since_epoch = int(time.mktime(
    ...     trac_time.timetuple()))
    >>> test_transport.local_timezone = 'CET'
    >>> test_transport.utc_offset = 60*60
    >>> trac.getCurrentDBTime()
    datetime.datetime(2008, 4, 9, 2, 2, 1, tzinfo=<UTC>)


== Getting modified bugs ==

We only want to update the bug watches whose remote bugs have been
modified since the last time we checked.

In order to demonstrate this, we'll create some mock remote bugs for our
test XML-RPC transport to check.

    >>> from canonical.launchpad.ftests.externalbugtracker import (
    ...     MockTracRemoteBug)

    >>> remote_bugs = {
    ...     '1': MockTracRemoteBug('1', datetime(2008, 4, 1, 0, 0, 0)),
    ...     '2': MockTracRemoteBug('2', datetime(2007, 1, 1, 1, 1, 1)),
    ...     '3': MockTracRemoteBug('3', datetime(2008, 1, 1, 1, 2, 3)),}

    >>> test_transport.remote_bugs = remote_bugs

Calling the getModifiedRemoteBugs() method of our trac instance and
passing it a list of bug ids and a  datetime object will return a list
of the ids of the bugs which have been modified since that time.

    >>> bug_ids_to_check = ['1', '2', '3']
    >>> last_checked = datetime(2008, 1, 1, 0, 0, 0)
    >>> trac.getModifiedRemoteBugs(
    ...     bug_ids_to_check, last_checked)
    ['1', '3']

Different last_checked times will result in different numbers of bugs
being returned.

    >>> last_checked = datetime(2008, 2, 1, 0, 0, 0)
    >>> trac.getModifiedRemoteBugs(
    ...     bug_ids_to_check, last_checked)
    ['1']

If no bugs have been updated since last_checked, getModifiedRemoteBugs()
will return an empty list.

    >>> last_checked = datetime(2008, 5, 1, 0, 0, 0)
    >>> trac.getModifiedRemoteBugs(
    ...     bug_ids_to_check, last_checked)
    []


== Getting the status of remote bugs ==

Like all other ExternalBugTrackers, the TrackLPPlugin ExternalBugTracker
allows us to fetch bugs statuses from the remote bug tracker.

