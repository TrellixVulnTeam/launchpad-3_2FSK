Source Packages
===============

A source package is a thing from which binary packages are built, to then be
installed using a package management tool like apt-get or rpm. One named source
package in a distro may be used to build several different named binary
packages, on one or more architectures. One named binary package in a distro
may have been built from more than one named source package (e.g. a different
source package may have been used to build "foo" on i386 vs. "foo" on ppc.)

Named Source Package
--------------------

The are various metadata we're interested in collecting about a bundle of code
used to build binary packages for installation in a particular distro release.
One such thing is the name of that bundle of code. This is abstracted into a
separate SourcePackageName table.

Accessing source package names is done through the ISourcePackageNameSet
utility.

The ISourcePackageNameSet utility is accessed in the usual fashion:

    >>> from zope.component import getUtility
    >>> from canonical.launchpad.interfaces import ISourcePackageNameSet
    >>> sourcepackagenameset = getUtility(ISourcePackageNameSet)

To retrieve a specific source package name, use ISourcePackageNameSet.get:

    >>> firefox = sourcepackagenameset.get(1)
    >>> print firefox.name
    mozilla-firefox

To retrieve a specific source package name by its name, use
ISourcePackageNameSet.queryByName:

    >>> firefox = sourcepackagenameset.queryByName("mozilla-firefox")
    >>> print firefox.name
    mozilla-firefox

If the package doesn't exist, queryByName returns None:

    >>> foobar = sourcepackagenameset.queryByName("foobar")
    >>> print foobar
    None

Packaging
---------

Distribution packages are linked to upstream productseries through the
packaging process. Here we test the code that links all of those.

First, let's get some useful objects from the db.

    >>> from canonical.launchpad.database import SourcePackageName
    >>> evolution = SourcePackageName.byName('evolution')
    >>> a52dec = SourcePackageName.byName('a52dec')
    >>> netapplet = SourcePackageName.byName('netapplet')
    >>> firefox = SourcePackageName.byName('mozilla-firefox')
    >>> pmount = SourcePackageName.byName('pmount')

    >>> from canonical.launchpad.database import DistroRelease
    >>> warty = DistroRelease.get(1)
    >>> hoary = DistroRelease.get(3)
    >>> sarge = DistroRelease.get(7)
    >>> sid = DistroRelease.get(8)
    >>> g2k5 = DistroRelease.get(9)

Now let's make sure that we can see a productseries for a source package.

    >>> from canonical.launchpad.database import SourcePackage
    >>> sp = SourcePackage(sourcepackagename=firefox, distrorelease=hoary)
    >>> sp.productseries.name
    u'1.0'

Now we make sure there is no Packaging data for a52dec in hoary.

    >>> from canonical.launchpad.database import Packaging
    >>> Packaging.selectBy(sourcepackagenameID=a52dec.id,
    ...     distroreleaseID=hoary.id).count()
    0

So far so good.

Now verify we still get a product for that source package, thanks to the
fact that we have Warty data for it

    >>> sp = SourcePackage(sourcepackagename=a52dec, distrorelease=hoary)
    >>> sp.productseries.product.name
    u'a52dec'

Similarly, we should be able to get the packaging information from a parent
distrorelease, on the basis that a derivative is highly unlikely to change
the packaging drastically without changing the name of the package.

First, show there is no packging data for a52dec in g2k5:

    >>> Packaging.selectBy(sourcepackagenameID=a52dec.id,
    ...     distroreleaseID=g2k5.id).count()
    0

Now verify we still get a product for that source package

    >>> sp = SourcePackage(sourcepackagename=a52dec, distrorelease=g2k5)
    >>> sp.productseries.product.name
    u'a52dec'


Test the Changelog concatenation process:

    >>> sp = SourcePackage(sourcepackagename=pmount, distrorelease=hoary)
    >>> sp.changelog
    u'This is a placeholder changelog for pmount 0.1-2 \n\nThis is a placeholder changelog for pmount 0.1-1 \n\n'