Introduction
============

Bugs are problems in software. When a bug gets assigned to a specific
upstream or distro/sourcepackagename/binarypackagename, a bug /task/ is
created. In essence, a bug task is a bug that needs to be fixed in a specific
place. Where a bug has things like a title, comments and subscribers, it's
the bug task that tracks priority, severity, assignee, etc.

Working with Bug Tasks in Launchpad
===================================

Creating Bug Tasks
------------------

All BugTask creation and retrieval is done through an IBugTaskSet utility.

    >>> from zope.component import getUtility
    >>> import transaction
    >>> from canonical.launchpad.interfaces import IBugTaskSet
    >>> bugtaskset = getUtility(IBugTaskSet)

To create a bug task, you have to be logged in:

    >>> from canonical.launchpad.ftests import login, ANONYMOUS
    >>> login('foo.bar@canonical.com')

There are three kinds of bug tasks. We need to pass the bug task creation
methods some other objects to create a task, so lets get the utilities we need
to access those other objects:

    >>> from canonical.launchpad.interfaces import (IBugSet, IPersonSet,
    ...     IProductSet, IDistributionSet, IDistroReleaseSet)
    >>> productset = getUtility(IProductSet)
    >>> distroset = getUtility(IDistributionSet)
    >>> distoreleaseset = getUtility(IDistroReleaseSet)
    >>> bugset = getUtility(IBugSet)
    >>> personset = getUtility(IPersonSet)
    >>> bug_one = bugset.get(1)
    >>> sabdfl = personset.get(1)

Next, we need to grab some values to provide for priority, severity and status.

    >>> from canonical.lp.dbschema import (BugTaskStatus, BugSeverity,
    ...     BugPriority)
    >>> STATUS_NEW = BugTaskStatus.NEW
    >>> STATUS_ACCEPTED = BugTaskStatus.ACCEPTED
    >>> STATUS_FIXED = BugTaskStatus.FIXED
    >>> SEVERITY_NORMAL = BugSeverity.NORMAL
    >>> PRIORITY_MEDIUM = BugPriority.MEDIUM

  i. Upstream -- a bug that has to be fixed in an upstream product

    >>> evolution = productset.get(5)
    >>> upstream_task = bugtaskset.createTask(
    ...     bug = bug_one, product = evolution, owner = sabdfl,
    ...     status = STATUS_NEW, priority = PRIORITY_MEDIUM,
    ...     severity = SEVERITY_NORMAL)
    >>> upstream_task.product == evolution
    True

    >>> from canonical.launchpad.interfaces import IUpstreamBugTask
    >>> IUpstreamBugTask.providedBy(upstream_task)
    True

  ii. Distro -- a bug that has to be fixed in a specific distro

    >>> ubuntu = distroset.get(1)
    >>> distro_task = bugtaskset.createTask(
    ...     bug = bug_one, distribution = ubuntu, owner = sabdfl,
    ...     status = STATUS_NEW, priority = PRIORITY_MEDIUM,
    ...     severity = SEVERITY_NORMAL)
    >>> distro_task.distribution == ubuntu
    True

    >>> from canonical.launchpad.interfaces import IDistroBugTask
    >>> IDistroBugTask.providedBy(distro_task)
    True

  ii. Distro Release -- a bug that has to be fixed in a specific distro
  release. This primary use case for distro release bug tasks is for backporting
  fixes (e.g. for security bugs or bugs causing critical data loss.)

    >>> hoary = distoreleaseset.get(3)
    >>> distro_release_task = bugtaskset.createTask(
    ...     bug = bug_one, distrorelease = hoary, owner = sabdfl,
    ...     status = STATUS_NEW, priority = PRIORITY_MEDIUM,
    ...     severity = SEVERITY_NORMAL)
    >>> distro_release_task.distrorelease == hoary
    True

    >>> from canonical.launchpad.interfaces import IDistroReleaseBugTask
    >>> IDistroReleaseBugTask.providedBy(distro_release_task)
    True

XXX: Brad Bollenbach, 2005-02-24: See the bottom of this file for a chunk of
test documentation that is missing from here, due to problems with resetting
the connection after an IntegrityError is raised. ARGH.

Retrieving and Searching for Bug Tasks
--------------------------------------

To retrieve a specific BugTask, use IBugTaskSet.get. As an example, interacting
with the system as an anonymous (i.e. unauthenticated) user:

    >>> from canonical.launchpad.interfaces import IPerson
    >>> from canonical.launchpad.database import Person
    >>> login(ANONYMOUS)

let's fetch the BugTask with ID 1:

    >>> bugtask = bugtaskset.get(1)
    >>> bugtask.bug.title
    u'Firefox does not support SVG'

If you pass an ID for which no object exists, you'll get a
zope.exceptions.NotFoundError:

    >>> bugtask = bugtaskset.get(-1)
    Traceback (most recent call last):
      ...
    NotFoundError: 'BugTask with ID -1 does not exist'

Each task has a "contextname", a string describing the site of the
task. It concatenates the display names of the distribution,

    >>> bugtask = bugtaskset.get(1)
    >>> bugtask.contextname
    u'Ubuntu'

distro release, or product;

    >>> bugtask = bugtaskset.get(2)
    >>> bugtask.contextname
    u'Mozilla Firefox'

the name of the source package (if any); and the name of the binary
package (but only if it's named differently from the source
package).

Let's thoroughly test BugTask.contextname.  We'll set up a dummy bugtask
class into which we put a copy of the contextname method, so we can test
it in isolation.

    >>> from canonical.launchpad.database import BugTask
    >>> class DummyBugTask:
    ...     distribution = None
    ...     distrorelease = None
    ...     sourcepackagename = None
    ...     binarypackagename = None
    ...     product = None
    ...
    ...     # This next line is a hack to take a copy of the method and
    ...     # add it to this class.
    ...     contextname = BugTask.contextname.fget
    >>> class NamedThing:
    ...     def __init__(self, name):
    ...         self.name = '[%s.name]' % name
    ...         self.displayname = '[%s.displayname]' % name

When all the important attributes are None, then the bugtask is in an invalid
state.

    >>> bugtask = DummyBugTask()
    >>> bugtask.contextname()
    Traceback (most recent call last):
    ...
    AssertionError

Product alone:

    >>> bugtask.product = NamedThing('product')
    >>> bugtask.contextname()
    '[product.displayname]'

Put things back the way they were.

    >>> bugtask.product = None

Distribution alone.

    >>> bugtask.distribution = NamedThing('distribution')
    >>> bugtask.contextname()
    '[distribution.displayname]'

Distribution and sourcepackagename.

    >>> bugtask.sourcepackagename = NamedThing('spn')
    >>> bugtask.contextname()
    '[distribution.displayname] [spn.name]'

Distribution and sourcepackagename and binarypackagename.

    >>> bugtask.binarypackagename = NamedThing('bpn')
    >>> bugtask.contextname()
    '[distribution.displayname] [spn.name] [bpn.name]'

Reset the state of our bugtask.

    >>> bugtask.binarypackagename = None
    >>> bugtask.sourcepackagename = None
    >>> bugtask.distribution = None

Just a distrorelease.

    >>> bugtask.distrorelease = NamedThing('distrorelease')
    >>> bugtask.distrorelease.distribution = NamedThing('distribution')
    >>> bugtask.contextname()
    '[distribution.displayname] [distrorelease.displayname]'

Distrorelease and sourcepackagename.

    >>> bugtask.sourcepackagename = NamedThing('spn')
    >>> bugtask.contextname()
    '[distribution.displayname] [distrorelease.displayname] [spn.name]'

Distrorelease, sourcepackagename and binarypackagename.

    >>> bugtask.binarypackagename = NamedThing('bpn')
    >>> bugtask.contextname()
    '[distribution.displayname] [distrorelease.displayname] [spn.name] [bpn.name]'

Note that we haven't tested any combinations that shouldn't occur, except
for the case when everything is None.


To retrieve a set of bug tasks matching a set of search criteria, use
BugTaskSet.search. Here's how you'd grab all the NEW and ACCEPTED tasks:

For upstream:

    >>> from canonical.launchpad.searchbuilder import any
    >>> from canonical.lp.dbschema import BugTaskStatus
    >>> from canonical.launchpad.database import Product
    >>> upstream_mozilla = Product.get(4)
    >>> bugtasks = bugtaskset.search(
    ...     status = any(BugTaskStatus.NEW, BugTaskStatus.ACCEPTED),
    ...     product = upstream_mozilla,
    ...     orderby = "id")
    >>> print bugtasks.count()
    4
    >>> bugtask_ids = [bt.id for bt in bugtasks]
    >>> print bugtask_ids
    [2, 13, 14, 15]

For a distribution:

    >>> debian = distroset.get(3)
    >>> sample_person = personset.get(12)
    >>> bugtasks = bugtaskset.search(
    ...     status = any(BugTaskStatus.NEW, BugTaskStatus.ACCEPTED),
    ...     distribution = debian, orderby = "id",
    ...     assignee = sample_person)
    >>> print bugtasks.count()
    1
    >>> bugtasks[0].id
    5

To provide null-matching search criteria, use canonical.launchpad.searchbuilder.NULL:

    >>> from canonical.launchpad.searchbuilder import NULL
    >>> bugtasks = bugtaskset.search(product = upstream_mozilla, assignee = NULL)
    >>> print bugtasks.count()
    2
    >>> print [bugtask.bug.id for bugtask in bugtasks]
    [6, 4]

There's also support for searching tasks based on a string of text, e.g.:

    >>> bugtasks = bugtaskset.search(
    ...     product = upstream_mozilla, searchtext = "instructions")
    >>> print bugtasks.count()
    1
    >>> print [bugtask.bug.id for bugtask in bugtasks]
    [5]

It's also possible to iterate over all the bug tasks:

    >>> bugtasks = [bugtask for bugtasks in bugtaskset]
    >>> print len(bugtasks)
    12

Bug Task Maintainers
--------------------

The upcoming sections mention bug task maintainers, so we should
probably clarify that before going any further. IBugTask provides a
maintainer attribute, and a maintainer_displayname attribute; the
latter is mainly for use in ZCML configuration on add/editforms where
you want to show the maintainer's name. maintainer_displayname will
probably go away in the future and be replaced by a smarter display
widget for the maintainer name.

The maintainer of an upstream task is simply the Product.owner:

    >>> bugtask = bugtaskset.get(1)
    >>> bugtask.maintainer.id
    17

The maintainer of a distribution task is the source package maintainer:

    >>> bugtask = bugtaskset.get(4)
    >>> bugtask.maintainer.id
    1

or None, if the task is not yet assigned to a specific source
package. So, borrowing the distro task we filed earlier:

    >>> print distro_task.maintainer
    None
    >>> print distro_task.maintainer_displayname
    None

Editing Bug Tasks
-----------------

Upstream Bug Tasks
^^^^^^^^^^^^^^^^^^

Only the maintainer and the assignee (if there is one) may edit upstream
bug tasks.

    >>> login(ANONYMOUS)
    >>> upstream_task.status = STATUS_ACCEPTED
    Traceback (most recent call last):
      ...
    Unauthorized: ('status', 'launchpad.Edit')

As you can see an anonymous user was not able to edit the task. Also the
task is not editable by an authenticated user who is not the maintainer.

    >>> login('foo.bar@canonical.com')
    >>> upstream_task.status = STATUS_FIXED
    Traceback (most recent call last):
      ...
    Unauthorized: ('status', 'launchpad.Edit')

Now let's login as a maintainer and try again.

    >>> login('test@canonical.com')
    >>> upstream_task.status = STATUS_FIXED

The maintainer could be a team as well. In that case, all members of
that team, or members of teams which are themselves members of that
team, are able to edit the task.

Let's create a new team, a product which the team owns, and
associate the same bug with this product:

    >>> from canonical.lp.dbschema import TeamSubscriptionPolicy
    >>> policy = TeamSubscriptionPolicy.OPEN
    >>> foobar = personset.get(16)
    >>> foo_team = personset.newTeam(
    ...     subscriptionpolicy = policy, name = 'foo',
    ...     displayname = "The Foo Team", teamownerID = foobar.id)
    >>> foo_product = productset.createProduct(
    ...     owner = foo_team.id, name = 'foo-product',
    ...     displayname = 'foo product', title = 'Foo',
    ...     summary = 'a great product', description = 'no long desc')
    >>> upstream_task = bugtaskset.createTask(
    ...     bug = bug_one, product = foo_product, owner = sabdfl,
    ...     status = STATUS_NEW, priority = PRIORITY_MEDIUM,
    ...     severity = SEVERITY_NORMAL)
    >>> upstream_task.maintainer == foo_team
    True
    >>> upstream_task.maintainer_displayname
    u'The Foo Team'

Then let's login as the Sample Person user:

    >>> login('test@canonical.com')

Note that Sample Person is not a member of the Foo team:

    >>> sample_person.inTeam(foo_team)
    False

Thus, he can't edit the task:

    >>> upstream_task.status = STATUS_ACCEPTED
    Traceback (most recent call last):
      ...
    Unauthorized: ('status', 'launchpad.Edit')

If he joins the maintainer team, though, he's allowed to edit the task.
Let's add him to the maintainer team:

    >>> sample_person = personset.get(12)
    >>> sample_person.join(foo_team)
    True

Now he's allowed to edit the task:

    >>> upstream_task.status = STATUS_ACCEPTED

Next, we demonstrate how the assignee can edit the task.  Let's remove
the logged in person from the maintainer team, so that he can't edit the
task anymore:

    >>> sample_person.leave(foo_team)
    >>> upstream_task.status = STATUS_FIXED
    Traceback (most recent call last):
      ...
    Unauthorized: ('status', 'launchpad.Edit')

Then let's login as one member of the maintainer team (in this case the
team owner) and assign Sample Person to the task:

    >>> login('foo.bar@canonical.com')
    >>> upstream_task.assignee = sample_person.id

Now Sample Person is allowed to edit the bug task again:

    >>> login('test@canonical.com')
    >>> upstream_task.status = STATUS_FIXED

Distro and Distro Release Bug Tasks
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Any logged-in user can edit tasks filed on distros as long as the bug
is not marked private. So, as an anonymous user, we can edit anything:

    >>> login(ANONYMOUS)
    >>> distro_task.status = STATUS_FIXED
    Traceback (most recent call last):
      ...
    Unauthorized: ('status', 'launchpad.Edit')

    >>> distro_release_task.assignee = sample_person
    Traceback (most recent call last):
      ...
    Unauthorized: ('assignee', 'launchpad.Edit')

But once authenticated:

    >>> login('test@canonical.com')

We can edit the task:

    >>> distro_task.status = STATUS_FIXED
    >>> distro_release_task.assignee = sample_person

Bug Privacy
===========

A bug is either private or public. Private bugs are only visible (e.g. in
search listings) to explicit subscribers. Public bugs are visible to
anyone.

    >>> from zope.event import notify
    >>> from zope.publisher.browser import TestRequest
    >>> from canonical.launchpad.event.sqlobjectevent import (
    ...     SQLObjectToBeModifiedEvent, SQLObjectModifiedEvent)

Let's log in as the user Foo Bar (to be allowed to edit bugs):

    >>> login('foo.bar@canonical.com')

and mark one of the Firefox bugs private:

    >>> bug_firefox_no_svg_support = bugtaskset.get(2)
    >>> notify(SQLObjectToBeModifiedEvent(
    ...     bug_firefox_no_svg_support.bug, {'private' : True}))

    >>> def capture_state(obj, *fields):
    ...     class State: pass
    ...     state = State()
    ...     for field in fields:
    ...         setattr(state, field, getattr(obj, field))
    ...     return state
    >>> old_state = capture_state(
    ...     bug_firefox_no_svg_support.bug, "id", "title",
    ...     "summary", "description", "private", "name",
    ...     "duplicateof")
    >>> bug_firefox_no_svg_support.bug.private = True
    >>> bug_set_private = SQLObjectModifiedEvent(
    ...     bug_firefox_no_svg_support.bug, old_state,
    ...     ["id", "title", "private"])
    >>> notify(bug_set_private)
    >>> transaction.commit()

Because Foo Bar is a member of the Ubuntu Team, and the Ubuntu Team is
one of the maintainers on this bug report, Foo Bar will see the bug in
searches:

    >>> firefox = productset.get(4)
    >>> firefox_bugtasks = bugtaskset.search(
    ...     product=firefox, status=any(STATUS_NEW, STATUS_ACCEPTED))
    >>> [bugtask.bug.id for bugtask in firefox_bugtasks]
    [6, 5, 4, 1]

Now, if we log in as David Allouche:

    >>> login("david.allouche@canonical.com")

The same search as above yields only three bugs, because David
Allouche can't see the private bug.

    >>> bugtasks = bugtaskset.search(
    ...     status = any(BugTaskStatus.NEW, BugTaskStatus.ACCEPTED),
    ...     product = upstream_mozilla,
    ...     orderby = "id")
    >>> print bugtasks.count()
    3
    >>> bugtask_ids = [bt.id for bt in bugtasks]
    >>> print bugtask_ids
    [13, 14, 15]

Trying to retrieve the bug directly will work fine:

    >>> bug_firefox_no_svg_support = bugtaskset.get(2)

But attribute access on the IBugTask will raise an authorization
exception:

    >>> bug_firefox_no_svg_support.bug
    Traceback (most recent call last):
      ...
    Unauthorized: ('bug', 'launchpad.View')

As well, trying to edit a distro task as David Allouche will also
raise an Unauthorized exception:

    >>> bug_debian_firefox_no_svg_support = bugtaskset.get(4)
    >>> bug_debian_firefox_no_svg_support.status = BugTaskStatus.FIXED
    Traceback (most recent call last):
      ...
    Unauthorized: ('status', 'launchpad.Edit')

But, logged in as the Firefox maintainer:

    >>> login('test@canonical.com')

We'll find all four IBugTasks that match the search criteria, as the maintainer
is also an explicit subscriber in this case.

    >>> bugtasks = bugtaskset.search(
    ...     status = any(BugTaskStatus.NEW, BugTaskStatus.ACCEPTED),
    ...     product = upstream_mozilla,
    ...     orderby = "id")
    >>> print bugtasks.count()
    4
    >>> bugtask_ids = [bt.id for bt in bugtasks]
    >>> print bugtask_ids
    [2, 13, 14, 15]

And, as you would expect, we'll also be able to access it directly:

    >>> bug_firefox_no_svg_support = bugtaskset.get(2)
    >>> bug_firefox_no_svg_support.bug.title
    u'Firefox does not support SVG'

XXX: Brad Bollenbach, 2005-02-24: This bit testing the IntegrityError should be
higher up in the file (under the explanation about creating tasks), but I can't
figure out how to reset the connection properly after an IntegrityError is
raised. ARGH.

Note that a task filed on a specific distro release does *not* have its
distribution column set. In fact, a task must have exactly one of its product,
distribution or distrorelease fields set, otherwise the database integrity
constraints will be violated.

    >>> bad_task = bugtaskset.createTask(
    ...     bug = bug_one, distribution = ubuntu, distrorelease = hoary,
    ...     owner = sabdfl, status = STATUS_NEW, priority = PRIORITY_MEDIUM,
    ...     severity = SEVERITY_NORMAL)
    Traceback (most recent call last):
      ...
    IntegrityError: ...
