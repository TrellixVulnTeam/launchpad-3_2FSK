= Deadlocks & Serialization errors =

The Psycopg Database Adapter will catch serialization, deadlock
and integrity exceptions and reraise them as Retry exceptions. A
serialization exception occurs when a connection is running in the
SERIALIZABLE transaction isolation level and PostgreSQL is detects
that your connections reads are now inconsistant due to a concurrent
update. Retrying the transaction is the documented way of handling this
case. A deadlock occurs when two connections are waiting on locks both
held by the other connection. The best way of handling this for a web
application seems also to be to retry the transaction.

This is not being tested upstream in the SVN PsycopgDA branch, as testing
requires access to a PostgreSQL database and I can't write a suitably
generic test harness at this time. So we test here in Launchpad to catch
regressions, which I expect will occur with PostgreSQL and psycopg version
changes. Also, the Retry exception being raised on IntegrityViolations is
a Launchpad specific hack - I am unsure if all users of psycopgda would
want this functionality.

In order to catch the psycopg connections, Psycopgda needs to return
wrapped ZopeConnection and ZopeCursor instances (the wrapped connection
is only needed to make the cursor() method return a wrapped cursor).

    >>> import transaction
    >>> from zope.component import getUtility
    >>> from zope.app.rdb.interfaces import IZopeDatabaseAdapter
    >>> from sqlos.interfaces import IConnectionName
    >>> from psycopgda.adapter import PsycopgConnection, PsycopgCursor

    >>> name = getUtility(IConnectionName)
    >>> da = getUtility(IZopeDatabaseAdapter, name.name)
    >>> con = da()
    >>> cur = con.cursor()
    >>> isinstance(con, PsycopgConnection)
    True
    >>> isinstance(cur, PsycopgCursor)
    True

Test integrity violations. This one is easy. Note that the exception
raised is a subclass of both IntegrityError and Retry, to allow the
publishing machinery to handle the Retry exception without modification
and to allow existing code that handles IntegrityErrors themselves to
continue functioning as normal.

    >>> from zope.publisher.interfaces import Retry
    >>> cur.execute("UPDATE JabberID SET jabberid='dupe' WHERE id=1")
    >>> try:
    ...     cur.execute("UPDATE JabberID SET jabberid='dupe' WHERE id=2")
    ... except Retry, error:
    ...     print '%s raised' % error.__class__
    ...     print str(error)
    canonical.launchpad.webapp.adapter.RetryPsycopgIntegrityError raised
    ERROR:  duplicate key violates unique constraint "jabberid_jabberid_key"
    <BLANKLINE>
    UPDATE JabberID SET jabberid='dupe' WHERE id=2

Early versions of psycopg would raise some integrity violations as
ProgrammingErrors. We should confirm we are running a version of psycopg
that does not have this problem.

    >>> con.rollback()
    >>> cur = con.cursor()
    >>> try:
    ...     cur.execute("""
    ...         INSERT INTO JabberID (person, jabberid)
    ...         VALUES (1, 'markshuttleworth@jabber.org')
    ...         """)
    ... except Retry, error:
    ...     print '%s raised' % error.__class__
    canonical.launchpad.webapp.adapter.RetryPsycopgIntegrityError raised


To trigger a serialization exception using the database adapter, we need
to use two threads that are synchronized to ensure the querys occur in the
correct order.

    >>> import traceback
    >>> from threading import Thread, Event
    >>> steps = [Event(), Event()]
    >>> class STask1(Thread):
    ...     def run(self):
    ...         try:
    ...             self.traceback = None
    ...             con = da()
    ...             cur = con.cursor()
    ...             cur.execute("SELECT name FROM Person WHERE id=22")
    ...             self.traceback = repr(list(cur.fetchall()))
    ...             steps[0].set()
    ...             steps[1].wait()
    ...             cur.execute("UPDATE Person SET name='argh' WHERE id=22")
    ...             transaction.commit()
    ...             self.traceback = None
    ...         except:
    ...             self.traceback = traceback.format_exc()
    ...             steps[0].set()
    ...         con.close()

    >>> class STask2(Thread):
    ...     def run(self):
    ...         try:
    ...             self.traceback = None
    ...             con = da()
    ...             cur = con.cursor()
    ...             steps[0].wait()
    ...             cur.execute("UPDATE Person SET name='whatever' WHERE id=22")
    ...             transaction.commit()
    ...         except Exception:
    ...             self.traceback = traceback.format_exc()
    ...         steps[1].set()
    ...         con.close()

    >>> task1 = STask1()
    >>> task2 = STask2()
    >>> task1.start()
    >>> task2.start()
    >>> task1.join()
    >>> task2.join()

    Only one thread raised an exception, and that exception is a
    Retry exception.

    >>> bool(task1.traceback and task2.traceback)
    False
    >>> print task1.traceback or task2.traceback
    Traceback (most recent call last):
    ...
    Retry: ...


Deadlocks can be tested for the same way as serialization exceptions.

    >>> steps = [Event(), Event()]
    >>> class DTask1(Thread):
    ...     def run(self):
    ...         try:
    ...             self.traceback = None
    ...             con = da()
    ...             cur = con.cursor()
    ...             cur.execute("LOCK Person IN ACCESS EXCLUSIVE MODE")
    ...             steps[0].set()
    ...             steps[1].wait()
    ...             cur.execute("LOCK Bug IN ACCESS EXCLUSIVE MODE")
    ...         except:
    ...             self.traceback = traceback.format_exc()
    ...             steps[0].set()

    >>> class DTask2(Thread):
    ...     def run(self):
    ...         try:
    ...             self.traceback = None
    ...             con = da()
    ...             cur = con.cursor()
    ...             steps[0].wait()
    ...             cur.execute("LOCK Bug IN ACCESS EXCLUSIVE MODE")
    ...             steps[1].set()
    ...             cur.execute("LOCK Person IN ACCESS EXCLUSIVE MODE")
    ...         except Exception:
    ...             self.traceback = traceback.format_exc()
    ...             steps[1].set()

    >>> task1 = DTask1()
    >>> task2 = DTask2()
    >>> task1.start()
    >>> task2.start()
    >>> task1.join()
    >>> task2.join()

Only one of the threads will have raised a Retry exception; the other
thread will have succeeded.

    >>> bool(task1.traceback and task2.traceback)
    False
    >>> print task1.traceback or task2.traceback
    Traceback (most recent call last):
    ...
    Retry: ...
