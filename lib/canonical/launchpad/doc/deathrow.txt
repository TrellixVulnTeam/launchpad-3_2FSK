= Testing the Package Death Row =

  >>> import datetime
  >>> import pytz
  >>> from canonical.database.sqlbase import flush_database_updates
  >>> from canonical.launchpad.interfaces import PackagePublishingStatus
  >>> from canonical.archivepublisher.deathrow import DeathRow
  >>> from canonical.archivepublisher.diskpool import DiskPool
  >>> from canonical.launchpad.database import Distribution
  >>> from canonical.launchpad.database import \
  ...   SecureBinaryPackagePublishingHistory as SBPPH
  >>> from canonical.launchpad.database import \
  ...   SecureSourcePackagePublishingHistory as SSPPH
  >>> from canonical.launchpad.database import \
  ...   SourcePackageReleaseFile as SPRF
  >>> class MockLogger:
  ...     def debug(self, s):
  ...         print "DEBUG:", s
  ...     def info(self, s):
  ...         print "INFO:", s
  ...     def exception(self, s):
  ...         print "EXC:", s

We're working inside Ubuntu:

  >>> distro = Distribution.selectOneBy(name="ubuntu")

Temporary directories to be used in tests:

  >>> import os
  >>> pool_path = '/tmp/pool'
  >>> os.makedirs(pool_path)
  >>> temp_path = '/tmp/temp'
  >>> os.makedirs(temp_path)


== Nothing to do ==

The no-operation use case:

  >>> disk_pool = DiskPool(pool_path, temp_path, MockLogger())
  >>> death_row = DeathRow(distro.main_archive, disk_pool, MockLogger())
  >>> death_row.reap(dry_run=True)
  DEBUG: 0 Sources
  DEBUG: 0 Binaries
  INFO: Removing 0 files marked for reaping
  INFO: Total bytes freed: 0
  DEBUG: Marking 0 condemned packages as removed.

= Package Removal (dry-run) =

And, if we mark some packages to be pending removal. Source publication
15 refers to alsa-utils_1.0.9a-4.dsc:

  >>> this_year = datetime.datetime.now().year
  >>> old_date = datetime.datetime(year=this_year - 2, month=1, day=1,
  ...                              tzinfo=pytz.timezone('UTC'))
  >>> future_date = datetime.datetime(year=this_year + 2, month=1, day=1,
  ...                                 tzinfo=pytz.timezone('UTC'))

  >>> publishing_record = SSPPH.get(15)
  >>> print publishing_record.dateremoved
  None
  >>> publishing_record.status = PackagePublishingStatus.DELETED
  >>> publishing_record.scheduleddeletiondate = old_date

Source publication 25 includes 'foobar-1.0.dsc' (but the source pacakge
is 'cdrkit'; our sample data is not entirely consistent but it
doesn't matter for this test.)  It will be considered for file deletion
but nothing actually deleted because other publications are referring to
the files.

  >>> publishing_record = SSPPH.get(25)
  >>> print publishing_record.distroseries.name
  breezy-autotest
  >>> print publishing_record.dateremoved
  None
  >>> publishing_record.status = PackagePublishingStatus.OBSOLETE
  >>> publishing_record.scheduleddeletiondate = old_date

Source publication 12 includes alsa-utils_1.0.9a-4ubuntu1.dsc:

  >>> publishing_record = SSPPH.get(12)
  >>> print publishing_record.distroseries.name
  hoary
  >>> print publishing_record.dateremoved
  None
  >>> publishing_record.status = PackagePublishingStatus.SUPERSEDED
  >>> publishing_record.scheduleddeletiondate = old_date

But so does source publication 20, which we'll set to pending removal
but with a scheduled deletion date in the future. Because not all of the
references to the file are ready to be removed, the file will not be
deleted yet.

  >>> publishing_record = SSPPH.get(20)
  >>> print publishing_record.distroseries.name
  warty
  >>> print [f.libraryfile.filename
  ...        for f in publishing_record.sourcepackagerelease.files]
  [u'alsa-utils_1.0.9a-4ubuntu1.dsc']
  >>> publishing_record.status = PackagePublishingStatus.SUPERSEDED
  >>> publishing_record.scheduleddeletiondate = future_date

Knock off some binaries as well:

  >>> publishing_record = SBPPH.get(17)
  >>> print publishing_record.dateremoved
  None
  >>> publishing_record.status = PackagePublishingStatus.SUPERSEDED
  >>> publishing_record.scheduleddeletiondate = old_date

  >>> publishing_record = SBPPH.get(19)
  >>> print publishing_record.dateremoved
  None
  >>> publishing_record.status = PackagePublishingStatus.DELETED
  >>> publishing_record.scheduleddeletiondate = old_date

  >>> publishing_record = SBPPH.get(24)
  >>> print publishing_record.dateremoved
  None
  >>> publishing_record.status = PackagePublishingStatus.OBSOLETE
  >>> publishing_record.scheduleddeletiondate = old_date

As above, both 19 and 21 binary publication refer to the same pmount
binaries, and since 21 is not to be removed, 19 is supposed to be left
alone too.  Publishing record 23 refers to package 'cdrkit'
which we just made obsolete, and is also considered for death row
processing.

  >>> publishing_record = SBPPH.get(21)
  >>> print [f.libraryfile.filename
  ...        for f in publishing_record.binarypackagerelease.files]
  [u'pmount_1.9-1_all.deb']

  >>> publishing_record = SBPPH.get(19)
  >>> print [f.libraryfile.filename
  ...        for f in publishing_record.binarypackagerelease.files]
  [u'pmount_1.9-1_all.deb']

Our sample data has "cdrkit" with a .deb name of "foobar".  Go figure.

  >>> publishing_record = SBPPH.get(24)
  >>> print [f.libraryfile.filename
  ...        for f in publishing_record.binarypackagerelease.files]
  [u'foobar_1.0_all.deb']

Flush our these updates and kick the DeathRow processor again.

  >>> flush_database_updates()
  >>> disk_pool = DiskPool(pool_path, temp_path, MockLogger())
  >>> death_row = DeathRow(distro.main_archive, disk_pool, MockLogger())
  >>> death_row.reap(dry_run=True)
  DEBUG: ...
  ...
  DEBUG: (Not really!) removing main linux-source-2.6.15/linux-2.6.12_2.6.12.20_i386.deb
  DEBUG: File to remove main linux-source-2.6.15/linux-2.6.12_2.6.12.20_i386.deb is not in pool, skipping
  DEBUG: (Not really!) removing main cdrkit/foobar_1.0_all.deb
  DEBUG: File to remove main cdrkit/foobar_1.0_all.deb is not in pool, skipping
  DEBUG: (Not really!) removing main alsa-utils/alsa-utils_1.0.9a-4.dsc
  DEBUG: File to remove main alsa-utils/alsa-utils_1.0.9a-4.dsc is not in pool, skipping
  INFO: Total bytes freed: 0
  DEBUG: Marking 3 condemned packages as removed.

Note that while we are in dry run mode, the database queries are
actually executed; the process-death-row script however does not commit
the transaction when that flag is set.

Look at the results of our actions. Two packages removed (one source
and one binary) and the date removed properly set up:

  >>> from canonical.database.sqlbase import get_transaction_timestamp
  >>> transaction_timestamp = get_transaction_timestamp()

  >>> source_publishing_record = SSPPH.get(15)
  >>> source_publishing_record.status.name
  'DELETED'

  >>> source_publishing_record.dateremoved == transaction_timestamp
  True

  >>> binary_publishing_record = SBPPH.get(17)
  >>> binary_publishing_record.status.name
  'SUPERSEDED'

  >>> binary_publishing_record.dateremoved == transaction_timestamp
  True

Source publication 20 (has a future 'scheduled deletion date') and
binary publication 19 (file hold by another active publication), of
course are left alone:

  >>> publishing_record = SSPPH.get(20)
  >>> publishing_record.dateremoved is None
  True

  >>> publishing_record = SBPPH.get(19)
  >>> publishing_record.dateremoved is None
  True

Deathrow is also able to ignore files if there is any reference not
yet dominated, for instance, just-deleted packages, they will contain
empty 'scheduleddeletiondate' (see archivepublish/domination.py).

  >>> publishing_record = SSPPH.get(20)
  >>> publishing_record.status = PackagePublishingStatus.DELETED
  >>> publishing_record.scheduleddeletiondate = None

Deathrow will simply ignore references to the just-deleted package,
since it can't be sure whether or not they can be removed.

  >>> flush_database_updates()
  >>> disk_pool = DiskPool(pool_path, temp_path, MockLogger())
  >>> death_row = DeathRow(distro.main_archive, disk_pool, MockLogger())
  >>> death_row.reap(dry_run=True)
  DEBUG: ...
  ...
  INFO: Removing 0 files marked for reaping
  INFO: Total bytes freed: 0
  DEBUG: Marking 0 condemned packages as removed.

Since the just-deleted package was ignored its related publications
were not removed from disk.

  >>> publishing_record = SSPPH.get(20)
  >>> publishing_record.dateremoved is None
  True

  >>> publishing_record = SBPPH.get(19)
  >>> publishing_record.dateremoved is None
  True


== Package Removal (simulated real run) ==

Test that bytes freed computing is handled correctly:

  >>> def removeFileReturningSize(cn, sn, fn):
  ...    print "DEBUG: (Not really!) removing %s %s/%s" % (cn, sn, fn)
  ...    return 5
  >>> death_row._removeFile = removeFileReturningSize
  >>> publishing_record = SSPPH.get(2)
  >>> publishing_record.status = PackagePublishingStatus.DELETED
  >>> publishing_record.scheduleddeletiondate = old_date
  >>> publishing_record.dateremoved = None
  >>> publishing_record = SBPPH.get(24)
  >>> publishing_record.status = PackagePublishingStatus.SUPERSEDED
  >>> publishing_record.scheduleddeletiondate = old_date
  >>> publishing_record.dateremoved = None
  >>> flush_database_updates()
  >>> death_row.reap()
  DEBUG: ...
  ...
  INFO: Removing 2 files marked for reaping
  DEBUG: (Not really!) removing main cdrkit/foobar_1.0_all.deb
  DEBUG: (Not really!) removing main evolution/evolution-1.0.tar.gz
  INFO: Total bytes freed: 10
  DEBUG: Marking 2 condemned packages as removed.

Test that random exceptions are handled correctly:

  >>> def removeFileRaisingOtherException(cn, sn, fn):
  ...    print "DEBUG: (Not really!) removing %s %s/%s" % (cn, sn, fn)
  ...    raise TypeError
  >>> death_row._removeFile = removeFileRaisingOtherException
  >>> publishing_record = SSPPH.get(10)
  >>> publishing_record.status = PackagePublishingStatus.SUPERSEDED
  >>> publishing_record.scheduleddeletiondate = old_date
  >>> flush_database_updates()
  >>> death_row.reap()
  DEBUG: ...
  ...
  INFO: Removing 1 files marked for reaping
  DEBUG: (Not really!) removing main alsa-utils/alsa-utils_1.0.8-1ubuntu1.dsc
  EXC: Removing file main alsa-utils/alsa-utils_1.0.8-1ubuntu1.dsc generated exception, continuing
  INFO: Total bytes freed: 0
  DEBUG: Marking 1 condemned packages as removed.


Remove temporary diretories used for tests:

  >>> import shutil
  >>> shutil.rmtree(pool_path)
  >>> shutil.rmtree(temp_path)
