Distro Releases
===============

From the DerivationOverview spec
<https://launchpad.canonical.com/DerivationOverview>:

    A distribution of GNU/Linux comprises a set of packages, an installer,
    possibly a live-CD, some amount of metadata associated with the arrangement
    of those elements and also a lot of information on managing it.

A distro release is a given version of a distribution. So, for Ubuntu, there
are releases (or planned releases) like "warty", "hoary" and "bendy".

Distro releases are retrieved with the IDistroReleaseSet utility, much like
people are retrieved with the IPersonSet utility, or bug tasks are retrieved
with the IBugTaskSet utility.

The IDistroReleaseSet utility is accessed in the usual fashion:

    >>> from zope.component import getUtility
    >>> from canonical.launchpad.interfaces import (
    ...     IDistroReleaseSet, IDistributionSet)
    >>> distroreleaseset = getUtility(IDistroReleaseSet)

To retrieve a specific release of a distribution, use IDistroReleaseSet.get:

    >>> warty = distroreleaseset.get(1)
    >>> print warty.name
    warty
    >>> print warty.fullreleasename
    Ubuntu Warty

Or IDistroReleaseSet.findByName:

    >>> for distrorelease in distroreleaseset.findByName("warty"):
    ...     print distrorelease.name
    warty

To get one specific release by name, use queryByName:

    >>> ubuntu = getUtility(IDistributionSet).getByName("ubuntu")

    >>> warty = distroreleaseset.queryByName(ubuntu, "warty")
    >>> warty.name
    u'warty'

If the release by that name doesn't exist, None will be returned:

    >>> foobar = distroreleaseset.queryByName(ubuntu, "foobar")
    >>> print foobar
    None

Or IDistroReleaseSet.findByVersion:

    >>> for distrorelease in distroreleaseset.findByVersion("5.04"):
    ...     print distrorelease.name
    hoary

To search the set of IDistroReleases, use IDistroReleaseSet.search:

    >>> ubuntu_releases = distroreleaseset.search(
    ...     distribution=ubuntu, isreleased=True, orderBy="-datereleased")
    >>> [release.name for release in ubuntu_releases]
    [u'warty']

    >>> all_ubuntu_releases = distroreleaseset.search(distribution=ubuntu)
    >>> all_ubuntu_releases.count()
    4

DistroRelease.getPublishedReleases:

    >>> from canonical.launchpad.database import SourcePackageName, DistroRelease
    >>> warty2 = DistroRelease.get(1)

Passing a ISourcePackageName as argument:

    >>> prs = warty2.getPublishedReleases(
    ...       SourcePackageName.byName('mozilla-firefox'))
    >>> print len(prs)
    1
    >>> print prs[0].sourcepackagerelease.sourcepackagename.name
    mozilla-firefox

Passing a string name:

    >>> print len(warty2.getPublishedReleases('mozilla-firefox'))
    1

Including pending publication records in the result:

    >>> print len(warty2.getPublishedReleases('mozilla-firefox',
    ...           include_pending=True))
    2

Not found as empty list:

    >>> print len(warty2.getPublishedReleases('nosuchpackage'))
    0

canUploadToPocket method helps us to decide if an upload is allowed or
not, according the distrorelease status and the upload target pocket.

   >>> from canonical.launchpad.interfaces import IDistributionSet
   >>> ubuntu = getUtility(IDistributionSet)['ubuntu']
   >>> breezy_autotest = ubuntu['breezy-autotest']

   >>> from canonical.lp.dbschema import PackagePublishingPocket

   >>> warty.releasestatus.name
   'CURRENT'
   >>> warty.canUploadToPocket(PackagePublishingPocket.RELEASE)
   False
   >>> warty.canUploadToPocket(PackagePublishingPocket.SECURITY)
   True

   >>> breezy_autotest.releasestatus.name
   'EXPERIMENTAL'
   >>> breezy_autotest.canUploadToPocket(PackagePublishingPocket.RELEASE)
   True
   >>> breezy_autotest.canUploadToPocket(PackagePublishingPocket.SECURITY)
   False

Package searching
-----------------

You can search through binary packages publishing in a distribution
release by using the searchPackages method, which uses magical fti:

    >>> len(warty.searchPackages("pmount"))
    1

This also works for small or weirdly named packages that don't work
through fti, and even for substrings:

    >>> len(warty.searchPackages("linux-2.6.12"))
    1
    >>> len(warty.searchPackages("at"))
    1
    >>> len(warty.searchPackages("inux-2"))
    1


DistroReleases have components and sections
-------------------------------------------

A distrorelease has some number of components and/or sections which
are valid for that distrorelease. These selections are used by (among
other things) the uploader for validating incoming uploads.

   >>> hoary = distroreleaseset.get(3)
   >>> for c in hoary.components:
   ...     print c.name
   main
   restricted
   >>> for s in hoary.sections:
   ...     print s.name
   base
   web
   editors
   admin
   devel

   >>> from canonical.launchpad.interfaces import (
   ...    IComponentSet, ISectionSet)
   >>> univ = getUtility(IComponentSet).ensure('universe')
   >>> python = getUtility(ISectionSet).ensure('python')

   >>> hoary.addComponent(univ)
   >>> hoary.addSection(python)

   >>> for c in hoary.components:
   ...     print c.name
   main
   restricted
   universe

   >>> for s in hoary.sections:
   ...     print s.name
   base
   web
   editors
   admin
   devel
   python


DistroReleases can be initialised from their parents
----------------------------------------------------

When a distrorelease is derived from another distrorelease (be it a
derivative distribution, or simply the next release in a sequence from
Ubuntu) we need to initialise the new release with quite a lot of
information. Not least of which is the section and component
selections and the publishing information for the distrorelease.

DistroRelease provides us with a method for doing this which carefully
goes behind the back of sqlobject to copy potentially tens of
thousands of rows around in order to set up a distrorelease.

IDistroRelease lists a series of preconditions for performing an
initialisation. In particular the initialiser won't overwrite
publishing records etc. Essentially this is a "Do not push this button
again" type set of assertions.

   >>> login("foo.bar@canonical.com")
   >>> humpy = distroreleaseset.new(ubuntu, 'humpy', 'Humpy Hippo',
   ...                              'The Humpy Hippo', 'Fat', 'Yo Momma',
   ...                              '99.2',hoary, hoary.owner)
   >>> humpy_i386 = humpy.newArch('i386', hoary['i386'].processorfamily,
   ...                            True, humpy.owner)
   >>> humpy.nominatedarchindep = humpy_i386
   >>> humpy.initialiseFromParent()
   >>> len(hoary.getPublishedReleases('pmount'))
   1
   >>> len(humpy.getPublishedReleases('pmount'))
   1
   >>> len(hoary['i386'].getReleasedPackages('pmount'))
   1
   >>> len(humpy_i386.getReleasedPackages('pmount'))
   1

Check if the attributes of an DRSPR instance for the just initialised
distrorelease are sane. A DRSPR instance should filter attributes of
a SPR according the distrorelease in question (practically according
what is published in this distrorelelase)

Since the initialise-from-parent procedure copies the latest
publications from the parent IDRSPR.builds should be empty, reflecting
that there are no builds for this SPR in this DistroRelease.
IDRSPR.builds will be non-empty after a developer submits a new SPR
for the  DistroRelease.

In other hand IDRSPR.binaries should return the binaries resulted of
the SPRs inheritance by joining BPP->BPR->BUILD->SPR, i.e, binaries
published in this distrorelease (in fact, in one of its architectures)
resulted of the sourcepackagerelease in question, but built anywhere.
(fix bug #52938)

Initialise a new distrorelease based on warty (since it has, at least
one coherent published source + binary, mozilla-firefox)

   >>> bumpy = distroreleaseset.new(ubuntu, 'bumpy', 'Bumpy',
   ...                              'The Bumpy', 'Fat', 'Boom',
   ...                              '99.3', warty, warty.owner)

   >>> bumpy_i386 = bumpy.newArch('i386', warty['i386'].processorfamily,
   ...                            True, bumpy.owner)
   >>> bumpy.nominatedarchindep = bumpy_i386
   >>> bumpy.initialiseFromParent()

Build a new ISourcePackage based in the new distrorelease:

   >>> bumpy_firefox_sp = bumpy.getSourcePackage('mozilla-firefox')

Check the content IDRSPR binaries & builds attributes:

'binaries' should be inherited from parent release.

   >>> bumpy_firefox_sp.currentrelease.binaries.count()
   1

   >>> bumpy_firefox_sp.currentrelease.sourcepackagerelease.binaries.count()
   2

   >>> for bin in bumpy_firefox_sp.currentrelease.binaries:
   ...     print bin.id, bin.title, bin.build.distroarchrelease.title
   12 mozilla-firefox-0.9 The Warty Warthog Release for i386 (x86)

'builds' should be empty since it was built in parent (warty), not in this
distrorelease (bumby.

   >>> bumpy_firefox_sp.currentrelease.builds.count()
   0

the SPR returns all build records for it.

   >>> bumpy_firefox_sp.currentrelease.sourcepackagerelease.builds.count()
   3

Translatable Packages and Packaging
-----------------------------------

You can easily find out what packages are translatable in a
distribution release:

   >>> translatables = hoary.getTranslatableSourcePackages()
   >>> for translatable in translatables:
   ...    print translatable.name
   evolution
   mozilla
   pmount

Packages can be linked to upstream productseries in specific
distribution releases. IDistroRelease offers a way to query translatable
packages that are linked to upstream productseries.

   >>> unlinked_translatables = hoary.getUnlinkedTranslatableSourcePackages()
   >>> for translatable in unlinked_translatables:
   ...    print translatable.name
   pmount
   mozilla

The links to upstream product series can be verified using the
packagings property:

    >>> packagings = hoary.packagings
    >>> for packaging in packagings:
    ...     print packaging.sourcepackagename.name, \
    ...           packaging.productseries.product.displayname
    evolution Evolution
    mozilla-firefox Mozilla Firefox
    netapplet NetApplet

From the results above you can notice that neither mozilla-firefox nor
netapplet are translatable in Hoary.


DistroRelease can build meta objects for packages
-------------------------------------------------

   >>> from zope.interface.verify import verifyObject
   >>> from canonical.launchpad.interfaces import (
   ...     ISourcePackage,
   ...     IDistroReleaseBinaryPackage,
   ...     IDistroReleaseSourcePackageRelease,
   ...     ISourcePackagePublishingHistory)


   >>> pmount_src_name =  SourcePackageName.byName('pmount')
   >>> pmount_source = hoary.getSourcePackage(pmount_src_name)
   >>> ISourcePackage.providedBy(pmount_source)
   True

   >>> from canonical.launchpad.database.binarypackagename import (
   ...                                       BinaryPackageName)
   >>> pmount_bin_name =  BinaryPackageName.byName('pmount')
   >>> pmount_binary = hoary.getBinaryPackage(pmount_bin_name)
   >>> IDistroReleaseBinaryPackage.providedBy(pmount_binary)
   True

   >>> from canonical.launchpad.database.sourcepackagerelease import (
   ...                                           SourcePackageRelease)
   >>> pmount_rel = SourcePackageRelease.selectOneBy(
   ...     sourcepackagenameID=pmount_src_name.id, version='0.1-1')
   >>> pmount_rel.sourcepackagename.name
   u'pmount'

   >>> pmount_srcrel = hoary.getSourcePackageRelease(pmount_rel)
   >>> IDistroReleaseSourcePackageRelease.providedBy(pmount_srcrel)
   True

Check some properties of DRSPR meta class

Entire publishing history:

   >>> pmount_srcrel.publishing_history.count()
   1

Most recent published history row:

   >>> pmount_srcrel.current_published is None
   True

   >>> netapplet_srcrel =  hoary.getSourcePackage('netapplet').currentrelease
   >>> spph = netapplet_srcrel.current_published
   >>> verifyObject(ISourcePackagePublishingHistory, spph)
   True

   >>> spph.section.name
   u'web'

The changesfile attribute contains the package changelog. It is provided as
an ILibraryFileAlias:

   >>> firefox_srcrel =  warty.getSourcePackage(
   ...    'mozilla-firefox').currentrelease
   >>> firefox_srcrel.title
   u'mozilla-firefox 0.9 (source) in ubuntu warty'

   >>> firefox_srcrel.changesfile
   <LibraryFileAlias at ...>

If the package changelog is not available, that attribute is None:

   >>> netapplet_srcrel.changesfile is None
   True

Perform `post publication` override:

   >>> new_section = getUtility(ISectionSet)['base']

   >>> netapplet_srcrel.changeOverride(new_section=new_section)
   >>> pub_hist = netapplet_srcrel.publishing_history
   >>> pub_hist.count()
   2

Override information about 'pmount' is pending publication:

   >>> pub_hist[0].status.name, pub_hist[0].section.name
   ('PENDING', u'base')

Supersede current publication:

   >>> superseded_netapplet = netapplet_srcrel.supersede()
   >>> netapplet_srcrel.publishing_history.count()
   2

We need to flush cached values.

   >>> from canonical.database.sqlbase import flush_database_updates
   >>> flush_database_updates()

   >>> superseded_netapplet.status.name, superseded_netapplet.datesuperseded
   ('SUPERSEDED', CURRENT_TIMESTAMP AT TIME ZONE 'UTC')


DistroRelease Translations migration
------------------------------------

We have several ways to copy translations between distro releases.

The main one is to clone what we have in its parent distribution:

   >>> humpy.copyMissingTranslationsFromParent()

Note that only current PO templates are copied from the distribution parent:

   >>> len(hoary.potemplates) > len(hoary.currentpotemplates)
   True
   >>> len(humpy.potemplates) == len(humpy.currentpotemplates)
   True
   >>> len(humpy.potemplates) == len(hoary.currentpotemplates)
   True

Define a couple of functions we will need to compare the files from the parent
and child distro release.

   >>> def get_diff(old_file, new_file):
   ...     from canonical.launchpad.helpers import test_diff
   ...     old_file_lines = old_file.split('\n')
   ...     new_file_lines = new_file.split('\n')
   ...     # Remove X-Rosetta-Export-Date line to prevent time bombs in
   ...     # tests.
   ...     are_different = False
   ...     for i in range(len(old_file_lines)):
   ...         if (old_file_lines[i].startswith('"X-Rosetta-Export-Date:') and
   ...             new_file_lines[i].startswith('"X-Rosetta-Export-Date:')):
   ...             # The date is autogenerated so it depends when we do
   ...             # the export. We do this check here to prevent any
   ...             # time bomb.
   ...             continue
   ...         elif old_file_lines[i] != new_file_lines[i]:
   ...             # The output is different.
   ...             are_different = True
   ...
   ...         if are_different:
   ...             return u"Output doesn't match:\n\n %s\n" % test_diff(
   ...                 old_file_lines, new_file_lines)
   ...     return u''

   >>> def compare_translations(orig_distrorelease, dest_distrorelease):
   ...
   ...
   ...     orig_templates = sorted(
   ...         orig_distrorelease.currentpotemplates,
   ...         key=lambda x: (x.potemplatename.name, x.sourcepackagename.name))
   ...     dest_templates = sorted(
   ...         dest_distrorelease.potemplates,
   ...         key=lambda x: (x.potemplatename.name, x.sourcepackagename.name))
   ...
   ...     output_text = u''
   ...     for i in range(len(orig_templates)):
   ...         old_template = orig_templates[i]
   ...         new_template = dest_templates[i]
   ...         if old_template.priority != new_template.priority:
   ...             output_text += u'Priority of %s is different from %s\n' % (
   ...                 old_template.title, new_template.title)
   ...         output = get_diff(old_template.export(), new_template.export())
   ...         if output != u'':
   ...            output_text += output
   ...         for old_pofile in old_template.pofiles:
   ...             new_pofile = new_template.getPOFileByLang(
   ...                 old_pofile.language.code, old_pofile.variant)
   ...             old_pofile_data = old_pofile.uncachedExport(
   ...                 included_obsolete=False,force_utf8=True)
   ...             new_pofile_data = new_pofile.uncachedExport(
   ...                 included_obsolete=False, force_utf8=True)
   ...             output = get_diff(old_pofile_data, new_pofile_data)
   ...             if output is not None:
   ...                 output_text += output
   ...     return output_text

Let's compare what we have in our parent distro release and the new one just
created. We should get no differences at all.

   >>> print compare_translations(hoary, humpy)
   <BLANKLINE>

Now, we are going to test how to migrate updates from Hoary to Humpy. To do
this test, we will add some new translations to Hoary, migrate them to Humpy
and check that the changes are migrated when needed.

Get the needed objects to prepare this test.

    >>> import datetime
    >>> import pytz
    >>> from canonical.launchpad.interfaces import (
    ...     ISourcePackageNameSet, IPOTemplateSet, IPersonSet)
    >>> evolution = getUtility(ISourcePackageNameSet)['evolution']
    >>> potemplateset = getUtility(IPOTemplateSet)
    >>> potemplatesubset_hoary = potemplateset.getSubset(distrorelease=hoary,
    ...     sourcepackagename=evolution)
    >>> potemplate_hoary = potemplatesubset_hoary.getPOTemplateByName('evolution-2.2')
    >>> pofile_es_hoary = potemplate_hoary.getPOFileByLang('es')
    >>> potemplatesubset_humpy = potemplateset.getSubset(distrorelease=humpy,
    ...     sourcepackagename=evolution)
    >>> potemplate_humpy = potemplatesubset_humpy.getPOTemplateByName('evolution-2.2')
    >>> pofile_es_humpy = potemplate_humpy.getPOFileByLang('es')
    >>> UTC = pytz.timezone('UTC')

The one submitting the string will be Carlos. He's an editor for this POFile.

    >>> carlos = getUtility(IPersonSet).getByName('carlos')

Update a string in the parent release.

    >>> pomsgset_hoary = pofile_es_hoary.getPOMsgSet(u'evolution addressbook')
    >>> pomsgset_hoary.updateTranslationSet(
    ...     carlos, { 0: u'hoary updated string' }, fuzzy=False,
    ...     published=False, lock_timestamp=datetime.datetime.now(UTC))

And another update in a string that is untranslated.

    >>> pomsgset_hoary = pofile_es_hoary.getPOMsgSet(u'has ')
    >>> pomsgset_hoary.updateTranslationSet(
    ...     carlos, { 0: u'empty string translated' }, fuzzy=False,
    ...     published=False, lock_timestamp=datetime.datetime.now(UTC))

Update a string in the children release.

    >>> pomsgset_humpy = pofile_es_humpy.getPOMsgSet(u'current addressbook folder')
    >>> pomsgset_humpy.updateTranslationSet(
    ...     carlos, { 0: u'humpy updated string' }, fuzzy=False,
    ...     published=False, lock_timestamp=datetime.datetime.now(UTC))

Let's update the statistics.

    >>> pofile_es_hoary.updateStatistics()
    (7, 2, 1)
    >>> pofile_es_humpy.updateStatistics()
    (7, 2, 0)

We can also see that the statistics show differences between each distribution
release for the rosetta count of translations:

    >>> pofile_es_hoary.currentCount() == pofile_es_humpy.currentCount()
    True
    >>> pofile_es_hoary.updatesCount() == pofile_es_humpy.updatesCount()
    True
    >>> pofile_es_hoary.rosettaCount() == pofile_es_humpy.rosettaCount()
    False

We can see now that the changes are detected.

    # Disabled because it fails intermittendly and prevents PQM landing.
    # See bug #78907.
    > > > print compare_translations(hoary, humpy)
    Output doesn't match:
    <BLANKLINE>
    --- expected
    +++ actual
    <BLANKLINE>
    @@ -31,11 +31,11 @@
    <BLANKLINE>
     #: a11y/addressbook/ea-addressbook-view.c:103
     #: a11y/addressbook/ea-minicard-view.c:119
     msgid "evolution addressbook"
    -msgstr "hoary updated string"
    +msgstr "libreta de direcciones de Evolution"
    <BLANKLINE>
     #: a11y/addressbook/ea-minicard-view.c:101
     msgid "current addressbook folder"
    -msgstr "carpeta de libretas de direcciones actual"
    +msgstr "humpy updated string"
    <BLANKLINE>
     #: a11y/addressbook/ea-minicard-view.c:102
     #, fuzzy
    @@ -44,7 +44,7 @@
    <BLANKLINE>
    <BLANKLINE>
     #: a11y/addressbook/ea-minicard-view.c:102
     msgid "has "
    -msgstr "empty string translated "
    +msgstr ""
    <BLANKLINE>
     #: a11y/addressbook/ea-minicard-view.c:104
     msgid " cards"

Let's migrate the updates.

    >>> humpy.copyMissingTranslationsFromParent()

Now, we should have only the update from Humpy as a difference

    >>> print compare_translations(hoary, humpy)
    Output doesn't match:
    <BLANKLINE>
    --- expected
    +++ actual
    <BLANKLINE>
    @@ -35,7 +35,7 @@
    <BLANKLINE>
     #: a11y/addressbook/ea-minicard-view.c:101
     msgid "current addressbook folder"
    -msgstr "carpeta de libretas de direcciones actual"
    +msgstr "humpy updated string"
    <BLANKLINE>
     #: a11y/addressbook/ea-minicard-view.c:102
     #, fuzzy

What would happen now, if the same string that is changed in Humpy is also
changed in Hoary?

    >>> pomsgset_hoary = pofile_es_hoary.getPOMsgSet(u'current addressbook folder')
    >>> pomsgset_hoary.updateTranslationSet(
    ...     carlos, { 0: u'second hoary updated string' }, fuzzy=False,
    ...     published=False, lock_timestamp=datetime.datetime.now(UTC))

We copy missing translations...

    >>> humpy.copyMissingTranslationsFromParent()

And we can see that the change is not migrated to Humpy because we already got
a change directly there that we should not overwrite.

    >>> print compare_translations(hoary, humpy)
    Output doesn't match:
    <BLANKLINE>
    --- expected
    +++ actual
    <BLANKLINE>
    @@ -35,7 +35,7 @@
    <BLANKLINE>
     #: a11y/addressbook/ea-minicard-view.c:101
     msgid "current addressbook folder"
    -msgstr "second hoary updated string"
    +msgstr "humpy updated string"
    <BLANKLINE>
     #: a11y/addressbook/ea-minicard-view.c:102
     #, fuzzy

We can also see that the statistics are updated and both distributions have
the same values:

    >>> pofile_es_hoary.currentCount() == pofile_es_humpy.currentCount()
    True
    >>> pofile_es_hoary.updatesCount() == pofile_es_humpy.updatesCount()
    True
    >>> pofile_es_hoary.rosettaCount() == pofile_es_humpy.rosettaCount()
    True


SourcePackagePublishingHistory
------------------------------

IDistroRelease.getSourcePackagePublishing returns all the ISPPH
records for a given status in a given pocket. It makes easy to
generate a list of currently published sources for override-check, for
instance. it can also be used to generate the archive packages list in
the future.


   >>> ubuntu = getUtility(IDistributionSet)['ubuntu']
   >>> hoary = ubuntu['hoary']

   >>> from canonical.lp.dbschema import (
   ...    PackagePublishingPocket, PackagePublishingStatus)

   >>> hoary_pub_sources = hoary.getSourcePackagePublishing(
   ...     PackagePublishingStatus.PUBLISHED,
   ...     PackagePublishingPocket.RELEASE)

   >>> hoary_pub_sources.count()
   6

   >>> hoary_pub_source = hoary_pub_sources[0]

   >>> from canonical.launchpad.interfaces import (
   ...     ISourcePackagePublishingHistory)
   >>> verifyObject(ISourcePackagePublishingHistory, hoary_pub_source)
   True

   >>> hoary_pub_source.sourcepackagerelease.name
   u'alsa-utils'

   >>> hoary_pub_source.sourcepackagerelease.version
   u'1.0.9a-4ubuntu1'

   >>> hoary_pub_source.component.name
   u'main'

   >>> hoary_pub_source.section.name
   u'base'

   >>> hoary.getSourcePackagePublishing(
   ...     PackagePublishingStatus.PUBLISHED,
   ...     PackagePublishingPocket.UPDATES).count()
   0

This method also allow us to restrict the results to a given
component:

   >>> component_main = getUtility(IComponentSet)['main']
   >>> hoary.getSourcePackagePublishing(
   ...     PackagePublishingStatus.PUBLISHED,
   ...     PackagePublishingPocket.RELEASE,
   ...     component=component_main).count()
   5

   >>> component_multiverse = getUtility(IComponentSet)['multiverse']
   >>> hoary.getSourcePackagePublishing(
   ...     PackagePublishingStatus.PUBLISHED,
   ...     PackagePublishingPocket.RELEASE,
   ...     component=component_multiverse).count()
   0

ISPP.publishedBinaries return all the binaries generated by the
publication in question:

   >>> warty = ubuntu['warty']
   >>> warty_pub_sources = warty.getSourcePackagePublishing(
   ...     PackagePublishingStatus.PUBLISHED,
   ...     PackagePublishingPocket.RELEASE)

   >>> warty_pub_source = warty_pub_sources[3]
   >>> warty_pub_source.sourcepackagerelease.name
   u'mozilla-firefox'
   >>> warty_pub_source.sourcepackagerelease.version
   u'0.9'
   >>> warty_pub_source.component.name
   u'main'
   >>> warty_pub_source.section.name
   u'web'

   >>> warty_mozilla_pub_binaries = warty_pub_source.publishedBinaries()
   >>> warty_mozilla_pub_binaries.count()
   1
   >>> warty_mozilla_pub_bin = warty_mozilla_pub_binaries[0]

   >>> from canonical.launchpad.interfaces import (
   ...    IBinaryPackagePublishingHistory)
   >>> verifyObject(IBinaryPackagePublishingHistory, warty_mozilla_pub_bin)
   True

   >>> warty_mozilla_pub_bin.binarypackagerelease.name
   u'mozilla-firefox'
   >>> warty_mozilla_pub_bin.binarypackagerelease.version
   u'0.9'
   >>> warty_mozilla_pub_bin.component.name
   u'main'
   >>> warty_mozilla_pub_bin.section.name
   u'base'

DistroRelease.getBinaryPackagePublishing will return
BinaryPackagePublishingHistory objects for the DistroRelease:

    >>> warty = ubuntu['warty']
    >>> bpphs = warty.getBinaryPackagePublishing()
    >>> bpphs.count()
    6
    >>> 'mozilla-firefox' in set(
    ...     pkgpub.binarypackagerelease.binarypackagename.name
    ...     for pkgpub in bpphs)
    True

It also allows us to pass wanted strings like: name, version, archtag and
sourcename.

    >>> warty.getBinaryPackagePublishing(
    ...     name="nosuchpackage").count()
    0
    >>> warty.getBinaryPackagePublishing(
    ...     version="nosuchversion").count()
    0
    >>> warty.getBinaryPackagePublishing(
    ...     archtag="nosucharch").count()
    0
    >>> warty.getBinaryPackagePublishing(
    ...     sourcename="nosuchsource").count()
    0

We can restrict the results by component:

    >>> warty.getBinaryPackagePublishing(
    ...     component=component_main).count()
    6
    >>> warty.getBinaryPackagePublishing(
    ...     component=component_multiverse).count()
    0

By pocket:

    >>> warty.getBinaryPackagePublishing(
    ...     pocket=PackagePublishingPocket.RELEASE).count()
    6
    >>> warty.getBinaryPackagePublishing(
    ...     pocket=PackagePublishingPocket.BACKPORTS).count()
    0

Or any combination of them:

    >>> warty.getBinaryPackagePublishing(
    ...     sourcename="alsa", pocket=PackagePublishingPocket.RELEASE,
    ...     component=component_main).count()
    0

    >>> warty.getBinaryPackagePublishing(
    ...     name="mozilla-firefox", archtag='i386',
    ...     component=component_main).count()
    1


Specification Listings
======================

We should be able to get lists of specifications in different states
related to a distrorelease.

Basically, we can filter by completeness, and by whether or not the spec is
informational.

 >>> distroset = getUtility(IDistributionSet)
 >>> kubuntu = distroset.getByName("kubuntu")
 >>> krunch = kubuntu.getRelease("krunch")
 >>> from canonical.lp.dbschema import SpecificationFilter

First, there should be one informational specs for krunch:

 >>> filter = [SpecificationFilter.INFORMATIONAL]
 >>> krunch.specifications(filter=filter).count()
 1


There are 2 completed specs for Krunch:

 >>> filter = [SpecificationFilter.COMPLETE]
 >>> for spec in kubuntu.specifications(filter=filter):
 ...    print spec.name, spec.is_complete
 thinclient-local-devices True
 usplash-on-hibernation True


And there are 2 incomplete specs:

 >>> filter = [SpecificationFilter.INCOMPLETE]
 >>> for spec in krunch.specifications(filter=filter):
 ...     print spec.name, spec.is_complete
 cluster-installation False
 revu False


If we ask for all specs, we get them in the order of priority.

 >>> filter = [SpecificationFilter.ALL]
 >>> for spec in krunch.specifications(filter=filter):
 ...    print spec.priority.title, spec.name
 Essential cluster-installation
 High revu
 Medium thinclient-local-devices
 Low usplash-on-hibernation
 Undefined kde-desktopfile-langpacks
 Not krunch-desktop-plan


With a distrorelease, we can ask for ACCEPTED, PROPOSED and DECLINED specs:

 >>> filter=[SpecificationFilter.ACCEPTED]
 >>> for spec in krunch.specifications(filter=filter):
 ...     print spec.name, spec.goalstatus.title
 cluster-installation Accepted
 revu Accepted
 thinclient-local-devices Accepted
 usplash-on-hibernation Accepted

 >>> filter=[SpecificationFilter.PROPOSED]
 >>> for spec in krunch.specifications(filter=filter):
 ...     print spec.name, spec.goalstatus.title
 kde-desktopfile-langpacks Proposed

 >>> filter=[SpecificationFilter.DECLINED]
 >>> for spec in krunch.specifications(filter=filter):
 ...     print spec.name, spec.goalstatus.title
 krunch-desktop-plan Declined


And if we ask just for specs, we get BOTH the incomplete and the complete
ones that have been accepted.

 >>> for spec in krunch.specifications():
 ...     print spec.name, spec.is_complete, spec.goalstatus.title
 cluster-installation False Accepted
 revu False Accepted
 thinclient-local-devices True Accepted
 usplash-on-hibernation True Accepted

We can filter for specifications that contain specific text:

 >>> for spec in krunch.specifications(filter=['usb']):
 ...     print spec.name
 thinclient-local-devices


Drivers
=======

Distributions have drivers, who are people that have permission to approve
bugs and features for specific releases. The rules are that:

 1. a "driver" can be set on either Distribution or DistroRelease
 2. drivers are only actually relevant on a DistroRelease, because thats the
    granularity at which we track spec/bug targeting
 3. the important attribute is ".drivers" on a distrorelease, it is
    calculated based on the combination of owners and drivers in the
    distribution and the distrorelease. It is a LIST of drivers, which might
    be empty, or have one or two people/teams in it.
 4. If the release has a driver, then that driver is in the list.
 5. If the distribution has a driver then that is in the list too, otherwise
 6. If neither the release nor the distribution has a driver, then the
    distribution registrant is the driver.

We test these rules below.


First, we look at a release where both the distribution and release have
drivers. Kubuntu should be a good example.

 >>> kubuntu.driver.name
 u'jblack'
 >>> krunch.driver.name
 u'edgar'
 >>> for d in krunch.drivers:
 ...     print d.name
 edgar
 jblack


Now, we look at a release where there is a driver on the release but not on
the distribution.

 >>> debian = distroset.getByName('debian')
 >>> print debian.driver
 None
 >>> print debian.owner.name
 sabdfl
 >>> sarge = debian.getRelease('sarge')
 >>> print sarge.driver.name
 jdub
 >>> for d in sarge.drivers:
 ...     print d.name
 jdub
 sabdfl


Now, a release where there is no driver on the release but there is a driver
on the distribution.

 >>> redhat = distroset.getByName('redhat')
 >>> print redhat.driver.name
 jblack
 >>> six = redhat.getRelease('six')
 >>> print six.driver
 None
 >>> for d in six.drivers:
 ...     print d.name
 jblack


Finally, on a release where neither the distribution nor the release have a
driver. Here, we expect the driver to be the owner of the distribution
(because this is the "commonest fallback").

 >>> sid = debian.getRelease('sid')
 >>> print debian.driver
 None
 >>> print debian.owner.name
 sabdfl
 >>> print sid.driver
 None
 >>> print sid.owner.name
 jdub

 >>> for d in sid.drivers:
 ...     print d.name
 sabdfl

== Last Uploads ==

IDistroRelease provides the 'getLastUpload' method which returns a
list of last 5 (five) IDistroReleaseSourcePackageRelease (IDRSPR)
uploaded and published in its context.

  >>> warty = ubuntu['warty']
  >>> last_uploads = warty.getLastUploads()

Each element is a IDistroReleaseSourcePackageRelease instance:

  >>> for upload in last_uploads:
  ...     print upload.name, upload.version
  mozilla-firefox 0.9

Also, empty results (caused obviously by lack of sample data or very
earlier development state of a distrorelease) are possible:

  >>> breezy_autotest = ubuntu['breezy-autotest']
  >>> last_uploads = breezy_autotest.getLastUploads()

  >>> len(last_uploads) == 0
  True
