= Person and the Answer Tracker =

== searchQuestions() ==

IPerson defines a searchQuestions() method which can be used to
select all or a subset of the questions in which the person is
involved. This includes questions which the person created, is assigned
to, is subscribed to, commented on, or answered. Various subsets can
be selected by using the following criteria status, search_text and
participation type.

    >>> from canonical.launchpad.interfaces import IPersonSet
    >>> personset = getUtility(IPersonSet)
    >>> foo_bar = personset.getByEmail('foo.bar@canonical.com')

=== search_text ===

The search_text parameter will limit the questions to those matching
the query using the regular full text algorithm.

    >>> for question in foo_bar.searchQuestions(search_text='firefox'):
    ...     print question.title, question.status.title
    Firefox loses focus and gets stuck              Open
    mailto: problem in webpage                      Solved
    Newly installed plug-in doesn't seem to be used Answered

=== sort ===

When using the search_text criteria, the default is to sort the results
by relevancy. One can use the sort parameter to change that. It takes
one of the constant defined in the QuestionSort enumeration.

    >>> from canonical.lp.dbschema import QuestionSort
    >>> for question in foo_bar.searchQuestions(
    ...         search_text='firefox', sort=QuestionSort.OLDEST_FIRST):
    ...     print question.id, question.title, question.status.title
    4 Firefox loses focus and gets stuck              Open
    6 Newly installed plug-in doesn't seem to be used Answered
    9 mailto: problem in webpage                      Solved

When no text search is done, the default sort order is
QuestionSort.NEWEST_FIRST.

    >>> for question in foo_bar.searchQuestions():
    ...     print question.id, question.title, question.status.title
    11 Continue playing after shutdown                      Open
    10 Play DVDs in Totem                                   Answered
     9 mailto: problem in webpage                           Solved
     8 Installation of Java Runtime Environment for Mozilla Answered
     7 Slow system                                          Needs information
     6 Newly installed plug-in doesn't seem to be used      Answered
     4 Firefox loses focus and gets stuck                   Open

=== status ===

The last searches showed that by default, not all statuses are searched
for by default (they excluded expired and invalid questions). The status
parameter can be used to control the list of statuses to select:

    >>> from canonical.lp.dbschema import QuestionStatus
    >>> for question in foo_bar.searchQuestions(status=QuestionStatus.INVALID):
    ...     print question.title, question.status.title
    Firefox is slow and consumes too much RAM   Invalid

The status parameter can also take a list of statuses.

    >>> for question in foo_bar.searchQuestions(
    ...         status=[QuestionStatus.SOLVED, QuestionStatus.INVALID]):
    ...     print question.title, question.status.title
    mailto: problem in webpage                  Solved
    Firefox is slow and consumes too much RAM   Invalid

=== participation ===

By default, any types of relationship to a question is considered by
searchQuestions. This can customized through the participation
parameter. It takes one or a list of constants from the
QuestionParticipation enumeration.

To select only questions on which the person commented, the
QuestionParticipation.COMMENTER is used:

    >>> from canonical.lp.dbschema import QuestionParticipation
    >>> for question in foo_bar.searchQuestions(
    ...         participation=QuestionParticipation.COMMENTER, status=None):
    ...     print question.title
    Continue playing after shutdown
    Play DVDs in Totem
    mailto: problem in webpage
    Installation of Java Runtime Environment for Mozilla
    Newly installed plug-in doesn't seem to be used

QuestionParticipation.SUBSCRIBER will only select the questions to which
the person is subscribed to:

    >>> for question in foo_bar.searchQuestions(
    ...         participation=QuestionParticipation.SUBSCRIBER, status=None):
    ...     print question.title
    Slow system
    Firefox is slow and consumes too much RAM

QuestionParticipation.OWNER selects the questions that the person created:

    >>> for question in foo_bar.searchQuestions(
    ...         participation=QuestionParticipation.OWNER, status=None):
    ...     print question.title
    Slow system
    Firefox loses focus and gets stuck
    Firefox is slow and consumes too much RAM

QuestionParticipation.ANSWERER selects the questions for which the person
was marked as the answerer:

    >>> for question in foo_bar.searchQuestions(
    ...         participation=QuestionParticipation.ANSWERER, status=None):
    ...     print question.title
    mailto: problem in webpage
    Firefox is slow and consumes too much RAM

QuestionParticipation.ASSIGNEE selects that questions which are assigned to
the person:

    >>> for question in foo_bar.searchQuestions(
    ...         participation=QuestionParticipation.ASSIGNEE, status=None):
    ...     print question.title

If a list of these constants is used, all of these participation types
will be selected:

    >>> for question in foo_bar.searchQuestions(
    ...         participation=[
    ...             QuestionParticipation.OWNER,
    ...             QuestionParticipation.ANSWERER],
    ...         status=None):
    ...     print question.title
    mailto: problem in webpage
    Slow system
    Firefox loses focus and gets stuck
    Firefox is slow and consumes too much RAM

=== language ===

By default, questions in all languages are included in the results. It is
possible to filter questions by the language they were writtenin . One or
a list of ILanguage object should be passed in the language parameter to
specify the language filter.

    >>> from canonical.launchpad.interfaces import ILanguageSet
    >>> spanish = getUtility(ILanguageSet)['es']
    >>> english = getUtility(ILanguageSet)['en']

Foo bar doesn't have any questions written in Spanish.

    >>> for question in foo_bar.searchQuestions(language=spanish):
    ...     print question.title

But carlos has one.

    >>> carlos = getUtility(IPersonSet).getByName('carlos')
    >>> for question in carlos.searchQuestions(
    ...     language=[english, spanish]):
    ...     [question.title, question.language.code]
    [u'Problema al recompilar kernel con soporte smp (doble-n\xfacleo)',
     u'es']

=== needs_attention ===

The method accept a parameter called needs_attention which only selects
the questions that needs attention from the person. This includes questions
owned by the person in the ANSWERED or NEEDSINFO state. It also includes
questions on which the person requested for more information or gave an
answer and that are back in the OPEN state.

    >>> for question in foo_bar.searchQuestions(needs_attention=True):
    ...     print question.status.title, question.owner.displayname, (
    ...         question.title)
    Open              Sample Person Continue playing after shutdown
    Needs information Foo Bar       Slow system

=== Combination ===

The returned sets of questions is the intersection of the sets delimited
by each criteria:

    >>> for question in foo_bar.searchQuestions(
    ...         search_text='firefox OR Java', status=QuestionStatus.ANSWERED,
    ...         participation=QuestionParticipation.COMMENTER):
    ...     print question.title, question.status.title
    Installation of Java Runtime Environment for Mozilla    Answered
    Newly installed plug-in doesn't seem to be used         Answered

== getSupportedLanguages() ==

IPerson also provides a getSupportedLanguages method which can be used
to retrieve the list of languages in which the person or team can
answer questions.

    # Helper to see easily the languages in a list.
    >>> def language_codes(languages):
    ...     return sorted(str(language.code) for language in languages)

For a person, it is the same list than its list of known languages:

    >>> sample_person = getUtility(IPersonSet).getByEmail('test@canonical.com')
    >>> language_codes(sample_person.languages)
    []
    >>> language_codes(sample_person.getSupportedLanguages())
    []

    >>> carlos = getUtility(IPersonSet).getByName('carlos')
    >>> language_codes(carlos.languages)
    ['ca', 'es']
    >>> language_codes(carlos.getSupportedLanguages())
    ['ca', 'es']

Also, note that all English variants will be excluded.

    >>> daf = getUtility(IPersonSet).getByName('daf')
    >>> language_codes(daf.languages)
    ['cy', 'en_GB', 'ja']
    >>> language_codes(daf.getSupportedLanguages())
    ['cy', 'ja']

For team with a list of known languages set, the same rule applies:

    >>> from canonical.launchpad.interfaces import ILanguageSet
    >>> ubuntu_team = getUtility(IPersonSet).getByName('ubuntu-team')
    >>> esperanto = getUtility(ILanguageSet)['eo']
    >>> ubuntu_team.addLanguage(esperanto)

    >>> language_codes(ubuntu_team.languages)
    ['eo']
    >>> language_codes(ubuntu_team.getSupportedLanguages())
    ['eo']

When the list of known languages is not set, and the team's
preferred email address is set, the list of supported languages
is empty; the languages spoken by the team members are not 
included in the team's languages.

    >>> rosetta_admins = getUtility(IPersonSet).getByName(
    ...     'rosetta-admins')

    >>> carlos.inTeam(rosetta_admins)
    True
    >>> daf.inTeam(rosetta_admins)
    True

    >>> language_codes(rosetta_admins.languages)
    []
    >>> language_codes(rosetta_admins.getSupportedLanguages())
    []

But when both the list of known languages is not set, and the
team's preferred email address is not set, the list of supported
languages will be the union of all the members supported languages.
These rules are applied recursively when teams are nested one inside
the other. For example, the 'Guadamen' team includes the Ubuntu Team
and doesn't have its list of known languages set, so it will be the
languages of the Ubuntu Team that will be used.

    >>> guadamen_team = getUtility(IPersonSet).getByName('guadamen')
    >>> ubuntu_team.inTeam(guadamen_team)
    True

    >>> language_codes(guadamen_team.languages)
    []
    >>> language_codes(guadamen_team.getSupportedLanguages())
    ['eo']


== getQuestionLanguages() ==

IPerson also defines a getQuestionLanguages() attribute which contains
the set of languages used by all of the questions in which this person
is involved.

    >>> sorted(language.code for language in foo_bar.getQuestionLanguages())
    [u'en']

This includes questions which the person owns. But also, questions that
the user subscribed to.

    >>> from canonical.launchpad.interfaces import IQuestionSet
    >>> pt_BR_question = getUtility(IQuestionSet).get(13)
    >>> login('foo.bar@canonical.com')
    >>> pt_BR_question.subscribe(foo_bar)
    <QuestionSubscription...>

    >>> sorted(language.code for language in foo_bar.getQuestionLanguages())
    [u'en', u'pt_BR']

And also questions for which he's the answerer.

    >>> es_question = getUtility(IQuestionSet).get(12)
    >>> es_question.reject(foo_bar, 'Reject question.')
    <QuestionMessage...>

    >>> sorted(language.code for language in foo_bar.getQuestionLanguages())
    [u'en', u'es', u'pt_BR']

As well, as question which are assigned to the user.

    >>> pt_BR_question.assignee = carlos
    >>> from canonical.database.sqlbase import flush_database_updates
    >>> flush_database_updates()

    >>> sorted(language.code for language in carlos.getQuestionLanguages())
    [u'es', u'pt_BR']

And questions on which the user commented:

    >>> en_question = getUtility(IQuestionSet).get(1)
    >>> login('carlos@canonical.com')
    >>> en_question.addComment(carlos, 'A simple comment.')
    <QuestionMessage...>

    >>> sorted(language.code for language in carlos.getQuestionLanguages())
    [u'en', u'es', u'pt_BR']

== getDirectAnswerQuestionTargets() ==

IPerson defines getDirectAnswerQuestionTargets that can be used to retrieve
a list of IQuestionTargets that a person subscribed himself to as an
answer contact.

    >>> no_priv = getUtility(IPersonSet).getByName('no-priv')
    >>> no_priv.getDirectAnswerQuestionTargets()
    []
    
    >>> from canonical.launchpad.interfaces import IProductSet
    >>> firefox = getUtility(IProductSet).getByName("firefox")
    >>> firefox.addAnswerContact(no_priv)
    True
    
    >>> for target in no_priv.getDirectAnswerQuestionTargets():
    ...    print target.name
    firefox

== getTeamAnswerQuestionTargets() ==
    
IPerson defines getTeamAnswerQuestionTargets that retreives a list of
IQuestionTargets that the person is subscribed to indirectly as an
answer contact through his team membership.

    >>> landscape_team = getUtility(IPersonSet).getByName(
    ...    "landscape-developers")
    >>> landscape_team.addMember(no_priv, foo_bar)
    >>> no_priv.inTeam(landscape_team)
    True
    
    >>> from canonical.launchpad.interfaces import IDistributionSet
    >>> ubuntu = getUtility(IDistributionSet).getByName("ubuntu")
    >>> ubuntu.addAnswerContact(landscape_team)
    True
    
    >>> sorted([target.name
    ...         for target in no_priv.getTeamAnswerQuestionTargets()])
    [u'ubuntu']
    
Indirect team membership is also taken in consideration. For example, 
the Landscape Team joins the Translator Team. So targets for which the
Translator team is an answer contact will be included in No Privileges 
Person's supported IQuestionTargets:

    >>> translator_team = getUtility(IPersonSet).getByName('ubuntu-translators')
    >>> no_priv.inTeam(translator_team)
    False
    >>> translator_team.addMember(landscape_team, carlos)

    # We need to accept the invitation sent by the addMember() call in
    # order to make landscape_team an actual member of translator_team.
    >>> login(landscape_team.teamowner.preferredemail.email)
    >>> landscape_team.acceptInvitationToBeMemberOf(
    ...     translator_team, comment='something')

    >>> no_priv.hasParticipationEntryFor(translator_team)
    True
    >>> evolution_package = ubuntu.getSourcePackage('evolution')
    >>> evolution_package.addAnswerContact(translator_team)
    True
    >>> sorted([target.name
    ...         for target in no_priv.getTeamAnswerQuestionTargets()])
    [u'evolution', u'ubuntu']

    
