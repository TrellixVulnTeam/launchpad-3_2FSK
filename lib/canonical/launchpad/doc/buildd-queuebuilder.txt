QueueBuilder Tests
==================

QueueBuilder is a script to sanely initialise new build jobs, it
verifies the available DistroArchReleases, for which we are able to
build packages, repairs broken Builds entries that makes sense,
verifies the packages pending to build, install the jobs in
BuildQueue table and scores the build acording a bunch of
parameters. 

  >>> from canonical.launchpad.scripts.builddmaster import BuilddMaster

import the bunch of required database classes:

  >>> from canonical.launchpad.database import (
  ...      SourcePackageRelease, SourcePackageName, DistroRelease,
  ...      SourcePackagePublishing, SecureSourcePackagePublishingHistory,
  ...      PocketChroot, DistroArchRelease, Build, BuildQueue,
  ...      SourcePackageReleaseFile)

  >>> from canonical.lp.dbschema import (
  ...      PackagePublishingPocket, PackagePublishingStatus,
  ...      SourcePackageFileType)

  >>> from canonical.database.constants import UTC_NOW


The Master side of Buildd requires access to Launchpad Database, the
user designed for this kind of access is 'fiera', as in all test the
transaction should be retrieved.
 
  >>> import transaction

The master also requires an 'logging' instance to not compromise the
standard output with noisely output.

  >>> import logging

Now we have satisfied all needs for BuildMaster, let's instantiate it.

  >>> bm = BuilddMaster(logging.getLogger(), transaction)

Emulates a PocketChroot entry to validate the distroarchrelese 
Ubuntu/Warty/i386/RELEASE:

  >>> dr = DistroRelease.selectOneBy(name='warty')
  >>> dar = DistroArchRelease.selectOneBy(distroreleaseID=dr.id,
  ...                                     architecturetag='i386')

Pick up any existent librarian file as chroot.

  >>> pocket = PocketChroot(distroarchreleaseID=dar.id, 
  ...                       chroot=1) 

Produce a set of available DistroArchRelease, for which the 
build jobs will be created. 

  >>> distroreleases = set()
  >>> for dar in DistroArchRelease.select():
  ...     distroreleases.add(dar.distrorelease)
  ...     bm.addDistroArchRelease(dar)
  ...
  WARNING:root:Disabling: No CHROOT found for pocket 'Release'

Only Ubuntu/Warty/i386 has an available CHROOT, it's the only one supported. 

  >>> [arch.architecturetag for arch in bm._archreleases]
  [u'i386']

Adding a new dummy sourcepackagerelease and publish it in Ubuntu/Warty/i386:

  >>> name = SourcePackageName(name="test-buildd")

Note that the magic number "1" is used to pick up an arbitrary required
entity from the existent sampledata, we don't care about
them. (creator=1 is sabdfl, manifest=1 is the first dummy manifest
added by the current sample data and so on)
   
  >>> srcpkgrel = SourcePackageRelease(creator=1, version='666', 
  ...                                  section=1, maintainer=1, component=1, 
  ...                                  uploaddistrorelease=1,
  ...                                  sourcepackagename=name.id,
  ...                                  architecturehintlist="all",
  ...                                  builddependsindep=None,
  ...                                  builddepends=None, dsc=None,
  ...                                  changelog=None, manifest=1,
  ...                                  dscsigningkey=None)

  >>> tar = SourcePackageFileType.TARBALL
  >>> srcfile = SourcePackageReleaseFile(sourcepackagerelease=srcpkgrel.id,
  ...                                    libraryfile=1,
  ...                                    filetype=tar)
  >>> srcfile.libraryfile.filename, srcfile.sourcepackagerelease.name
  (u'netapplet-1.0.0.tar.gz', u'test-buildd')

  >>> published = PackagePublishingStatus.PUBLISHED
  >>> release_pocket = PackagePublishingPocket.RELEASE
  >>> p = SecureSourcePackagePublishingHistory(
  ...                                    sourcepackagerelease=srcpkgrel.id,
  ...                                    distroreleaseID=dr.id, 
  ...                                    status=published,
  ...                                    pocket=release_pocket,
  ...                                    component=srcpkgrel.component, 
  ...                                    section=srcpkgrel.section,
  ...                                    datecreated=UTC_NOW)

Verify how many Build entries we have from sampledata:

  >>> Build.select().count()
  2

Create missing builds (packages w/o build entry) for those distroreleases.
As we just insert a new sourcepackagerelease in run-time we expect to
have a new build for it:

  >>> for dr in distroreleases:
  ...      bm.createMissingBuilds(dr)

Check if we create a new Build entry for just added sourcepackagerelease:

  >>> Build.select().count()
  3

  >>> b = Build.selectOneBy(sourcepackagereleaseID=srcpkgrel.id)
  >>> b.sourcepackagerelease.name
  u'test-buildd'

Now we have Build table properly set and probably with some entries
marked as NEEDSBUILD we can create BuildQueue entries for it 

  >>> bm.addMissingBuildQueueEntries()  
  >>> BuildQueue.select().count()
  2

A separate process is responsible for cleaning up the BuildQueue and
scroring the jobs properly.

The default score value is 0 (zero), attempt for the fact we already
have a build queue entry added by the sampledata, that's why the 2nd 
element of the result.

  >>> job = BuildQueue.select(orderBy='id')[1]
  >>> job.lastscore
  0

After sanitising the jobs, only the ones containing
sourcepackagerelease files should remain:

  >>> new_jobs = bm.sanitiseAndScoreCandidates()
  >>> len(new_jobs)
  1
 
  >>> job = new_jobs[0]
  >>> job.build.sourcepackagerelease.name
  u'test-buildd'

And we grant some score depending on: time pending on the buildqueue,
component the package belongs to, and the urgency of the upload.
There is still some work to do here, for further information see the
launchpad/scripts/builddmaster.py code. The job presented should won
exactly ** 101 ** points last turn (1 for the default urgency 'LOW' and 
100 for the 'Main' component, further tests for scoring are in
buildd-scoring.txt)

  >>> job.lastscore
  101
   


