= Translation context =

GNU gettext 0.15 introduced a 'msgctxt' keyword, which allows defining
a string to be used as 'context disambiguator' when two messages have
identical msgids, but different meanings (are used in different "contexts"),
and they are usually translated differently.

== Helper imports ==

    >>> from zope.app import datetimeutils
    >>> from canonical.launchpad.ftests import syncUpdate
    >>> from canonical.launchpad.interfaces import ITranslationImportQueue
    >>> from canonical.launchpad.interfaces import IPersonSet
    >>> from canonical.launchpad.interfaces import ILaunchpadCelebrities
    >>> from canonical.launchpad.interfaces import IPOTemplateNameSet
    >>> from canonical.launchpad.database import (
    ...     POTemplateSubset, SourcePackageName)
    >>> from canonical.launchpad.scripts.po_import import (
    ...     AutoApproveProcess, ImportProcess)
    >>> import datetime
    >>> import pytz
    >>> UTC = pytz.timezone('UTC')

We need this for the Librarian to work properly.

    >>> import transaction

And also, the DBSchema to change the imports status

    >>> from canonical.lp.dbschema import RosettaImportStatus

Then, let's get a handle to our mailer. This is the thing we'll examine to show
what email has been sent, to whom, and what the body of the message contains:

    >>> import email
    >>> from canonical.launchpad.mail import stub

Here's a fake logger to capture any errors that happen.

    >>> class FakeLogger:
    ...     def message(self, prefix, *stuff, **kw):
    ...         print prefix, ' '.join(stuff)
    ...
    ...         if 'exc_info' in kw:
    ...             import sys
    ...             import traceback
    ...             exception = traceback.format_exception(*sys.exc_info())
    ...             for thing in exception:
    ...                 for line in thing.splitlines():
    ...                     self.log(line)
    ...
    ...     def log(self, *stuff, **kw):
    ...         self.message('log>', *stuff, **kw)
    ...
    ...     def warning(self, *stuff, **kw):
    ...         self.message('WARNING', *stuff, **kw)
    ...
    ...     def info(self, *stuff, **kw):
    ...         self.message('INFO', *stuff, **kw)

This is a function for importing a pofile or potemplate from a string,
printing out the import status after import is done.

    >>> def import_pofile_or_potemplate(file_contents, person, series,
    ...                                 pofile=None, potemplate=None):
    ...     translation_import_queue = getUtility(ITranslationImportQueue)
    ...     if pofile:
    ...         entry = translation_import_queue.addOrUpdateEntry(
    ...             pofile.path, file_contents, True, person,
    ...             productseries=series, pofile=pofile)
    ...     else:
    ...         entry = translation_import_queue.addOrUpdateEntry(
    ...             potemplate.path, file_contents, True, person,
    ...             productseries=series, potemplate=potemplate)
    ...     transaction.commit()
    ...     entry.status = RosettaImportStatus.APPROVED
    ...     syncUpdate(entry)
    ...     if pofile:
    ...         pofile.importFromQueue(FakeLogger())
    ...     else:
    ...         potemplate.importFromQueue(FakeLogger())
    ...     print entry.status.name

== Import ==

Login as an admin to be able to do changes to the import queue.

    >>> login('carlos@canonical.com')

Now, is time to create the new potemplate

    >>> from canonical.launchpad.database import ProductRelease
    >>> release = ProductRelease.get(3)
    >>> release.productseries.product.name
    u'firefox'
    >>> series = release.productseries
    >>> ptn = getUtility(IPOTemplateNameSet)['firefox']
    >>> subset = POTemplateSubset(productseries=series)

Here's the person who'll be doing the import.

    >>> person_set = getUtility(IPersonSet)
    >>> person = person_set.getByName('carlos')

And this is the POTemplate where the import will be done.

    >>> potemplate = subset.new(
    ...     potemplatename=ptn,
    ...     path='po/firefox.pot',
    ...     owner=person)

We've got a template with two pairs of messages with duplicated msgids.
In the first pair of messages, there is context added using 'msgctxt'
to only one, and in the second pair of messages, different context is
present on both messages (and, we're also using the fact that for plural
form messages, gettext makes use of only msgid when comparing messages).

    >>> potemplate_contents = r'''
    ... msgid ""
    ... msgstr ""
    ... "POT-Creation-Date: 2004-07-11 16:16+0900\n"
    ... "Content-Type: text/plain; charset=CHARSET\n"
    ... "Plural-Forms: nplurals=INTEGER; plural=EXPRESSION;\n"
    ... "X-Rosetta-Export-Date: %s\n"
    ...
    ... msgid "bar"
    ... msgstr ""
    ...
    ... msgctxt "context"
    ... msgid "bar"
    ... msgstr ""
    ...
    ... #, c-format
    ... msgctxt "First message"
    ... msgid "%%d file"
    ... msgstr ""
    ...
    ... #, c-format
    ... msgctxt "Second message"
    ... msgid "%%d file"
    ... msgid_plural "%%d files"
    ... msgstr[0] ""
    ... msgstr[1] ""
    ... ''' % datetime.datetime.now(UTC).isoformat()

This file can now be correctly imported:

    >>> import_pofile_or_potemplate(potemplate_contents, person, series,
    ...                             potemplate=potemplate)
    IMPORTED

The method getPOTMsgSetByMsgIDText returns a message without context if
context is not asked for specifically.

    >>> potmsgset = potemplate.getPOTMsgSetByMsgIDText('bar')
    >>> print potmsgset.msgid
    bar
    >>> print potmsgset.context
    None

And if all the messages have a context, getPOTMsgSetByMsgIDText returns
nothing when context is not specified.

    >>> potmsgset = potemplate.getPOTMsgSetByMsgIDText('%d file')
    >>> print potmsgset
    None

To get a message with context, we pass a context parameter.

    >>> potmsgset = potemplate.getPOTMsgSetByMsgIDText('bar', context='context')
    >>> print potmsgset.msgid
    bar
    >>> print potmsgset.context
    context

It also works for plural form messages.

    >>> potmsgset = potemplate.getPOTMsgSetByMsgIDText('%d file',
    ...                                                context='First message')
    >>> print potmsgset.msgid
    %d file
    >>> print potmsgset.context
    First message
    >>> potmsgset = potemplate.getPOTMsgSetByMsgIDText('%d file',
    ...                                                context='Second message')
    >>> print potmsgset.msgid
    %d file
    >>> print potmsgset.context
    Second message

Importing a PO template with two messages with identical strings, but no
context differences fails.

    >>> potemplate_contents = r'''
    ... msgid ""
    ... msgstr ""
    ... "POT-Creation-Date: 2004-07-11 16:16+0900\n"
    ... "Content-Type: text/plain; charset=CHARSET\n"
    ... "Plural-Forms: nplurals=INTEGER; plural=EXPRESSION;\n"
    ... "X-Rosetta-Export-Date: %s\n"
    ...
    ... msgctxt "context"
    ... msgid "bar"
    ... msgstr ""
    ...
    ... msgctxt "context"
    ... msgid "bar"
    ... msgstr ""
    ... ''' % datetime.datetime.now(UTC).isoformat()

Importing this file fails because of conflicting messages.

    >>> import_pofile_or_potemplate(potemplate_contents, person, series,
    ...                             potemplate=potemplate)
    WARNING We got an error import...
    ...duplicate msgid...
    FAILED

We can also import POFile with context messages.

    >>> pofile = potemplate.newPOFile('sr')
    >>> pofile.path='sr.po'
    >>> pofile_contents = r'''
    ... msgid ""
    ... msgstr ""
    ... "POT-Creation-Date: 2004-07-11 16:16+0900\n"
    ... "Content-Type: text/plain; charset=CHARSET\n"
    ... "Language: Serbian\n"
    ... "Plural-Forms: nplurals=3; plural=(n%%10==1 && n%%100!=11 ? 0 : n%%10>=2 && n%%10<=4 && (n%%100<10 || n%%100>=20) ? 1 : 2);\n"
    ... "X-Rosetta-Export-Date: %s\n"
    ...
    ... msgid "bar"
    ... msgstr "foo"
    ...
    ... msgctxt "context"
    ... msgid "bar"
    ... msgstr "fooing"
    ...
    ... #, c-format
    ... msgctxt "First message"
    ... msgid "%%d file"
    ... msgstr "Translation %%d"
    ...
    ... #, c-format
    ... msgctxt "Second message"
    ... msgid "%%d file"
    ... msgid_plural "%%d files"
    ... msgstr[0] "%%d translation"
    ... msgstr[1] "%%d translationes"
    ... msgstr[2] "%%d translations"
    ... ''' % datetime.datetime.now(UTC).isoformat()

Importing this file succeeds.

    >>> import_pofile_or_potemplate(pofile_contents, person, series,
    ...                             pofile=pofile)
    IMPORTED

If we don't pass context to POFile.getPOMsgSet method, we get the translation
for the message without the context.

    >>> pomsgset = pofile.getPOMsgSet(key=u'bar')
    >>> print pomsgset.active_texts
    [u'foo']

If we pass the context parameter to getPOMsgSet, we get the translation for
a message with context.

    >>> pomsgset = pofile.getPOMsgSet(key=u'bar', context=u'context')
    >>> print pomsgset.active_texts
    [u'fooing']

If a message requires context, you cannot get it without it:

    >>> pomsgset = pofile.getPOMsgSet(key=u'%d file')
    >>> print pomsgset
    None

If you add context, it actually works.

    >>> pomsgset = pofile.getPOMsgSet(key=u'%d file', context=u'First message')
    >>> print pomsgset.active_texts
    [u'Translation %d']

And for messages with plural forms, it gets all the translations.

    >>> pomsgset = pofile.getPOMsgSet(key=u'%d file', context=u'Second message')
    >>> print pomsgset.active_texts
    [u'%d translation', u'%d translationes', u'%d translations']

== Export ==

Make sure exported files are correct.  Exporting a POT file returns exactly
the same contents, except that header is marked fuzzy.

    >>> from canonical.launchpad.components.poexport import POTemplateExporter
    >>> exporter = POTemplateExporter(potemplate)
    >>> potfile = exporter.export_potemplate()
    >>> print potfile
    #, fuzzy
    msgid ""
    msgstr ""
    "POT-Creation-Date: 2004-07-11 16:16+0900\n"
    "Content-Type: text/plain; charset=CHARSET\n"
    "Plural-Forms: nplurals=INTEGER; plural=EXPRESSION;\n"
    "X-Rosetta-Export-Date: ...\n"
    <BLANKLINE>
    msgid "bar"
    msgstr ""
    <BLANKLINE>
    msgctxt "context"
    msgid "bar"
    msgstr ""
    <BLANKLINE>
    #, c-format
    msgctxt "First message"
    msgid "%d file"
    msgstr ""
    <BLANKLINE>
    #, c-format
    msgctxt "Second message"
    msgid "%d file"
    msgid_plural "%d files"
    msgstr[0] ""
    msgstr[1] ""

And a Serbian PO file is exported using regular export_to_pofile call.

    >>> from canonical.launchpad.database import LanguageSet
    >>> language = LanguageSet()['sr']
    >>> pofile_contents = exporter.export_pofile(language)
    >>> print pofile_contents
    msgid ""
    msgstr ""
    "POT-Creation-Date: 2004-07-11 16:16+0900\n"
    "Content-Type: text/plain; charset=CHARSET\n"
    "Language: Serbian\n"
    "Plural-Forms: nplurals=3; plural=(n%10==1...
    "X-Rosetta-Export-Date: ...\n"
    <BLANKLINE>
    msgid "bar"
    msgstr "foo"
    <BLANKLINE>
    msgctxt "context"
    msgid "bar"
    msgstr "fooing"
    <BLANKLINE>
    #, c-format
    msgctxt "First message"
    msgid "%d file"
    msgstr "Translation %d"
    <BLANKLINE>
    #, c-format
    msgctxt "Second message"
    msgid "%d file"
    msgid_plural "%d files"
    msgstr[0] "%d translation"
    msgstr[1] "%d translationes"
    msgstr[2] "%d translations"
