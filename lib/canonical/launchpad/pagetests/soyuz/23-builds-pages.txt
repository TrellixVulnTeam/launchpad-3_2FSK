Those pages are based in the BuildRecordView class and
template/builds-list.pt. Basically they have a buildstate selector
action via HTTP GET and present a batched list of build records
according the selected buildstate, by default All

  >>> def check_builds_options(contents):
  ...     """Check if the label and/or the field for the optional
  ...     "names containing" search are present in the given page contents.
  ...
  ...     Check the presence of "build_state" selection widget via assertion.
  ...
  ...     Check the presence of "Update" submit button via assertion.
  ...
  ...     Return "State and Name present" if the page provide both parameters,
  ...     "State present, Name not present" if the page only permits browse
  ...     by state and "mismatch" if the page, erroneously,  provide only
  ...     part of the required arguments to enable filter by name.
  ...     """
  ...     assert '<input type="submit" value="Update" />' in contents
  ...
  ...     field_state = find_tag_by_id(contents, 'build_state') is not None
  ...     field_name = find_tag_by_id(contents, 'build_text') is not None
  ...
  ...     if field_state and field_name:
  ...         return "State and Name present"
  ...     elif field_state and not field_name :
  ...         return "State present, Name not present"
  ...     else:
  ...         return "mismatch"

Ensure all IBuildRecordView (+builds) pages are provided by the same class,
i.e., they provide the expected arguments/features in different contexts:

For Distribution, it's possible to filter build results by state and name:

  >>> browser.open("http://launchpad.dev/ubuntu")
  >>> browser.getLink("Builds").click()
  >>> print check_builds_options(browser.contents)
  State and Name present

For Distrorelease, same as Distribution:

  >>> browser.open("http://launchpad.dev/ubuntu/hoary")
  >>> browser.getLink("Show builds").click()
  >>> print check_builds_options(browser.contents)
  State and Name present

For DistroArchSeries, same as Distribution:

  >>> browser.open("http://launchpad.dev/ubuntu/hoary/i386")
  >>> browser.getLink("Show builds").click()
  >>> print check_builds_options(browser.contents)
  State and Name present

For Builder, same as Distribution:

  >>> browser.open("http://launchpad.dev/+builds/bob")
  >>> browser.getLink("Show build history").click()
  >>> print check_builds_options(browser.contents)
  State and Name present

For Archive (PPA), same as Distribution:

  >>> browser.open("http://launchpad.dev/~cprov/+archive")
  >>> browser.getLink("View build records").click()
  >>> print check_builds_options(browser.contents)
  State and Name present

For SourcePackage, it's only possible to filter by state.

  >>> browser.open(
  ...   "http://launchpad.dev/ubuntu/hoary/+source/pmount")
  >>> browser.getLink("Show builds").click()
  >>> print check_builds_options(browser.contents)
  State present, Name not present

The source package default state is "all states":

  >>> soup = find_main_content(browser.contents)
  >>> [results] = soup.findAll(attrs={'selected': 'selected'})
  >>> print extract_text(results)
  All states

Check the contents of the distro builds list page.

  >>> browser.open("http://launchpad.dev/ubuntu/+builds")

Check the presence of some build titles, specially the 'not
initialised' one (fix bug #52704)

 * SUPERSEDED and NEEDSBUILD builds contain title
 * MANUALDEWAIT builds contain: title, dependencies-line, start,
   finished, duration and a link to the build log.

  >>> browser.getControl(name="build_state").value = ['all']
  >>> browser.getControl("Update").click()
  >>> print find_tags_by_class(
  ...     browser.contents, 'builds_list')[0].renderContents()
  <BLANKLINE>
  ...
  ...FULLYBUILT...
  ...hppa build of mozilla-firefox 0.9 in ubuntu warty RELEASE...
  ...FULLYBUILT...
  ...i386 build of commercialpackage 1.0-1 in ubuntu breezy-autotest RELEASE...
  ...FAILEDTOUPLOAD...
  ...i386 build of cdrkit 1.0 in ubuntu breezy-autotest RELEASE...
  ...FAILEDTOBUILD...
  ...i386 build of cdrkit 1.0 in ubuntu warty RELEASE...
  ...FAILEDTOBUILD...
  ...i386 build of foobar 1.0 in ubuntu warty RELEASE...

  # We had too many results. Some of them are on the second batch.
  >>> browser.getLink("Next").click()
  >>> print find_tags_by_class(
  ...     browser.contents, 'builds_list')[0].renderContents()
  <BLANKLINE>
  ...
  ...SUPERSEDED...
  ...i386 build of at 0.00 in ubuntu warty RELEASE...
  ...SUPERSEDED...
  ...i386 build of linux-source-2.6.15 2.6.15.3 in ubuntu warty RELEASE...
  ...SUPERSEDED...
  ...i386 build of netapplet 0.99.6-1 in ubuntu warty RELEASE...
  ...MANUALDEPWAIT...
  ...i386 build of libstdc++ b8p in ubuntu hoary RELEASE...
  ...Missing dep...
  ...cpp...gcc-4.0...
  ...Build star...
  ...2006-02-27...
  ...finis...
  ...2006-02-28...
  ...six minutes...see the log...

Check the results of some searches on build state.

  >>> browser.getControl(name="build_state").value = ['built']
  >>> browser.getControl("Update").click()
  >>> print browser.contents
  <BLANKLINE>
  ...
  ...hppa build of mozilla-firefox 0.9 in ubuntu warty RELEASE...
  ...i386 build of commercialpackage 1.0-1 in ubuntu breezy-autotest RELEASE...
  ...

  >>> browser.getControl(name="build_state").value = ['depwait']
  >>> browser.getControl("Update").click()
  >>> print browser.contents
  <BLANKLINE>
  ...
  ...i386 build of libstdc++ b8p in ubuntu hoary...
  ...

  >>> browser.getControl(name="build_state").value = ['failed']
  >>> browser.getControl("Update").click()
  >>> print browser.contents
  <BLANKLINE>
  ...
  ...i386 build of pmount 0.1-1 in ubuntu warty...
  ...

Checking UnexpectedFormData on unknown build_state values (bug #41104)

Pagetest infrastructure won't allow us to pass a not presented field
to the form:

  >>> browser.open("http://launchpad.dev/+builds/bob/+history")
  >>> browser.getControl(name="build_state").value = ['foo']
  Traceback (most recent call last):
  ...
  ItemNotFoundError: insufficient items with name 'foo'

However even if we build an URL with a incorrect value, code is prepared
to raise the correct exception:

  >>> browser.open(
  ...     "http://launchpad.dev/+builds/bob/+history?build_state=foo")
  Traceback (most recent call last):
  ...
  UnexpectedFormData: No suitable state found for value "foo"


== Builds page messages ==

When you first view the builds page for a distribution that has no
builds, for instance 'debian' in our sampledata, the page says 'No
packages are currently building'. We assume that this is your first
view if there are no GET arguments.

  >>> browser.open("http://launchpad.dev/debian/+builds")
  >>> print extract_text(
  ...     find_tag_by_id(browser.contents, 'no-default-result'))
  No 'Currently building' build records.
  >>> find_tag_by_id(browser.contents, 'empty-result') is None
  True

When the user updates the page, the message changes to say that 'No
matching builds' be found. This message clearly differentiate first
page loads from searches, helping the user to figure out exactly what
was done before.

  >>> browser.getControl(name="build_state").value = ['all']
  >>> browser.getControl("Update").click()
  >>> find_tag_by_id(browser.contents, 'no-default-result') is None
  True
  >>> print extract_text(
  ...     find_tag_by_id(browser.contents, 'empty-result'))
  No matching builds.

If there *are* builds present, we don't display any special
message. (We added this to catch bug #160331.)"

  >>> browser.open("http://launchpad.dev/ubuntu/+builds")
  >>> find_tag_by_id(browser.contents, 'empty-result') is None
  True
  >>> find_tag_by_id(browser.contents, 'no-default-result') is None
  True

The same mechanism still works for a SourcePackage-Builds page with
no builds, see bug 62545.

After opening a empty SourcePackage Builds page we will repeat the
same set of tests done for Distribution Builds page.

  >>> browser.open(
  ...    "http://launchpad.dev/ubuntu/hoary/+source/mozilla-firefox/+builds")

First load only 'No packages currently building' message is presented.

  >>> print extract_text(
  ...     find_tag_by_id(browser.contents, 'no-default-result'))
  No build records.
  >>> find_tag_by_id(browser.contents, 'empty-result') is None
  True

When the user updates the page, the message for empty results changes
to 'No matching builds'.

  >>> browser.getControl(name="build_state").value = ['all']
  >>> browser.getControl("Update").click()

  >>> find_tag_by_id(browser.contents, 'no-default-result') is None
  True
  >>> print extract_text(
  ...     find_tag_by_id(browser.contents, 'empty-result'))
  No matching builds.

The described mechanism should work similarly for:

 * Builder History;
 * DistroSeries Builds and
 * DistroArchSeries Builds.


== Partner builds ==

Builds of partner packages show up on the builds page as any other package
from the primary archive.

  >>> browser.open(
  ...    "http://launchpad.dev/ubuntu//+builds?build_text="
  ...    "commercialpackage&build_state=built")
  >>> print extract_text(find_tags_by_class(browser.contents, 'listing')[0])
  i386 build of commercialpackage 1.0-1 in ubuntu breezy-autotest RELEASE
  ...

And also on the distro series builds page:

  >>> browser.open("http://launchpad.dev/ubuntu/breezy-autotest/+builds?build_text=commercialpackage&build_state=built")
  >>> print extract_text(find_tags_by_class(browser.contents, 'listing')[0])
  i386 build of commercialpackage 1.0-1 in ubuntu breezy-autotest RELEASE
  ...


== Upload status ==

A (distro) source package release page shows any builds for that source and
the status of the build.  If the build has been uploaded, then an upload
status is shown in parentheses after the build status.

    >>> browser.open("http://launchpad.dev/ubuntu/+source/mozilla-firefox/0.9")
    >>> print extract_text(find_tag_by_id(browser.contents,"portlet-builds"))
    Builds
    warty
    hppa
    Successfully built
    hoary
    i386
    Currently building
    breezy-autotest
    i386
    Successfully built (NEW)
    warty
    i386
    Successfully built

