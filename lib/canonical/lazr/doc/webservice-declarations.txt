= Web Service API Declarations =

You can easily create a web service by tagging your content interfaces
with some decorators. From this tagging the web service API will be
created automatically.


== Exporting the data model ==

The LAZR Web Service data model consists of entries and collection (see
webservice.txt for all the details). Entries support the IEntry
interface and are basically a single resource exported. Think something
like a bug, a person, an article, etc. Collections are a set of
resources of the same types, think something like the set of bugs,
persons, teams, articles, etc.


=== Exporting entries ===

Only entries are exported as data. You can mark that one of your content
interface is exported on the web service as an entry, by using the
export_as_webservice_entry() declaration.

You can mark the fields that should be part of the entry data model by
using the exported() wrapper. It takes an optional 'exported_as' parameter
that can be used to change the name under which the field will be
exported.

For example, here we declare that the IBook interface is exported as an
entry on the  web service. It exports the title, author, and base_price
field, but not the inventory_number field.

    >>> from zope.interface import Interface
    >>> from zope.schema import TextLine, Float
    >>> from canonical.lazr.rest.declarations import (
    ...     export_as_webservice_entry, exported)
    >>> class IBook(Interface):
    ...     """A simple book data model."""
    ...     export_as_webservice_entry()
    ...
    ...     title = exported(TextLine(title=u'The book title'))
    ...
    ...     author = exported(TextLine(title=u"The book's author."))
    ...
    ...     base_price = exported(Float(
    ...         title=u"The regular price of the book."),
    ...         exported_as='price')
    ...
    ...     inventory_number = TextLine(title=u'The inventory part number.')

These declarations adds tagged value to the original interface elements.
The tags are in the lazr.webservice namespace and are dictionaries of
elements.

    >>> from pprint import pformat
    >>> def print_export_tag(element):
    ...     """Print the content of the 'lazr.webservice.exported' tag."""
    ...     def format_value(value):
    ...         if isinstance(value, dict):
    ...             return pformat(value)
    ...         else:
    ...             return repr(value)
    ...     tag = element.queryTaggedValue('lazr.webservice.exported')
    ...     if tag is None:
    ...         print "tag 'lazr.webservice.exported' is not present"
    ...     else:
    ...         print "\n".join(
    ...             "%s: %s" %(key, format_value(value))
    ...             for key, value in sorted(tag.items()))
    >>> print_export_tag(IBook)
    type: 'entry'
    >>> print_export_tag(IBook['title'])
    as: 'title'
    type: 'field'
    >>> print_export_tag(IBook['author'])
    as: 'author'
    type: 'field'
    >>> print_export_tag(IBook['base_price'])
    as: 'price'
    type: 'field'
    >>> print_export_tag(IBook['inventory_number'])
    tag 'lazr.webservice.exported' is not present

Only IField can be exported as entry fields.

    >>> from zope.interface import Attribute
    >>> class NotAField1(Interface):
    ...     an_attribute = exported(Attribute('A standard attribute'))
    Traceback (most recent call last):
      ...
    TypeError: exported() can only be used on IFields.

In the same vein, export_as_webservice_entry() can only be used on
Interface.

    >>> class NotAnInterface(object):
    ...     export_as_webservice_entry()
    Traceback (most recent call last):
      ...
    TypeError: export_as_webservice_entry() can only be used on an
    interface.

And from within a class declaration.

    >>> export_as_webservice_entry()
    Traceback (most recent call last):
      ...
    TypeError: export_as_webservice_entry() can only be used from within
    an interface definition.


=== Exporting a collection ===

Collections scoped to an entry are exported simply by using
exported() on the CollectionField containing the scoped collection
items:

    >>> class ISimpleComment(Interface):
    ...     """A simple comment."""
    ...     comment = TextLine(title=u'Comment')

    >>> from zope.schema import Object
    >>> from canonical.lazr.fields import CollectionField
    >>> class IBookWithComments(IBook):
    ...     """A book with some comments."""
    ...     export_as_webservice_entry()
    ...
    ...     comments = exported(CollectionField(
    ...         value_type=Object(schema=ISimpleComment)))

Top-level collections are different though, they are exported by using
the export_as_webservice_collection() in the *Set class. The method that
returns all of the collection items must be tagged with
@collection_default_content decorator.

    >>> from canonical.lazr.rest.declarations import (
    ...     export_as_webservice_collection, collection_default_content,
    ...     REQUEST_USER)
    >>> class IBookSet(Interface):
    ...     """Set of all the books in the system."""
    ...     export_as_webservice_collection(IBook)
    ...
    ...     @collection_default_content()
    ...     def getAllBooks():
    ...         """Return an iterator over all the books."""

In case the method to call requires parameters, the value to use can be
specified using parameters to the decorator constructor. There is a
special REQUEST_USER marker that can be used to specify that this
parameter should contain the logged in user.

    >>> class ICheckedOutBookSet(Interface):
    ...     """Give access to the checked out books."""
    ...     export_as_webservice_collection(IBook)
    ...
    ...     @collection_default_content(user=REQUEST_USER, title='')
    ...     def getByTitle(title, user):
    ...         """Return checked out books.
    ...         :param title: String to match against the book title.
    ...             The empty string matches everything.
    ...         :param user: The user who should have checked the book out.
    ...         """

Like for entries, this adds keys in the 'lazr.webservice.exported'
tagged value.

    >>> print_export_tag(IBookSet)
    collection_default_content: 'getAllBooks'
    collection_default_content_params: {}
    collection_entry_schema: <InterfaceClass __builtin__.IBook>
    type: 'collection'

    >>> print_export_tag(ICheckedOutBookSet)
    collection_default_content: 'getByTitle'
    collection_default_content_params: {'user': <object...>, 'title': ''}
    collection_entry_schema: <InterfaceClass __builtin__.IBook>
    type: 'collection'

The entry schema for a collection must be provided and must be an
interface:

    >>> class MissingEntrySchema(Interface):
    ...     export_as_webservice_collection()
    Traceback (most recent call last):
      ...
    TypeError: export_as_webservice_collection() takes exactly 1
    argument (0 given)

    >>> class InvalidEntrySchema(Interface):
    ...     export_as_webservice_collection("not an interface")
    Traceback (most recent call last):
      ...
    TypeError: entry_schema must be an interface.

It's an error to try to export a collection without marking a method as
exporting the default content.

    >>> class IDummyInterface(Interface):
    ...     pass

    >>> class MissingDefaultContent(Interface):
    ...     export_as_webservice_collection(IDummyInterface)
    Traceback (most recent call last):
      ...
    TypeError: export_as_webservice_collection() is missing a method
    tagged with @collection_default_content.

As it is an error, to mark more than one methods:

    >>> class TwoDefaultContent(Interface):
    ...     export_as_webservice_collection(IDummyInterface)
    ...     @collection_default_content()
    ...     def getAll1():
    ...         """A first getAll()."""
    ...     @collection_default_content()
    ...     def getAll2():
    ...         """Another getAll()."""
    Traceback (most recent call last):
      ...
    TypeError: only one method should be marked with
    @collection_default_content.

export_as_webservice_collection() can only be used on Interface.

    >>> class NotAnInterface(object):
    ...     export_as_webservice_collection(IDummyInterface)
    Traceback (most recent call last):
      ...
    TypeError: export_as_webservice_collection() can only be used on an
    interface.

And from within a class declaration.

    >>> export_as_webservice_collection(IDummyInterface)
    Traceback (most recent call last):
      ...
    TypeError: export_as_webservice_collection() can only be used from
    within an interface definition.

collection_default_content() can only be used from within an Interface
declaration:

    >>> @collection_default_content()
    ... def a_function(): pass
    Traceback (most recent call last):
      ...
    TypeError: @collection_default_content can only be used from within
    an interface definition.

And the interface must have been exported as a collection:

    >>> class NotExported(Interface):
    ...     export_as_webservice_entry()
    ...     @collection_default_content()
    ...     def a_function(): pass
    Traceback (most recent call last):
      ...
    TypeError: @collection_default_content can only be used from within an
    interface exported as a collection.


=== Exporting methods ===

Entries and collections can support operations on the webservice. The
operations supported are defined by tagging methods in the content
interface with special decorators.

Three different decorators are used based on the kind of method
exported.

1. @export_read_operation

    This will mark the method as available as a GET operation on the
    exported resource.

2. @export_write_operation

    This will mark the method as available as a POST operation on the
    exported resource.

3. @export_factory_operation(schema, fields)

    Like the @export_write_operation decorator, this will mark the
    method as available as a POST operation on the exported resource,
    with the addition that the result of the method is a new object and
    the HTTP status code will be set appropriately.

    This decorator takes as parameters the schema of the object it is
    creating and the name of the fields in the schema that are passed as
    parameters.

The specification of the web service's acceptable method parameters
should be described using the @operation_parameters decorator, which
takes normal IField instances. The @operation_returns decorator
should be used to descibe the type of the method's return value--this
also takes an IField instance.

    >>> from canonical.lazr.rest.declarations import (
    ...     export_operation_as, export_factory_operation,
    ...     export_read_operation, operation_parameters,
    ...     operation_returns, rename_parameters_as)
    >>> from canonical.lazr.interface import copy_field
    >>> from canonical.lazr.fields import Reference
    >>> class IBookSetOnSteroids(IBookSet):
    ...     """IBookSet supporting some methods."""
    ...     export_as_webservice_collection(IBook)
    ...
    ...     @collection_default_content()
    ...     @operation_parameters(
    ...         text=copy_field(IBook['title'], title=u'Text to search for.'))
    ...     @operation_returns(
    ...         CollectionField(value_type=Reference(schema=IBook)))
    ...     @export_read_operation()
    ...     def searchBooks(text):
    ...         """Return list of books containing 'text'."""
    ...
    ...     @export_operation_as('create_book')
    ...     @rename_parameters_as(base_price='price')
    ...     @export_factory_operation(
    ...         IBook, ['author', 'base_price', 'title'])
    ...     def new(author, base_price, title):
    ...         """Create a new book."""

In the above example, the exported new() method demonstrates two
features to support having different names on the web service than in
the internal API.  It is possible to export a method under a different
name by using the @export_operation_as decorator which takes the name
under which the method should be exported.

The @rename_parameters_as decorator can be used to rename the method
parameters on the web service.  In the example, the 'base_price' parameter
will be called 'price' when exported on the web service.

When some required parameters of the method should not be provided by
the webservice client, it is possible to use the @call_with decorator to
specify the value to use. The special REQUEST_USER marker can be used to
specify that this parameter should contain the logged in user.

    >>> from canonical.lazr.rest.declarations import (
    ...     call_with, export_write_operation, REQUEST_USER)
    >>> class IBookOnSteroids(IBook):
    ...     """IBook with some methods."""
    ...     export_as_webservice_entry()
    ...
    ...     @call_with(who=REQUEST_USER, kind='normal')
    ...     @export_write_operation()
    ...     def checkout(who, kind):
    ...         """Check this book out."""

Like other declarations, these will add tagged values to the interface
method. We didn't have to specify the return type for the factory
operation, because a factory operation always returns the
newly-created object.

    >>> print_export_tag(IBookSetOnSteroids['new'])
    as: 'create_book'
    call_with: {}
    creates: <...IBook...>
    params: {'author': <...TextLine...>,
        'base_price': <...Float...>,
        'title': <...TextLine...>}
    return_type: <zope.schema._field.Object object...>
    type: 'factory'

We did specify the return type for the 'searchBooks' method: it
returns a collection.

    >>> print_export_tag(IBookSetOnSteroids['searchBooks'])
    as: 'searchBooks'
    call_with: {}
    params: {'text': <...TextLine...>}
    return_type: <canonical.lazr.fields.CollectionField object...>
    type: 'read_operation'

The 'checkout' method doesn't return anything.

    >>> print_export_tag(IBookOnSteroids['checkout'])
    as: 'checkout'
    call_with: {'kind': 'normal', 'who': <object...>}
    params: {}
    return_type: None
    type: 'write_operation'

Parameters that are not renamed are exported under the same name:

    >>> for name, param in sorted(IBookSetOnSteroids['new'].getTaggedValue(
    ...     'lazr.webservice.exported')['params'].items()):
    ...     print "%s: %s" % (name, param.__name__)
    author: author
    base_price: price
    title: title

It is possible to use @operation_parameters with
@export_factory_operation to specify parameters that are not part of the
schema.

    >>> class ComplexBookFactory(Interface):
    ...     export_as_webservice_entry()
    ...
    ...     @operation_parameters(collection=TextLine())
    ...     @export_factory_operation(IBook, ['author', 'title'])
    ...     def create_book(author, title, collection):
    ...         """Create a book in a collection."""

    >>> print_export_tag(ComplexBookFactory['create_book'])
    as: 'create_book'
    call_with: {}
    creates: <...IBook...>
    params: {'author': <...TextLine...>,
        'collection': <...TextLine...>,
        'title': <...TextLine...>}
    return_type: <zope.schema._field.Object object...>
    type: 'factory'

Parameters default and required attributes are set automatically based
on the method signature.

    >>> class ComplexParameterDefinition(Interface):
    ...     export_as_webservice_entry()
    ...
    ...     @operation_parameters(
    ...         required1=TextLine(),
    ...         required2=TextLine(default=u'Not required'),
    ...         optional1=TextLine(required=True),
    ...         optional2=TextLine(),
    ...         )
    ...     @export_read_operation()
    ...     def a_method(required1, required2, optional1='Default',
    ...                  optional2='Default2'):
    ...         """Method demonstrating how required/default are set."""

In this example, the required1 definition will be automatically
considered required.

    >>> param_defs = ComplexParameterDefinition['a_method'].getTaggedValue(
    ...     'lazr.webservice.exported')['params']
    >>> param_defs['required1'].required
    True

But required2 will not be considered required because a default value
was provided.

    >>> param_defs['required2'].required
    False

NOTE: It's not possible to make an optional parameter required on the
webservice. In the above case, required=True was specified on
"optional1", but that will be overridden. The reason for that is that by
default required is always True, so it's not possible to distinguish
between the case where required was set to True, and required is True
because it's the default value.

    >>> param_defs['optional1'].required
    False
    >>> param_defs['optional1'].default
    u'Default'

And optional2 was exported with the same default than the method:

    >>> param_defs['optional2'].required
    False
    >>> param_defs['optional2'].default
    u'Default2'

All these decorators can only be used from within an interface
definition:

    >>> @export_operation_as('test')
    ... def a_method1(self): pass
    Traceback (most recent call last):
      ...
    TypeError: export_operation_as() can only be used from within an interface
    definition.

    >>> @export_read_operation()
    ... def another_method(self): pass
    Traceback (most recent call last):
      ...
    TypeError: export_read_operation() can only be used from within an
    interface definition.

An error is also reported if not enough parameters are defined as
exported:

    >>> class MissingParameter(Interface):
    ...     export_as_webservice_entry()
    ...     @call_with(param1=1)
    ...     @operation_parameters(
    ...         param2=TextLine())
    ...     @export_read_operation()
    ...     def a_method(param1, param2, param3, param4): pass
    Traceback (most recent call last):
      ...
    TypeError: method "a_method" needs more parameters definitions to be
    exported: param3, param4

Defining a parameter not available on the method also results in an
error:

    >>> class BadParameter(Interface):
    ...     export_as_webservice_entry()
    ...     @operation_parameters(
    ...         no_such_param=TextLine())
    ...     @export_read_operation()
    ...     def a_method(): pass
    Traceback (most recent call last):
      ...
    TypeError: method "a_method" doesn't have the following exported
    parameters: no_such_param.

But that's not a problem if the exported method actually takes arbitrary
keyword parameters:

    >>> class AnyParameter(Interface):
    ...     export_as_webservice_entry()
    ...     @operation_parameters(
    ...         param1=TextLine())
    ...     @export_read_operation()
    ...     def a_method(**kwargs): pass

When using @export_factory_operation, TypeError will also be raised if
one of the field doesn't exists in the schema:

    >>> class MissingParameter(Interface):
    ...     export_as_webservice_entry()
    ...     @export_factory_operation(IBook, ['no_such_field'])
    ...     def a_method(): pass
    Traceback (most recent call last):
      ...
    TypeError: IBook doesn't define 'no_such_field'.

Or if the field name doesn't represent a field:

    >>> class NotAField(Interface):
    ...     export_as_webservice_entry()
    ...     @export_factory_operation(IBookOnSteroids, ['checkout'])
    ...     def a_method(): pass
    Traceback (most recent call last):
      ...
    TypeError: IBookOnSteroids.checkout doesn't provide IField.

Or if @operation_parameters redefine a field specified in the factory:

    >>> class Redefinition(Interface):
    ...     export_as_webservice_entry()
    ...     @operation_parameters(title=TextLine())
    ...     @export_factory_operation(IBookOnSteroids, ['title'])
    ...     def create_book(title): pass
    Traceback (most recent call last):
      ...
    TypeError: 'title' parameter is already defined.

All parameters definitions must be schema fields:

    >>> class BadParameterDefinition(Interface):
    ...     export_as_webservice_entry()
    ...     @operation_parameters(a_param=object())
    ...     @export_read_operation()
    ...     def a_method(): pass
    Traceback (most recent call last):
      ...
    TypeError: export definition of "a_param" in method "a_method" must
    provide IField: <object...>

Renaming a parameter that wasn't defined results in an error:

    >>> class NonExistentParameter(Interface):
    ...     @rename_parameters_as(param1='name', param2='name2')
    ...     @operation_parameters(param1=TextLine())
    ...     @export_read_operation()
    ...     def a_method(param1): pass
    Traceback (most recent call last):
      ...
    TypeError: rename_parameters_as(): no "param2" parameter is exported.

Trying to use @rename_parameters_as without exporting the method also
results in an error.

    >>> class MissingMethodExport(Interface):
    ...     @rename_parameters_as(a_param='name')
    ...     def a_method(): pass
    Traceback (most recent call last):
      ...
    TypeError: "a_method" isn't exported on the webservice.


=== Exporting exceptions ===

When a method raises an exception, the default is to report the error as
'500 Internal Server Error'. In many cases, that's not the case and one
of the 4XX error would be better.

Exceptions can be tagged with the webservice_error() declaration to
state the proper HTTP status code to use for that kind of error.

    >>> from canonical.lazr.rest.declarations import webservice_error
    >>> class InvalidEmail(Exception):
    ...     """Error happening when the email is not valid."""
    ...     webservice_error(400)

The directive sets the __lazr_webservice_error__ attribute on the
exception which will be used by the view handling the exception.

    >>> InvalidEmail.__lazr_webservice_error__
    400

Using that directive outside of a class declaration is an error:

    >>> webservice_error(402)
    Traceback (most recent call last):
      ...
    TypeError: webservice_error() can only be used from within an
    exception definition.


=== Export and inheritance ===

A child interface inherits the markup of its ancestors, even when the
base interface isn't exported itself.

    >>> class IHasName(Interface):
    ...     name = exported(TextLine())
    ...
    ...     @operation_parameters(new_name=TextLine())
    ...     @export_write_operation()
    ...     def rename(new_name):
    ...         """Rename the object."""

    >>> class IUser(IHasName):
    ...     export_as_webservice_entry()
    ...
    ...     nickname = exported(TextLine())
    ...
    ...     @operation_parameters(to=Object(IHasName), msg=TextLine())
    ...     @export_write_operation()
    ...     def talk_to(to, msg):
    ...         """Sends a message to another named object."""

    >>> for name in sorted(IUser.names(True)):
    ...     print '== %s ==' % name
    ...     print_export_tag(IUser[name])
    == name ==
    as: 'name'
    type: 'field'
    == nickname ==
    as: 'nickname'
    type: 'field'
    == rename ==
    as: 'rename'
    call_with: {}
    params: {'new_name': <...TextLine...>}
    return_type: None
    type: 'write_operation'
    == talk_to ==
    as: 'talk_to'
    call_with: {}
    params: {'msg': <...TextLine...>,
        'to': <...Object...>}
    return_type: None
    type: 'write_operation'



== Generating the webservice ==

=== Entry ==

The webservice can be generated from tagged interfaces.
generate_entry_interface() will create a subinterface of IEntry
containing a copy of the IField definitions from the original interface
that were tagged for export.

    >>> from canonical.lazr.rest.declarations import generate_entry_interface
    >>> entry_interface = generate_entry_interface(IBook)

The created interface is named with 'Entry' appended to the original
name, and is in the same module

    >>> entry_interface.__module__
    '__builtin__'
    >>> entry_interface.__name__
    'IBookEntry'

It extends IEntry.

    >>> from canonical.lazr.interfaces.rest import IEntry
    >>> entry_interface.extends(IEntry)
    True

All fields tagged were copied to the new interface:

    >>> for name, field in sorted(entry_interface.namesAndDescriptions()):
    ...     print "%s: %s" % (name, field.__class__.__name__)
    author: TextLine
    price: Float
    title: TextLine

The field __name__ attribute contains the exported name:

    >>> print entry_interface['price'].__name__
    price

It's an error to use generate_entry_interface() on an interface that
wasn't marked for export:

    >>> class SimpleNotExported(Interface):
    ...     """Interface not exported."""
    >>> generate_entry_interface(SimpleNotExported)
    Traceback (most recent call last):
      ...
    TypeError: 'SimpleNotExported' isn't tagged for webservice export.

The interface must also be exported as an entry:

    >>> generate_entry_interface(IBookSet)
    Traceback (most recent call last):
      ...
    TypeError: 'IBookSet' isn't exported as an entry.

The adapter can be generated using the generate_entry_adapter(). It
takes the tagged content interface and the IEntry subinterface as
parameters.

    >>> from canonical.lazr.rest.declarations import generate_entry_adapter
    >>> entry_adapter_factory = generate_entry_adapter(IBook, entry_interface)

The resulting adapter provides the webservice interface:

    >>> entry_interface.implementedBy(entry_adapter_factory)
    True

The resulting class is named based on the interface:

    >>> entry_adapter_factory.__name__
    'BookEntryAdapter'

The resulting adapter has its schema attribute set to the exported
interface, and proxies all attributes to the underlying object.

    >>> from zope.interface import implements
    >>> from zope.interface.verify import verifyObject

    >>> class Book(object):
    ...     """Simple IBook implementation."""
    ...     implements(IBook)
    ...     def __init__(self, author, title, base_price, inventory_number):
    ...         self.author = author
    ...         self.title = title
    ...         self.base_price = base_price
    ...         self.inventory_number = inventory_number

    >>> entry_adapter = entry_adapter_factory(
    ...     Book(u'Aldous Huxley', u'Island', 10.0, '12345'))

    >>> entry_adapter.schema is entry_interface
    True
    >>> verifyObject(entry_interface, entry_adapter)
    True
    >>> entry_adapter.author
    u'Aldous Huxley'
    >>> entry_adapter.price
    10.0
    >>> entry_adapter.title
    u'Island'

It's an error to call this function on an interface not exported on the
web service:

    >>> generate_entry_adapter(SimpleNotExported, entry_interface)
    Traceback (most recent call last):
      ...
    TypeError: 'SimpleNotExported' isn't tagged for webservice export.

Or exported as a collection:

    >>> generate_entry_adapter(IBookSet, entry_interface)
    Traceback (most recent call last):
      ...
    TypeError: 'IBookSet' isn't exported as an entry.


=== Collection ===

An ICollection adapter for content interface tagged as being exported as
collections on the webservice can be generated by using the
generate_collection_adapter() function.

    >>> from canonical.lazr.interfaces.rest import ICollection
    >>> from canonical.lazr.rest.declarations import (
    ...     generate_collection_adapter)

    >>> collection_adapter_factory = generate_collection_adapter(IBookSet)
    >>> ICollection.implementedBy(collection_adapter_factory)
    True

The find() method will return the result of calling the method tagged
with the @collection_default_content decorator.

    >>> class BookSet(object):
    ...     """Simple IBookSet implementation."""
    ...     implements(IBookSet)
    ...
    ...     def __init__(self, books=()):
    ...         self.books = books
    ...
    ...     def getAllBooks(self):
    ...         return self.books

    >>> collection_adapter = collection_adapter_factory(
    ...     BookSet(['A book', 'Another book']))

    >>> verifyObject(ICollection, collection_adapter)
    True

    >>> collection_adapter.find()
    ['A book', 'Another book']

If parameters were specified, they'll be passed in to the method by
find(). The REQUEST_USER marker value will be replaced by the logged in
user.

    >>> from zope.component import provideUtility
    >>> from canonical.launchpad.webapp.interfaces import ILaunchBag
    >>> class FakeLaunchBag:
    ...     implements(ILaunchBag)
    ...     user = 'A user'
    >>> provideUtility(FakeLaunchBag(), ILaunchBag)

    >>> class CheckedOutBookSet(object):
    ...     """Simple ICheckedOutBookSet implementation."""
    ...     implements(ICheckedOutBookSet)
    ...
    ...     def getByTitle(self, title, user):
    ...         print '%s searched for checked out book matching "%s".' % (
    ...             user, title)

    >>> checked_out_adapter = generate_collection_adapter(
    ...     ICheckedOutBookSet)(CheckedOutBookSet())

    >>> checked_out_adapter.find()
    A user searched for checked out book matching "".

It's an error to call this function on an interface not exported on the
web service:

    >>> generate_collection_adapter(SimpleNotExported)
    Traceback (most recent call last):
      ...
    TypeError: 'SimpleNotExported' isn't tagged for webservice export.

Or exported as an entry.

    >>> generate_collection_adapter(IBook)
    Traceback (most recent call last):
      ...
    TypeError: 'IBook' isn't exported as a collection.


=== Methods ===

IResourceOperation adapters can be generated for exported methods by
using the generate_operation_adapter() function. Using it on a method
exported as a read operation will generate an IResourceGETOperation.

    >>> from canonical.lazr.interfaces.rest import IResourceGETOperation
    >>> from canonical.lazr.rest.declarations import (
    ...     generate_operation_adapter)

    >>> read_method_adapter_factory = generate_operation_adapter(
    ...     IBookSetOnSteroids['searchBooks'])
    >>> IResourceGETOperation.implementedBy(read_method_adapter_factory)
    True

The defined adapter is named GET_<interface>_<exported_name> and uses
the ResourceOperation base class.

    >>> from canonical.lazr.rest.operation import ResourceOperation
    >>> read_method_adapter_factory.__name__
    'GET_IBookSetOnSteroids_searchBooks'
    >>> issubclass(read_method_adapter_factory, ResourceOperation)
    True

The adapter's params attribute contains the specification of the
parameters accepted by the operation.

    >>> from operator import attrgetter
    >>> def print_params(params):
    ...     """Print the name and type of the defined parameters."""
    ...     for param in sorted(params, key=attrgetter('__name__')):
    ...         print "%s: %s" % (param.__name__, param.__class__.__name__)
    >>> print_params(read_method_adapter_factory.params)
    text: TextLine

The call() method calls the underlying method and return its result.

    >>> class BookSetOnSteroids(BookSet):
    ...     implements(IBookSetOnSteroids)
    ...
    ...     result = None
    ...
    ...     def searchBooks(self, text):
    ...         return self.result
    ...
    ...     def new(self, author, base_price, title):
    ...         return Book(author, title, base_price, "unknown")

    >>> from canonical.lazr.testing.webservice import FakeRequest
    >>> request = FakeRequest()
    >>> read_method_adapter = read_method_adapter_factory(
    ...     BookSetOnSteroids(), request)
    >>> verifyObject(IResourceGETOperation, read_method_adapter)
    True

    >>> read_method_adapter.context.result = []
    >>> print read_method_adapter.call(text='')
    []

When the method returns one of the basic python scalar type, it is
encoded using JSON and the content-type is set to application/json.
(That is done because the API framework expects either a string where
it means that the response was properly encoded, an object adaptable to
IEntry or a list of such objects.)

    >>> read_method_adapter.context.result = "A string."
    >>> print read_method_adapter.call(text='')
    "A string."
    >>> request.response.status
    200
    >>> print request.response.headers['Content-Type']
    application/json

    >>> read_method_adapter.context.result = True
    >>> read_method_adapter.call(text='')
    'true'

    >>> read_method_adapter.context.result = 10
    >>> read_method_adapter.call(text='')
    '10'

    >>> read_method_adapter.context.result = None
    >>> read_method_adapter.call(text='')
    'null'

    >>> read_method_adapter.context.result = 1.3
    >>> read_method_adapter.call(text='')
    '1.3'

Other results are passed untransformed.

    >>> read_method_adapter.context.result = [object()]
    >>> print read_method_adapter.call(text='')
    [<object...>]


Methods exported as a write operations generates an adapter providing
IResourcePOSTOperation.

    >>> from canonical.lazr.interfaces.rest import IResourcePOSTOperation

    >>> write_method_adapter_factory = generate_operation_adapter(
    ...     IBookOnSteroids['checkout'])
    >>> IResourcePOSTOperation.implementedBy(write_method_adapter_factory)
    True

The generated adapter class name is POST_<interface>_<operation>.

    >>> print write_method_adapter_factory.__name__
    POST_IBookOnSteroids_checkout

The adapter's params property also contains the available parameters
(for which there are none in this case.)

    >>> print_params(write_method_adapter_factory.params)

    >>> class BookOnSteroids(Book):
    ...     def checkout(self, who, kind):
    ...         print "%s did a %s check out of '%s'." % (
    ...             who, kind, self.title)

    >>> write_method_adapter = write_method_adapter_factory(
    ...     BookOnSteroids(
    ...         'Aldous Huxley', 'The Doors of Perception', 8, 'unknown'),
    ...     FakeRequest())

    >>> verifyObject(IResourcePOSTOperation, write_method_adapter)
    True

The call() method invokes the exported method on the context object. In
this case, the underlying parameters were set using call_with. The
REQUEST_USER specification is replaced by the current user.

    >>> write_method_adapter.call()
    A user did a normal check out of 'The Doors of Perception'.
    'null'

Methods exported as a factory also generate an adapter providing
IResourcePOSTOperation.

    >>> factory_method_adapter_factory = generate_operation_adapter(
    ...     IBookSetOnSteroids['new'])
    >>> IResourcePOSTOperation.implementedBy(factory_method_adapter_factory)
    True

    >>> factory_method_adapter = factory_method_adapter_factory(
    ...     BookSetOnSteroids(), FakeRequest())
    >>> verifyObject(IResourcePOSTOperation, factory_method_adapter)
    True

The generated adapter class name is also POST_<interface>_<operation>.

    >>> print write_method_adapter_factory.__name__
    POST_IBookOnSteroids_checkout

The adapter's params property also contains the available parameters.

    >>> print_params(factory_method_adapter_factory.params)
    author: TextLine
    price: Float
    title: TextLine

Factory operations set the 201 Created status code and return the
URL to the newly created object. The body of the response will be empty.

(For canonical_url() to work, we need to register an ICanonicalUrlData
adapter and set the request as the current interaction.)

    >>> from urllib import quote
    >>> from zope.component import provideAdapter
    >>> from canonical.launchpad.webapp.interfaces import ICanonicalUrlData
    >>> class BookUrlData(object):
    ...     inside = None
    ...     rootsite = None
    ...
    ...     def __init__(self, context):
    ...         self.context = context
    ...
    ...     @property
    ...     def path(self):
    ...         return "books/%s" % quote(self.context.title)
    >>> provideAdapter(BookUrlData, [IBook], ICanonicalUrlData)

    >>> from zope.security.management import endInteraction, newInteraction
    >>> endInteraction()
    >>> newInteraction(factory_method_adapter.request)

    >>> factory_method_adapter.call(
    ...     author='Aldous Huxley', title="Eyeless in Gaza", price=10.5)
    u''
    >>> response = factory_method_adapter.request.response
    >>> response.status
    201
    >>> print response.headers['Location']
    http://api.example.org/books/Eyeless%20in%20Gaza

The generate_operation_adapter() function can only be called on an
IMethod marked for export:

    >>> generate_operation_adapter(IBook)
    Traceback (most recent call last):
      ...
    TypeError: <...IBook...> doesn't provide IMethod.

    >>> generate_operation_adapter(IBookSet['getAllBooks'])
    Traceback (most recent call last):
      ...
    TypeError: 'getAllBooks' isn't tagged for webservice export.


=== Security ===

The adapters have checkers defined for them that grant access to all
attributes in the interface. (There is no reason to protect them since
the underlying content security checker will still apply.)

    >>> from canonical.lazr.debug import debug_proxy
    >>> from zope.security.checker import ProxyFactory

    # ProxyFactory wraps the content using the defined checker.
    >>> print debug_proxy(ProxyFactory(entry_adapter))
    zope.security._proxy._Proxy (using zope.security.checker.Checker)
        public: author, price, schema, title
        public (set): author, price, schema, title

    >>> print debug_proxy(ProxyFactory(collection_adapter))
    zope.security._proxy._Proxy (using zope.security.checker.Checker)
        public: entry_schema, find

    >>> print debug_proxy(ProxyFactory(read_method_adapter))
    zope.security._proxy._Proxy (using zope.security.checker.Checker)
        public: __call__

    >>> print debug_proxy(ProxyFactory(write_method_adapter))
    zope.security._proxy._Proxy (using zope.security.checker.Checker)
        public: __call__

    >>> print debug_proxy(ProxyFactory(factory_method_adapter))
    zope.security._proxy._Proxy (using zope.security.checker.Checker)
        public: __call__


== ZCML Registration ==

There is a ZCML directive available that will inspect a given module and
generate and register all the interfaces and adapters for all interfaces
marked for export.

(Put the interface in a module where it will be possible for the ZCML
handler to inspect.)

    >>> import sys
    >>> from types import ModuleType
    >>> bookexample = ModuleType('bookexample')
    >>> sys.modules['canonical.lazr.bookexample'] = bookexample
    >>> bookexample.IBook = IBook
    >>> bookexample.IBookSet = IBookSet
    >>> bookexample.IBookOnSteroids = IBookOnSteroids
    >>> bookexample.IBookSetOnSteroids = IBookSetOnSteroids
    >>> bookexample.ISimpleComment = ISimpleComment
    >>> bookexample.InvalidEmail = InvalidEmail

    >>> from zope.configuration import xmlconfig
    >>> zcmlcontext = xmlconfig.string("""
    ... <configure
    ...     xmlns:webservice="http://namespaces.canonical.com/webservice">
    ...   <include file="lib/canonical/lazr/rest/meta.zcml" />
    ...   <webservice:register module="canonical.lazr.bookexample" />
    ... </configure>
    ... """)

After the registration, adapters from IBook to IEntry, and IBookSet to
ICollection are available:

    >>> from zope.component import getAdapter
    >>> book = Book(u'George Orwell', u'1984', 10.0, u'12345-1984')
    >>> bookset = BookSet([book])

    >>> entry_adapter = getAdapter(book, IEntry)
    >>> verifyObject(IEntry, entry_adapter)
    True

    >>> print entry_adapter.schema.__name__
    IBookEntry
    >>> verifyObject(entry_adapter.schema, entry_adapter)
    True

    >>> collection_adapter = getAdapter(bookset, ICollection)
    >>> verifyObject(ICollection, collection_adapter)
    True

IResourceOperation adapters named under the exported method names
are also available for IBookSetOnSteroids and IBookOnSteroids.

    >>> from zope.component import getGlobalSiteManager
    >>> adapter_registry = getGlobalSiteManager().adapters

    >>> from canonical.lazr.interfaces.rest import WebServiceLayer
    >>> adapter_registry.lookup(
    ...     (IBookSetOnSteroids, WebServiceLayer), IResourceGETOperation,
    ...     'searchBooks')
    <class '...GET_IBookSetOnSteroids_searchBooks'>
    >>> adapter_registry.lookup(
    ...     (IBookSetOnSteroids, WebServiceLayer), IResourcePOSTOperation,
    ...     'create_book')
    <class '...POST_IBookSetOnSteroids_create_book'>
    >>> adapter_registry.lookup(
    ...     (IBookOnSteroids, WebServiceLayer), IResourcePOSTOperation,
    ...     'checkout')
    <class '...POST_IBookOnSteroids_checkout'>

There is also a 'index.html' view on the WebServiceLayer registered for the
InvalidEmail exception.

    >>> from zope.interface import implementedBy
    >>> adapter_registry.lookup(
    ...     (implementedBy(InvalidEmail), WebServiceLayer), Interface,
    ...         'index.html')
    <class '...WebServiceExceptionView'>

(Clean-up.)

    >>> del bookexample
    >>> del sys.modules['canonical.lazr.bookexample']
