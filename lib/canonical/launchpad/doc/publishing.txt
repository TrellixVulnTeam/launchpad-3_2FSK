== SourcePackagePublishingHistory ==

This class provides public access to publishing records via a SQL view.

    >>> from canonical.launchpad.database import SourcePackagePublishingHistory
    >>> from canonical.launchpad.database import BinaryPackagePublishingHistory

Select a publishing record from the sampledata (pmount is a
interesting one):

    >>> spph = SourcePackagePublishingHistory.get(8)
    >>> spph.sourcepackagerelease.name, spph.distroseries.name
    (u'pmount', u'hoary')

Verify if the object follows its interface contracts:

    >>> from canonical.launchpad.webapp.testing import verifyObject
    >>> from canonical.launchpad.interfaces import (
    ...     ISourcePackageRelease, IDistroSeries,
    ...     ISourcePackagePublishingHistory,
    ...     IBinaryPackagePublishingHistory,
    ...     ISourcePackage,
    ...     IDistributionSourcePackageRelease)

    >>> verifyObject(ISourcePackagePublishingHistory, spph)
    True

 XXX cprov 20060322: None of the attributes below pass verifyObject().
 So, they claim to implement some thing they don't really have. Most
 of the problems are related with bad interface inheritance.

    >>> IDistroSeries.providedBy(spph.distroseries)
    True

    >>> ISourcePackageRelease.providedBy(spph.sourcepackagerelease)
    True

    >>> ISourcePackageRelease.providedBy(spph.supersededby)
    True

    >>> IDistributionSourcePackageRelease.providedBy(
    ...     spph.meta_sourcepackagerelease)
    True

    >>> IDistributionSourcePackageRelease.providedBy(spph.meta_supersededby)
    True

    >>> ISourcePackage.providedBy(spph.meta_sourcepackage)
    True

ISourcePackagePublishingHistory has some handy shortcuts to get textual
representations of the source package name, version, component and section.
This is mostly as a convenience to API users so that we don't need to export
tiny 2-column content classes and force the users to retrieve those.

    >>> print spph.source_package_name
    pmount

    >>> print spph.source_package_version
    0.1-1

    >>> print spph.component_name
    main

    >>> print spph.section_name
    base

There is also a property that returns the changesfile URL.  This is proxied
through the webapp rather than being a librarian URL because the changesfile
could be private and thus in the restricted librarian.

    >>> from canonical.archiveuploader.tests import (
    ...     insertFakeChangesFileForAllPackageUploads)
    >>> insertFakeChangesFileForAllPackageUploads()

The pmount source has no packageupload in the sampledata:

    >>> print spph.changes_file_url
    None

The iceweasel source has good data:

    >>> pub = spph.archive.getPublishedSources(name="iceweasel")[0]
    >>> print pub.changes_file_url
    http://launchpad.dev/ubuntu/+archive/primary/+files/mozilla-firefox_0.9_i386.changes

A helper is also included to create a summary of the build statuses for
the spph's related builds, getStatusSummaryForBuilds(), which just
augments the IBuildSet.getStatusSummaryForBuilds() method to include the
'pending' state when builds are fully built but not yet published.

    >>> from canonical.launchpad.tests.test_publishing import (
    ...     SoyuzTestPublisher)
    >>> from canonical.launchpad.interfaces.build import BuildStatus
    >>> stp = SoyuzTestPublisher()
    >>> stp.prepareBreezyAutotest()
    >>> spph = stp.getPubSource(architecturehintlist='any')
    >>> builds = spph.createMissingBuilds()
    >>> for build in builds:
    ...     build.buildstate = BuildStatus.FULLYBUILT

Create a helper for printing the build status summary:

    >>> def print_build_status_summary(summary):
    ...     print summary['status'].title
    ...     for build in summary['builds']:
    ...         print build.title
    >>> build_status_summary = spph.getStatusSummaryForBuilds()
    >>> print_build_status_summary(build_status_summary)
    FULLYBUILT_PENDING
    hppa build of foo 666 in ubuntutest breezy-autotest RELEASE
    i386 build of foo 666 in ubuntutest breezy-autotest RELEASE

If one of the builds becomes published, it will not appear in the summary:

    >>> from canonical.launchpad.interfaces.publishing import (
    ...     PackagePublishingStatus)
    >>> bpr = stp.uploadBinaryForBuild(builds[0], 'foo-bin')
    >>> bpph = stp.publishBinaryInArchive(bpr, spph.archive,
    ...     status=PackagePublishingStatus.PUBLISHED)
    >>> print_build_status_summary(spph.getStatusSummaryForBuilds())
    FULLYBUILT_PENDING
    i386 build of foo 666 in ubuntutest breezy-autotest RELEASE

After publishing the second binary, the status changes to FULLYBUILT as
per normal:

    >>> bpr = stp.uploadBinaryForBuild(builds[1], 'foo-bin')
    >>> bpph = stp.publishBinaryInArchive(bpr, spph.archive,
    ...     status=PackagePublishingStatus.PUBLISHED)
    >>> print_build_status_summary(spph.getStatusSummaryForBuilds())
    FULLYBUILT
    hppa build of foo 666 in ubuntutest breezy-autotest RELEASE
    i386 build of foo 666 in ubuntutest breezy-autotest RELEASE

If a build is deleted, it does not cause the build status summary to change:

    >>> from canonical.launchpad.interfaces import IPersonSet
    >>> from canonical.launchpad.interfaces.publishing import IPublishingSet
    >>> sabdfl = getUtility(IPersonSet).getByName('sabdfl')
    >>> ignored = getUtility(IPublishingSet).requestDeletion([spph], sabdfl)
    >>> import transaction
    >>> transaction.commit()
    >>> print_build_status_summary(spph.getStatusSummaryForBuilds())
    FULLYBUILT
    hppa build of foo 666 in ubuntutest breezy-autotest RELEASE
    i386 build of foo 666 in ubuntutest breezy-autotest RELEASE

IBinaryPackagePublishingHistory also contains similar API conveniences.

    >>> bpph = stp.getPubBinaries()[0]
    >>> verifyObject(IBinaryPackagePublishingHistory, bpph)
    True

    >>> print bpph.binary_package_name
    foo-bin

    >>> print bpph.binary_package_version
    666

    >>> print bpph.component_name
    main

    >>> print bpph.section_name
    base


== Stanza generation ==

    >>> from canonical.launchpad.interfaces import (
    ...     IArchiveSafePublisher,
    ...     IBinaryPackagePublishingHistory,
    ...     ISourcePackageFilePublishing,
    ...     ISecureSourcePackagePublishingHistory,
    ...     ISecureBinaryPackagePublishingHistory)

Retrieve any SourcePackagePublishingHistory entry.

    >>> spph = SourcePackagePublishingHistory.get(10)

    >>> verifyObject(ISourcePackagePublishingHistory, spph)
    True

    >>> print spph.displayname
    alsa-utils 1.0.8-1ubuntu1 in warty

A 'stanza' is the name given to a group of attributes related to one
source or binary package in the archive index file, it provides
information to APT, things like, package name, pool path, DSC format,
files checksum, etc.

The archive index should contain one entry for each source or binary
currently published in the archive, it is usually partionated by
component:

<mirror_url_base>/ubuntu/edgy/main/binary-i386/Packages
<mirror_url_base>/ubuntu/edgy/main/source/Sources

The archive index is also available in in compressed formats.

    >>> print spph.getIndexStanza() #doctest: -NORMALIZE_WHITESPACE
    Package: alsa-utils
    Binary: alsa-mixer
    Version: 1.0.8-1ubuntu1
    Section: base
    Maintainer: Mark Shuttleworth <sabdfl@hbd.com>
    Architecture: all
    Standards-Version: 3.6.2
    Format: 1.0
    Directory: pool/main/a/alsa-utils
    Files:
     01234567890123456789012345678925 3 alsa-utils_1.0.8-1ubuntu1.dsc

Empty fields like are suppressed, like 'Build-Depends' or
'Build-Depends-Indep' to avoid extra charge on download.
See sourcepackagerelease.txt for further information about the fields
in question.

Files published are accessible via the files property:

    >>> any_pub_file = spph.files[-1]
    >>> ISourcePackageFilePublishing.providedBy(any_pub_file)
    True

    >>> [(pub_file.libraryfilealias.filename, pub_file.file_type_name,
    ...   pub_file.archive_url) for pub_file in spph.files]
    [(u'alsa-utils_1.0.8-1ubuntu1.dsc', 'dsc',
      u'http://ftpmaster.internal/ubuntu/pool/main/a/alsa-utils/alsa-utils_1.0.8-1ubuntu1.dsc')]


== Deletion and obsolescence ==

ArchivePublisherBase, which is common to SourcePackagePublishingHistory
and BinaryPackagePublishingHistory, contains the methods requestDeletion
and requestObsolescence.  These will change the publishing record to
the states DELETED and OBSOLETE respectively.

requestDeletion requires a removed_by (IPerson) and optionally a
removal_comment argument.

    >>> from canonical.launchpad.interfaces import IPersonSet
    >>> from zope.component import getUtility
    >>> sabdfl = getUtility(IPersonSet).getByName('sabdfl')
    >>> modified_spph = spph.requestDeletion(sabdfl, "testing deletion")

Inspecting the modified record shows it's ready for domination:

    >>> from canonical.database.sqlbase import get_transaction_timestamp
    >>> transaction_timestamp = get_transaction_timestamp()

    >>> modified_spph.status
    <DBItem PackagePublishingStatus.DELETED, (4) Deleted>

    >>> modified_spph.datesuperseded == transaction_timestamp
    True

    >>> print modified_spph.removed_by.name
    sabdfl

    >>> print modified_spph.removal_comment
    testing deletion

requstObsolescence takes no additional arguments:

    >>> modified_spph = spph.requestObsolescence()

Inspecting the modified record shows it's ready for death row (obsoleted
publications skip domination because domination only works in post-release
pockets for stable distroseries):

    >>> modified_spph.status
    <DBItem PackagePublishingStatus.OBSOLETE, (5) Obsolete>

    >>> modified_spph.scheduleddeletiondate == transaction_timestamp
    True


== Copying and published binarypackages lookup ==

ISourcePackagePublishingHistory provides the getPublishedBinaries
which returns all published binaries build from a source in the pocket
it is published.

We will use SoyuzTestPublisher to generate coherent publications to
test this feature.

    >>> from canonical.launchpad.tests.test_publishing import (
    ...      SoyuzTestPublisher)
    >>> test_publisher = SoyuzTestPublisher()

    >>> from canonical.launchpad.ftests import login
    >>> login('foo.bar@canonical.com')

    >>> test_publisher.prepareBreezyAutotest()

We will create a publication for a source (foo) and two
architecture-specific binaries in ubuntu/breezy-autotest.

    >>> from canonical.launchpad.interfaces import (
    ...     PackagePublishingStatus, PackagePublishingPocket)
    >>> source = test_publisher.getPubSource(
    ...     architecturehintlist='any',
    ...     status=PackagePublishingStatus.PUBLISHED,
    ...     pocket=PackagePublishingPocket.PROPOSED)
    >>> binaries = test_publisher.getPubBinaries(
    ...     pub_source=source,
    ...     status=PackagePublishingStatus.PUBLISHED,
    ...     pocket=PackagePublishingPocket.PROPOSED)

    >>> print source.displayname
    foo 666 in breezy-autotest

    >>> for bin in binaries:
    ...     print bin.displayname
    foo-bin 666 in breezy-autotest i386
    foo-bin 666 in breezy-autotest hppa

Using the source publication, ISecureSourcePackagePublishingHistory, we
can obtain the published binaries.

    >>> created_ids = [bin.id for bin in binaries]
    >>> retrieved_ids = [bin.id for bin in source.getPublishedBinaries()]
    >>> sorted(created_ids) == sorted(retrieved_ids)
    True

We can also inspect the builds created for a source publication
without retrieving its binaries.

    >>> for build in source.getBuilds():
    ...     print build.title
    hppa build of foo 666 in ubuntutest breezy-autotest PROPOSED
    i386 build of foo 666 in ubuntutest breezy-autotest PROPOSED

Now that we know how to retrieve generated binary publication related
to a source publication we can exercise the API provided to copy
publications across suites and/or archives.

One of the most common use-cases for copying a publication is when
archive-admins wants to release for public audience a Stable Release
Update (SRU) which was successfully tested in PROPOSED pocket. This
procedure will consist of a source copy from PROPOSED to UPDATES
including its binaries.

'distroseries' and 'archive' will be constant.

    >>> distroseries = source.distroseries
    >>> archive = source.archive

'pocket' will be UPDATES.

    >>> pocket = PackagePublishingPocket.UPDATES

Let's perform the copy of the source and all its binaries.

    >>> copied_source = source.copyTo(distroseries, pocket, archive)

    >>> copied_binaries = []
    >>> for bin in binaries:
    ...     copied_binaries.extend(
    ...         bin.copyTo(distroseries, pocket, archive))

The 'copied' records are instances of
{Source,Binary}PackagePublishingHistory:

    >>> ISourcePackagePublishingHistory.providedBy(copied_source)
    True

    >>> [IBinaryPackagePublishingHistory.providedBy(bin)
    ...  for bin in copied_binaries]
    [True, True]

Copied publications are created as PENDING, so the publisher will have
a chance to verify it's contents and include it in the destination
archive index.

    >>> print copied_source.status.name
    PENDING

    >>> for bin in copied_binaries:
    ...     print bin.status.name
    PENDING
    PENDING

Let's retrieve the 'insecure' corresponding publishing records since
only they provide the API we are interested in.

    >>> copied_source = SourcePackagePublishingHistory.get(copied_source.id)

    >>> copied_binaries = [BinaryPackagePublishingHistory.get(bin.id)
    ...                    for bin in copied_binaries]

When we call createMissingBuilds method on the copied sources it won't
create any builds since the binaries were copied over too.

    >>> copied_source.createMissingBuilds()
    []

Now we can observe that both, the original and the copied sources are
related only with their corresponding binaries, see bug #181834 for
previous broken implementation in this area.

    >>> for bin in source.getPublishedBinaries():
    ...     print bin.displayname, bin.pocket.name, bin.status.name
    foo-bin 666 in breezy-autotest hppa PROPOSED PUBLISHED
    foo-bin 666 in breezy-autotest i386 PROPOSED PUBLISHED

    >>> for bin in copied_source.getPublishedBinaries():
    ...     print bin.displayname, bin.pocket.name, bin.status.name
    foo-bin 666 in breezy-autotest hppa UPDATES PENDING
    foo-bin 666 in breezy-autotest i386 UPDATES PENDING

Note that even PENDING binary publications are returned by
getPublishedBinaries(), it considers both PENDING and PUBLISHED status
as active, SUPERSEDED, DELETED and OBSOLETE are excluded. Differently,
getBuiltBinaries() follows binaries in any state.

    >>> len(source.getPublishedBinaries())
    2

    >>> len(source.getBuiltBinaries())
    2

Note that getPublishedBinaries() returns a SelectResult and
getBuiltBinaries() returns a list.

When we supersede one of the original binary publications, it gets
excluded from the getPublishedBinaries() results, but not from the
getBuiltBinaries() result.

    >>> from canonical.launchpad.ftests import syncUpdate

    >>> a_binary = source.getPublishedBinaries()[0]
    >>> superseded = a_binary.supersede()
    >>> syncUpdate(superseded)

    >>> len(source.getPublishedBinaries())
    1

    >>> len(source.getBuiltBinaries())
    2

The same happens when we delete the i386 binary, so no binaries are
published in the original location.

    >>> deleted = source.getPublishedBinaries()[0].requestDeletion(
    ...     sabdfl, "go")
    >>> syncUpdate(deleted)

    >>> len(source.getPublishedBinaries())
    0

    >>> len(source.getBuiltBinaries())
    2

Finally we will mark both copied binary publication as obsolete and
verify that the getPublishedBinaries() result is also empty after that.

    >>> len(copied_source.getPublishedBinaries())
    2

    >>> for bin in copied_source.getPublishedBinaries():
    ...     obsoleted = bin.requestObsolescence()
    ...     syncUpdate(obsoleted)

    >>> len(copied_source.getPublishedBinaries())
    0

    >>> len(copied_source.getBuiltBinaries())
    2

Additionally to find all built binaries regardless of their states,
getBuiltBinaries() also excludes the duplications generated by
overrides.

Before performing an overriding we will move the all built binaries in
the copied location to PUBLISHED, so they can be visible again for
getPublishedBinaries().

    >>> for pub in copied_source.getBuiltBinaries():
    ...     secure_record = pub.secure_record
    ...     secure_record.status = PackagePublishingStatus.PUBLISHED
    ...     secure_record.scheduleddeletiondate = None
    ...     syncUpdate(secure_record)

Now we override the first binary publication, the hppa one, to
component 'universe'.

    >>> from canonical.launchpad.interfaces import IComponentSet
    >>> universe = getUtility(IComponentSet)['universe']

    >>> first_binary = copied_source.getPublishedBinaries()[0]
    >>> override = first_binary.changeOverride(new_component=universe)

Not only do the two copied binaries show up in getPublishedBinaries(),
but also the override just done.

    >>> for pub in copied_source.getPublishedBinaries():
    ...     print pub.displayname, pub.component.name
    foo-bin 666 in breezy-autotest hppa universe
    foo-bin 666 in breezy-autotest hppa main
    foo-bin 666 in breezy-autotest i386 main

The publication duplication is solved in the publishing pipeline,
specifically in the 'domination' state. See
`archivepublisher.tests.test_dominator` for more information.

On the other hand, getBuiltBinaries() will return only 2 binary
publications and the hppa one is the overridden one.

    >>> for pub in copied_source.getBuiltBinaries():
    ...     print pub.displayname, pub.component.name
    foo-bin 666 in breezy-autotest hppa universe
    foo-bin 666 in breezy-autotest i386 main

We have to re-publish the superseded and the deleted publications above
because it's used below.

    >>> superseded.status = PackagePublishingStatus.PUBLISHED
    >>> syncUpdate(superseded)
    >>> deleted.status = PackagePublishingStatus.PUBLISHED
    >>> syncUpdate(deleted)


== Copying and inspecting architecture independent binaries ==

copyTo() behaves differently for architecture independent and
architecture specific binaries. We will create a
architecture-independent publication called 'pirulito' perform a copy
using it.

    >>> source_all = test_publisher.getPubSource(
    ...     sourcename='pirulito', architecturehintlist='all',
    ...     status=PackagePublishingStatus.PUBLISHED,
    ...     pocket=PackagePublishingPocket.PROPOSED)

    >>> binaries_all = test_publisher.getPubBinaries(
    ...     binaryname='pirulito', pub_source=source_all,
    ...     status=PackagePublishingStatus.PUBLISHED,
    ...     pocket=PackagePublishingPocket.PROPOSED)

    >>> print source_all.displayname
    pirulito 666 in breezy-autotest

    >>> for bin in binaries_all:
    ...     print bin.displayname
    pirulito 666 in breezy-autotest i386
    pirulito 666 in breezy-autotest hppa

Sources are treated in the same way, one publication for each copy
request.

    >>> copied_source_all = source_all.copyTo(distroseries, pocket, archive)

    >>> print copied_source_all.displayname
    pirulito 666 in breezy-autotest

Architecture independent binaries, however, when copied results in
multiple publications, one for it supported architecture in the
destination distroseries. In other words, arch-indep copying is
atomic.

    >>> [bin_i386, bin_hppa] = binaries_all

    >>> bin_i386.binarypackagerelease == bin_hppa.binarypackagerelease
    True

    >>> bin_i386.binarypackagerelease.architecturespecific
    False

    >>> binary_copies = bin_i386.copyTo(distroseries, pocket, archive)

The same binary is published in both supported architecture.

    >>> for bin in binary_copies:
    ...     print bin.displayname
    pirulito 666 in breezy-autotest hppa
    pirulito 666 in breezy-autotest i386

getPublishedBinaries() on the copied sources returns both binary
publications, even if they refer to the same architecture independent
binary.

    >>> copied_binaries_all = copied_source_all.getPublishedBinaries()

    >>> for bin in copied_binaries_all:
    ...     print bin.displayname
    pirulito 666 in breezy-autotest hppa
    pirulito 666 in breezy-autotest i386

    >>> [copy_i386, copy_hppa] = copied_binaries_all

    >>> copy_i386.binarypackagerelease == copy_hppa.binarypackagerelease
    True

getBuiltBinaries(), on the other hand, returns only one publication
(the one for the 'nominatedarchindep' architecture in the destination
distroseries).

    >>> [built_binary] = copied_source_all.getBuiltBinaries()

    >>> print built_binary.displayname
    pirulito 666 in breezy-autotest i386


== Copying to PPAs ==

Another common copy use-case is rebuild the same source in another
suite. To simulate this we will create a publication in Celso's PPA.

    >>> cprov = getUtility(IPersonSet).getByName('cprov')

    >>> ppa_source = test_publisher.getPubSource(
    ...     archive=cprov.archive,
    ...     status=PackagePublishingStatus.PUBLISHED)
    >>> ppa_binaries = test_publisher.getPubBinaries(
    ...     pub_source=ppa_source,
    ...     status=PackagePublishingStatus.PUBLISHED)

    >>> print ppa_source.displayname, ppa_source.archive.displayname
    foo 666 in breezy-autotest PPA for Celso Providelo

    >>> for bin in ppa_binaries:
    ...     print bin.displayname, bin.archive.displayname
    foo-bin 666 in breezy-autotest i386 PPA for Celso Providelo
    foo-bin 666 in breezy-autotest hppa PPA for Celso Providelo

Now we will copy only the source from Celso's PPA breezy-autotest to
hoary-test.

    >>> breezy_autotest = ppa_source.distroseries
    >>> hoary_test = breezy_autotest.distribution.getSeries(
    ...     'hoary-test')
    >>> hoary_test.nominatedarchindep = hoary_test["i386"]
    >>> fake_chroot = test_publisher.addMockFile('fake_chroot.tar.gz')
    >>> trash = hoary_test["i386"].addOrUpdateChroot(fake_chroot)

Perform the source-only copy.

    >>> ppa_copied_source = ppa_source.copyTo(
    ...     hoary_test, PackagePublishingPocket.RELEASE, cprov.archive)

    >>> ppa_copied_source = SourcePackagePublishingHistory.get(
    ...     ppa_copied_source.id)

Since it's a rebuild we can immediately create the corresponding
builds.

    >>> builds = ppa_copied_source.createMissingBuilds()

    >>> for build in builds:
    ...     print build.title
    i386 build of foo 666 in ubuntutest hoary-test RELEASE

If createMissingBuilds get called again on either sources no builds
will get created.

    >>> ppa_source.createMissingBuilds()
    []

    >>> ppa_copied_source.createMissingBuilds()
    []

In the sampledata, both, hoary-test and breezy-autotest derives from
ubuntu/warty. To make it more realistic we will make hoary-test derive
from breezy-autotest and test if the build algorithm copes with it.

This simulates a rebuild in of the same source in a more recent
distroseries, like rebuilding SRUs for constant sources.

    >>> breezy_autotest.parent_series = None
    >>> hoary_test.parent_series = breezy_autotest

    >>> ppa_source.createMissingBuilds()
    []

    >>> ppa_copied_source.createMissingBuilds()
    []

Now, let's check the opposite, as if the copy was from a more recent
distroseries to a older one, like a backport rebuild.

    >>> breezy_autotest.parent_series = hoary_test
    >>> hoary_test.parent_series = None

    >>> ppa_source.createMissingBuilds()
    []

    >>> ppa_copied_source.createMissingBuilds()
    []

It is also possible to copy sources and binaries to another
distroseries within the same PPA. That's usually the case for
architecture-independent sources.

    >>> ppa_source = test_publisher.getPubSource(
    ...     archive=cprov.archive, version="999",
    ...     status=PackagePublishingStatus.PUBLISHED)

    >>> ppa_binaries = test_publisher.getPubBinaries(
    ...     pub_source=ppa_source,
    ...     status=PackagePublishingStatus.PUBLISHED)

Let's perform the copy of the source and its i386 binary.

    >>> series = hoary_test
    >>> pocket = PackagePublishingPocket.RELEASE
    >>> archive = cprov.archive

    >>> copied_source = ppa_source.copyTo(series, pocket, archive)

    >>> ppa_binary_i386 = ppa_binaries[0]
    >>> print ppa_binary_i386.displayname
    foo-bin 999 in breezy-autotest i386

    >>> copied_binary = ppa_binary_i386.copyTo(series, pocket, archive)

The source and binary are present in hoary-test:

    >>> copied_source = SourcePackagePublishingHistory.get(copied_source.id)
    >>> print copied_source.displayname
    foo 999 in hoary-test

    >>> for bin in copied_source.getPublishedBinaries():
    ...     print bin.displayname
    foo-bin 999 in hoary-test amd64
    foo-bin 999 in hoary-test i386

So, no builds are created.

    >>> copied_source.createMissingBuilds()
    []


== getSourceAndBinaryLibraryFiles ==

This method retrieves LibraryFileAlias records for all source and binary
files associated with this publication.

Using the same Ubuntu source publishing example as above:

    >>> for file in source.getSourceAndBinaryLibraryFiles():
    ...     print file.filename
    foo-bin_666_hppa.deb
    foo-bin_666_i386.deb
    foo_666.dsc

We can also publish a package in a PPA and query on its files:

    >>> ppa_source = test_publisher.getPubSource(
    ...     status=PackagePublishingStatus.PUBLISHED,
    ...     archive=cprov.archive)
    >>> ppa_binaries= test_publisher.getPubBinaries(
    ...     pub_source=ppa_source,
    ...     status=PackagePublishingStatus.PUBLISHED)

    >>> for file in ppa_source.getSourceAndBinaryLibraryFiles():
    ...     print file.filename
    foo-bin_666_all.deb
    foo_666.dsc


== Publishing records age ==

Both ISourcePackagePublishingHistory and IBinaryPackagePublishingHistory
implement the 'age' property which return a timedelta representing
"NOW - datecreated".

    >>> ppa_source.age
    datetime.timedelta(...)

    >>> ppa_binaries[0].age
    datetime.timedelta(...)


== Secure Source Publishing ==

'secure_record' returns a ISecureSourcePackagePublishing instance
corresponding to this publication. This instance also implements
IArchiveSafePublisher.

    >>> sspph = spph.secure_record
    >>> ISecureSourcePackagePublishingHistory.providedBy(sspph)
    True
    >>> verifyObject(IArchiveSafePublisher, sspph)
    True
    >>> sspph.embargo
    False


== Binary and Binary File Publishing ===

Symmetric behaviour is offered for BinaryPackagePublishing,
BinaryPackageFile and ISecureBinaryPackagePublishingHistory

    >>> from canonical.launchpad.interfaces import (
    ...     IBinaryPackageFilePublishing)

    >>> bpph = BinaryPackagePublishingHistory.get(15)
    >>> print bpph.displayname
    mozilla-firefox 0.9 in woody i386

    >>> IBinaryPackagePublishingHistory.providedBy(bpph)
    True

Generating respective "Packages" stanzas:

    >>> print bpph.getIndexStanza() #doctest: -NORMALIZE_WHITESPACE
    Package: mozilla-firefox
    Source: mozilla-firefox
    Priority: important
    Section: editors
    Maintainer: Mark Shuttleworth <mark@canonical.com>
    Architecture: i386
    Version: 0.9
    Recommends: gcc-3.4-base, libc6 (>= 2.3.2.ds1-4), gcc-3.4 (>= 3.4.1-4sarge1), gcc-3.4 (<< 3.4.2), libstdc++6-dev (>= 3.4.1-4sarge1)
    Replaces: gnome-mozilla-browser
    Suggests: firefox-gnome-support (= 1.0.7-0ubuntu20), latex-xft-fonts, xprint
    Provides: mozilla-firefox
    Depends: gcc-3.4-base, libc6 (>= 2.3.2.ds1-4), gcc-3.4 (>= 3.4.1-4sarge1), gcc-3.4 (<< 3.4.2), libstdc++6-dev (>= 3.4.1-4sarge1)
    Conflicts: firefox, mozilla-web-browser
    Pre-Depends: pmount, foo
    Enhances: pmount, bar
    Breaks: pmount, baz
    Filename: pool/universe/m/mozilla-firefox/mozilla-firefox_0.9_i386.deb
    Size: 3
    MD5sum: 01234567890123456789012345678926
    SHA1: 5a04c7b5ea3f0fdbc95d0dd47f3c5bc275da8a33
    Description: Mozilla Firefox Web Browser
     Mozilla Firefox Web Browser is .....

    >>> sbpph = bpph.secure_record
    >>> ISecureBinaryPackagePublishingHistory.providedBy(sbpph)
    True
    >>> verifyObject(IArchiveSafePublisher, sbpph)
    True
    >>> sbpph.embargo
    False

    >>> any_file = bpph.files[-1]
    >>> IBinaryPackageFilePublishing.providedBy(any_file)
    True

    >>> [pub_file.libraryfilealias.filename for pub_file in bpph.files]
    [u'mozilla-firefox_0.9_i386.deb']

    >>> [pub_file.archive_url for pub_file in bpph.files]
    [u'http://ftpmaster.internal/debian/pool/universe/m/mozilla-firefox/mozilla-firefox_0.9_i386.deb']


== IPublishingSet ==

This utility implements the following methods:

 * getBuildsForSources();
 * getFilesForSources();
 * getBinaryPublicationsForSources();
 * getPackageDiffsForSources();

They receive a list of `SourcePackagePublishingHistory` objects and
fetch the corresponding information for all of them.

Their returned `ResultSet` (they all use storm natively) follows a
pattern:

 * (`SourcePackagePublishingHistory`, <object>, [prejoins,])

This way the useful references gets cached and the callsites can group
the results as necessary.

The `IPublishingSet` methods are also used to implement the corresponding
features in `ISourcePackagePublishingHistory`:

 * getBuilds -> IPublishingSet.getBuildsForSources;
 * getSourceAndBinaryLibraryFiles -> IPublishingSet.getFilesForSources;
 * getPublishedBinaries -> IPublishingSet.getBinaryPublicationsForSources;

So, they were already tested implicitly before in this file, the
simply use the IPublishing methods passing only a single source
publication. Now we will document how they work for multiple source
publications.

IPublishingSet is an essential component for
`ArchiveSourcePublications` feature, see more  information below in
its corresponding test section.

    >>> from canonical.launchpad.interfaces.publishing import (
    ...     IPublishingSet)

    >>> publishing_set = getUtility(IPublishingSet)

    >>> verifyObject(IPublishingSet, publishing_set)
    True

We will assembly a list of source publications based on what was
ever published in Celso's PPA.

    >>> cprov = getUtility(IPersonSet).getByName('cprov')
    >>> cprov_sources = list(cprov.archive.getPublishedSources())
    >>> len(cprov_sources)
    8

Now that we have a set of source publications let's get the builds in
its context.

    >>> cprov_builds = publishing_set.getBuildsForSources(cprov_sources)

It returns a `ResultSet` and it contains 3-element tuples as
`SourcePackagePublishingHistory`, `Build` and `DistroArchseries` for
each build found.

    >>> cprov_builds.count()
    7

The `ResultSet` is ordered by ascending
`SourcePackagePublishingHistory.id` and ascending
`DistroArchseries.architecturetag` in this order.

    >>> source_pub, build, arch = cprov_builds.last()

    >>> print source_pub.displayname
    foo 666 in breezy-autotest

    >>> print build.title
    i386 build of foo 666 in ubuntutest breezy-autotest RELEASE

    >>> print arch.displayname
    ubuntutest Breezy Badger Autotest i386

Now we retrieve all binary publications for Celso's PPA sources.

    >>> cprov_binaries = publishing_set.getBinaryPublicationsForSources(
    ...     cprov_sources)

The returned `ResultSet` contains 5-element tuples as
(`SourcePackagePublishingHistory`, `BinaryPackagePublishingHistory`,
 `BinaryPackageRelease`, `BinaryPackageName`, `DistroArchSeries`).

    >>> cprov_binaries.count()
    11

This result is ordered by ascending
`SourcePackagePublishingHistory.id`, ascending `BinaryPackageName.name`,
ascending `DistroArchSeries.architecturetag and descending
`BinaryPackagePublishingHistory.id`.

    >>> (source_pub, binary_pub, binary, binary_name,
    ...  arch) = cprov_binaries.last()

    >>> print source_pub.displayname
    foo 666 in breezy-autotest

    >>> print binary_pub.displayname
    foo-bin 666 in breezy-autotest i386

    >>> print binary.title
    foo-bin-666

    >>> print binary_name.name
    foo-bin

    >>> print arch.displayname
    ubuntutest Breezy Badger Autotest i386

We can retrieve all files related with Celso's PPA publications.

    >>> cprov_files = publishing_set.getFilesForSources(
    ...     cprov_sources)

This `ResultSet` contains 3-element tuples as
(`SourcePackagePublishingHistory`, `LibraryFileAlias`,
`LibraryFileContent`)

    >>> cprov_files.count()
    14

This result are not ordered since it comes from SQL UNION, so call
sites are responsible to order them appropriately. So, can can only
check that they unpack as specified, a 3-element tuple.

    >>> source, file, content = cprov_files.any()

    >>> ordered_filenames = sorted(
    ...    file.filename for source, file, content in cprov_files)

    >>> print ordered_filenames[-1]
    firefox-0.9.2.orig.tar.gz

getPackageDiffsForSources() is also provided by `IPublishingSet`, it
allows callsites to retrieve all related `PackageDiff` records based
on a collection of source publications.

The sampledata does not contain any `PackageDiff`s, thus nothing is
returned for the Celso's sources.

    >>> cprov_diffs = publishing_set.getPackageDiffsForSources(
    ...     cprov_sources)

    >>> cprov_diffs.count()
    0

For testing purposes we will create a `PackageDiff` for Celso's
'pmount' and another for Celso's 'iceweasel' sources.

    >>> a_source = cprov_sources[-2]
    >>> print a_source.displayname
    iceweasel 1.0 in warty

    >>> to_source = cprov_sources[-1]
    >>> print to_source.displayname
    pmount 0.1-1 in warty

    >>> pmount_diff = a_source.sourcepackagerelease.requestDiffTo(
    ...     cprov, to_source.sourcepackagerelease)
    >>> print pmount_diff.title
    1.0 (in Ubuntu) to 0.1-1

    >>> iceweasel_diff = to_source.sourcepackagerelease.requestDiffTo(
    ...     cprov, a_source.sourcepackagerelease)
    >>> print iceweasel_diff.title
    0.1-1 (in Ubuntu) to 1.0

    >>> from canonical.database.sqlbase import flush_database_updates
    >>> flush_database_updates()

The `PackageDiff` are availble via getPackageDiffsForSources() even if
they are not completed yet.

    >>> cprov_diffs.count()
    2

Let's fulfill the file related with the 'pmount' diff.

    >>> from canonical.launchpad.interfaces.librarian import (
    ...     ILibraryFileAliasSet)

    >>> diff_file = getUtility(ILibraryFileAliasSet)[1]

    >>> from zope.security.proxy import removeSecurityProxy
    >>> naked_diff = removeSecurityProxy(pmount_diff)
    >>> naked_diff.diff_content = diff_file
    >>> flush_database_updates()

getPackageDiffsForSources() returns a list of 4-element tuple, ordered
by ascending publishing id and descending `PackageDiff` creation date,
containing:

 * `SourcePackagePublishingHistory`;
 * `PackageDiff`;
 * `LibraryFileAlias`;
 * `LibraryFileContent`.

    >>> [iceweasel_diff, pmount_diff] = cprov_diffs

    >>> source_pub, diff, file, content = pmount_diff

    >>> print source_pub.displayname
    pmount 0.1-1 in warty

    >>> print diff.title
    1.0 (in Ubuntu) to 0.1-1

    >>> print file.filename
    netapplet-1.0.0.tar.gz

    >>> print content.md5
    01234567890123456789012345678900

All elements of the result are present, even if they do not correspond
to actual objects in the database, which is the case of pending diff
requests. On pending diffs, `LibraryFileAlias` and
`LibraryFileContent` elements are None.

    >>> source_pub, diff, file, content = iceweasel_diff

    >>> print source_pub.displayname
    iceweasel 1.0 in warty

    >>> print diff.title
    0.1-1 (in Ubuntu) to 1.0

    >>> print file
    None

    >>> print content
    None

getChangesFilesForSources(), provided by IPublishingSet, allows
call sites to retrieve all changesfiles related to a set of source
publications.

    >>> cprov_changes = publishing_set.getChangesFilesForSources(
    ...     cprov_sources)

    >>> cprov_changes.count()
    6

The returned ResultSet element is tuple containing:

 * `SourcePackagePublishingHistory`;
 * `PackageUpload`;
 * `SourcePackageRelease`;
 * `LibraryFileAlias`;
 * `LibraryFileContent`.

    >>> a_change = cprov_changes[0]

    >>> source_pub, upload, source, file, content = a_change

    >>> print source_pub.displayname
    iceweasel 1.0 in warty

    >>> print upload.displayname
    iceweasel

    >>> print source.title
    iceweasel - 1.0

    >>> print file.filename
    mozilla-firefox_0.9_i386.changes

    >>> print content.md5
    e4a7193a8f72fa2755e2162512069093

Last but not least the publishing set class allows for the bulk deletion
of publishing history records.

    >>> import operator
    >>> cprov_sources = sorted(list(
    ...     cprov.archive.getPublishedSources(
    ...     status=PackagePublishingStatus.PUBLISHED)),
    ...     key=operator.attrgetter('id'))
    >>> print len(cprov_sources)
    6

We will delete the first two source publishing history records and
need to know the number of associated binary publishing history
records.

    >>> cprov_binaries = publishing_set.getBinaryPublicationsForSources(
    ...     cprov_sources)
    >>> cprov_binaries.count()
    9

This is the published binary that will get deleted.

    >>> cprov_binaries = publishing_set.getBinaryPublicationsForSources(
    ...     cprov_sources[:2])
    >>> cprov_binaries.count()
    1

Let's get rid of the first two source publishing history records and their
associated binary publishing records now.

    >>> deleted = publishing_set.requestDeletion(
    ...     cprov_sources[:2], cprov, 'OOPS-934EC47')

The number of published sources will decrease by two as expected.

    >>> cprov_sources = list(
    ...     cprov.archive.getPublishedSources(
    ...     status=PackagePublishingStatus.PUBLISHED))
    >>> print len(cprov_sources)
    4

Analogously, the number of associated published binaries will be less
by one.

    >>> cprov_binaries = publishing_set.getBinaryPublicationsForSources(
    ...     cprov_sources)
    >>> cprov_binaries.count()
    8

Please note also that the source publishing records to be deleted must
be passed as a list. Otherwise an exception will be raised.

    >>> deleted = publishing_set.requestDeletion(
    ...     tuple(cprov_sources[:2]), cprov, 'OOPS-934EC47')
    Traceback (most recent call last):
    ...
    AssertionError: The 'sources' parameter must be a list.


== ArchiveSourcePublications ==

`ArchiveSourcePublications` wraps `IPublishingSet` methods to build a
set of objects which decorate `ISourcePackagePublishingHistory` with
cached references.

All references related with the given set of source publications are
fetch in a fixed number of queries (3) instead of varying according
the size of the set (3 * N).

     >>> from canonical.launchpad.components.archivesourcepublication import (
     ...     ArchiveSourcePublications)

We will use all published sources in Celso's PPA as our initial set.

    >>> cprov = getUtility(IPersonSet).getByName('cprov')
    >>> cprov_published_sources = cprov.archive.getPublishedSources(
    ...     status=PackagePublishingStatus.PUBLISHED)

We use the source publications to initialise
`ArchiveSourcePublications`.

    >>> decorated_set = ArchiveSourcePublications(cprov_published_sources)
    >>> empty_decorated_set = ArchiveSourcePublications([])

`ArchiveSourcePublications` implements __nonzero__, so callsites can
verify in advance whether there are elements to be iterated or not.

    >>> bool(decorated_set)
    True

    >>> bool(empty_decorated_set)
    False

Note that this check is *cheap* since it's based only on the given set
of source publications and doesn't require the class to fetch the
extra information. The extra information will be only fetch when the
set gets iterated.

The size of the `ArchiveSourcePublications` always matches the given
source publication set size:

    >>> cprov_published_sources.count()
    4

    >>> len(list(decorated_set))
    4

The decorated objects are returned in the same order used in the given
'source_publications'.

    >>> def compare_ids(given, returned):
    ...     given_ids = [obj.id for obj in given]
    ...     returned_ids = [obj.id for obj in returned]
    ...     if given_ids == returned_ids:
    ...        print 'Matches'
    ...     else:
    ...        print 'Mismatch:', given_ids, returned_ids

    >>> compare_ids(cprov_published_sources, decorated_set)
    Matches

Now we will shuffle the order of the given publications, ensure they are
different, and check if the order is respected:

    >>> original_sources_list = list(cprov_published_sources)
    >>> shuffled_sources_list = list(cprov_published_sources)

    >>> import random
    >>> while shuffled_sources_list == original_sources_list:
    ...     random.shuffle(shuffled_sources_list)

    >>> shuffled_decorated_list = ArchiveSourcePublications(
    ...      shuffled_sources_list)

The shuffled sources list order is respected by
ArchiveSourcePublication.

    >>> compare_ids(shuffled_sources_list, shuffled_decorated_list)
    Matches

And the order is not the same than the original source set.

    >>> compare_ids(original_sources_list, shuffled_decorated_list)
    Mismatch: ...

We will check a little bit of the `ArchiveSourcePublications`
internals. There are three essential methods to fetch distinct
information to be cached in the decorated objects:

  * getBuildsBySource;
  * getBinariesBySource;
  * getChangesFileBySources

They exclude the extra references ('prejoins') returned  from the
corresponding `IPublishingSet` methods and group the wanted results as
a dictionary, keyed by `SourcePackagePublishingHistory `, in way they
can be quickly looked up when building `ArchiveSourcePublications`.

    >>> real_pub = cprov_published_sources[0]

Builds by source.

    >>> builds_by_source = decorated_set.getBuildsBySource()

    >>> compare_ids(
    ...     real_pub.getBuilds(), builds_by_source.get(real_pub, []))
    Matches

Binary publications by source.

    >>> binaries_by_source = decorated_set.getBinariesBySource()

    >>> compare_ids(
    ...     real_pub.getPublishedBinaries(),
    ...     binaries_by_source.get(real_pub, []))
    Matches

getChangesFileBySources() returns a dictionary mapping each individual
source package publication to its corresponding changesfile (as a
LibraryFileAlias).

    >>> all_cprov_sources = cprov.archive.getPublishedSources()

We select the only available publication in Celso's PPA with a valid
changesfile in the sampledata.

    >>> pub_with_changes = all_cprov_sources[-2]
    >>> the_source = pub_with_changes.sourcepackagerelease
    >>> the_change = the_source.upload_changesfile
    >>> print the_change.filename
    mozilla-firefox_0.9_i386.changes

The same control-publication is reachable in the dictionary returned
by getChangesFileBySources().

    >>> decorated_changes = ArchiveSourcePublications(all_cprov_sources)
    >>> changes_by_source = decorated_changes.getChangesFileBySource()
    >>> decorated_change = changes_by_source.get(pub_with_changes)
    >>> print decorated_change.filename
    mozilla-firefox_0.9_i386.changes

Enough internals! What really matters for callsites is that, when
iterated, `ArchiveSourcePublications`returns `ArchiveSourcePublication`
objects that decorates `ISourcePackagePublishingHistory` and have
expensive references for other objects already cached. This makes the
whole difference when rendering PPA pages with many source
publications.

    >>> decorated_pub = list(decorated_set)[0]

    >>> print decorated_pub
    <...ArchiveSourcePublication ...>

    >>> verifyObject(ISourcePackagePublishingHistory, decorated_pub)
    True

`ArchiveSourcePublication` caches the returned values for following
methods:
  * sourcepackagerelease;
  * getBuilds;
  * getPublishedBinaries.

    >>> compare_ids(real_pub.getBuilds(), decorated_pub.getBuilds())
    Matches

    >>> compare_ids(
    ...     real_pub.getPublishedBinaries(),
    ...     decorated_pub.getPublishedBinaries())
    Matches

The 'sourcepackagerelease' attribute from a decorated
`ArchiveSourcePublication` object is also another decorated object,
this way we can cache information refered to:

 * upload_changesfile.

We select an arbitrary source publication from the Celso's PPA
sampledata which has no corresponding 'changesfile'. Both, the real
SourcePackageRelease object and the decorated one, reflect this
condition.

    >>> pub_with_changes = cprov_published_sources[-1]
    >>> the_source = pub_with_changes.sourcepackagerelease
    >>> print the_source.upload_changesfile
    None

    >>> decorated_pub_with_changes = list(decorated_set)[-1]
    >>> decorated_source = decorated_pub_with_changes.sourcepackagerelease
    >>> print decorated_source.upload_changesfile
    None

We can create a processed upload record for that publication, together
with a corresponding changesfiles.

    >>> upload_record = the_source.upload_distroseries.createQueueEntry(
    ...     PackagePublishingPocket.RELEASE, 'foo.changes', 'boing',
    ...     pub_with_changes.archive)
    >>> uploaded_source = upload_record.addSource(the_source)
    >>> upload_record.setDone()
    >>> print upload_record.changesfile.filename
    foo.changes

That done, the real and the decorated SourcePackageRelease objects
agree regarding the changesfile existence.

    >>> the_source = pub_with_changes.sourcepackagerelease
    >>> print the_source.upload_changesfile.filename
    foo.changes

    >>> decorated_pub_with_changes = list(decorated_set)[-1]
    >>> decorated_source = decorated_pub_with_changes.sourcepackagerelease
    >>> print decorated_source.upload_changesfile.filename
    foo.changes

`ArchiveSourcePublication` also has a decorated version of the 
getStatusSummaryForBuilds() method.

    >>> print_build_status_summary(
    ...     decorated_pub.getStatusSummaryForBuilds())
    FULLYBUILT
    i386 build of foo 999 in ubuntutest breezy-autotest RELEASE

We can verify that this decorated version is in fact using the cached
builds by explicitly modifying the cached builds on the delegate. We'll
modify the cached builds by appending the same build to the cached builds.

    >>> decorated_pub._builds += decorated_pub.getBuilds()
    >>> print_build_status_summary(
    ...     decorated_pub.getStatusSummaryForBuilds())
    FULLYBUILT
    i386 build of foo 999 in ubuntutest breezy-autotest RELEASE
    i386 build of foo 999 in ubuntutest breezy-autotest RELEASE


== IPublishingSet.getBuildStatusSummariesForSourceIdsAndArchive() ==

This extra method on IPublishingSet allows a summary of the build status
for a set of sources to be presented. The corresponding archive is a
required parameter that ensures that this method only
returns information about builds from the specified archive (as this method
is used via the API via IArchive.getBuildSummariesForSourceIds).

First we'll create two source publishing history records:

    >>> from canonical.launchpad.tests.test_publishing import (
    ...     SoyuzTestPublisher)
    >>> stp = SoyuzTestPublisher()
    >>> stp.prepareBreezyAutotest()
    >>> firefox_source_pub = stp.getPubSource(sourcename='firefox-test')
    >>> binaries = stp.getPubBinaries(pub_source=firefox_source_pub,
    ...     status=PackagePublishingStatus.PUBLISHED)
    >>> foo_pub = stp.getPubSource(sourcename='foobar-test')
    >>> binaries = stp.getPubBinaries(pub_source=foo_pub,
    ...     status=PackagePublishingStatus.PUBLISHED)

    >>> from lp.registry.interfaces.distribution import (
    ...     IDistributionSet)
    >>> ubuntu = getUtility(IDistributionSet)['ubuntu']
    >>> ubuntu_test = getUtility(IDistributionSet)['ubuntutest']

Create a small function for displaying the results:

    >>> def print_build_summary(summary):
    ...     print "%s\n%s\nRelevant builds:\n%s" % (
    ...         summary['status'].title,
    ...         summary['status'].description,
    ...         "\n".join(
    ...             " - %s" % build.title for build in summary['builds'])
    ...     )

    >>> def print_build_summaries(summaries):
    ...     count = 0
    ...     for source_id, summary in sorted(summaries.items()):
    ...         count += 1
    ...         print "Source number: %s" % count
    ...         print_build_summary(summary)

And then grab the build summaries for firefox and foo:

    >>> build_summaries = \
    ...     publishing_set.getBuildStatusSummariesForSourceIdsAndArchive(
    ...         [firefox_source_pub.id, foo_pub.id],
    ...         ubuntu_test.main_archive)
    >>> print_build_summaries(build_summaries)
    Source number: 1
    FULLYBUILT
    All builds were built successfully.
    Relevant builds:
     - i386 build of firefox-test 666 in ubuntutest breezy-autotest RELEASE
    Source number: 2
    FULLYBUILT
    All builds were built successfully.
    Relevant builds:
     - i386 build of foobar-test 666 in ubuntutest breezy-autotest RELEASE

Any of the source ids passed into 
getBuildStatusSummariesForSourceIdsAndArchive that do not belong to the
required archive parameter will be ignored:

    >>> build_summaries = \
    ...     publishing_set.getBuildStatusSummariesForSourceIdsAndArchive(
    ...         [firefox_source_pub.id, foo_pub.id],
    ...         archive=ubuntu.main_archive)
    >>> print_build_summaries(build_summaries)


