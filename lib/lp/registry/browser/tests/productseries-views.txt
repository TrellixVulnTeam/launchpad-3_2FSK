= Set Up =

We will have to check for a BranchJob being created for a branch, so
let's put this check in a convenient function.

    >>> from zope.component import getUtility
    >>> from lp.code.interfaces.branchjob import (
    ...     IRosettaUploadJobSource)
    >>> job_counter = 0
    >>> def isUploadJobCreatedForBranch(productseries,
    ...                                 force_translations_upload=None):
    ...     global job_counter
    ...     ready_jobs = list(getUtility(IRosettaUploadJobSource).iterReady())
    ...     if len(ready_jobs) <= job_counter:
    ...         return False
    ...     job = ready_jobs[job_counter]
    ...     job_counter += 1
    ...     if force_translations_upload is None:
    ...         return productseries.branch == job.branch
    ...     return (productseries.branch == job.branch and
    ...            force_translations_upload == job.force_translations_upload)

Also, we need to set-up a branch for the product of this productseries. The
last_mirrored_id and the last_scanned_id is set to the same value to pretend
that the branch has been mirrored and scanned.

    >>> def makeScannedProductBranch(productseries):
    ...     branch = factory.makeProductBranch(productseries.product)
    ...     branch.last_mirrored_id = "some_rev_id"
    ...     branch.last_scanned_id = "some_rev_id"
    ...     return branch

For these tasks we need to log in.

    >>> login('foo.bar@canonical.com')


= ProductSeriesLinkBranchView =

The ProductSeries is setup to sync translations from a branch but no branch
has been linked to the ProductSeries yet.

    >>> from canonical.launchpad.interfaces.translations import (
    ...     TranslationsBranchImportMode)
    >>> productseries = factory.makeProductSeries()
    >>> productseries.translations_autoimport_mode = (
    ...     TranslationsBranchImportMode.IMPORT_TEMPLATES)

When a branch is linked to the ProductSeries using this view, a new
BranchJob to upload translation files to rosetta is created.

    >>> from canonical.launchpad.webapp.servers import LaunchpadTestRequest
    >>> from lp.registry.browser.productseries import (
    ...     ProductSeriesLinkBranchView)
    >>> branch = makeScannedProductBranch(productseries)
    >>> request = LaunchpadTestRequest(
    ...     method='POST',
    ...     form={'field.branch': branch.unique_name,
    ...           'field.actions.update': 'Update'})
    >>> view = ProductSeriesLinkBranchView(
    ...     productseries, request)
    >>> view.initialize()
    >>> print isUploadJobCreatedForBranch(productseries)
    True

When a branch is removed from the ProductSeries using this view, no new
BranchJob is created.

    >>> branch = makeScannedProductBranch(productseries)
    >>> request = LaunchpadTestRequest(
    ...     method='POST',
    ...     form={'field.branch': '',
    ...           'field.actions.update': 'Update'})
    >>> view = ProductSeriesLinkBranchView(
    ...     productseries, request)
    >>> view.initialize()
    >>> print isUploadJobCreatedForBranch(productseries)
    False


= ProductSeriesTranslationsSettingsView =

Special settings for translations of a ProductSeries are set through
this view.

The ProductSeries instance has a branch set that contains the source
code.

    >>> productseries = factory.makeProductSeries()
    >>> productseries.branch = makeScannedProductBranch(productseries)

    >>> from lp.registry.browser.productseries import (
    ...     ProductSeriesTranslationsSettingsView)

The only setting currently available is for the import of translation
templates from bazaar branches hosted on Launchpad.

    >>> request = LaunchpadTestRequest()
    >>> view = ProductSeriesTranslationsSettingsView(
    ...     productseries, request)
    >>> view.setUpFields()
    >>> [field.__name__ for field in view.form_fields]
    ['translations_autoimport_mode']

This setting is represented by a SettingsRadioWidget which is derived
from LaunchpadRadioWidgetWithDescription.

    >>> view.setUpWidgets()
    >>> view.widgets['translations_autoimport_mode']
    <...SettingsRadioWidget object at...>

Submitting the form via "Change settings" will update the corresponding
attribute of the ProductSeries.

    >>> request = LaunchpadTestRequest(
    ...     method='POST',
    ...     form={'field.translations_autoimport_mode': 'IMPORT_TEMPLATES',
    ...           'field.actions.save_settings': 'Save Settings'})
    >>> view = ProductSeriesTranslationsSettingsView(
    ...     productseries, request)
    >>> print productseries.translations_autoimport_mode.title
    None
    >>> view.initialize()
    >>> print productseries.translations_autoimport_mode.title
    Import template files

Also, a branch job to upload the full set of translation files has been
created to create the initial database entries from the files in the branch.

    >>> print isUploadJobCreatedForBranch(productseries)
    True


= ProductSeriesTranslationsBzrImportView =

When requesting a one-time import of translation files, an Upload job
is created that has force_translations_upload set to true.

    >>> productseries = factory.makeProductSeries()
    >>> productseries.branch = makeScannedProductBranch(productseries)
    >>> from lp.registry.browser.productseries import (
    ...     ProductSeriesTranslationsBzrImportView)
    >>> request = LaunchpadTestRequest(
    ...     method='POST',
    ...     form={'field.actions.request_import':
    ...               'Request one-time import'})
    >>> view = ProductSeriesTranslationsBzrImportView(
    ...     productseries, request)
    >>> view.initialize()
    >>> print isUploadJobCreatedForBranch(productseries, True)
    True


== ProductSeries view ==

The default view for the productseries includes a script that augments the
'Create milestone' link to show a formoverlay to create a milestone and
update the milestones and releases table.

    >>> from canonical.launchpad.testing.pages import find_tag_by_id

    >>> product = factory.makeProduct(name='app')
    >>> series = factory.makeSeries(name='simple', product=product)
    >>> view = create_view(series, '+index', principal=product.owner)
    >>> script = find_tag_by_id(view.render(), 'milestone-script')
    >>> print script
    <script id="milestone-script" type="text/javascript">
        YUI().use(... 'lp.milestoneoverlay', 'lp.milestonetable'...
            var series_uri = '/app/simple';
            var milestone_form_uri = '.../app/simple/+addmilestone/++form++';
            var milestone_row_uri_template =
                '/app/+milestone/{name}/+productseries-table-row';
            var milestone_rows_id = '#milestone-rows';...
            Y.on('domready', function () {
                var create_milestone_link = Y.get('.menu-link-create_milestone');
                create_milestone_link.addClass('js-action');...
                Y.lp.milestoneoverlay.attach_widget(config);...
                Y.lp.milestonetable.setup(table_config);...

The view also sets teh class of the milestone and releases table which can
be removed by the in-page script. If the product series has no milestones,
the class table is 'listing unseen'.

    >>> print view.milestone_table_class
    listing unseen

When the product series has milestones, the class is just 'listing'.

    >>> milestone = series.newMilestone('12', code_name='twelve')
    >>> view = create_view(series, '+index')
    >>> print view.milestone_table_class
    listing


== Delete ProductSeries ==

Users with edit permission may delete a project's series. This person is
often the project's owner or series driver who has setup the series by
mistake.

    >>> from datetime import datetime
    >>> from pytz import UTC

    >>> product = factory.makeProduct(name="field", displayname='Field')
    >>> productseries = factory.makeProductSeries(
    ...     product=product, name='rabbit')

    # Hack the creation date for testing purposes.
    >>> test_date = datetime(2009, 05, 01, 19, 34, 24, tzinfo=UTC)
    >>> productseries.datecreated = test_date

Users without edit permission cannot access the view.

    >>> from canonical.launchpad.webapp.authorization import check_permission

    >>> login('no-priv@canonical.com')
    >>> view = create_view(productseries, name='+delete')
    >>> check_permission('launchpad.Edit', view)
    False

The project owner can access the view.

    >>> login_person(product.owner)
    >>> view = create_view(productseries, name='+delete')
    >>> check_permission('launchpad.Edit', view)
    True

The delete view has a label to explain what it does.

    >>> print view.label
    Delete Field series rabbit

The view has a a next_url to the product used when the delete is successful,
though it is None by default. There is a cancel_url that links to the series.

    >>> print view.next_url
    None

    >>> print view.cancel_url
    http://launchpad.dev/field/rabbit

There are helper properties that list the associates objects with the
series, the most important of which are milestones. Bugtasks and
specifications that will be unassigned, and release files that will be
deleted are available.

    >>> view.milestones
    []
    >>> view.bugtasks
    []
    >>> view.specifications
    []
    >>> view.product_release_files
    []

Most series that are deleted do not have any related objects, but a small
portion do.

    >>> milestone_one = productseries.newMilestone('0.1', code_name='one')
    >>> release_one = milestone_one.createProductRelease(
    ...     product.owner, test_date)
    >>> milestone_one.active = False
    >>> milestone_two = productseries.newMilestone('0.2', code_name='two')
    >>> specification = factory.makeSpecification(product=product)
    >>> specification.milestone = milestone_one
    >>> bug = factory.makeBug(product=product)
    >>> bugtask = bug.bugtasks[0]
    >>> bugtask.milestone = milestone_two

    >>> view = create_view(productseries, name='+delete')
    >>> [milestone.name for milestone in view.milestones]
    [u'0.2', u'0.1']
    >>> view.has_bugtasks_and_specifications
    True
    >>> [bugtask.milestone.name for bugtask in view.bugtasks]
    [u'0.2']
    >>> [spec.milestone.name for spec in view.specifications]
    [u'0.1']

    # Listing and deleting product release files is done in the story
    # because they require the Librarian to be running.

Series that are the active focus of development cannot be deleted. The
view's can_delete property checks this rule.

    >>> productseries.is_development_focus
    False
    >>> view.can_delete
    True

    >>> active_series = product.getSeries('trunk')
    >>> active_series.is_development_focus
    True
    >>> active_view = create_view(active_series, '+delete')
    >>> active_view.can_delete
    False

The delete action will not delete a series that is the active focus of
development.

    >>> transaction.commit()
    >>> form = {
    ...     'field.actions.delete': 'Delete this Series',
    ...     }
    >>> active_view = create_initialized_view(
    ...     active_series, '+delete', form=form)
    >>> for error in active_view.errors:
    ...     print error
    You cannot delete a series that is the focus of development. Make another
    series the focus of development before deleting this one.
    >>> print active_series.product.name
    field

Calling the view's delete action on a series that can be deleted will
untarget the bugtasks and specifications that are targeted to the
series' milestones. The milestones, releases, and release files are
deleted.

    >>> view = create_initialized_view(productseries, '+delete', form=form)
    >>> for notification in view.request.response.notifications:
    ...     print notification.message
    Series rabbit deleted.

    >>> print view.next_url
    http://launchpad.dev/field
    >>> [milestone for milestone in product.all_milestones]
    []
    >>> [release for release in  product.releases]
    []
    >>> print specification.milestone
    None
    >>> print bugtask.milestone
    None

The series was not actually deleted because there are problematic objects
like translations. The series are assigned to the Obsolete Junk project.
The series name is changed to 'product_name-series_name-date_created' to
avoid conflicts.

    >>> from canonical.launchpad.interfaces.launchpad import (
    ...     ILaunchpadCelebrities)

    >>> obsolete_junk = getUtility(ILaunchpadCelebrities).obsolete_junk
    >>> productseries.product == obsolete_junk
    True
    >>> print productseries.name
    field-rabbit-20090501-193424


Linking packages
----------------

Distrobution sourcepackages can be linked to product series using the
+addpackage named view.

    >>> ubuntu = getUtility(ILaunchpadCelebrities).ubuntu
    >>> hoary = ubuntu.getSeries('hoary')
    >>> sourcepackagename = factory.makeSourcePackageName('hot')
    >>> sourcepackage = factory.makeSourcePackage(
    ...     sourcepackagename=sourcepackagename, distroseries=hoary)
    >>> product = factory.makeProduct(name="hot", displayname='Hot')
    >>> productseries = factory.makeProductSeries(
    ...     product=product, name='hotter')
    >>> productseries.sourcepackages
    []

The view has a label and requires a distro series, source package name,
and a packaging contents.

    >>> view = create_view(productseries, '+addpackage')
    >>> print view.label
    Add distribution packaging record

    >>> print view.field_names
    ['distroseries', 'sourcepackagename', 'packaging']

    >>> form = {
    ...     'field.distroseries': 'ubuntu/hoary',
    ...     'field.sourcepackagename': 'hot',
    ...     'field.packaging': 'Primary Product',
    ...     'field.actions.continue': 'Continue',
    ...     }
    >>> view = create_initialized_view(
    ...     productseries, '+addpackage', form=form)
    >>> view.errors
    []
    >>> for package in productseries.sourcepackages:
    ...     print package.name
    hot

It is an error to link a series to the same package twice.

    >>> form = {
    ...     'field.distroseries': 'ubuntu/hoary',
    ...     'field.sourcepackagename': 'hot',
    ...     'field.packaging': 'Primary Product',
    ...     'field.actions.continue': 'Continue',
    ...     }
    >>> view = create_initialized_view(
    ...     productseries, '+addpackage', form=form)
    >>> for error in view.errors:
    ...     print error
    This series is already packaged in Hoary

