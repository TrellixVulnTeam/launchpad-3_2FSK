Old Launchpad Test Harnesses
============================

Deprecated
----------

The code demonstrated in this doctest is being deprecated in favour of
Layers. However, not all functionality has yet been ported so this old
code needs to remain for a while longer.

Introduction
------------

There is a selection of test harnesses to chose from for writing Launchpad
functional tests. Although you could simply always use the most fully
featured, this is not recommended as it will needlessly slow things down
and hide errors (eg. if this object is supposed to be usable outside of
zope, we should not be testing it with the full Z3 functional test
harness).

If you are wondering why we use `PgTestSetup().setUp()` and
`PgTestSetup.tearDown()` instead of `pgtestsetup.setUp()` or
`pgtestsetup.tearDown()`, it is because I'm mirroring the design used in
Zope3's `FunctionalTestSetup`.

canonical.functional.FunctionalTestCase
---------------------------------------

This is a customised zope3 FunctionalTestCase and should be used when you
simply need the zope3 utilities etc available.

PgTestSetup
-----------

PgTestSetup is used for tests that require access to a PostgreSQL backend.
For example, we would use this for testing SQLObject or our custom
extentions to it.

The class is defined in canonical.ftests.pgsql

>>> from canonical.ftests.pgsql import PgTestSetup

The setup procedure builds us a fresh, empty database

>>> PgTestSetup().setUp()

We can get connections to this database

>>> connection = PgTestSetup().connect()
>>> cursor = connection.cursor()
>>> cursor.execute("""CREATE TABLE Beer (
...     id serial PRIMARY KEY, name text, stamp timestamp without time zone
...     )""")
>>> cursor.execute("""INSERT INTO Beer(name, stamp) VALUES (
...     'Mountain Goat', '2005-12-29')""")

Note that the type conversion methods have been loaded (as implemented
by psycopgda), so our strings are Unicode and datetime instances returned.
Note that PostgreSQL versions prior to 8.1 called UTF-8 UNICODE.

>>> cursor.execute("SHOW client_encoding")
>>> cursor.fetchone()[0] in (u'UNICODE', u'UTF8')
True
>>> cursor.execute("SELECT name, stamp FROM Beer")
>>> tuple(cursor.fetchone())
(u'Mountain Goat', datetime.datetime(2005, 12, 29, 0, 0))

When we have finished, we need to call the tearDown method which closes
all outstanding connections and destroys the database

>>> PgTestSetup().tearDown()

Because the database has been destroyed, further tests will not be
affected.

>>> PgTestSetup().setUp()
>>> connection = PgTestSetup().connect()
>>> cursor = connection.cursor()
>>> cursor.execute("CREATE TABLE Beer (id serial PRIMARY KEY, name text)")
>>> PgTestSetup().tearDown()

We can also specify a different template to duplicate than the default
clean one (template1). For example, if you need a launchpad database
containing no data, you can use `launchpad_empty` as the template.

>>> PgTestSetup('launchpad_empty').setUp()
>>> connection = PgTestSetup().connect()
>>> cursor = connection.cursor()
>>> cursor.execute("SELECT COUNT(*) FROM Person")
>>> int(cursor.fetchone()[0])
0
>>> PgTestSetup().tearDown()

We can also specify the user that we connect as to avoid connecting as the
PostgreSQL default user.

>>> from canonical.config import config
>>> pgsetup = PgTestSetup(dbuser='statistician')
>>> connection = pgsetup.connect()
>>> cursor = connection.cursor()
>>> cursor.execute("SELECT current_user")
>>> cursor.fetchone()[0]
u'statistician'
>>> pgsetup.tearDown()


LaunchpadTestSetup
------------------

LaunchpadTestSetup is identical to PgTestSetup, except that it creates a
fresh copy of the Launchpad database filled with our sample data. This
class is defined in canonical.launchpad.ftests.harness.

Note that at this level, you cannot access any of the SQLBase objects

>>> from canonical.launchpad.ftests.harness import LaunchpadTestSetup
>>> LaunchpadTestSetup().setUp()
>>> connection = LaunchpadTestSetup().connect()
>>> cursor = connection.cursor()
>>> cursor.execute("SELECT displayname FROM person WHERE name='carlos'")
>>> cursor.fetchone()[0]
u'Carlos Perell\xf3 Mar\xedn'

By default, LaunchpadTestSetup connects as the 'launchpad' user:

>>> cursor.execute("SELECT current_user")
>>> cursor.fetchone()[0]
u'launchpad'

>>> LaunchpadTestSetup().tearDown()

You can connect as a different database user using the same mechanism
described above for PgTestSetup

>>> lpsetup = LaunchpadTestSetup()
>>> lpsetup.dbuser = 'statistician'
>>> lpsetup.setUp()
>>> connection = lpsetup.connect()
>>> cursor = connection.cursor()
>>> cursor.execute("SELECT current_user")
>>> cursor.fetchone()[0]
u'statistician'
>>> lpsetup.tearDown()


LaunchpadZopelessTestSetup
--------------------------

LaunchpadZopelessTestSetup builds on LaunchpadTestSetup, calling
initZopeless for you so you can access the SQLBase objects without needing
the Zope3 infrastructure.

>>> from canonical.launchpad.ftests.harness import LaunchpadZopelessTestSetup
>>> LaunchpadZopelessTestSetup().setUp()
>>> from lp.registry.model.person import Person
>>> stub = Person.byName('stub')
>>> stub.displayname
u'Stuart Bishop'
>>> stub.displayname = u'The Walrus'
>>> stub.displayname
u'The Walrus'

You have access to the zopeless transaction

>>> LaunchpadZopelessTestSetup().txn.abort()
>>> stub.displayname
u'Stuart Bishop'

And always remember to tearDown or you will victimize other tests!

>>> LaunchpadZopelessTestSetup().tearDown()


In general, Zopeless tests should never be running as the launchpad user.
You can select the user you connect as:

>>> setup = LaunchpadZopelessTestSetup(dbuser=config.librarian.dbuser)
>>> setup.setUp()
>>> from lp.registry.model.sourcepackagename import SourcePackageName
>>> SourcePackageName.get(1).name
Traceback (most recent call last):
...
ProgrammingError: permission denied for relation sourcepackagename
<BLANKLINE>
>>> setup.tearDown()


LaunchpadFunctionalTestSetup
----------------------------

One with the lot. A LaunchpadTestSetup which also loads in the Zope3
environment.

>>> from canonical.launchpad.ftests.harness import LaunchpadFunctionalTestSetup
>>> LaunchpadFunctionalTestSetup().setUp()

You have full access to the SQLBase objects

>>> mark = Person.byName('mark')
>>> mark.displayname
u'Mark Shuttleworth'

You also have access to the Zope3 component architecture, as registered
by ftesting.zcml

>>> from zope.app import zapi
>>> from zope.sendmail.interfaces import IMailer
>>> zapi.getUtility(IMailer, 'smtp') is not None
True

>>> LaunchpadFunctionalTestSetup().tearDown()

You can change the user that the tests connect as:

  XXX 2008-05-29 jamesh:
  Using LaunchpadFunctionalLayer for non-webapp db users is generally
  a sign of a bug.  These bits of code should generally be using
  LaunchpadZopelessLayer.

##>>> setup = LaunchpadFunctionalTestSetup(dbuser=config.librarian.dbuser)
##>>> setup.setUp()
##>>> connection = setup.connect()
##>>> cursor = connection.cursor()
##>>> cursor.execute('SELECT current_user')
##>>> cursor.fetchone()[0]
##u'librarian'
##>>> SourcePackageName.get(1).name
##Traceback (most recent call last):
##...
##ProgrammingError: permission denied ...
##>>> setup.tearDown()

And the next test will be unaffected:

>>> setup = LaunchpadFunctionalTestSetup()
>>> setup.setUp()
>>> connection = setup.connect()
>>> cursor = connection.cursor()
>>> cursor.execute('SELECT current_user')
>>> cursor.fetchone()[0]
u'launchpad'
>>> SourcePackageName.get(1).name
u'mozilla-firefox'
>>> setup.tearDown()


LibrarianTestSetup
------------------

Code that needs to access the Librarian can do so easily. Note that
LibrarianTestSetup requires the Launchpad database to be available, and
thus requires LaunchpadTestSetup or similar to be used in tandam.
You probably really want LaunchpadFunctionalTestSetup so you can access
the Librarian as a Utility.

>>> from canonical.librarian.testing.server import LibrarianTestSetup
>>> from canonical.launchpad.ftests import login, ANONYMOUS
>>> from zope.app import zapi
>>> from canonical.librarian.interfaces import ILibrarianClient
>>> from StringIO import StringIO

>>> LaunchpadFunctionalTestSetup().setUp()
>>> librarian = LibrarianTestSetup()
>>> librarian.setUp()
>>> login(ANONYMOUS)

>>> some_content = StringIO()
>>> print >> some_content, 'Hi Mum\n'*100
>>> size = len(some_content.getvalue())
>>> some_content.seek(0)
>>> librarian_client = zapi.getUtility(ILibrarianClient)
>>> file_alias_id = librarian_client.addFile(
...     'hi.txt', size, some_content, 'text/plain')
>>> isinstance(file_alias_id, (int, long))
True

Note that you currently can't retrieve a file from the Librarian in
the same transaction it was added

>>> import transaction
>>> transaction.commit()
>>> url = librarian_client.getURLForAlias(file_alias_id)
>>> data = librarian_client.getFileByAlias(file_alias_id).read()
>>> data == some_content.getvalue()
True

>>> librarian.tearDown()
>>> LaunchpadFunctionalTestSetup().tearDown()

>>> from canonical.testing import reset_logging
>>> reset_logging()

