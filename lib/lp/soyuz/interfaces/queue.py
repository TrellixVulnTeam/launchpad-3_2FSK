# Copyright 2009 Canonical Ltd.  This software is licensed under the
# GNU Affero General Public License version 3 (see the file LICENSE).

# pylint: disable-msg=E0211,E0213

"""Queue interfaces."""

__metaclass__ = type

__all__ = [
    'IHasQueueItems',
    'IPackageUploadQueue',
    'IPackageUpload',
    'IPackageUploadBuild',
    'IPackageUploadSource',
    'IPackageUploadCustom',
    'IPackageUploadSet',
    'NonBuildableSourceUploadError',
    'PackageUploadStatus',
    'PackageUploadCustomFormat',
    'QueueBuildAcceptError',
    'QueueInconsistentStateError',
    'QueueSourceAcceptError',
    'QueueStateWriteProtectedError',
    ]

from zope.schema import Int, TextLine
from zope.interface import Interface, Attribute
from lazr.enum import DBEnumeratedType, DBItem
from canonical.launchpad import _


class QueueStateWriteProtectedError(Exception):
    """This exception prevent directly set operation in queue state.

    The queue state machine is controlled by its specific provided methods,
    like: setNew, setAccepted and so on.
    """


class QueueInconsistentStateError(Exception):
    """Queue state machine error.

    It's generated when the solicited state makes the record
    inconsistent against the current system constraints.
    """


class NonBuildableSourceUploadError(QueueInconsistentStateError):
    """Source upload will not result in any build record.

    This error is raised when trying to accept a source upload that is
    consistent but will not build in any of the architectures supported
    in its targeted distroseries.
    """


class QueueSourceAcceptError(Exception):
    """It prevents a PackageUploadSource from being ACCEPTED.

    It is generated by Component and/or Section mismatching in a DistroSeries.
    """


class QueueBuildAcceptError(Exception):
    """It prevents a PackageUploadBuild from being ACCEPTED.

    It is generated by Component and/or Section mismatching in a DistroSeries.
    """


class IPackageUploadQueue(Interface):
    """Used to establish permission to a group of package uploads.

    Recieves an IDistroSeries and a PackageUploadStatus dbschema
    on initialisation.
    No attributes exposed via interface, only used to check permissions.
    """


class IPackageUpload(Interface):
    """A Queue item for Lucille"""

    id = Int(
            title=_("ID"), required=True, readonly=True,
            )

    status = Int(
            title=_("Queue status"), required=False, readonly=True,
            )

    distroseries = Int(
            title=_("Series"), required=True, readonly=False,
            )

    pocket = Int(
            title=_("The pocket"), required=True, readonly=False,
            )

    changesfile = Attribute("The librarian alias for the changes file "
                            "associated with this upload")

    signing_key = Attribute("Changesfile Signing Key.")
    archive = Int(title=_("Archive"), required=True, readonly=True)
    sources = Attribute("The queue sources associated with this queue item")
    builds = Attribute("The queue builds associated with the queue item")
    customfiles = Attribute("Custom upload files associated with this "
                            "queue item")

    datecreated = Attribute("The date on which this queue was created.")
    displayname = TextLine(
        title=_("Generic displayname for a queue item"), readonly=True)
    displayversion = TextLine(
        title=_("The source package version for this item"), readonly=True)
    displayarchs = TextLine(
        title=_("Architetures related to this item"), readonly=True)

    sourcepackagerelease = Attribute(
        "The source package release for this item")

    contains_source = Attribute("whether or not this upload contains sources")
    contains_build = Attribute("whether or not this upload contains binaries")
    contains_installer = Attribute(
        "whether or not this upload contains installers images")
    contains_translation = Attribute(
        "whether or not this upload contains translations")
    contains_upgrader = Attribute(
        "wheter or not this upload contains upgrader images")
    contains_ddtp = Attribute(
        "wheter or not this upload contains DDTP images")
    isPPA = Attribute(
        "Return True if this PackageUpload is a PPA upload.")

    components = Attribute(
        """The set of components used in this upload.

        For sources, this is the component on the associated
        sourcepackagerelease.  For binaries, this is all the components
        on all the binarypackagerelease records arising from the build.
        """)

    def isAutoSyncUpload(changed_by_email):
        """Return True if this is a (Debian) auto sync upload.

        Sync uploads are source-only, unsigned and not targeted to
        the security pocket.  The Changed-By field is also the Katie
        user (archive@ubuntu.com).
        """

    def setNew():
        """Set queue state to NEW."""

    def setUnapproved():
        """Set queue state to UNAPPROVED."""

    def setAccepted():
        """Set queue state to ACCEPTED.

        Perform the required checks on its content, so we guarantee data
        integrity by code.
        """

    def setDone():
        """Set queue state to DONE."""

    def setRejected():
        """Set queue state to REJECTED."""

    def acceptFromUploader(changesfile_path, logger=None):
        """Perform upload acceptance during upload-time.

         * Move the upload to accepted queue in all cases;
         * Publish and close bugs for 'single-source' uploads;
         * Skip bug-closing for PPA uploads.
        """

    def acceptFromQueue(announce_list, logger=None, dry_run=False):
        """Call setAccepted, do a syncUpdate, and send notification email."""

    def rejectFromQueue(logger=None, dry_run=False):
        """Call setRejected, do a syncUpdate, and send notification email."""

    def realiseUpload(logger=None):
        """Take this ACCEPTED upload and create the publishing records for it
        as appropriate.

        When derivation is taken into account, this may result in queue items
        being created for derived distributions.

        If a logger is provided, messages will be written to it as the upload
        is entered into the publishing records.

        Return a list containing the publishing records created.
        """

    def addSource(spr):
        """Add the provided source package release to this queue entry."""

    def addBuild(build):
        """Add the provided build to this queue entry."""

    def addCustom(library_file, custom_type):
        """Add the provided library file alias as a custom queue entry of
        the given custom type.
        """

    def syncUpdate():
        """Write updates made on this object to the database.

        This should be used when you can't wait until the transaction is
        committed to have some updates actually written to the database.
        """

    def notify(announce_list=None, summary_text=None,
        changes_file_object=None, logger=None):
        """Notify by email when there is a new distroseriesqueue entry.

        This will send new, accept, announce and rejection messages as
        appropriate.

        :param announce_list: The email address of the distro announcements

        :param summary_text: Any additional text to append to the auto-
            generated summary.  This is also the only text used if there is
            a rejection message generated.

        :param changes_file_object: An open file object pointing at the
            changes file.  Current, only nascentupload need supply this
            as the transaction is not committed to the DB at that point so
            data needs to be obtained from the changes file.

        :param logger: Specify a logger object if required.  Mainly for tests.
        """

    def overrideSource(new_component, new_section, allowed_components):
        """Override the source package contained in this queue item.

        :param new_component: An IComponent to replace the existing one
            in the upload's source.
        :param new_section: An ISection to replace the existing one
            in the upload's source.
        :param allowed_components: A sequence of components that the
            callsite is allowed to override from and to.

        :raises QueueInconsistentStateError: if either the existing
            or the new_component are not in the allowed_components
            sequence.

        The override values may be None, in which case they are not
        changed.

        :return: True if the source was overridden.
        """

    def overrideBinaries(new_component, new_section, new_priority,
                         allowed_components):
        """Override all the binaries in a binary queue item.

        :param new_component: An IComponent to replace the existing one
            in the upload's source.
        :param new_section: An ISection to replace the existing one
            in the upload's source.
        :param new_priority: A valid PackagePublishingPriority to replace
            the existing one in the upload's binaries.
        :param allowed_components: A sequence of components that the
            callsite is allowed to override from and to.

        :raises QueueInconsistentStateError: if either the existing
            or the new_component are not in the allowed_components
            sequence.

        The override values may be None, in which case they are not
        changed.

        :return: True if the binaries were overridden.
        """


class IPackageUploadBuild(Interface):
    """A Queue item's related builds (for Lucille)"""

    id = Int(
            title=_("ID"), required=True, readonly=True,
            )


    packageupload = Int(
            title=_("PackageUpload"), required=True,
            readonly=False,
            )

    build = Int(
            title=_("The related build"), required=True, readonly=False,
            )

    def verifyBeforeAccept():
        """Perform overall checks before accepting a binary upload.

        Ensure each uploaded binary file can be published in the targeted
        archive.

        If any of the uploaded binary files are already published a
        QueueInconsistentStateError is raised containing all filenames
        that cannot be published.

        This check is very similar to the one we do for source upload and
        was designed to prevent the creation of binary publications that
        will never reach the archive.

        See bug #227184 for further details.
        """

    def publish(logger=None):
        """Publish this queued source in the distroseries referred to by
        the parent queue item.

        We determine the distroarchseries by matching architecturetags against
        the distroarchseries the build was compiled for.

        This method can raise NotFoundError if the architecturetag can't be
        matched up in the queue item's distroseries.

        Returns a list of the secure binary package publishing history
        objects in case it is of use to the caller. This may include records
        published into other distroarchseriess if this build contained arch
        independant packages.

        If a logger is provided, information pertaining to the publishing
        process will be logged to it.
        """

class IPackageUploadSource(Interface):
    """A Queue item's related sourcepackagereleases (for Lucille)"""

    id = Int(
            title=_("ID"), required=True, readonly=True,
            )


    packageupload = Int(
            title=_("PackageUpload"), required=True,
            readonly=False,
            )

    sourcepackagerelease = Int(
            title=_("The related source package release"), required=True,
            readonly=False,
            )

    def getSourceAncestry():
        """Return a suitable ancestry publication for this context.

        The possible ancestries locations for a give source upload, assuming
        that only PRIMARY archive allows post-RELEASE pockets are:

         1. original archive, original distroseries and pocket (old
            DEVELOPMENT/SRU/PPA uploads);
         2. primary archive, original distroseries and release pocket (NEW
            SRU/PPA uploads fallback);
         3. primary_archive, any distroseries and release pocket (BACKPORTS)

        We lookup a source publication with the same name in those location
        and in that order. If an ancestry is found it is returned, otherwise
        it returns None.

        :return: `ISourcePackagePublishingHistory` for the corresponding
             ancestry or None if it wasn't found.
        """

    def verifyBeforeAccept():
        """Perform overall checks before promoting source to ACCEPTED queue.

        If two queue items have the same (name, version) pair there is
        an inconsistency. To identify this situation we check the accepted
        & done queue items for each distroseries for such duplicates and
        raise an exception if any are found.
        See bug #31038 & #62976 for details.
        """

    def verifyBeforePublish():
        """Perform overall checks before publishing a source queue record.

        Check if the source package files do not collide with the
        ones already published in the archive. We need this to catch
        inaccurate  *epoched* versions, which would pass the upload version
        check but would collide with diff(s) or dsc(s) previously published
        on disk. This inconsistency is well known in debian-like archives
        and happens because filenames do not contain epoch. For further
        information see bug #119753.
        """

    def checkComponentAndSection():
        """Verify the current Component and Section via Selection table.

        Check if the current sourcepackagerelease component and section
        matches with those included in the target distribution series,
        if not raise QueueSourceAcceptError exception.
        """

    def publish(logger=None):
        """Publish this queued source in the distroseries referred to by
        the parent queue item.

        Returns the secure source package publishing history object in case
        it is of use to the caller.

        If a logger is provided, information pertaining to the publishing
        process will be logged to it.
        """


class IPackageUploadCustom(Interface):
    """Stores anything else than source and binaries that needs publication.

    It is essentially a map between DistroSeries/Pocket/LibrarianFileAlias.

    The LibrarianFileAlias usually is a TGZ containing an specific format.
    Currently we support:
     [Debian-Installer, Rosetta-Translation, Dist-Upgrader, DDTP-Tarball]

    Each one has an processor which is invoked by the publish method.
    """

    id = Int(
            title=_("ID"), required=True, readonly=True,
            )

    packageupload = Int(
            title=_("PackageUpload"), required=True,
            readonly=False,
            )

    customformat = Int(
            title=_("The custom format for the file"), required=True,
            readonly=False,
            )

    libraryfilealias = Int(
            title=_("The file"), required=True, readonly=False,
            )

    def temp_filename():
        """Return a filename containing the libraryfile for this upload.

        This filename will be in a temporary directory and can be the
        ensure dir can be deleted once whatever needed the file is finished
        with it.
        """

    def publish(logger=None):
        """Publish this custom item directly into the filesystem.

        This can only be run by a process which has filesystem access to
        the archive (or wherever else the content will go).

        If a logger is provided, information pertaining to the publishing
        process will be logged to it.
        """

    def publish_DEBIAN_INSTALLER(logger=None):
        """Publish this custom item as a raw installer tarball.

        This will write the installer tarball out to the right part of
        the archive.

        If a logger is provided, information pertaining to the publishing
        process will be logged to it.
        """

    def publish_DIST_UPGRADER(logger=None):
        """Publish this custom item as a raw dist-upgrader tarball.

        This will write the dist-upgrader tarball out to the right part of
        the archive.

        If a logger is provided, information pertaining to the publishing
        process will be logged to it.
        """

    def publish_DDTP_TARBALL(logger=None):
        """Publish this custom item as a raw ddtp-tarball.

        This will write the ddtp-tarball out to the right part of
        the archive.

        If a logger is provided, information pertaining to the publishing
        process will be logged to it.
        """

    def publish_ROSETTA_TRANSLATIONS(logger=None):
        """Publish this custom item as a rosetta tarball.

        Essentially this imports the tarball into rosetta.

        If a logger is provided, information pertaining to the publishing
        process will be logged to it.
        """

class IPackageUploadSet(Interface):
    """Represents a set of IPackageUploads"""

    def __iter__():
        """IPackageUpload iterator"""

    def __getitem__(queue_id):
        """Retrieve an IPackageUpload by a given id"""

    def get(queue_id):
        """Retrieve an IPackageUpload by a given id"""

    def count(status=None, distroseries=None, pocket=None):
        """Number of IPackageUpload present in a given status.

        If status is ommitted return the number of all entries.
        'distroseries' is optional and restrict the results in given
        distroseries, same for pocket.
        """

    def getBuildByBuildIDs(build_ids):
        """Return `PackageUploadBuilds`s for the supplied build IDs."""

    def getSourceBySourcePackageReleaseIDs(spr_ids):
        """Return `PackageUploadSource`s for the sourcepackagerelease IDs."""


class IHasQueueItems(Interface):
    """An Object that has queue items"""

    def getPackageUploadQueue(state):
        """Return an IPackageUploadeQueue occording the given state."""

    def getQueueItems(status=None, name=None, version=None,
                      exact_match=False, pocket=None, archive=None):
        """Get the union of builds, sources and custom queue items.

        Returns builds, sources and custom queue items in a given state,
        matching a give name and version terms.

        If 'status' is not supplied, return all items in the queues,
        it supports multiple statuses as a list.

        If 'name' and 'version' are supplied only items which match (SQL LIKE)
        the sourcepackage name, binarypackage name or the filename will be
        returned.  'name' can be supplied without supplying 'version'.
        'version' has no effect on custom queue items.

        If 'pocket' is specified return only queue items inside it, otherwise
        return all pockets.  It supports multiple pockets as a list.

        If 'archive' is specified return only queue items targeted to this
        archive, if not restrict the results to the IDistribution.main_archive.

        Use 'exact_match' argument for precise results.
        """


class PackageUploadStatus(DBEnumeratedType):
    """Distro Release Queue Status

    An upload has various stages it must pass through before becoming part
    of a DistroSeries. These are managed via the Upload table
    and related tables and eventually (assuming a successful upload into the
    DistroSeries) the effects are published via the PackagePublishing and
    SourcePackagePublishing tables.  """

    NEW = DBItem(0, """
        New

        This upload is either a brand-new source package or contains a
        binary package with brand new debs or similar. The package must sit
        here until someone with the right role in the DistroSeries checks
        and either accepts or rejects the upload. If the upload is accepted
        then entries will be made in the overrides tables and further
        uploads will bypass this state """)

    UNAPPROVED = DBItem(1, """
        Unapproved

        If a DistroSeries is frozen or locked out of ordinary updates then
        this state is used to mean that while the package is correct from a
        technical point of view; it has yet to be approved for inclusion in
        this DistroSeries. One use of this state may be for security
        releases where you want the security team of a DistroSeries to
        approve uploads.  """)

    ACCEPTED = DBItem(2, """
        Accepted

        An upload in this state has passed all the checks required of it and
        is ready to have its publishing records created.  """)

    DONE = DBItem(3, """
        Done

        An upload in this state has had its publishing records created if it
        needs them and is fully processed into the DistroSeries. This state
        exists so that a logging and/or auditing tool can pick up accepted
        uploads and create entries in a journal or similar before removing
        the queue item.  """)

    REJECTED = DBItem(4, """
        Rejected

        An upload which reaches this state has, for some reason or another
        not passed the requirements (technical or human) for entry into the
        DistroSeries it was targetting. As for the 'done' state, this state
        is present to allow logging tools to record the rejection and then
        clean up any subsequently unnecessary records.  """)


# If you change this (add items, change the meaning, whatever) search for
# the token ##CUSTOMFORMAT## e.g. database/queue.py or nascentupload.py and
# update the stuff marked with it.
class PackageUploadCustomFormat(DBEnumeratedType):
    """Custom formats valid for the upload queue

    An upload has various files potentially associated with it, from source
    package releases, through binary builds, to specialist upload forms such
    as a debian-installer tarball or a set of translations.
    """

    DEBIAN_INSTALLER = DBItem(0, """
        raw-installer

        A raw-installer file is a tarball. This is processed as a version
        of the debian-installer to be unpacked into the archive root.
        """)

    ROSETTA_TRANSLATIONS = DBItem(1, """
        raw-translations

        A raw-translations file is a tarball. This is passed to the rosetta
        import queue to be incorporated into that package's translations.
        """)

    DIST_UPGRADER = DBItem(2, """
        raw-dist-upgrader

        A raw-dist-upgrader file is a tarball. It is simply published into
        the archive.
        """)

    DDTP_TARBALL = DBItem(3, """
        raw-ddtp-tarball

        A raw-ddtp-tarball contains all the translated package description
        indexes for a component.
        """)
