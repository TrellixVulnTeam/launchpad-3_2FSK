== The nascent uploads ==

We also need to set up the OpenPGP key used to sign things so that we can
identify the upload signer later on.

  >>> from canonical.launchpad.interfaces import IGPGKeySet
  >>> from canonical.lp.dbschema import GPGKeyAlgorithm
  >>> discarded_key = getUtility(IGPGKeySet).new(26, '20687895',
  ...     '961F4EB829D7D304A77477822BC8401620687895', 1024, GPGKeyAlgorithm.D)

Next we import the test keys so we have them ready for verification

  >>> from canonical.launchpad.ftests import import_public_test_keys
  >>> import_public_test_keys()

We need to be logged into the security model in order to get any further

  >>> login('foo.bar@canonical.com')

For the purpose of this test, hoary needs to be an open (development)
distrorelease so that we can upload to it.

  >>> from canonical.launchpad.interfaces import IDistributionSet
  >>> ubuntu = getUtility(IDistributionSet)['ubuntu']
  >>> hoary = ubuntu['hoary']
  >>> from canonical.lp.dbschema import DistributionReleaseStatus
  >>> hoary.releasestatus = DistributionReleaseStatus.DEVELOPMENT

A nascent upload is a collection of files in a directory. They
represent what may turn out to be an acceptible upload to a launchpad
managed archive.

  >>> from canonical.archivepublisher.nascentupload import NascentUpload
  >>> from canonical.archivepublisher.uploadpolicy import findPolicyByName
  >>> from canonical.archivepublisher.tests import datadir

  >>> class MockLogger:
  ...     def debug(self, s):
  ...         print "DEBUG:", s

The policy we feed to to the nascent upload needs to have its command
line options passed in.

  >>> class MockOptions:
  ...     distro = "ubuntu"
  ...     distrorelease = "hoary"

  >>> class BuilddOptions(MockOptions):
  ...     buildid = 1

  >>> buildd_policy = findPolicyByName('buildd')
  >>> buildd_policy.setOptions(BuilddOptions())

When initially constructing a NascentUpload instance, it verifies that
the changes file specified exists, raising FileNotFound if it does not.

  >>> NascentUpload(buildd_policy, datadir(""), "DOES-NOT-EXIST",
  ...     MockLogger())
  Traceback (most recent call last):
  ...
  FileNotFound: DOES-NOT-EXIST
  >>> ed_upload = NascentUpload(findPolicyByName('insecure'),
  ...     datadir(''), "ed_0.2-20_i386.changes", MockLogger())
  >>> ed_upload.changes_filename == datadir("ed_0.2-20_i386.changes")
  True
  >>> ed_upload.policy.setOptions(MockOptions())

The nascent upload contains files (assuming it's sane) and as such we
have a NascentUploadedFile type to represent them.

  >>> from canonical.archivepublisher.nascentupload import NascentUploadedFile

To construct a nascentuploadedfile we need an fsroot and a line from a
Files section of a changes file.

  >>> nuf = NascentUploadedFile(
  ...     datadir(''),
  ...     ' 0c466ce6a160c62fa558fbbb46a4ea45 44718 editors important '
  ...     'ed_0.2-20_i386.deb')
  >>> nuf.filename
  'ed_0.2-20_i386.deb'
  >>> nuf._size
  44718
  >>> nuf._digest
  '0c466ce6a160c62fa558fbbb46a4ea45'
  >>> nuf.section
  'editors'
  >>> nuf.priority
  'important'

When we ask the object for its size or digest through the properties,
it will check them. If they're correct, no exception will be raised.

  >>> nuf.size
  44718
  >>> nuf.digest
  '0c466ce6a160c62fa558fbbb46a4ea45'
  >>> nuf.sha_digest
  'e5c467ca14ab67f73f8cbb9bb9016f670b14c8b7'
  >>> nuf._values_checked
  True

Going back to the upload itself, at a very basic level a NascentUpload
allows us to probe the contents of the changes file to see things like
the maintainer.

  >>> ed_upload.changes['maintainer']
  'James Troup <james@nocrew.org>'

We can also extract the list of files from the upload. If this raises
an exception then the file list is utterly broken.

  >>> for uploaded_file in ed_upload.files:
  ...     print uploaded_file.filename
  ed_0.2-20.dsc
  ed_0.2-20.diff.gz
  ed_0.2-20_i386.deb

The nascent upload can tell us if it is sourceful or not, (ditto binaryful)

  >>> ed_upload.sourceful
  True
  >>> ed_upload.binaryful
  True
  >>> ed_upload.archindep
  False
  >>> ed_upload.archdep
  True

  >>> ed_source_upload = NascentUpload(buildd_policy,
  ...     datadir(''), "ed_0.2-20_i386.source-only-unsigned-changes",
  ...     MockLogger())
  >>> ed_source_upload.sourceful
  True
  >>> ed_source_upload.binaryful
  False

  >>> ed_binary_upload = NascentUpload(buildd_policy,
  ...     datadir(''), "ed_0.2-20_i386.binary-only-unsigned-changes",
  ...     MockLogger())
  >>> ed_binary_upload.sourceful
  False
  >>> ed_binary_upload.binaryful
  True
  >>> ed_binary_upload.archdep
  True
  >>> ed_binary_upload.archindep
  False


If the Architecture line does not match then we get an exception.

  >>> ed_mismatched_upload = NascentUpload(buildd_policy,
  ...     datadir(''), "ed_0.2-20_i386.mismatched-arch-unsigned-changes",
  ...     MockLogger())
  >>> ed_mismatched_upload.sourceful
  True
  >>> ed_mismatched_upload.rejection_message
  'Mismatch in binaryfulness. (arch) False != (files) True\nOne or more files uploaded with specific architecture but changes file does not list it.'

We can distinguish between the arch-indep and arch-dep binary uploads.

  >>> quodlibet = NascentUpload(buildd_policy,
  ...     datadir(''), "quodlibet_0.13.1-1_i386.changes", MockLogger())
  >>> quodlibet.sourceful
  False
  >>> quodlibet.binaryful
  True
  >>> quodlibet.archdep
  True
  >>> quodlibet.archindep
  True

We can ask sourceful uploads if they are native or not. If they are
not native we can find out if they have an orig.tar.gz or not.

  >>> ed_upload.native
  False
  >>> ed_upload.hasorig
  False

If we ask a non-sourceful upload about its native or hasorig status it
should throw an exception because non-sourceful uploads have no
concept of nativeness.

  >>> ed_binary_upload.native
  Traceback (most recent call last):
  ...
  UploadError: Attempted to ask a non-sourceful upload if it is native or not.


We can parse addresses and look them up in launchpad.

  >>> addr = ed_upload.parse_address("Foo Bar <foo.bar@canonical.com>")
  >>> addr['person'].displayname
  u'Foo Bar'

If the address is unparsable, we get an error.

  >>> ed_upload.parse_address("Cannot Parse Me <FOOO>")
  Traceback (most recent call last):
  ...
  UploadError: Cannot Parse Me <FOOO>: no @ found in email address part.

If the email address is not yet registered and policy.create_people is True,
a new Person will be created.

  >>> orig_create_people = ed_upload.policy.create_people
  >>> ed_upload.policy.create_people = True
  >>> addr = ed_upload.parse_address("Baz <baz@canonical.com>")
  >>> addr['person'].creation_rationale.name
  'SOURCEPACKAGEUPLOAD'
  >>> addr['person'].creation_comment
  u'when the ed package was uploaded to Ubuntu'
  >>> ed_upload.policy.create_people = orig_create_people


The upload can extract distributions and distroreleases if it tries
  >>> ed_upload.distro.name
  u'ubuntu'
  >>> ed_upload.distrorelease.name
  u'hoary'

The policy we've used so far won't allow us to upload binary or
mixed-mode sets. We'll override this for our test set...

  >>> ed_upload.policy.can_upload_binaries = True
  >>> ed_upload.policy.can_upload_mixed = True

Finally we can ask the upload to process itself.
  >>> from canonical.launchpad.database import (
  ...     SourcePackageName, BinaryPackageName, DistroRelease)
  >>> hoary = DistroRelease.get(3)
  >>> saved_list = hoary.changeslist
  >>> hoary.changeslist = "dapper-announce@lists.ubuntu.com"
  >>> hoary.sync()
  >>> ed_upload.distrorelease.changeslist
  u'dapper-announce@lists.ubuntu.com'
  >>> ed_upload.process()
  DEBUG: Beginning processing.
  DEBUG: Checking signature on changes file.
  DEBUG: Verifying signature on ed_0.2-20_i386.changes
  DEBUG: Verifying the changes file.
  DEBUG: Verifying files in upload.
  DEBUG: Verifying source file ed_0.2-20.dsc
  DEBUG: Verifying signature on .../data/ed_0.2-20.dsc
  DEBUG: Verifying source file ed_0.2-20.diff.gz
  DEBUG: Verifying binary ed_0.2-20_i386.deb
  DEBUG: Performing DSC verification.
  DEBUG: Verifying uploaded source package by unpacking it.
  DEBUG: Cleaning up source tree.
  DEBUG: Done
  DEBUG: Verifying timestamps in ed_0.2-20_i386.deb
  DEBUG: Finding and applying overrides.
  DEBUG: getPublishedReleases()
  DEBUG: ed: (source) NEW
  DEBUG: getPublishedReleases()
  DEBUG: Checking against i386 for ed
  DEBUG: ed: (binary) NEW
  DEBUG: Daniel Silverstone (26) is an uploader for main, restricted, universe.
  DEBUG: Finished checking upload.
  >>> print ed_upload.rejection_message+"\nEND"
  END
  >>> ed_upload.rejected
  False
  >>> success, msgs = ed_upload.do_accept()
  DEBUG: Building recipients list.
  DEBUG: Attempting to decide if James Troup is in the keyring.
  DEBUG: Decision: False
  DEBUG: Adding recipient: 'Daniel Silverstone <daniel.silverstone@canonical.com>'
  DEBUG: Build ... created
  DEBUG: Creating a New queue entry
  >>> print success
  True
  >>> for msg in msgs:
  ...     print msg, "END"
  From: Root <root@localhost>
  To: Daniel Silverstone <daniel.silverstone@canonical.com>
  Bcc: Root <root@localhost>
  Precedence: bulk
  Subject: ed_0.2-20_i386.changes is NEW
  <BLANKLINE>
  NEW: ed_0.2-20.dsc
   OK: ed_0.2-20.diff.gz
  NEW: ed_0.2-20_i386.deb
  <BLANKLINE>
  -----BEGIN PGP SIGNED MESSAGE-----
  Hash: SHA1
  <BLANKLINE>
  Format: 1.7
  Date: Wed,  2 Apr 2003 17:19:47 +0100
  Source: ed
  Binary: ed
  Architecture: source i386
  Version: 0.2-20
  Distribution: unstable
  Urgency: low
  Maintainer: James Troup <james@nocrew.org>
  Changed-By: James Troup <james@nocrew.org>
  Description:
   ed         - The classic unix line editor
  Closes: 122517 130327 179957
  Changes:
   ed (0.2-20) unstable; urgency=low
   .
     * Move to dpatch; existing non-debian/ changes split into
       01_buf.c-tmpfile, 02_-Wall-cleanup, 03_ed.1-cleanup and
       04_Makfile.in-no-libed.
     * debian/rules: include /usr/share/dpatch/dpatch.make.
     * debian/rules (build): depend on patch-stamp.
     * debian/rules (clean): depend on unpatch.  Remove debian/patched.
     * debian/rules (.PHONY): add 'patch' and 'unpatch'.
     * debian/control (Build-Depends): add dpatch.
   .
     * debian/rules: update copyright.
     * debian/copyright: likewise and update upstream URL.
     * debian/changelog: remove local-variables stuff.
   .
     * debian/rules: use install_foo convenience variables.
     * debian/rules (clean): remove *~ in any subdirectory.
   .
     * debian/control (Standards-Version): bump to 3.5.8.0.
     * debian/postinst, debian/prerm: no longer do /usr/doc symlinks.
   .
     * config, test/*: unused aegis cruft; removed.
     * Undo s/%/$/ change in RCS keywords.
   .
     * debian/postinst: provide editor.1.gz alternative; thanks to Ben Harris
       <bjh21@cam.ac.uk> for the suggestion.  Closes: #122517
     * 05_ed.1-warning-fix.dpatch: new patch to avoid groff warnings.  Thanks
       to Colin Watson <cjwatson@debian.org>.  Closes: #179957
     * 06_testsuite-Makefile.dpatch: new patch to ensure the test suite bombs
       out on errors.  Thanks to Joel Baker <fenton@debian.org>.
       Closes: #130327
  Files:
   22beb6b9d1fe984cd3a20571a4e958ac 522 editors important ed_0.2-20.dsc
   f9e1e5f13725f581919e9bfd62272a05 8506 editors important ed_0.2-20.diff.gz
   0c466ce6a160c62fa558fbbb46a4ea45 44718 editors important ed_0.2-20_i386.deb
  <BLANKLINE>
  -----BEGIN PGP SIGNATURE-----
  Version: GnuPG v1.4.1 (GNU/Linux)
  <BLANKLINE>
  iD8DBQFDTWC+K8hAFiBoeJURAnA7AJ9i9ZjWjtqUQ+nFJfPnsjOmfUq6DQCffPZZ
  nwN7DFh8fuhURm3VCzcwIGc=
  =jANz
  -----END PGP SIGNATURE-----
  <BLANKLINE>
  <BLANKLINE>
  Your package contains new components which requires manual editing of
  the override file.  It is ok otherwise, so please be patient.  New
  packages are usually added to the overrides about once a week.
  <BLANKLINE>
  You may have gotten the distrorelease wrong.  If so, you may get warnings
  above if files already exist in other distroreleases.
  END

Retrive the just-inserted SourcePackageRelease correspondent to 'ed'
(it's the only one we have, the process to retrieve a non-published
SPR w/o at least one Upload entry is quite unusual)

  >>> from canonical.launchpad.database import (
  ...     SourcePackageRelease, SourcePackageName)
  >>> ed_name = SourcePackageName.selectOneBy(name='ed')
  >>> ed_spr = SourcePackageRelease.selectBy(sourcepackagenameID=ed_name.id)[0]

Check if we have rebuid the change's author line properly (as
mentioned in bug # 30621)

  >>> print ed_spr.changelog
  ed (0.2-20) unstable; urgency=low
  ...
   -- James Troup <james@nocrew.org>  Wed,  2 Apr 2003 17:19:47 +0100

Some new fields required for NoMoreAptFtparchive implementation are
present in SourcePackageRelease. They are cached from the DSC and used
for the archive index generation:

The 'Maintainer:' identification in RFC-822 format, as it was in DSC:

  >>> ed_spr.dsc_maintainer_rfc822
  u'James Troup <james@nocrew.org>'

Version of debian policy/standards used to build this sourcepackage:

  >>> ed_spr.dsc_standards_version
  u'3.5.8.0'

Format of the included DSC (.dsc) file:

  >>> ed_spr.dsc_format
  u'1.0'

Binaries names claimed to be resulted of this source, line with names
separated by space:

  >>> ed_spr.dsc_binaries
  u'ed'


Roll back everything so that we can try again

  >>> import transaction
  >>> transaction.abort()

First up, construct an upload of just the ed source...

  >>> class MockMunchyLogger:
  ...     def debug(self, s):
  ...         pass

  >>> ed_src = NascentUpload(findPolicyByName('sync'), 
  ...          datadir('split-upload-test'), "ed_0.2-20_source.changes", 
  ...          MockMunchyLogger())
  >>> ed_src.policy.setOptions(MockOptions())
  >>> ed_src.process()
  >>> ed_src.rejected
  False
  >>> success, msgs = ed_src.do_accept()
  >>> success
  True

The ed source would be in NEW, so punt it into accepted.

  >>> from canonical.lp.dbschema import PackageUploadStatus
  >>> from canonical.launchpad.interfaces import QueueInconsistentStateError
  >>> new_queue = hoary.getQueueItems(PackageUploadStatus.NEW)
  >>> for item in new_queue:
  ...     try:
  ...         print "%s/%s" % (item.sourcepackagerelease.name, 
  ...                          item.sourcepackagerelease.version)
  ...         item.setAccepted()
  ...         item.sync()
  ...     except QueueInconsistentStateError, info:
  ...         print info
  ed/0.2-20


Check if we refuse duplicated uploads even before publishing (bug #31038)

The uploaded source will be considered okay, since it still passing
all the consistency checks.

However there is another candidate, submitted before and not yet
published in the archive, which provides the same sourcepackagename
and sourcepackageversion for the distrorelease in question.

  >>> ed_src = NascentUpload(findPolicyByName('sync'),
  ...          datadir('split-upload-test'), "ed_0.2-20_source.changes",
  ...          MockMunchyLogger())
  >>> ed_src.policy.setOptions(MockOptions())
  >>> ed_src.process()
  >>> ed_src.rejected
  False

This is a special trick to make do_accept() consider this upload OLD
(publication already present in the archive), so it will try to
automatically promote the queue entry to ACCEPTED.

  >>> for upload_file in ed_src.files:
  ...     upload_file.new = False

The we invoke do_accept() normally, since the upload is consistent.
but since the uniqueness check in IUpload.setAccepted() has detected
another accepted candidate that conflicts with the proposed one.
The upload will be rejected.

  >>> success, msgs = ed_src.do_accept()
  >>> ed_src.rejected
  True
  >>> print ed_src.rejection_message
  Exception while accepting: This sourcepackagerelease is already accepted in hoary.

We rely on process-upload transaction rollback to not store bogus
queue entry in the database.

  >>> success
  False

  >>> hoary.getQueueItems(PackageUploadStatus.NEW).count()
  1

Next we send in the binaries, since the source should be in ACCEPTED the
binary should go straight there too.

XXX cprov 20060728: Building from ACCEPTED is special condition, not
really used in production. We should remove the support for this use
case, see further info in bug #55774.

  >>> ed_bin = NascentUpload(findPolicyByName('sync'), 
  ...          datadir('split-upload-test'), "ed_0.2-20_i386.changes", 
  ...          MockMunchyLogger())
  >>> ed_bin.policy.setOptions(MockOptions())
  >>> ed_bin.policy.can_upload_binaries = True
  >>> ed_bin.process()
  >>> ed_bin.rejected
  False
  >>> print ed_bin.rejection_message+"\nEND"
  END
  >>> success, msgs = ed_bin.do_accept()
  >>> success
  True

Chuck it all away again

  >>> transaction.abort()

And this time, try an upload to -updates, it'll have to be signed etc because
we're using the insecure policy to check everything in it end-to-end. We have
to set hoary to CURRENT in order to do this because we're not allowed
to upload to -UPDATES in a DEVELOPMENT release.

  >>> hoary.releasestatus = DistributionReleaseStatus.CURRENT

  >>> ed_src = NascentUpload(findPolicyByName('sync'), 
  ...          datadir('updates-upload-test'), "ed_0.2-20_source.changes", 
  ...          MockMunchyLogger())
  >>> ed_src.policy.setOptions(MockOptions())
  >>> ed_src.policy.distrorelease = None # Override this by the changes
  >>> ed_src.process()
  >>> ed_src.rejected
  False
  >>> ed_src.rejection_message
  ''
  >>> success, msgs = ed_src.do_accept()
  >>> success
  True
  >>> print ed_src.queue_root.pocket.name
  UPDATES

Even though this went to a pocket and thus would be unapproved rather
than accepted, the ed upload ought still make it to NEW instead of
unapproved.

  >>> print ed_src.queue_root.status.name
  NEW

And pop it back to development now that we're done

  >>> hoary.releasestatus = DistributionReleaseStatus.DEVELOPMENT

Check the uploader behaviour against a missing orig.tar.gz file,
bug # 30741.

  >>> ed21_src = NascentUpload(findPolicyByName('sync'),
  ...          datadir('ed-0.2-21'), "ed_0.2-21_source.changes",
  ...          MockMunchyLogger())
  >>> ed21_src.policy.setOptions(MockOptions())
  >>> ed21_src.process()
  >>> ed21_src.rejected
  True
  >>> print ed21_src.rejection_message+"\nEND"
  Unable to find ed_0.2.orig.tar.gz in the distribution.
  END

== Installer source uploads doesn't contain 'Standards-Version' ==

Check if we can accept a installer-source upload which doesn't have
'Standards-Version' field in DSC. See bug #75874 for further
information.

  >>> inst_src = NascentUpload(
  ...          findPolicyByName('sync'), datadir(''),
  ...          "test75874_0.1_source.changes", MockMunchyLogger())
  >>> inst_src.policy.setOptions(MockOptions())
  >>> inst_src.process()

  >>> inst_src.rejected
  False

  >>> success, msgs = inst_src.do_accept()
  >>> success
  True

Look for the respective SourcePackageRelease entry and inspect its
content, it should have all the required fields except the
'dsc_standards_version':

  >>> inst_queue = hoary.getQueueItems(DistroReleaseQueueStatus.NEW,
  ...                                  name='test75874', exact_match=True)[0]
  >>> inst_spr = inst_queue.sources[0].sourcepackagerelease

  >>> inst_spr.dsc_maintainer_rfc822
  u'Colin Watson <cjwatson@ubuntu.com>'

  >>> inst_spr.dsc_binaries
  u'test75874'

  >>> inst_spr.dsc_standards_version is None
  True

Chuck it all away again

  >>> transaction.abort()

== Insecure Policy ==

'insecure' upload policy forces NascentUpload to perform ACLs over the
DSC signature. It only allows 'source' upload where both, changesfile
and DSC, should be signed.

  >>> from zope.interface.verify import verifyObject
  >>> from canonical.launchpad.interfaces import (
  ...     IGPGKey, IPersonSet)

Ensure that the key is attached to the database to be used in tests:

  >>> key_owner = getUtility(IPersonSet).getByName('kinnison')
  >>> uploader_key = getUtility(IGPGKeySet).new(key_owner, '20687895',
  ...     '961F4EB829D7D304A77477822BC8401620687895', 1024, GPGKeyAlgorithm.D)

When using 'insecure' policy, NascentUpload instace stores the DSC
sigining key reference as an IGPGKey:

  >>> ed_ok = NascentUpload(
  ...     findPolicyByName('insecure'), datadir(''),
  ...     "ed_0.2-20_i386.changes", MockMunchyLogger())
  >>> ed_ok.policy.setOptions(MockOptions())

XXX cprov 20061206: ok, by lack of better sample-packages we will
override the policy attributes to allow binary (and mixed) uploads.

  >>> ed_ok.policy.can_upload_binaries = True
  >>> ed_ok.policy.can_upload_mixed = True

  >>> ed_ok.process()
  >>> ed_ok.rejected
  False

  >>> verifyObject(IGPGKey, ed_ok.dsc_signing_key)
  True

  >>> ed_ok.dsc_signing_key.fingerprint == uploader_key.fingerprint
  True

Let's modify the current ACL rules for ubuntu, moving the upload
rights to all commponents from 'ubuntu-team' to 'sabdfl':

  >>> new_uploader = getUtility(IPersonSet).getByName('sabdfl')
  >>> for distro_component in ubuntu.uploaders:
  ...     distro_component.uploader = new_uploader

This time the upload should fail because the ACLs don't let
"kinnison", the key owner,  upload a package.

  >>> ed_failed = NascentUpload(
  ...     findPolicyByName('insecure'), datadir(''),
  ...     "ed_0.2-20_i386.changes", MockMunchyLogger())
  >>> ed_failed.policy.setOptions(MockOptions())

XXX cprov 20061206: ok, by lack of better sample-packages we will
override the policy attributes to allow binary (and mixed) upload.

  >>> ed_failed.policy.can_upload_binaries = True
  >>> ed_failed.policy.can_upload_mixed = True

  >>> ed_failed.process()
  >>> ed_failed.rejected
  True
  >>> ed_failed.rejection_message
  'Signer has no upload rights at all to this distribution.'

Even in a rejected upload using 'insecure' policy, the DSC signing key
is stored in NascentUpload instance for further checks:

  >>> verifyObject(IGPGKey, ed_failed.dsc_signing_key)
  True

  >>> ed_failed.dsc_signing_key.fingerprint == uploader_key.fingerprint
  True

