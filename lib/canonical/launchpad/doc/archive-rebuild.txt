== Archive rebuild ==

We model archive rebuild attempt as distinct `IArchives` targeted to
a `IDistroSeries`. This way we can have several rebuilds all with
similar purposes for different distroseries individually published in
the same location. See the example:

 1. rebuilds.ubuntu.com/warty-gcc-toolchain
 2. rebuilds.ubuntu.com/warty-gtk2.0
 3. rebuilds.ubuntu.com/hoary-gcc-toolchain
 4. rebuilds.ubuntu.com/hoary-glibc

== IArchiveRebuildSet utility ==

This utility implements methods for creating and looking up
ArchiveRebuilds.

    >>> from canonical.launchpad.interfaces.archiverebuild import (
    ...     IArchiveRebuildSet)
    >>> archiverebuild_set = getUtility(IArchiveRebuildSet)

We can iterate over existent `ArchiveRebuild` using the
IArchvieRebuildSet utility, even when we have none in sampledata.

    >>> [rebuild.id for rebuild in archiverebuild_set]
    []

We will create some rebuilds also using the utility. For doing that we
need a target IDistroSeries and a IPerson to be the registrant.

    >>> from canonical.launchpad.interfaces.distribution import (
    ...     IDistributionSet)
    >>> from canonical.launchpad.interfaces.person import (
    ...     IPersonSet)

    >>> ubuntu = getUtility(IDistributionSet).getByName('ubuntu')
    >>> warty = ubuntu.getSeries('warty')
    >>> hoary = ubuntu.getSeries('hoary')

    >>> cprov = getUtility(IPersonSet).getByName('cprov')

`ArchiveRebuild`s get created with distinct names.

    >>> rebuild_warty = archiverebuild_set.new(
    ...     name='gcc4.0-toolchain', distroseries=warty,
    ...     registrant=cprov, reason="Because I can.")

    >>> rebuild_hoary = archiverebuild_set.new(
    ...     name='gcc4.0-toolchain', distroseries=hoary,
    ...     registrant=cprov, reason="Because I want.")

Once created the ArchiveRebuild records can be seen during the
IArchiveRebuildSet iteration, which is ordered by descending database
ID, i.e. newest first.

    >>> for rebuild in archiverebuild_set:
    ...     print rebuild.archive.name
    hoary-gcc4.0-toolchain
    warty-gcc4.0-toolchain

ArchiveRebuilds are created with INPROGRESS status.

    >>> print rebuild_warty.status.name
    INPROGRESS

Archive.name collisions are detected during creation and an error is
raised.

    >>> archiverebuild_set.new(
    ...     name='gcc4.0-toolchain', distroseries=hoary,
    ...     registrant=cprov, reason="Because I want.")
    Traceback (most recent call last):
    ...
    ArchiveRebuildAlreadyExists: There is already an archive rebuild
    named 'hoary-gcc4.0-toolchain' in ubuntu context. Choose another name.

A ArchiveRebuild can be retrieved by database ID.

    >>> candidate = archiverebuild_set.get(rebuild_hoary.id)
    >>> rebuild_hoary.id == candidate.id
    True

and also by targeted distribution and archive name.

    >>> candidate = archiverebuild_set.getByDistributionAndArchiveName(
    ...     ubuntu, 'hoary-gcc4.0-toolchain')
    >>> rebuild_hoary.id == candidate.id
    True

When a corresponding rebuild cannot be found, None is returned.

    >>> print archiverebuild_set.getByDistributionAndArchiveName(
    ...     ubuntu, 'boing')
    None

`ArchiveRebuild`s are directly attached to `DistroSeries` and that's
how they are going to be presented.

Before verifying the results of getByDistroSeries() we will create
other rebuilds for hoary.

    >>> rebuild_hoary_gtk = archiverebuild_set.new(
    ...     name='gtk3', distroseries=hoary,
    ...     registrant=cprov, reason="Because we need.")

    >>> rebuild_hoary_qt = archiverebuild_set.new(
    ...     name='qt4', distroseries=hoary,
    ...     registrant=cprov, reason="Because we were forced.")

The results of getByDistroSeries() are ordered by ascending 'status'
and then descending database ID. This way, rebuilds in early
status/stages will be presented first.

    >>> for rebuild in archiverebuild_set.getByDistroSeries(hoary):
    ...     print rebuild.archive.name, rebuild.status.name
    hoary-qt4               INPROGRESS
    hoary-gtk3              INPROGRESS
    hoary-gcc4.0-toolchain  INPROGRESS

Setting 'hoary-qt4' rebuild as OBSOLETE will move it to the end of the
list, since it is an higher 'status' (see further details about rebuild
state-handling below).

    >>> login('celso.providelo@canonical.com')
    >>> rebuild_hoary_qt.setObsolete()
    >>> login(ANONYMOUS)

    >>> for rebuild in archiverebuild_set.getByDistroSeries(hoary):
    ...     print rebuild.archive.name, rebuild.status.name
    hoary-gtk3              INPROGRESS
    hoary-gcc4.0-toolchain  INPROGRESS
    hoary-qt4               OBSOLETE


== IArchiveRebuild ==

`IArchiveRebuild` objects represents a join between a `IArchive` with
REBUILD purpose and an `IDistroSeries`. It also aggregates extra
information to this relationship as 'registrant', 'status' and 'reason'.

    >>> from canonical.launchpad.interfaces.archiverebuild import (
    ...     IArchiveRebuild)
    >>> from canonical.launchpad.webapp.testing import verifyObject

    >>> verifyObject(IArchiveRebuild, rebuild_hoary_qt)
    True

Let's see what is stored for the just-created 'rebuild_hoary_qt'.

It stores the 'date_created' as the current transaction time.

    >>> from canonical.database.sqlbase import get_transaction_timestamp
    >>> rebuild_hoary_qt.date_created == get_transaction_timestamp()
    True

It correctly attaches a REBUILD archive to a hoary distroseries.

    >>> print rebuild_hoary_qt.archive.name
    hoary-qt4

    >>> print rebuild_hoary_qt.archive.purpose.name
    REBUILD

    >>> print rebuild_hoary_qt.distroseries.displayname
    Hoary

The rebuild 'registrant'.

    >>> print rebuild_hoary_qt.registrant.displayname
    Celso Providelo

Additional information about the rebuild status and further comments.

    >>> print rebuild_hoary_qt.status.name
    OBSOLETE

    >>> print rebuild_hoary_qt.reason
    Because we were forced.

A 'title' attribute is also implemented for convenience.

    >>> print rebuild_hoary_qt.title
    hoary-qt4 for Hoary


== Editing ArchiveRebuild ==

Once created, the ArchiveRebuild lifecycle will imply in changes on
its 'status' and 'reason' fields.

The 'status' field can't be changed directly. It's is protected by a
state-machine that forces users to use special method that may trigger
further actions required to keep the rebuild workflow sane. They are:

 * setInProgress();
 * setCancelled();
 * setComplete();
 * setObsolete();

'status' attribute write is forbidden on IArchiveRebuild.

    >>> login('foo.bar@canonical.com')
    >>> from canonical.launchpad.interfaces.archiverebuild import (
    ...      ArchiveRebuildStatus)

    >>> rebuild_hoary_qt.status = ArchiveRebuildStatus.INPROGRESS
    Traceback (most recent call last):
    ...
    ForbiddenAttribute: ('status', <ArchiveRebuild at ...>)

The same operation also results in an error if we remove the zope
security proxy.

    >>> from zope.security.proxy import removeSecurityProxy
    >>> naked_rebuild = removeSecurityProxy(rebuild_hoary_qt)
    >>> naked_rebuild.status = ArchiveRebuildStatus.INPROGRESS
    Traceback (most recent call last):
    ...
    ArchiveRebuildStatusWriteProtectedError: Directly write on archive
    rebuild status is forbidden use the provided methods to set it.

Changing the 'status' is only possible via the mentioned methods.

    >>> rebuild_hoary_qt.setComplete()
    >>> print rebuild_hoary_qt.status.name
    COMPLETE

An error is also raised if a callsite attempts to set a rebuild to the
same status is already is.

    >>> rebuild_hoary_qt.setComplete()
    Traceback (most recent call last):
    ...
    ArchiveRebuildInconsistentStateError: Archive rebuild is already in
    COMPLETE status

'status' and 'reason' can only be changed by users in the following
users:

 1. 'registrant';
 2. Distribution onwer;
 3. Launchpad administrator.

An anonymous user cannot modify an ArchiveRebuild.

    >>> login(ANONYMOUS)
    >>> rebuild_hoary_qt.setCancelled()
    Traceback (most recent call last):
    ...
    Unauthorized: (..., 'setCancelled', 'launchpad.Edit')

    >>> rebuild_hoary_qt.reason = 'Who does need QT4 ?'
    Traceback (most recent call last):
    ...
    Unauthorized: (..., 'reason', 'launchpad.Edit')

The same goes for No Privileged user.

    >>> login('no-priv@canonical.com')

    >>> rebuild_hoary_qt.setCancelled()
    Traceback (most recent call last):
    ...
    Unauthorized: (..., 'setCancelled', 'launchpad.Edit')

    >>> rebuild_hoary_qt.reason = 'Who does need QT4 ?'
    Traceback (most recent call last):
    ...
    Unauthorized: (..., 'reason', 'launchpad.Edit')

Celso Providelo, as the rebuild registrant, can modify it.

    >>> login('celso.providelo@canonical.com')
    >>> rebuild_hoary_qt.setCancelled()
    >>> rebuild_hoary_qt.reason = 'Who does need QT4 ?'

Jeff Waugh as member of the team owning ubuntu distribution can also
edit it.

    >>> from canonical.launchpad.interfaces.person import IPersonSet
    >>> jdub = getUtility(IPersonSet).getByName('jdub')
    >>> jdub.inTeam(ubuntu.owner)
    True

    >>> login('jeff.waugh@ubuntulinux.com')
    >>> rebuild_hoary_qt.setComplete()
    >>> rebuild_hoary_qt.reason = 'I do not.'

Finally, a Launchpad administrator can also edit it, because he can do
pretty much everything he wants.

    >>> login('foo.bar@canonical.com')
    >>> rebuild_hoary_qt.setObsolete()
    >>> rebuild_hoary_qt.reason = 'I do :)'

