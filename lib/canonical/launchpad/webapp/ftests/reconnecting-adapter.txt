= Reconnecting Database Adapter =

Occasionally the database connections to Postgres may get dropped (due
to upgrades, network problems or bugs).  These outages should not
affect Launchpad for longer than the duration of the problem.

Therefore, Launchpad's main and session database connections must be
able to handle such outages.  We use a special "reconnecting database
connection" wrapper to implement this.

First import a few things for the test:

  >>> import psycopg
  >>> from canonical.config import config
  >>> from canonical.database.ftests import PortForwardTestSetup
  >>> from canonical.ftests.pgsql import PgTestSetup
  >>> from canonical.launchpad.webapp.adapter import (
  ...     ReconnectingDatabaseAdapter, ReconnectingConnection,
  ...     ReconnectingCursor, DisconnectedConnectionError)


Set up a port forwarder to the main Postgres database, so that we can
simulate connection drops:

  >>> portforward = PortForwardTestSetup()
  >>> portforward.setUp()


== ReconnectingConnection ==

The ReconnectingConnection class acts as a DB-API connection.  To
create a connection, we need to pass a connection factory function as
an argument to the constructor.  Lets create a reconnecting database
connection that goes through the port forwarding proxy:

  >>> def connection_factory():
  ...     dsn = 'dbname=%s host=localhost port=5555 user=%s' % (
  ...         PgTestSetup().dbname, config.launchpad.dbuser)
  ...     return psycopg.connect(dsn)
  >>> db = ReconnectingConnection(connection_factory)
  >>> db
  <...ReconnectingConnection ...>


This connection object can be used like any other connection:

  >>> cursor = db.cursor()
  >>> cursor.execute('SELECT 1')
  >>> for row in cursor.fetchall():
  ...     print row
  (1,)
  >>> db.rollback()
  >>> cursor.execute('SELECT 1')
  >>> cursor.fetchone()
  (1,)
  >>> db.commit()
  >>> cursor.execute('invalid sql that will abort the transaction')
  Traceback (most recent call last):
    ...
  ProgrammingError: ERROR:  syntax error at or near "invalid"
  LINE 1: invalid sql that will abort the transaction
          ^
  <BLANKLINE>
  invalid sql that will abort the transaction
  >>> db.rollback()


Unlike a regular database connection, this one can recover from a
database disconnection.  We will simulate a disconnect by temporarily
stopping the port forwarding proxy:

  >>> portforward.tearDown()
  >>> portforward.setUp()


If we now try to issue commands to the database, we get the
disconnection error from the database wrapped in a Zope Retry
exception:

  >>> import sys
  >>> import traceback
  >>> from zope.publisher.interfaces import Retry
  >>> try:
  ...     cursor.execute('SELECT 1')
  ... except Retry, exc:
  ...     print 'Retry:'
  ...     traceback.print_exception(file=sys.stdout,
  ...                               *exc.getOriginalException())
  Retry:
  Traceback (most recent call last):
    ...
  OperationalError: no connection to the server


While it is possible to reconnect to the database again, we continue
to get Retry errors until a rollback() is issued:

  >>> try:
  ...     cursor.fetchone()
  ... except Retry, exc:
  ...     print 'Retry:'
  ...     traceback.print_exception(file=sys.stdout,
  ...                               *exc.getOriginalException())
  Retry:
  DisconnectedConnectionError: Already disconnected
  >>> db.commit()
  Traceback (most recent call last):
    ...
  Retry: ...
  >>> db.rollback()


After the rollback, the connection is usable again:

  >>> cursor.execute('SELECT 1')
  >>> cursor.fetchone()
  (1,)


Database disconnections are also caught by other database operations,
such as committing the exception:

  >>> cursor.execute('SELECT 1')
  >>> cursor.fetchall()
  [(1,)]
  >>> portforward.tearDown()
  >>> portforward.setUp()
  >>> try:
  ...     db.commit()
  ... except Retry, exc:
  ...     print 'Retry:'
  ...     traceback.print_exception(file=sys.stdout,
  ...                               *exc.getOriginalException())
  Retry:
  Traceback (most recent call last):
    ...
  DatabaseError: {<cursor ...>: 'server closed the connection unexpectedly...'}
  >>> db.rollback()

XXX: 20070424 jamesh
We should test that a Retry exception gets issued if we disconnect
while reading a result set, but it is hard to trigger with simple
queries since the first results have already been received by the time
execute() completes.


== ReconnectingDatabaseAdapter ==

ReconnectingDatabaseAdapter is a Zope database adapter that makes use
of ReconnectingConnection for its underlying connections.  We'll now
create such an adapter, going through the port forwarding proxy:

  >>> adapter = ReconnectingDatabaseAdapter(
  ...     'dbi://%s:@localhost:5555/%s' % (
  ...     config.launchpad.dbuser, PgTestSetup().dbname))


The resulting connection and cursor provide the expected interfaces:

  >>> from zope.interface import providedBy
  >>> from zope.app.rdb.interfaces import (
  ...     IManageableZopeDatabaseAdapter, IZopeConnection, IZopeCursor)

  >>> IManageableZopeDatabaseAdapter in providedBy(adapter)
  True
  >>> db = adapter()
  >>> IZopeConnection in providedBy(db)
  True
  >>> cursor = db.cursor()
  >>> IZopeCursor in providedBy(cursor)
  True

The resulting connection behaves the same as a normal database
connection:

  >>> cursor.execute('SELECT 1')
  >>> for row in cursor.fetchall():
  ...     print row
  [1]
  >>> db.rollback()


And it handles disconnections too:

  >>> cursor.execute('SELECT 1')
  >>> cursor.fetchone()
  [1]
  >>> portforward.tearDown()
  >>> portforward.setUp()
  >>> try:
  ...     cursor.execute('SELECT 1')
  ... except Retry, exc:
  ...     print 'Retry:'
  ...     traceback.print_exception(file=sys.stdout,
  ...                               *exc.getOriginalException())
  Retry:
  Traceback (most recent call last):
    ...
  ProgrammingError: server closed the connection unexpectedly
    This probably means the server terminated abnormally
    before or while processing the request.
  <BLANKLINE>
  SELECT 1


Cleanup:

  >>> portforward.tearDown()
