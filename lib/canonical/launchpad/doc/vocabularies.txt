= Vocabularies =

== Introduction ==

Vocabularies are lists of terms. In Launchpad's Component Architecture
(CA), a vocabulary is a list of terms that a widget (normally a selection
style widget) "speaks", i.e., its allowed values.

    >>> from zope.component import getUtility
    >>> from canonical.launchpad.ftests import ANONYMOUS, login
    >>> from canonical.launchpad.interfaces import (
    ...     IPersonSet, IOpenLaunchBag, IProductSet, IProjectSet)
    >>> from canonical.database.sqlbase import flush_database_updates
    >>> person_set = getUtility(IPersonSet)
    >>> product_set = getUtility(IProductSet)
    >>> login('foo.bar@canonical.com')
    >>> launchbag = getUtility(IOpenLaunchBag)
    >>> launchbag.clear()


=== Values, Tokens, and Titles ===

In Launchpad, we generally use "tokenized vocabularies." Each term in
a vocabulary has a value, token and title. A term is rendered in a
select widget like this:

<option value="$token">$title</option>

The $token is probably the data you would store in your DB. The Token is
used to uniquely identify a Term, and the Title is the thing you display
to the user.


== Launchpad Vocabularies ==

There are two kinds of vocabularies in Launchpad: enumerable and
non-enumerable. Enumerable vocabularies are short enough to render in a
select widget. Non-enumerable vocabularies require a query interface to make
it easy to choose just one or a couple of options from several hundred,
several thousand, or more.

Vocabularies should not be imported - they can be retrieved from the
vocabulary registry.

    >>> from zope.schema.vocabulary import getVocabularyRegistry
    >>> vocabulary_registry = getVocabularyRegistry()
    >>> product_vocabulary = vocabulary_registry.get(None, "Product")
    >>> product_vocabulary.displayname
    'Select a project'


== Enumerable Vocabularies ==

== ActiveMailingList ==

The active mailing lists vocabulary matches and returns only those mailing
lists which are active.

    >>> list_vocabulary = vocabulary_registry.get(None, 'ActiveMailingList')
    >>> from canonical.launchpad.webapp.testing import verifyObject
    >>> from canonical.launchpad.webapp.vocabulary import IHugeVocabulary
    >>> verifyObject(IHugeVocabulary, list_vocabulary)
    True
    >>> list_vocabulary.displayname
    'Select an active mailing list.'

At first, there are no active mailing lists.

    >>> list(list_vocabulary)
    []
    >>> len(list_vocabulary)
    0
    >>> list(list_vocabulary.search())
    []

Mailing lists are not active when they are first registered.

    >>> # These are the convoluted steps to create some mailing lists.  We
    >>> # can't use the shortcuts that other related tests use because those
    >>> # leave the list in the ACTIVE state and we want to check things
    >>> # before they get to that state.
    >>> personset = getUtility(IPersonSet)
    >>> ddaa = personset.getByName('ddaa')
    >>> carlos = personset.getByName('carlos')
    >>> from canonical.launchpad.interfaces import (
    ...     IMailingListSet, MailingListStatus, TeamSubscriptionPolicy)
    >>> team_one = personset.newTeam(
    ...     ddaa, 'bass-players', 'Bass Players',
    ...     subscriptionpolicy=TeamSubscriptionPolicy.OPEN)
    >>> team_two = personset.newTeam(
    ...     ddaa, 'guitar-players', 'Guitar Players',
    ...     subscriptionpolicy=TeamSubscriptionPolicy.OPEN)
    >>> team_three = personset.newTeam(
    ...     ddaa, 'drummers', 'Drummers',
    ...     subscriptionpolicy=TeamSubscriptionPolicy.OPEN)
    >>> listset = getUtility(IMailingListSet)
    >>> list_one = listset.new(team_one)
    >>> list_two = listset.new(team_two)
    >>> list_three = listset.new(team_three)
    >>> list(list_vocabulary)
    []
    >>> len(list_vocabulary)
    0
    >>> list(list_vocabulary.search())
    []

Even when the mailing lists are approved, they are not yet active.

    >>> list_one.review(carlos, MailingListStatus.APPROVED)
    >>> list_two.review(carlos, MailingListStatus.APPROVED)
    >>> list_three.review(carlos, MailingListStatus.APPROVED)
    >>> list(list_vocabulary)
    []
    >>> len(list_vocabulary)
    0
    >>> list(list_vocabulary.search())
    []

Mailing lists become active once they have been constructed by Mailman (which
indicates so by transitioning the state to ACTIVE).

    >>> list_one.startConstructing()
    >>> list_two.startConstructing()
    >>> list_three.startConstructing()
    >>> list_one.transitionToStatus(MailingListStatus.ACTIVE)
    >>> list_two.transitionToStatus(MailingListStatus.ACTIVE)
    >>> list_three.transitionToStatus(MailingListStatus.ACTIVE)
    >>> flush_database_updates()
    >>> sorted(mailing_list.team.displayname
    ...        for mailing_list in list_vocabulary)
    [u'Bass Players', u'Drummers', u'Guitar Players']
    >>> len(list_vocabulary)
    3

Searching for active lists is done through the vocabulary as well.  With a
search term of None, all active lists are returned.

    >>> sorted(mailing_list.team.displayname
    ...        for mailing_list in list_vocabulary.search(None))
    [u'Bass Players', u'Drummers', u'Guitar Players']

If given, the search term matches the team name.

    >>> sorted(mailing_list.team.displayname
    ...        for mailing_list in list_vocabulary.search('player'))
    [u'Bass Players', u'Guitar Players']

The IHugeVocabulary interface also requires a search method that returns a
CountableIterator.

    >>> iter = list_vocabulary.searchForTerms('player')
    >>> from canonical.launchpad.webapp.vocabulary import CountableIterator
    >>> isinstance(iter, CountableIterator)
    True
    >>> sorted((term.value.team.name, term.token, term.title)
    ...         for term in iter)
    [(u'bass-players', 'bass-players', u'Bass Players'),
     (u'guitar-players', 'guitar-players', u'Guitar Players')]

The vocabulary supports accessing mailing lists by 'term', where the term must
be a mailing list.  The returned term's value is the mailing list object, the
token is the team name and the title is the team's display name.

    >>> term_1 = list_vocabulary.getTerm(list_two)
    >>> term_1.value.team.displayname
    u'Guitar Players'
    >>> term_1.token
    'guitar-players'
    >>> term_1.title
    u'Guitar Players'

You cannot get a term by an other object, such as a team.

    >>> list_vocabulary.getTerm(team_one)
    Traceback (most recent call last):
    ...
    ForbiddenAttribute: ...

Given a token, we can get back the term.

    >>> term_2 = list_vocabulary.getTermByToken(term_1.token)
    >>> term_2.value.team.displayname
    u'Guitar Players'
    >>> term_3 = list_vocabulary.getTerm(list_one)
    >>> term_4 = list_vocabulary.getTermByToken(term_3.token)
    >>> term_4.value.team.displayname
    u'Bass Players'

If you try to get the term by a token not represented in the vocabulary, you
get an exception.

    >>> list_vocabulary.getTermByToken('turntablists')
    Traceback (most recent call last):
    ...
    LookupError: turntablists

You can also ask whether a mailing list is contained in the vocabulary.

    >>> list_three in list_vocabulary
    True

You are not allowed to ask whether a non-mailing list object is contained in
this vocabulary.

    >>> team_three in list_vocabulary
    Traceback (most recent call last):
    ...
    ForbiddenAttribute: ...

Non-ACTIVE mailing lists are also not contained in the vocabulary.

    >>> team_four = personset.newTeam(
    ...     ddaa, 'flautists', 'Flautists',
    ...     subscriptionpolicy=TeamSubscriptionPolicy.OPEN)
    >>> list_four = listset.new(team_four)
    >>> list_four in list_vocabulary
    False

Sometimes, the vocabulary search doesn't return any active lists.

    >>> list(list_vocabulary.search('flautists'))
    []
    >>> list(list_vocabulary.search('cellists'))
    []


=== DistroSeriesVocabulary ===

Reflects the available distribution serieses.  Results are ordered by
`name`

    >>> distroseries_vocabulary = vocabulary_registry.get(
    ...     None,"DistroSeries")
    >>> for term in distroseries_vocabulary:
    ...     print "%30s %s" % (term.token, term.title)
            ubuntu/breezy-autotest Ubuntu: Breezy Badger Autotest
                     ubuntu/grumpy Ubuntu: The Grumpy Groundhog Release
                      ubuntu/hoary Ubuntu: The Hoary Hedgehog Release
                      ubuntu/warty Ubuntu: The Warty Warthog Release
                      debian/sarge Debian: Sarge
                        debian/sid Debian: Sid
                      debian/woody Debian: WOODY
                    guadalinex/2k5 GuadaLinex: Guada 2005
                    kubuntu/krunch Kubuntu: The Krunchy Kangaroo
                        redhat/7.0 Red Hat: Seven
                        redhat/six Red Hat: Six Six Six
        ubuntutest/breezy-autotest ubuntutest: Breezy Badger Autotest
             ubuntutest/hoary-test ubuntutest: Mock Hoary

    >>> distroseries_vocabulary.getTermByToken('ubuntu/hoary').value.title
    u'The Hoary Hedgehog Release'

    >>> def getTerms(vocab, search_text):
    ...     [vocab.toTerm(item) for item in vocab.search(search_text)]

    >>> getTerms(distroseries_vocabulary, 'woody')
    >>> getTerms(distroseries_vocabulary, 'debian')
    >>> getTerms(distroseries_vocabulary, 'invalid')
    >>> getTerms(distroseries_vocabulary, '')

    >> [term.token for term in distroseries_vocabulary.search('woody')]
    ['debian/woody']
    >> [term.token for term in distroseries_vocabulary.search('debian')]
    ['debian/sarge', 'debian/sid', 'debian/woody']
    >> [term.token for term in distroseries_vocabulary.search('invalid')]
    []
    >> [term.token for term in distroseries_vocabulary.search('')]
    []


=== DistributionUsingMaloneVocabulary ===

All the distributions that use Malone as their main bug tracker.

    >>> using_malone_vocabulary = vocabulary_registry.get(
    ...     None, 'DistributionUsingMalone')
    >>> len(using_malone_vocabulary)
    2
    >>> for term in using_malone_vocabulary:
    ...     print term.token, term.value.displayname, term.title
    gentoo Gentoo Gentoo
    ubuntu Ubuntu Ubuntu

    >>> from canonical.launchpad.interfaces import ILaunchpadCelebrities
    >>> ubuntu = getUtility(ILaunchpadCelebrities).ubuntu
    >>> ubuntu in using_malone_vocabulary
    True
    >>> debian = getUtility(ILaunchpadCelebrities).debian
    >>> debian in using_malone_vocabulary
    False

    >>> using_malone_vocabulary.getQuery() is None
    True

    >>> term = using_malone_vocabulary.getTerm(ubuntu)
    >>> print term.token, term.value.displayname, term.title
    ubuntu Ubuntu Ubuntu

    >>> term = using_malone_vocabulary.getTerm(debian)
    Traceback (most recent call last):
    ...
    LookupError:...

    >>> term = using_malone_vocabulary.getTermByToken('ubuntu')
    >>> print term.token, term.value.displayname, term.title
    ubuntu Ubuntu Ubuntu

    >>> term = using_malone_vocabulary.getTermByToken('debian')
    Traceback (most recent call last):
    ...
    LookupError:...


=== PersonActiveMembership ===

All the teams the person is an active member of.

    >>> foo_bar = person_set.getByEmail('foo.bar@canonical.com')
    >>> person_active_membership = vocabulary_registry.get(
    ...     foo_bar, 'PersonActiveMembership')
    >>> len(person_active_membership)
    9
    >>> for term in person_active_membership:
    ...     print term.token, term.value.displayname, term.title
    canonical-partner-dev Canonical Partner Developers
        Canonical Partner Developers
    guadamen GuadaMen GuadaMen
    admins Launchpad Administrators Launchpad Administrators
    launchpad-buildd-admins Launchpad Buildd Admins Launchpad Buildd Admins
    launchpad Launchpad Developers Launchpad Developers
    testing-spanish-team testing Spanish team testing Spanish team
    name18 Ubuntu Gnome Team Ubuntu Gnome Team
    ubuntu-team Ubuntu Team Ubuntu Team
    vcs-imports VCS imports VCS imports

    >>> launchpad_team = person_set.getByName('launchpad')
    >>> launchpad_team in person_active_membership
    True
    >>> mirrors_admins = person_set.getByName('mirrors-admins')
    >>> mirrors_admins in person_active_membership
    False

The PersonActiveMembership vocabulary only shows teams where the
membership is public.

    >>> from canonical.launchpad.interfaces import PersonVisibility
    >>> otherteam = person_set.getByName('otherteam')
    >>> otherteam.addMember(foo_bar, foo_bar)

    >>> otherteam.visibility = PersonVisibility.PRIVATE_MEMBERSHIP
    >>> for term in person_active_membership:
    ...     print term.token, term.value.displayname, term.title
    canonical-partner-dev Canonical Partner Developers
        Canonical Partner Developers
    guadamen GuadaMen GuadaMen
    admins Launchpad Administrators Launchpad Administrators
    launchpad-buildd-admins Launchpad Buildd Admins Launchpad Buildd Admins
    launchpad Launchpad Developers Launchpad Developers
    testing-spanish-team testing Spanish team testing Spanish team
    name18 Ubuntu Gnome Team Ubuntu Gnome Team
    ubuntu-team Ubuntu Team Ubuntu Team
    vcs-imports VCS imports VCS imports


    >>> otherteam.visibility = PersonVisibility.PUBLIC
    >>> for term in person_active_membership:
    ...     print term.token, term.value.displayname, term.title
    canonical-partner-dev Canonical Partner Developers
        Canonical Partner Developers
    guadamen GuadaMen GuadaMen
    admins Launchpad Administrators Launchpad Administrators
    launchpad-buildd-admins Launchpad Buildd Admins Launchpad Buildd Admins
    launchpad Launchpad Developers Launchpad Developers
    otherteam Other Team Other Team
    testing-spanish-team testing Spanish team testing Spanish team
    name18 Ubuntu Gnome Team Ubuntu Gnome Team
    ubuntu-team Ubuntu Team Ubuntu Team
    vcs-imports VCS imports VCS imports

    >>> term = person_active_membership.getTerm(launchpad_team)
    >>> print term.token, term.value.displayname, term.title
    launchpad Launchpad Developers Launchpad Developers

    >>> term = person_active_membership.getTerm(mirrors_admins)
    Traceback (most recent call last):
    ...
    LookupError:...

    >>> term = person_active_membership.getTermByToken('launchpad')
    >>> print term.token, term.value.displayname, term.title
    launchpad Launchpad Developers Launchpad Developers

    >>> term = person_active_membership.getTermByToken('mirrors-admins')
    Traceback (most recent call last):
    ...
    LookupError:...


=== PersonTeamParticipations ===

This vocabulary contains all the teams a person participates in. Either
through direct or indirect participations.

    >>> sample_person = person_set.getByName('name12')
    >>> [membership.team.name
    ...  for membership in sample_person.myactivememberships]
    [u'landscape-developers', u'launchpad-users', u'name20']
    >>> [team.name for team in sample_person.teams_participated_in]
    [u'landscape-developers', u'launchpad-users', u'name18', u'name20']

    >>> sample_person_teams_vocabulary = vocabulary_registry.get(
    ...     sample_person, 'PersonTeamParticipations')

    >>> for term in sample_person_teams_vocabulary:
    ...     print "%s: %s (%s)" % (term.token, term.title, term.value.name)
    landscape-developers: Landscape Developers (landscape-developers)
    launchpad-users: Launchpad Users (launchpad-users)
    name18: Ubuntu Gnome Team (name18)
    name20: Warty Security Team (name20)


=== Milestone ===

All the milestone in a context.

If no context is given, all milestones in the database are in the
vocabulary.

    >>> all_milestones = vocabulary_registry.get(None, 'Milestone')
    >>> len(all_milestones)
    3
    >>> for term in all_milestones:
    ...     print "%s: %s" % (term.value.target.name, term.value.name)
    debian: 3.1
    debian: 3.1-rc1
    firefox: 1.0

If the context is a product, only the product's milestones are in the
vocabulary.

    >>> firefox = product_set.getByName('firefox')
    >>> firefox_milestones = vocabulary_registry.get(firefox, 'Milestone')
    >>> for term in firefox_milestones:
    ...     print "%s: %s" % (term.value.target.name, term.value.name)
    firefox: 1.0

If the context is a bugtask, only the bugtask's target's milestones are
in the vocabulary.

    >>> from canonical.launchpad.interfaces import IBugSet
    >>> bug_one = getUtility(IBugSet).get(1)
    >>> firefox_task = bug_one.bugtasks[0]
    >>> firefox_task.bugtargetdisplayname
    u'Mozilla Firefox'
    >>> firefox_task_milestones = vocabulary_registry.get(
    ...     firefox_task, 'Milestone')
    >>> for term in firefox_task_milestones:
    ...     print "%s: %s" % (term.value.target.name, term.value.name)
    firefox: 1.0

    >>> bug_two = getUtility(IBugSet).get(2)
    >>> debian_woody_task = bug_two.bugtasks[-1]
    >>> debian_woody_task.bugtargetdisplayname
    u'mozilla-firefox (Debian Woody)'
    >>> debian_woody_milestones = vocabulary_registry.get(
    ...     debian_woody_task, 'Milestone')
    >>> debian_woody = debian_woody_task.distroseries
    >>> len(debian_woody_milestones)
    2

If one of the milestones is disabled, it won't be included in the vocabulary
anymore.

    >>> milestone = debian_woody.milestones[0]
    >>> milestone.visible = False
    >>> flush_database_updates()
    >>> len(vocabulary_registry.get(debian_woody_task, 'Milestone'))
    1

If the milestone was used in a bugtask before it was marked invisible, though,
it'll still show up on the vocabulary so that users can change it.

    >>> debian_woody_task.milestone = milestone
    >>> flush_database_updates()
    >>> len(vocabulary_registry.get(debian_woody_task, 'Milestone'))
    2

If the context is a specification, only milestones from that specification
target are in the vocabulary.

    >>> from canonical.launchpad.interfaces import ISpecificationSet
    >>> canvas_spec = firefox.getSpecification('canvas')
    >>> spec_target_milestones = vocabulary_registry.get(
    ...     canvas_spec, 'Milestone')
    >>> for term in spec_target_milestones:
    ...     print "%s: %s" % (term.value.target.name, term.value.name)
    firefox: 1.0


The vocabulary contains only visible milestones.

    >>> one_dot_o = firefox.milestones[0]
    >>> one_dot_o.name
    u'1.0'
    >>> one_dot_o.visible = False

We have set two milestones to be not visible, so there is only one left that
is visible in all_milestones.

    >>> all_milestones = vocabulary_registry.get(None, 'Milestone')
    >>> for term in all_milestones:
    ...     print "%s: %s" % (term.value.target.name, term.value.name)
    debian: 3.1-rc1
    >>> firefox_milestones = vocabulary_registry.get(firefox, 'Milestone')
    >>> len(firefox_milestones)
    0
    >>> firefox_task_milestones = vocabulary_registry.get(
    ...     firefox_task, 'Milestone')
    >>> len(firefox_task_milestones)
    0

There's one exception, though; if a bugtask is assigned to a
non-visible milestone, that milestone will be in the vocabulary.

    >>> firefox_task_milestones = vocabulary_registry.get(
    ...     firefox_task, 'Milestone')
    >>> firefox_task.milestone = one_dot_o
    >>> for term in firefox_task_milestones:
    ...     print "%s: %s" % (term.value.target.name, term.value.name)
    firefox: 1.0


=== BugNominatableSeriesVocabulary ===

All the serieses that can be nominated for fixing.

This vocabulary needs either a product or distribution in the launchbag
to get the available series. It also needs a bug, since it list only
series that haven't already been nominated.

Let's start with putting a product in the launchbag.

    >>> getUtility(IOpenLaunchBag).clear()
    >>> getUtility(IOpenLaunchBag).add(firefox)

Firefox has the following series:

    >>> for series in firefox.serieses:
    ...     print series.name
    1.0
    trunk

Now, if we look at bug one, we can see that it hasn't been targeted
for any Firefox series yet:

    >>> bug_one = getUtility(IBugSet).get(1)
    >>> for bugtask in bug_one.bugtasks:
    ...     print bugtask.bugtargetdisplayname
    Mozilla Firefox
    mozilla-firefox (Ubuntu)
    mozilla-firefox (Debian)

It has however been nominated for 1.0:

    >>> for nomination in bug_one.getNominations(firefox):
    ...     print nomination.target.name
    1.0

This means that if we iterate through the vocabulary with bug one, only
the trunk will be nominatable:

    >>> firefox_bug_one = bug_one.bugtasks[0]
    >>> firefox_bug_one.target.name
    u'firefox'
    >>> series_vocabulary = vocabulary_registry.get(
    ...     firefox_bug_one, 'BugNominatableSerieses')
    >>> for term in series_vocabulary:
    ...     print "%s: %s" % (term.token, term.title)
    trunk: Trunk

No series is targeted or nominated on bug 4:

    >>> bug_four = getUtility(IBugSet).get(4)
    >>> for bugtask in bug_four.bugtasks:
    ...     print bugtask.bugtargetdisplayname
    Mozilla Firefox

    >>> for nomination in bug_four.getNominations(firefox):
    ...     print nomination.target.name

So if we give bug four to the vocabulary, all serieses will be returned:

    >>> firefox_bug_four = bug_four.bugtasks[0]
    >>> firefox_bug_four.target.name
    u'firefox'
    >>> series_vocabulary = vocabulary_registry.get(
    ...     firefox_bug_four, 'BugNominatableSerieses')
    >>> for term in series_vocabulary:
    ...     print "%s: %s" % (term.token, term.title)
    1.0: 1.0
    trunk: Trunk

The same works for distributions:

    >>> getUtility(IOpenLaunchBag).clear()
    >>> getUtility(IOpenLaunchBag).add(ubuntu)

Bug one is nominated for Ubuntu Hoary:

    >>> bug_one = getUtility(IBugSet).get(1)
    >>> for bugtask in bug_one.bugtasks:
    ...     print bugtask.bugtargetdisplayname
    Mozilla Firefox
    mozilla-firefox (Ubuntu)
    mozilla-firefox (Debian)

    >>> for nomination in bug_one.getNominations(ubuntu):
    ...     print nomination.target.name
    hoary

So Hoary isn't included in the vocabulary:

    >>> ubuntu_bug_one = bug_one.bugtasks[1]
    >>> ubuntu_bug_one.distribution.name
    u'ubuntu'
    >>> serieses_vocabulary = vocabulary_registry.get(
    ...     ubuntu_bug_one, 'BugNominatableSerieses')
    >>> for term in serieses_vocabulary:
    ...     print "%s: %s" % (term.token, term.title)
    breezy-autotest: Breezy-autotest
    grumpy: Grumpy
    warty: Warty

The same is true for bug two, where the bug is targeted to Hoary.

    >>> bug_two = getUtility(IBugSet).get(2)
    >>> for bugtask in bug_two.bugtasks:
    ...     print bugtask.bugtargetdisplayname
    Tomcat
    Ubuntu
    Ubuntu Hoary
    mozilla-firefox (Debian)
    mozilla-firefox (Debian Woody)

    >>> for nomination in bug_two.getNominations(ubuntu):
    ...     print nomination.target.name
    hoary

    >>> ubuntu_bug_two = bug_two.bugtasks[1]
    >>> ubuntu_bug_two.distribution.name
    u'ubuntu'
    >>> serieses_vocabulary = vocabulary_registry.get(
    ...     ubuntu_bug_two, 'BugNominatableSerieses')
    >>> for term in serieses_vocabulary:
    ...     print "%s: %s" % (term.token, term.title)
    breezy-autotest: Breezy-autotest
    grumpy: Grumpy
    warty: Warty

We can get a specific term by using the release name:

    >>> term = serieses_vocabulary.getTermByToken('warty')
    >>> term.value == ubuntu.getSeries('warty')
    True

Trying to get a non-existant release will result in a LookupError:

    >>> series_vocabulary.getTermByToken('non-such-release')
    Traceback (most recent call last):
    ...
    LookupError...


=== ProjectProductsVocabulary ===

All the products in a project.

    >>> mozilla_project = getUtility(IProjectSet).getByName('mozilla')
    >>> mozilla_products_vocabulary = vocabulary_registry.get(
    ...     mozilla_project,'ProjectProducts')

    >>> for term in mozilla_products_vocabulary:
    ...     print "%s: %s" %(term.token, term.title)
    firefox: Mozilla Firefox
    thunderbird: Mozilla Thunderbird


=== ProjectProductsVocabularyUsingMalone ===

All the products in a project using Malone.


    >>> mozilla_project = getUtility(IProjectSet).getByName('mozilla')
    >>> for product in mozilla_project.products:
    ...     print "%s: %s" % (product.name, product.official_malone)
    firefox: True
    thunderbird: False

    >>> mozilla_products_vocabulary = vocabulary_registry.get(
    ...     mozilla_project,'ProjectProductsUsingMalone')
    >>> for term in mozilla_products_vocabulary:
    ...     print "%s: %s" %(term.token, term.title)
    firefox: Mozilla Firefox


== Non-Enumerable Vocabularies ==

Iterating over non-enumerable vocabularies, while possible, will
probably kill the database. Instead, these vocabularies are
search-driven.


=== BinaryAndSourcePackageNameVocabulary ===

The list of binary and source package names, ordered by name.

    >>> package_name_vocabulary = vocabulary_registry.get(
    ...     None, "BinaryAndSourcePackageName")
    >>> package_name_vocabulary.displayname
    'Select a Package'

When a package name matches both a binary package name and a source
package of the exact same name, the binary package name is
returned. This allows us, in bug reporting for example, to collect the
most specific information possible.

Let's demonstrate by searching for "mozilla-firefox", for which there is
both a source and binary package of that name.

    >>> package_name_terms = package_name_vocabulary.searchForTerms(
    ...     "mozilla-firefox")
    >>> package_name_terms.count()
    2
    >>> [(term.token, term.title) for term in package_name_terms]
    [('mozilla-firefox', u'iceweasel huh ?'),
     ('mozilla-firefox-data', u'Mozilla Firefox Data is .....')]

Searching for "mozilla" should return the binary package name above, and
the source package named "mozilla".

    >>> package_name_terms = package_name_vocabulary.searchForTerms("mozilla")
    >>> package_name_terms.count()
    3
    >>> [(term.token, term.title) for term in package_name_terms]
    [('mozilla', 'Not uploaded'),
     ('mozilla-firefox', u'iceweasel huh ?'),
     ('mozilla-firefox-data', u'Mozilla Firefox Data is .....')]

The search does a case-insensitive, substring match.

    >>> package_name_terms = package_name_vocabulary.searchForTerms("lInuX")
    >>> package_name_terms.count()
    2
    >>> [(term.token, term.title) for term in package_name_terms]
    [('linux-2.6.12', u'this kernel is like the crystal method: a temple o...'),
     ('linux-source-2.6.15', u'Source of: linux-2.6.12')]


=== BinaryPackageNameVocabulary ===

All the binary packages in Launchpad.

    >>> bpn_vocabulary = vocabulary_registry.get(None, 'BinaryPackageName')
    >>> len(bpn_vocabulary)
    8

    >>> bpn_terms = bpn_vocabulary.searchForTerms("mozilla")
    >>> len(bpn_terms)
    2
    >>> [(term.token, term.title) for term in bpn_terms]
    [('mozilla-firefox', u'iceweasel huh ?'),
     ('mozilla-firefox-data', u'Mozilla Firefox Data is .....')]


=== SourcePackageNameVocabulary ===

All the source packages in Launchpad.

    >>> spn_vocabulary = vocabulary_registry.get(None, 'SourcePackageName')
    >>> len(spn_vocabulary)
    17

    >>> spn_terms = spn_vocabulary.searchForTerms("mozilla")
    >>> len(spn_terms)
    2
    >>> [(term.token, term.title) for term in spn_terms]
    [('mozilla', 'Not yet built'),
     ('mozilla-firefox', u'Source of: mozilla-firefox, mozilla-firefox-data')]

    >>> spn_terms = spn_vocabulary.searchForTerms("pmount")
    >>> len(spn_terms)
    1
    >>> [(term.token, term.title) for term in spn_terms]
    [('pmount', u'Source of: pmount')]


=== LanguageVocabulary ===

All the languages known by Launchpad.

    >>> from canonical.launchpad.interfaces import ILanguageSet
    >>> language_set = getUtility(ILanguageSet)

    >>> language_vocabulary = vocabulary_registry.get(
    ...     None, 'Language')
    >>> len(language_vocabulary)
    559

    >>> es = language_set['es']
    >>> term = language_vocabulary.getTerm(es)
    >>> print term.token, term.value.displayname, term.title
    es Spanish (es) Spanish (es)

    >>> pt_BR = language_set['pt_BR']
    >>> term = language_vocabulary.getTerm(pt_BR)
    >>> print term.token, term.value.displayname, term.title
    pt_BR Portuguese (Brazil) (pt_BR) Portuguese (Brazil) (pt_BR)

    >>> term = language_vocabulary.getTermByToken('es')
    >>> print term.token, term.value.displayname, term.title
    es Spanish (es) Spanish (es)

    >>> term = language_vocabulary.getTermByToken('pt_BR')
    >>> print term.token, term.value.displayname, term.title
    pt_BR Portuguese (Brazil) (pt_BR) Portuguese (Brazil) (pt_BR)

A language token/code may not be used with 'in' tests.

    >>> u'es' in language_vocabulary
    Traceback (most recent call last):
    ...
    AssertionError: 'in LanguageVocabulary' requires ILanguage
    as left operand, got <type 'unicode'> instead.

A LookupError is raised when a term is requested by token that does
not exist.

    >>> language_vocabulary.getTermByToken('foo')
    Traceback (most recent call last):
    ...
    LookupError:...


=== TranslatableLanguageVocabulary ===

All the translatable languages known by Launchpad. English is not
a translatable language, nor are Languages that are not visible.

The vocabulary will behave identically to LanguageVocabulary in tests
when the language is not English and is visible.

    >>> translatable_language_vocabulary = vocabulary_registry.get(
    ...     None, 'TranslatableLanguage')

    >>> es = language_set['es']
    >>> term = translatable_language_vocabulary.getTerm(es)
    >>> print term.token, term.value.displayname, term.title
    es Spanish (es) Spanish (es)

    >>> pt_BR = language_set['pt_BR']
    >>> term = translatable_language_vocabulary.getTerm(pt_BR)
    >>> print term.token, term.value.displayname, term.title
    pt_BR Portuguese (Brazil) (pt_BR) Portuguese (Brazil) (pt_BR)

    >>> term = translatable_language_vocabulary.getTermByToken('es')
    >>> print term.token, term.value.displayname, term.title
    es Spanish (es) Spanish (es)

    >>> term = translatable_language_vocabulary.getTermByToken('pt_BR')
    >>> print term.token, term.value.displayname, term.title
    pt_BR Portuguese (Brazil) (pt_BR) Portuguese (Brazil) (pt_BR)

    >>> es in translatable_language_vocabulary
    True

A language token/code may not be used with 'in' tests.

    >>> u'es' in translatable_language_vocabulary
    Traceback (most recent call last):
    ...
    AssertionError: 'in TranslatableLanguageVocabulary' requires
    ILanguage as left operand, got <type 'unicode'> instead.

A LookupError is raised when a term is requested by token that does
not exist.

    >>> translatable_language_vocabulary.getTermByToken('foo')
    Traceback (most recent call last):
    ...
    LookupError:...

English and non-visible languages are not in the
TranslatableLanguageVocabulary. English is the only visible language
excluded from the vocabulary.

    >>> translatable_languages = set(
    ...     t.value for t in translatable_language_vocabulary)
    >>> all_languages = set(l.value for l in language_vocabulary)
    >>> difference = list(all_languages - translatable_languages)
    >>> len(difference)
    89

    >>> hidden_languages = [lang for lang in difference if not lang.visible]
    >>> len(hidden_languages)
    88

    >>> [lang.displayname for lang in difference if lang.visible]
    [u'English (en)']

The vocabulary will raise a LookupError if asked to return English.

    >>> english = language_set['en']
    >>> english in difference
    True
    >>> english in hidden_languages
    False
    >>> english.visible
    True

    >>> english in translatable_language_vocabulary
    False

    >>> translatable_language_vocabulary.getTerm(english)
    Traceback (most recent call last):
    ...
    LookupError:...

    >>> translatable_language_vocabulary.getTermByToken('en')
    Traceback (most recent call last):
    ...
    LookupError:...

The vocabulary will raise a LookupError if asked to return a
non-visible language. Chinese (zh) is one such language.

    >>> chinese = language_set['zh']
    >>> chinese in difference
    True
    >>> chinese in hidden_languages
    True
    >>> chinese.visible
    False

    >>> chinese in translatable_language_vocabulary
    False

    >>> translatable_language_vocabulary.getTerm(chinese)
    Traceback (most recent call last):
    ...
    LookupError:...

    >>> translatable_language_vocabulary.getTermByToken('zh')
    Traceback (most recent call last):
    ...
    LookupError:...


=== BranchVocabulary ===

The list of bzr branches registered in Launchpad.

Searchable by branch name or URL, registrant name, and project name.
Results are not restricted in any way by the context, but the results
are restricted based on who is asking (as far as private branches is
concerned).

    # Just use None as the context.
    >>> branch_vocabulary = vocabulary_registry.get(None, "Branch")
    >>> def print_vocab_branches(vocab, search):
    ...     for term in vocab.searchForTerms(search):
    ...         print term.value.unique_name

    >>> print_vocab_branches(branch_vocabulary, 'main')
    ~name12/firefox/main
    ~stevea/thunderbird/main
    ~justdave/+junk/main
    ~kiko/+junk/main
    ~vcs-imports/evolution/main
    ~name12/gnome-terminal/main

    >>> print_vocab_branches(branch_vocabulary, 'vcs-imports')
    ~vcs-imports/gnome-terminal/import
    ~vcs-imports/evolution/import
    ~vcs-imports/evolution/main

    >>> print_vocab_branches(branch_vocabulary, 'evolution')
    ~carlos/evolution/2.0
    ~vcs-imports/evolution/import
    ~vcs-imports/evolution/main

A search with the full branch unique name should also find the branch.

    >>> print_vocab_branches(branch_vocabulary, '~name12/firefox/main')
    ~name12/firefox/main

The tokens used by terms retrieved from BranchVocabulary use the
branch unique name as an ID:

    >>> from canonical.launchpad.interfaces.branchlookup import IBranchLookup
    >>> branch = getUtility(IBranchLookup).get(15)
    >>> print branch.unique_name
    ~name12/gnome-terminal/main
    >>> term = branch_vocabulary.toTerm(branch)
    >>> print term.token
    ~name12/gnome-terminal/main

The BranchVocabulary recognises both unique names and URLs as tokens:

    >>> term = branch_vocabulary.getTermByToken('~name12/gnome-terminal/main')
    >>> term.value == branch
    True
    >>> term = branch_vocabulary.getTermByToken(
    ...     'http://bazaar.launchpad.dev/~name12/gnome-terminal/main/')
    >>> term.value == branch
    True
    >>> term = branch_vocabulary.getTermByToken(
    ...     'http://example.com/gnome-terminal/main')
    >>> term.value == branch
    True

The searches that the BranchVocabulary does are private branch aware.
The results are effectively filtered on what the logged in user is
able to see.

    >>> print_vocab_branches(branch_vocabulary, 'trunk')
    ~spiv/+junk/trunk
    ~limi/+junk/trunk
    ~landscape-developers/landscape/trunk

    >>> login('no-priv@canonical.com')
    >>> print_vocab_branches(branch_vocabulary, 'trunk')
    ~spiv/+junk/trunk
    ~limi/+junk/trunk

    >>> login('foo.bar@canonical.com')


=== BranchRestrictedOnProduct ===

The BranchRestrictedOnProduct vocabulary restricts the result set to
those of the product of the context.  Currently only two types of
context are supported: Product; and Branch.  If a branch is the context,
then the product of the branch is used to restrict the query.

    >>> gnome_terminal = getUtility(IProductSet)["gnome-terminal"]
    >>> branch_vocabulary = vocabulary_registry.get(
    ...     gnome_terminal, "BranchRestrictedOnProduct")
    >>> print_vocab_branches(branch_vocabulary, 'main')
    ~name12/gnome-terminal/main

    >>> print_vocab_branches(branch_vocabulary, 'vcs-imports')
    ~vcs-imports/gnome-terminal/import

If a full unique name is entered that has a different product, the
branch is not part of the vocabulary.

    >>> print_vocab_branches(branch_vocabulary, '~name12/gnome-terminal/main')
    ~name12/gnome-terminal/main

    >>> print_vocab_branches(branch_vocabulary, '~name12/firefox/main')


The BranchRestrictedOnProduct behaves the same way as the more generic
BranchVocabulary with respect to the tokens and privacy awareness.


=== ProjectVocabulary ===

The list of selectable projects. The results are ordered by displayname.

    >>> project_vocabulary = vocabulary_registry.get(None, "Project")
    >>> project_vocabulary.displayname
    'Select a project group'

    >>> [p.title for p in project_vocabulary.search('mozilla')]
    [u'The Mozilla Project']
    >>> mozilla = project_vocabulary.getTermByToken('mozilla')
    >>> mozilla.title
    u'The Mozilla Project'

  The ProjectVocabulary does not list inactive projects.

    >>> from canonical.launchpad.interfaces import IProjectSet
    >>> moz_project = getUtility(IProjectSet)['mozilla']
    >>> moz_project in project_vocabulary
    True

    >>> [p.title for p in project_vocabulary.search('mozilla')]
    [u'The Mozilla Project']
    >>> moz_project.active = False
    >>> flush_database_updates()
    >>> moz_project in project_vocabulary
    False

    >>> [p.title for p in project_vocabulary.search('mozilla')]
    []
    >>> moz_project.active = True
    >>> flush_database_updates()


=== ProductVocabulary ===

The list of selectable products. Results are ordered by displayname.

    >>> product_vocabulary = vocabulary_registry.get(None, "Product")
    >>> product_vocabulary.displayname
    'Select a project'

    >>> list(product_vocabulary.search(None))
    []
    >>> gnome_products = product_vocabulary.search("gnome")
    >>> l = [product_term.title for product_term in gnome_products]
    >>> l[:2]
    [u'The Evolution Groupware Application', u'The GNOME Terminal Emulator']
    >>> l[2:]
    [u'The Gnome Panel Applets', u'Gnome Baker']
    >>> arch = product_vocabulary.getTermByToken("arch-mirrors")
    >>> arch.title
    u'Arch archive mirrors'

The ProductVocabulary does not list inactive products.

    >>> arch.value in product_vocabulary
    True

    >>> arch_product = product_set['arch-mirrors']
    >>> arch_product in product_vocabulary
    True

    >>> [t.title for t in product_vocabulary.search('arch and archive')]
    [u'Arch archive mirrors']
    >>> arch_product.active = False
    >>> flush_database_updates()
    >>> arch_product in product_vocabulary
    False
    >>> [t.title for t in product_vocabulary.search('arch and archive')]
    []
    >>> arch_product.active = True
    >>> flush_database_updates()


=== ProductReleaseVocabulary ===

The list of selectable products releases.

    >>> productrelease_vocabulary = vocabulary_registry.get(None,
    ...                                                     "ProductRelease")
    >>> productrelease_vocabulary.displayname
    'Select a Product Release'

    >>> list(productrelease_vocabulary.search(None))
    []
    >>> evolution_releases = productrelease_vocabulary.search("evolution")
    >>> l = [release_term.title for release_term in evolution_releases]
    >>> release = productrelease_vocabulary.getTermByToken(
    ...     "evolution/trunk/2.1.6")
    >>> release.title
    u'evolution trunk 2.1.6'


=== PersonAccountToMergeVocabulary ===

All non-merged people. This vocabulary is meant to be used only in the
people merge form.

    >>> vocab = vocabulary_registry.get(None, "PersonAccountToMerge")
    >>> vocab.displayname
    'Select a Person to Merge'

Searching for None returns an empty list.

    >>> list(vocab.search(None))
    []

Searching for 'Launchpad Administrators' will return an empty list, because
teams are not part of this vocabulary.

    >>> [item.name for item in list(vocab.search('Launchpad Administrators'))]
    []

A search using part of the email address of a team will also return an
empty list.

    >>> list(vocab.search('rosetta'))
    []

Searching for a person without a preferred email will return that
person's name.

    >>> [person.name for person in vocab.search('salgado')]
    [u'salgado']

A search using the beginning of a person's preferred email will return
that person that owns that email.

    >>> [(person.name, person.preferredemail.email)
    ...  for person in vocab.search('foo.bar')]
    [(u'name16', u'foo.bar@canonical.com')]

A search using part of the host of an email address will not return
anything, as we only match against the beginning of an email address.

    >>> list(vocab.search('canonical'))
    []

A person with a single and unvalidated email address can be merged.

    >>> from canonical.launchpad.interfaces import PersonCreationRationale
    >>> fooperson, email = person_set.createPersonAndEmail(
    ...     'foobaz@bar.com', PersonCreationRationale.UNKNOWN,
    ...     name='foobaz', displayname='foo baz')
    >>> fooperson in vocab
    True

But any person without a single email address can't.

    >>> email.destroySelf()
    >>> fooperson in vocab
    False

Any person that's already merged is not part of this vocabulary:

    >>> cprov = person_set.getByName('cprov')
    >>> cprov in vocab
    True

    # Here we cheat because IPerson.merged is a readonly attribute.
    >>> from zope.security.proxy import removeSecurityProxy
    >>> naked_cprov = removeSecurityProxy(cprov)
    >>> naked_cprov.merged = 1
    >>> naked_cprov.syncUpdate()
    >>> cprov in vocab
    False

A person whose account_status is any of the statuses of
INACTIVE_ACCOUNT_STATUSES is part of the vocabulary, though.

    >>> from canonical.launchpad.interfaces import INACTIVE_ACCOUNT_STATUSES
    >>> naked_cprov.merged = None
    >>> checked_count = 0
    >>> for status in INACTIVE_ACCOUNT_STATUSES:
    ...     naked_cprov.account_status = status
    ...     naked_cprov.syncUpdate()
    ...     checked_count += int(cprov in vocab)
    >>> checked_count == len(INACTIVE_ACCOUNT_STATUSES)
    True

=== NonMergedPeopleAndTeams ===

All non-merged people and teams.

    >>> vocab = vocabulary_registry.get(None, "NonMergedPeopleAndTeams")
    >>> vocab.displayname
    'Select a Person or Team'

    >>> list(vocab.search(None))
    []

This vocabulary includes both validated and unvalidated profiles, as well
as teams:

    >>> [(p.name, p.is_valid_person) for p in vocab.search('matsubara')]
    [(u'matsubara', False)]

    >>> [(p.name, p.is_valid_person) for p in vocab.search('mark@hbd.com')]
    [(u'sabdfl', True)]

    >>> [(p.name, getattr(p.teamowner, 'name', None))
    ...  for p in vocab.search('ubuntu-team')]
    [(u'doc', None), (u'name18', u'sabdfl'), (u'ubuntu-team', u'sabdfl')]

But it doesn't include merged accounts:

    >>> fooperson in vocab
    False


=== ValidPersonOrTeam ===

All 'valid' persons or teams. This is currently defined as people with a
password, a preferred email address and not merged (Person.merged is
None).  It also includes all public teams and private teams the
user has permission to view.

    >>> vocab = vocabulary_registry.get(None, "ValidPersonOrTeam")
    >>> vocab.displayname
    'Select a Person or Team'

    >>> list(vocab.search(None))
    []

We can do token lookups using either a person's name or a person's email
address.

    >>> vocab.getTermByToken('name16').value.displayname
    u'Foo Bar'
    >>> vocab.getTermByToken('foo.bar@canonical.com').value.displayname
    u'Foo Bar'

Almost all teams have the word 'team' as part of their names, so a search
for 'team' should give us some of them.  Notice that the
PRIVATE_MEMBERSHIP_TEAM 'myteam' is not included in the results.

    >>> sorted(person.name for person in vocab.search('team'))
    [u'name18', u'name20', u'name21', u'no-team-memberships',
     u'otherteam', u'simple-team', u'testing-spanish-team',
     u'ubuntu-team', u'warty-gnome']

Logging in as 'owner', who is a member of myteam shows that the token
lookup still omits myteam.

    >>> login('owner@canonical.com')
    >>> sorted(person.name for person in vocab.search('team'))
    [u'name18', u'name20', u'name21', u'no-team-memberships',
     u'otherteam', u'simple-team', u'testing-spanish-team',
     u'ubuntu-team', u'warty-gnome']

A PRIVATE team is displayed when the logged in user is a member of the team.

    >>> commercial = person_set.getByEmail('commercial-member@canonical.com')
    >>> vocab = vocabulary_registry.get(commercial, "ValidPersonOrTeam")
    >>> login('commercial-member@canonical.com')
    >>> priv_team = factory.makeTeam(name='private-team',
    ...     owner=commercial,
    ...     visibility=PersonVisibility.PRIVATE)
    >>> sorted(person.name for person in vocab.search('team'))
    [u'name18', u'name20', u'name21', u'no-team-memberships', u'otherteam',
     u'private-team',
     u'simple-team', u'testing-spanish-team', u'ubuntu-team', u'warty-gnome']

The PRIVATE team is not returned for a user who is not part of the team.

    >>> login('owner@canonical.com')
    >>> sorted(person.name for person in vocab.search('team'))
    [u'name18', u'name20', u'name21', u'no-team-memberships',
     u'otherteam', u'simple-team', u'testing-spanish-team',
     u'ubuntu-team', u'warty-gnome']

Searching for all teams, which requires monkey-patching the
`allow_null_search` property, will also return the private team.

    >>> login('commercial-member@canonical.com')
    >>> vocab.allow_null_search = True
    >>> sorted(person.name for person in vocab.search(''))
    [...u'private-team'...]

A search for 'support' will give us only the persons which have support
as part of their name or displayname, or the beginning of
one of its email addresses.

    >>> login('foo.bar@canonical.com')
    >>> vocab = vocabulary_registry.get(None, "ValidPersonOrTeam")
    >>> sorted(person.name for person in vocab.search('support'))
    [u'ubuntu-team']

Matsubara doesn't have a preferred email address; he's not a valid Person.

    >>> sorted(person.name for person in vocab.search('matsubara'))
    []

'foo.bar@canonical.com' is a valid Person.

    >>> [person.name for person in vocab.search('foo.bar')]
    [u'name16']

The vocabulary also allows us to search by IRC nickname.

    >>> [cjwatson] = vocab.search('cjwatson')
    >>> cjwatson.name, cjwatson.preferredemail.email
    (u'kamion', u'colin.watson@ubuntulinux.com')
    >>> [ircid.nickname for ircid in cjwatson.ircnicknames]
    [u'cjwatson']


=== ValidOwner ===

All valid persons and teams are also valid owners.

    >>> vocab = vocabulary_registry.get(None, "ValidOwner")
    >>> vocab.displayname
    'Select a Person or Team'

    >>> list(vocab.search(None))
    []

Almost all teams have the word 'team' as part of their names, so a
search for 'team' should give us some of them:

    >>> sorted(person.name for person in vocab.search('team'))
    [u'name18', u'name20', u'name21', u'no-team-memberships', u'otherteam',
     u'simple-team', u'testing-spanish-team', u'ubuntu-team', u'warty-gnome']


=== ValidTeam ===

The valid team vocabulary is just like the ValidPersonOrTeam vocabulary,
except that its terms are limited only to teams.  No non-team Persons will be
returned.

    >>> vocab = vocabulary_registry.get(None, 'ValidTeam')
    >>> vocab.displayname
    'Select a Team'
    >>> sorted((team.displayname, team.teamowner.displayname)
    ...        for team in vocab.search(None))
    [(u'Bass Players', u'David Allouche'),
     (u'Bazaar Experts', u'Tim Penhey'),
     (u'Canonical Partner Developers', u'Celso Providelo'),
     (u'Commercial Subscription Admins', u'Commercial Member'),
     (u'Commercial Subscription Approvers', u'Brad Crittenden'),
     (u'Drummers', u'David Allouche'),
     (u'Flautists', u'David Allouche'),
     (u'GuadaMen', u'Foo Bar'),
     (u'Guitar Players', u'David Allouche'),
     (u'Hoary Gnome Team', u'Mark Shuttleworth'),
     (u'Landscape Developers', u'Sample Person'),
     (u'Launchpad Administrators', u'Mark Shuttleworth'),
     (u'Launchpad Beta Testers', u'Launchpad Beta Testers Owner'),
     (u'Launchpad Buildd Admins', u'Foo Bar'),
     (u'Launchpad Developers', u'Foo Bar'),
     (u'Launchpad Users', u'Sample Person'),
     (u'Mailing List Experts', u'Launchpad Administrators'),
     (u'Mirror Administrators', u'Mark Shuttleworth'),
     (u'Other Team', u'Owner'),
     (u'Registry Administrators', u'Mark Shuttleworth'),
     (u'Rosetta Administrators', u'Launchpad Administrators'),
     (u'ShipIt Administrators', u'Mark Shuttleworth'),
     (u'Simple Team', u'One Membership'),
     (u'Ubuntu Gnome Team', u'Mark Shuttleworth'),
     (u'Ubuntu Team', u'Mark Shuttleworth'),
     (u'Ubuntu Translators', u'Rosetta Administrators'),
     (u'Ubuntu branches', u'Ubuntu-branches-owner'),
     (u'VCS imports', u'Robert Collins'),
     (u'Warty Gnome Team', u'Mark Shuttleworth'),
     (u'Warty Security Team', u'Mark Shuttleworth'),
     (u'testing Spanish team', u'Carlos Perell\xf3 Mar\xedn')]

Like with ValidPersonOrTeam, you can narrow your search down by providing some
text to match against the team name.  Still, you only get teams back.

    >>> sorted((team.displayname, team.teamowner.displayname)
    ...         for team in vocab.search('spanish'))
    [(u'testing Spanish team', u'Carlos Perell\xf3 Mar\xedn')]
    >>> sorted((team.displayname, team.teamowner.displayname)
    ...        for team in vocab.search('spanish | ubuntu'))
    [(u'Mirror Administrators', u'Mark Shuttleworth'),
     (u'Ubuntu Gnome Team', u'Mark Shuttleworth'),
     (u'Ubuntu Team', u'Mark Shuttleworth'),
     (u'Ubuntu Translators', u'Rosetta Administrators'),
     (u'Ubuntu branches', u'Ubuntu-branches-owner'),
     (u'testing Spanish team', u'Carlos Perell\xf3 Mar\xedn')]
    >>> sorted((team.displayname, team.teamowner.displayname)
    ...        for team in vocab.search('team'))
    [(u'Hoary Gnome Team', u'Mark Shuttleworth'),
     (u'Other Team', u'Owner'),
     (u'Simple Team', u'One Membership'),
     (u'Ubuntu Gnome Team', u'Mark Shuttleworth'),
     (u'Ubuntu Team', u'Mark Shuttleworth'),
     (u'Warty Gnome Team', u'Mark Shuttleworth'),
     (u'Warty Security Team', u'Mark Shuttleworth'),
     (u'testing Spanish team', u'Carlos Perell\xf3 Mar\xedn')]


=== ValidTeamMember ===

With the exception of all teams that have this team as a member and the
team itself, all valid persons and teams are valid members.

    >>> team = person_set.getByName('ubuntu-team')
    >>> team2 = person_set.getByName('guadamen')
    >>> person = person_set.getByName('name16')

ValidTeamMember needs a context:

    >>> vocab = vocabulary_registry.get(None, "ValidTeamMember")
    Traceback (most recent call last):
    ...
    AssertionError: ...

ValidTeamMember's context must implement ITeam:

    >>> vocab = vocabulary_registry.get(person, "ValidTeamMember")
    Traceback (most recent call last):
    ...
    AssertionError: ...

'name16' is a valid member for 'ubuntu-team':

    >>> vocab = vocabulary_registry.get(team, "ValidTeamMember")
    >>> vocab.displayname
    'Select a Person or Team'

    >>> person in vocab
    True
    >>> [person.name for person in vocab.search('foo.bar')]
    [u'name16']

'ubuntu-team' is not a valid member for itself:

    >>> team in vocab
    False
    >>> [person.name for person in vocab.search('ubuntu-team')]
    [u'name18']

'ubuntu-team' is a member of 'guadamen', so 'guadamen' can't be a member
of 'ubuntu-team'.

    >>> team2 in vocab
    False
    >>> [person.name for person in vocab.search('guadamen')]
    []


=== ValidTeamOwner ===

With the exception of the team itself and all teams owned by that team,
all valid persons and teams are valid owners for the team in context.

ValidTeamOwner needs a context.

    >>> vocab = vocabulary_registry.get(None, "ValidTeamOwner")
    Traceback (most recent call last):
    ...
    AssertionError: ...

ValidTeamOwner's context must provide IPerson or IPersonSet.

    >>> vocabulary_registry.get(team, "ValidTeamOwner")
    <...ValidTeamOwnerVocabulary...
    >>> vocabulary_registry.get(person_set, "ValidTeamOwner")
    <...ValidTeamOwnerVocabulary...
    >>> vocabulary_registry.get(firefox, "ValidTeamOwner")
    Traceback (most recent call last):
    ...
    AssertionError: ...

'ubuntu-team' is not a valid owner for itself.

    >>> vocab = vocabulary_registry.get(team, "ValidTeamOwner")
    >>> vocab.displayname
    'Select a Person or Team'

    >>> team in vocab
    False
    >>> [person.name for person in vocab.search('ubuntu-team')]
    [u'name18']

'name16' is a valid owner for 'ubuntu-team'.

    >>> person in vocab
    True
    >>> [person.name for person in vocab.search('foo.bar')]
    [u'name16']

=== ValidPerson ===

All 'valid' persons who are not a team.

    >>> vocab = vocabulary_registry.get(None, "ValidPerson")
    >>> vocab.displayname
    'Select a Person'
    >>> people = vocab.search(None)
    >>> people.count() > 0
    True
    >>> invalid_people = [person for person in people if not person.is_valid_person]
    >>> print len(invalid_people)
    0

There are two 'Carlos' in the sample data but only one is a valid person.

    >>> carlos_people = vocab.search('Carlos')
    >>> print len(list(carlos_people))
    1
    >>> invalid_carlos = [person for person in carlos_people if not person.is_valid_person]
    >>> print len(invalid_carlos)
    0

ValidPerson does not include teams.

    >>> # Create a new team.
    >>> carlos = getUtility(IPersonSet).getByName('carlos')
    >>> carlos_team = factory.makeTeam(
    ...     owner=carlos, name='carlos-team')
    >>> person_or_team_vocab = vocabulary_registry.get(
    ...     None, "ValidPersonOrTeam")
    >>> carlos_people_or_team = person_or_team_vocab.search('carlos')
    >>> # The people or team search yields our one Carlos person and
    >>> # the new team.
    >>> print len(list(carlos_people_or_team))
    2
    >>> carlos_team in carlos_people_or_team
    True

    >>> # But the ValidPersonVocabulary only has the original Carlos
    >>> # person, not the new team.
    >>> carlos_people = vocab.search('carlos')
    >>> print len(list(carlos_people))
    1
    >>> carlos_team in carlos_people
    False

=== Processor ===

All processors type available in Launchpad.

    >>> vocab = vocabulary_registry.get(None, "Processor")
    >>> vocab.displayname
    'Select a Processor'

    >>> [term.token for term in vocab.searchForTerms('386')]
    ['386']


=== BugWatchVocabulary ===

All bug watches associated with a bugtask's bug.

    >>> bug_one = getUtility(IBugSet).get(1)
    >>> bugtask = bug_one.bugtasks[0]
    >>> vocab = vocabulary_registry.get(bugtask, "BugWatch")
    >>> for term in vocab:
    ...     print term.title
    The Mozilla.org Bug Tracker <a...>#123543</a>
    The Mozilla.org Bug Tracker <a...>#2000</a>
    The Mozilla.org Bug Tracker <a...>#42</a>
    Debian Bug tracker <a...>#304014</a>

Bug watches with an email address URL (i.e. starts with "mailto:") are
treated differently.

    >>> from canonical.launchpad.interfaces import (
    ...     IBugWatchSet, IBugTrackerSet)

    >>> bug_twelve = getUtility(IBugSet).get(12)
    >>> email_bugtracker = getUtility(IBugTrackerSet).getByName('email')
    >>> email_bugwatch = getUtility(IBugWatchSet).createBugWatch(
    ...     bug_twelve, launchbag.user, email_bugtracker, '')
    >>> email_bugwatch.url
    u'mailto:bugs@example.com'

The title is rendered differently compared to other bug watches.

    >>> bugtask = bug_twelve.bugtasks[0]
    >>> vocab = vocabulary_registry.get(bugtask, "BugWatch")
    >>> for term in vocab:
    ...     print term.title
    Email bugtracker &lt;<a...>bugs@example.com</a>&gt;

Additionally, if the bug tracker's title contains the bug tracker's
URL, then the title is linkified instead.

    >>> email_bugtracker.title = (
    ...     'Lionel Richtea (%s)' % (
    ...         email_bugtracker.baseurl,))

    >>> for term in vocab:
    ...     print term.title
    Lionel Richtea (<a...>mailto:bugs@example.com</a>)

When there is no logged-in user, the title is much different. The
email address is hidden, and there is no hyperlink.

    >>> current_user = launchbag.user
    >>> login(ANONYMOUS)

    >>> for term in vocab:
    ...     print term.title
    Lionel Richtea (mailto:&lt;email address hidden&gt;)


=== DistributionOrProductVocabulary ===

All products and distributions. Note that the value type is
heterogeneous.

    >>> vocab = vocabulary_registry.get(None, "DistributionOrProduct")
    >>> for term in vocab:
    ...     if 'Ubuntu' in term.title:
    ...         print term.title, '- class', term.value.__class__.__name__
    Ubuntu Linux (Distribution) - class Distribution
    Ubuntu Test (Distribution) - class Distribution

They can be looked up by their aliases too.

    >>> vocab.getTermByToken('firefox').token
    'firefox'
    >>> login('mark@hbd.com')
    >>> product_set['firefox'].setAliases(['iceweasel'])
    >>> login_person(current_user)
    >>> vocab.getTermByToken('iceweasel').token
    'firefox'
    >>> [term.token for term in vocab.searchForTerms(query='iceweasel')]
    ['firefox']

Inactive projects and project groups are not available.

    >>> for term in vocab:
    ...     if 'Tomcat' in term.title:
    ...         print term.title, '- class', term.value.__class__.__name__
    Tomcat (Product) - class Product
    >>> tomcat = product_set.getByName('tomcat')
    >>> tomcat in vocab
    True
    >>> tomcat.active = False
    >>> flush_database_updates()
    >>> vocab = vocabulary_registry.get(None, "DistributionOrProduct")
    >>> tomcat in vocab
    False
    >>> tomcat.active = True
    >>> flush_database_updates()
    >>> vocab = vocabulary_registry.get(None, "DistributionOrProduct")
    >>> tomcat in vocab
    True

Project groups are not contained in this vocabulary:

    >>> apache = getUtility(IProjectSet).getByName('apache')
    >>> apache in vocab
    False


=== DistributionOrProductOrProjectVocabulary ===

All products, projects and distributions. Note that the value type is
heterogeneous.

    >>> vocab = vocabulary_registry.get(None, "DistributionOrProductOrProject")
    >>> for term in vocab:
    ...     if 'Ubuntu' in term.title:
    ...         print term.title, '- class', term.value.__class__.__name__
    Ubuntu Linux (Distribution) - class Distribution
    Ubuntu Test (Distribution) - class Distribution

They can be looked up by their aliases too.

    >>> vocab.getTermByToken('ubuntu').token
    'ubuntu'
    >>> from canonical.launchpad.interfaces.distribution import (
    ...     IDistributionSet)
    >>> login('mark@hbd.com')
    >>> getUtility(IDistributionSet)['ubuntu'].setAliases(['ubantoo'])
    >>> login_person(current_user)
    >>> vocab.getTermByToken('ubantoo').token
    'ubuntu'
    >>> [term.token for term in vocab.searchForTerms(query='ubantoo')]
    ['ubuntu']

Inactive projects and project groups are not available.

    >>> from canonical.launchpad.ftests import syncUpdate
    >>> tomcat = product_set.getByName('tomcat')
    >>> tomcat in vocab
    True
    >>> tomcat.active = False
    >>> syncUpdate(tomcat)
    >>> tomcat in vocab
    False

    >>> apache = getUtility(IProjectSet).getByName('apache')
    >>> apache in vocab
    True
    >>> apache.active = False
    >>> syncUpdate(apache)
    >>> apache in vocab
    False

    >>> vocab = vocabulary_registry.get(None, "DistributionOrProductOrProject")
    >>> for term in vocab:
    ...     if 'Apache' in term.title:
    ...         print term.title, '- class', term.value.__class__.__name__
    >>> for term in vocab:
    ...     if 'Tomcat' in term.title:
    ...         print term.title, '- class', term.value.__class__.__name__
    >>> product_set.getByName('tomcat').active = True
    >>> getUtility(IProjectSet).getByName('apache').active = True
    >>> flush_database_updates()
    >>> vocab = vocabulary_registry.get(None, "DistributionOrProductOrProject")
    >>> for term in vocab:
    ...     if 'Apache' in term.title:
    ...         print term.title, '- class', term.value.__class__.__name__
    Apache (Project) - class Project
    >>> for term in vocab:
    ...     if 'Tomcat' in term.title:
    ...         print term.title, '- class', term.value.__class__.__name__
    Tomcat (Product) - class Product


== FeaturedProjectVocabulary ==

The featured project vocabulary contains all the projects that are
featured on Launchpad. It is a subset of the
DistributionOrProductOrProjectVocabulary (defined using the
_clauseTables).

    >>> featured_project_vocabulary = vocabulary_registry.get(
    ...     None, 'FeaturedProject')
    >>> len(featured_project_vocabulary)
    9

    >>> for term in featured_project_vocabulary:
    ...     print term.token, term.value.displayname, term.title
    applets         Gnome Applets        The Gnome Panel Applets (Product)
    bazaar          Bazaar               Bazaar (Product)
    firefox         Mozilla Firefox      Mozilla Firefox (Product)
    gentoo          Gentoo               The Gentoo Linux (Distribution)
    gnome           GNOME                The GNOME Project (Project)
    gnome-terminal  GNOME Terminal       The GNOME Terminal Emulator (Product)
    mozilla the     Mozilla Project      The Mozilla Project (Project)
    thunderbird     Mozilla Thunderbird  Mozilla Thunderbird (Product)
    ubuntu          Ubuntu               Ubuntu Linux (Distribution)

    >>> ubuntu = getUtility(ILaunchpadCelebrities).ubuntu
    >>> ubuntu in featured_project_vocabulary
    True

    >>> debian = getUtility(ILaunchpadCelebrities).debian
    >>> debian in featured_project_vocabulary
    False


== SpecificationDepCandidatesVocabulary ==

All blueprints that can be added as a dependency of the
context blueprint.

First, we set up a product with three blueprints.

    >>> from canonical.launchpad.interfaces import (
    ...     SpecificationDefinitionStatus)
    >>> evolution = product_set.getByName('evolution')
    >>> foobar_person = person_set.getByName('name16')
    >>> foobar_person.displayname
    u'Foo Bar'
    >>> specset = getUtility(ISpecificationSet)
    >>> spec_a = specset.new('spec-a', 'Spec A',
    ...     'http://www.example.org/SpecA', 'The first spec',
    ...     SpecificationDefinitionStatus.APPROVED, foobar_person,
    ...     product=evolution)
    >>> spec_b = specset.new('spec-b', 'Spec B',
    ...     'http://www.example.org/SpecB', 'The second spec',
    ...     SpecificationDefinitionStatus.APPROVED, foobar_person,
    ...     product=evolution)
    >>> spec_c = specset.new('spec-c', 'Spec C',
    ...     'http://www.example.org/SpecC', 'The third spec',
    ...     SpecificationDefinitionStatus.APPROVED, foobar_person,
    ...     product=evolution)
    >>> sorted([spec.name for spec in evolution.specifications()])
    [u'spec-a', u'spec-b', u'spec-c']

The dependency candidates for spec_a are all blueprints for evolution
except for spec_a itself.

    >>> vocab = vocabulary_registry.get(
    ...     spec_a, "SpecificationDepCandidates")
    >>> sorted([term.value.name for term in vocab])
    [u'spec-b', u'spec-c']

Dependency candidate come only from the same product of the blueprint
they depend on.

    >>> unrelated_spec = specset.new('unrelated-spec', 'Unrelated Spec',
    ...     'http://example.com/SpecU', 'A spec unrelated to Evolution',
    ...     SpecificationDefinitionStatus.APPROVED, foobar_person,
    ...     product=firefox)
    >>> vocab = vocabulary_registry.get(
    ...     spec_a, "SpecificationDepCandidates")
    >>> unrelated_spec in vocab
    False
    >>> [term.value.product for term in vocab
    ...  if term.value.product != evolution]
    []

We mark spec_b as a dependency of spec_a and spec_c as a dependency
of spec_b.

    >>> spec_a.createDependency(spec_b)
    <SpecificationDependency at ...>
    >>> [spec.name for spec in spec_a.dependencies]
    [u'spec-b']

    >>> spec_b.createDependency(spec_c)
    <SpecificationDependency at ...>
    >>> [spec.name for spec in spec_b.dependencies]
    [u'spec-c']

No circular dependencies - the vocabulary excludes specifications that
are a dependency of the context spec.

    >>> spec_a in spec_b.all_blocked
    True
    >>> spec_b in spec_c.all_blocked
    True
    >>> vocab = vocabulary_registry.get(
    ...     spec_c, "SpecificationDepCandidates")
    >>> spec_a in [term.value for term in vocab]
    False

This vocabulary provides the IHugeVocabulary interface.

    >>> from canonical.launchpad.webapp.testing import verifyObject
    >>> from canonical.launchpad.webapp.vocabulary import IHugeVocabulary
    >>> verifyObject(IHugeVocabulary, vocab)
    True

The search() method returns specifications within the vocabulary
that matches the search string. The string is matched against the name,
or fallbacks to a full text search.

    >>> vocab = vocabulary_registry.get(
    ...     spec_a, "SpecificationDepCandidates")
    >>> list(vocab.search('spec-b')) == [spec_b]
    True
    >>> list(vocab.search('third')) == [spec_c]
    True

The search method uses the SQL `LIKE` operator, with the values quoted
appropriately. Queries conataining regual expression operators, for
example, will simply look for the respective characters within the
vocabulary's item (this used to be the cause of an OOPS, see
https://bugs.edge.launchpad.net/blueprint/+bug/139385 for more details).

    >>> list(vocab.search('*'))
    []


=== PPA ===

The PPA vocabulary contains all the PPAs available in a particular
collection. It provides the IHugeVocabulary interface.

    >>> from canonical.launchpad.webapp.testing import verifyObject
    >>> from canonical.launchpad.webapp.vocabulary import IHugeVocabulary

    >>> vocabulary = vocabulary_registry.get(None, 'PPA')
    >>> verifyObject(IHugeVocabulary, vocabulary)
    True

    >>> print vocabulary.displayname
    Select a PPA

Iterations over the PPA vocabulary will return on PPA archives.

    >>> sorted([term.value.owner.name for term in vocabulary])
    [u'cprov', u'no-priv', u'sabdfl']

PPA vocabulary terms contain:

 * token: the PPA owner name;
 * value: the IArchive object;
 * title: the first line of the PPA description text.

    >>> cprov_term = vocabulary.getTermByToken('cprov')

    >>> print cprov_term.token
    cprov

    >>> print cprov_term.value
    <Archive ...>

    >>> print cprov_term.title
    packages to help my friends.

Not found terms result in LookupError.

    >>> vocabulary.getTermByToken('foobar')
    Traceback (most recent call last):
    ...
    LookupError: foobar

PPA vocabulary searches consider the owner FTI and the PPA FTI itself.

    >>> cprov_search = vocabulary.search('cprov')
    >>> cprov_search.count() == 1
    True
    >>> print cprov_search[0].owner.name
    cprov

    >>> celso_search = vocabulary.search('celso')
    >>> celso_search.count() == 1
    True
    >>> print celso_search[0].owner.name
    cprov

    >>> friends_search = vocabulary.search('friends')
    >>> friends_search.count() == 1
    True
    >>> print friends_search[0].description
    packages to help my friends.

As mentioned the PPA vocabulary term title only contains the first
line of the PPA description.

    >>> cprov = getUtility(IPersonSet).getByName('cprov')

    >>> cprov.archive.description = "Single line."
    >>> flush_database_updates()

    >>> cprov_term = vocabulary.getTermByToken('cprov')
    >>> print cprov_term.title
    Single line.

    >>> cprov.archive.description = "First line\nSecond line."
    >>> flush_database_updates()

    >>> cprov_term = vocabulary.getTermByToken('cprov')
    >>> print cprov_term.title
    First line

PPAs with empty description are identified and have a title saying so.

    >>> cprov.archive.description = None
    >>> flush_database_updates()

    >>> cprov_term = vocabulary.getTermByToken('cprov')
    >>> print cprov_term.title
    No description available

Queries on empty strings also results in a valid SelectResults.

    >>> empty_search = vocabulary.search('')
    >>> empty_search.count() == 0
    True


# XXX Tom Berger 2007-07-05: document more vocabularies here, particularly
# when they break!

== Timezone ==

The TimezoneName vocabulary should only contain timezone names that
do not raise an exception when instantiated.

    >>> import pytz
    >>> timezone_vocabulary = vocabulary_registry.get(None, 'TimezoneName')
    >>> for timezone in timezone_vocabulary:
    ...     # Assign the return value of pytz.timezone() to the zone
    ...     # variable to prevent printing out the return value.
    ...     zone = pytz.timezone(timezone.value)


== CommercialProjectsVocabulary ==

The commercial projects vocabulary contains all commercial projects,
ordered by displayname.  Note:  a project is considered commercial if
it has a proprietary license or no license.  That's why some of these
clearly FOSS project in our test data show up as commercial.

For a normal user (one who does not have launchpad.Commercial
permission) the owned commercial project vocabulary is a list of
project the user either owns or manages.

The test data has one project with a proprietary license.  Let's
change bzr's so we will get more interesting results.

    >>> from canonical.launchpad.interfaces import License
    >>> bzr = product_set.getByName('bzr')
    >>> bzr.licenses = [License.OTHER_PROPRIETARY]

    >>> from canonical.launchpad.webapp.authorization import check_permission
    >>> login('bac@canonical.com')
    >>> bac = person_set.getByEmail('bac@canonical.com')
    >>> check_permission('launchpad.Commercial', bac)
    False

    >>> comm_proj_vocab = vocabulary_registry.get(bac, "CommercialProjects")
    >>> print comm_proj_vocab.displayname
    Select a commercial project

    >>> len(comm_proj_vocab)
    1

    >>> for term in comm_proj_vocab:
    ...     print term.value.displayname
    Mega Money Maker

If the user has launchpad.Commercial permission then all commercial
projects are returned.

    >>> login('commercial-member@canonical.com')
    >>> commercial_member = person_set.getByEmail('commercial-member@canonical.com')
    >>> check_permission('launchpad.Commercial', commercial_member)
    True

    >>> comm_proj_vocab = vocabulary_registry.get(commercial_member, "CommercialProjects")
    >>> print comm_proj_vocab.displayname
    Select a commercial project

    >>> len(comm_proj_vocab)
    2

    >>> for term in list(comm_proj_vocab)[:5]:
    ...     print term.value.displayname
    Bazaar
    Mega Money Maker
