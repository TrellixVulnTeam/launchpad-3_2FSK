= Profiling support =

Launchpad supports three modes of profiling.

== Profiling requests in pagetests ==

Our testing framework has support for profiling requests made in
pagetests.  When the PROFILE_PAGETESTS_REQUESTS environment variable is
set, it will save profiling information in the file specified in that
variable.

The pagetests profiler is created by the layer during its setUp.

    >>> from canonical.testing.layers import PageTestLayer

(Save the existing configuration.)

    >>> import os
    >>> import tempfile

    >>> old_profile_environ = os.environ.get(
    ...     'PROFILE_PAGETESTS_REQUESTS', '')

    >>> pagetests_profile_dir = tempfile.mkdtemp(prefix='pagetests_profile')
    >>> pagetests_profile = os.path.join(
    ...     pagetests_profile_dir, 'pagetests.prof')
    >>> os.environ['PROFILE_PAGETESTS_REQUESTS'] = pagetests_profile

    >>> PageTestLayer.setUp()
    >>> PageTestLayer.profiler
    <...Profile...>
    >>> len(PageTestLayer.profiler.getstats())
    0

The layer also replaces the standard HTTPCaller.__call__ by a wrapper
that takes care of profiling (among other things).

    >>> from zope.app.testing.functional import HTTPCaller

    # We need to close the default interaction.
    >>> logout()

    >>> http = HTTPCaller(host='launchpad.dev')
    >>> response = http('GET / HTTP/1.0')
    >>> profile_count = len(PageTestLayer.profiler.getstats())
    >>> profile_count > 0
    True

Requests made with a testbrowser will also be profiled.

    >>> from zope.testbrowser.testing import Browser
    >>> browser = Browser()
    >>> browser.open('http://launchpad.dev/')
    >>> len(PageTestLayer.profiler.getstats()) > profile_count
    True

Once the layer finishes, it saves the profile data in the requested file.

    >>> PageTestLayer.tearDown()
    >>> import pstats2
    >>> stats = pstats2.Stats(pagetests_profile)
    >>> os.remove(pagetests_profile)

When the environment isn't set, no profile is created.

    >>> del os.environ['PROFILE_PAGETESTS_REQUESTS']

    >>> PageTestLayer.setUp()
    >>> print PageTestLayer.profiler
    None

And no stats file is written when the layer is tore down.

    >>> PageTestLayer.tearDown()
    >>> os.path.exists(pagetests_profile)
    False


== Profiling request in the app server ==

It is also possible to get a profile of each request served by the app
server.

This is controlled by the [profiling] config section. Profiling is
controlled by the profile_requests configuration variable. When this is
True, each request will create a pstats file for the request in the
directory specified in the profile_dir variable.

By default profiling is turned off.

    >>> from canonical.config import config
    >>> config.profiling.profile_requests
    False

(Set the profile directory.)

    >>> from textwrap import dedent
    >>> profile_dir = tempfile.mkdtemp(prefix='profile')
    >>> config.push('profile_dir', dedent("""
    ...     [profiling]
    ...     profile_dir: %s""" % profile_dir))

So when making a request, no profile information is created.

    >>> response = http('GET / HTTP/1.0')

    >>> list(os.listdir(profile_dir))
    []

But if profiling is turned on, profiling data will be created in the
directory for the request.

    >>> config.push('profile_on', dedent("""\
    ...     [profiling]
    ...     profile_requests: True"""))

    >>> response = http('GET / HTTP/1.0')

The profile is named on the time of the request start, the pageid, and
the thread that processed it.

    >>> old_stat_float_times = os.stat_float_times()
    >>> os.stat_float_times(True)
    >>> def get_profiles():
    ...     """Return the profile file names sorted by name.
    ...
    ...     The time information is stripped out to avoid spurious test
    ...     failures. The time resolution isn't great enough to reliably
    ...     sort on it.
    ...     """
    ...     profiles = ['-'.join(name.split('-')[-4:])
    ...                 for name in os.listdir(profile_dir)]
    ...     return sorted(profiles)

    >>> profiles = get_profiles()
    >>> print "\n".join(profiles)
    RootObject:index.html-OOPS-...-MainThread.prof

Together with the profiling information, an OOPS report is also created.
It's not really an OOPS, but the same format is re-used to make
analyzing it easier.

    >>> from sys import stdout
    >>> from zope.error.interfaces import IErrorReportingUtility
    >>> logged_oops = getUtility(IErrorReportingUtility).getLastOopsReport()
    >>> logged_oops.write(stdout)
    Oops-Id: OOPS-...
    Exception-Type: ProfilingOops
    Exception-Value: None
    Date: ...
    Page-Id: RootObject:index.html
    Branch: ...
    Revision: ...
    User: ...
    URL: http://localhost/index.html
    ...

The OOPS id is referenced in the profiling log's filename.

    >>> profiling_filename = profiles[0]
    >>> profiling_oops_id = '-'.join(profiling_filename.split('-')[1:3])
    >>> profiling_oops_id == logged_oops.id
    True

These profile can be loaded using the pstats2 module.

    >>> import pstats2
    >>> stats = pstats2.Stats(
    ...     os.path.join(profile_dir, os.listdir(profile_dir)[0]))

Making another request will create another profile.

    >>> response = http('GET / HTTP/1.0')

    >>> print "\n".join(get_profiles())
    RootObject:index.html-OOPS-...-MainThread.prof
    RootObject:index.html-OOPS-...-MainThread.prof

If the request resulted in an OOPS, the logged OOPS will have the real
exception information, instead of the fake ProfilingOops one.  Two files
are logged. One for the first request in the slave store, and one for
the retried request in the master store:

    >>> http('GET /no-such-file HTTP/1.0', handle_errors=False)
    Traceback (most recent call last):
      ...
    NotFound:...
    >>> print "\n".join(get_profiles())
    RootObject:index.html-OOPS-...-MainThread.prof
    RootObject:index.html-OOPS-...-MainThread.prof
    Unknown-OOPS-...-MainThread.prof
    Unknown-OOPS-...-MainThread.prof

    >>> oops = getUtility(IErrorReportingUtility).getLastOopsReport()
    >>> oops.write(stdout)
    Oops-Id: OOPS-...
    Exception-Type: NotFound
    ...
    URL: http://localhost/no-such-file
    ...


== Memory profiling ==

It is possible to keep a log of the memory profile of the application. That's
useful to try to figure out what requests are causing the memory usage of the
server to increase.

To create that log, you set the configuration variable memory_profile_log.

    >>> memory_profile_log = os.path.join(profile_dir, 'memory.log')
    >>> config.push('memory_profile', dedent("""
    ...     [profiling]
    ...     profile_request: False
    ...     memory_profile_log: %s""" % memory_profile_log))

After each request is done, that log will have the timestamp of the request,
the page id, the oops id, the duration, the starting VSS and RSS, and the
ending VSS and RSS.

    >>> response = http('GET / HTTP/1.0')
    >>> memory_profile_fh = file(memory_profile_log)
    >>> (timestamp, page_id, oops_id, duration,
    ...  start_vss, start_rss, end_vss, end_rss) = (
    ...     memory_profile_fh.readline().split())
    >>> print timestamp
    20...
    >>> print oops_id
    OOPS-...
    >>> print page_id
    RootObject:index.html

When an OOPS is triggered by the request, its identifier is logged:

    >>> http('GET /no-such-file HTTP/1.0', handle_errors=False)
    Traceback (most recent call last):
      ...
    NotFound:...

Two lines are logged. The first one is for the request in the slave
store. When that fails, the request is retried in the master store,
causing another line to be logged.

    >>> (timestamp, page_id, first_oops_id, duration,
    ...  start_vss, start_rss, end_vss, end_rss) = (
    ...     memory_profile_fh.readline().split())
    >>> print first_oops_id
    OOPS-...
    >>> print page_id
    Unknown

    >>> (timestamp, page_id, second_oops_id, duration,
    ...  start_vss, start_rss, end_vss, end_rss) = (
    ...     memory_profile_fh.readline().split())
    >>> print second_oops_id
    OOPS-...
    >>> print page_id
    Unknown

The logged OOPSes aren't the same.

    >>> first_oops_id == second_oops_id
    False

The second OOPS has the real exception in its log, instead of the usual
ProfilingOops one.

    >>> oops = getUtility(IErrorReportingUtility).getLastOopsReport()
    >>> oops.write(stdout)
    Oops-Id: OOPS-...
    Exception-Type: NotFound
    ...
    URL: http://localhost/no-such-file
    ...


== Clean up ==

    >>> import shutil

    >>> os.environ['PROFILE_PAGETESTS_REQUESTS'] = old_profile_environ

    >>> shutil.rmtree(pagetests_profile_dir)
    >>> shutil.rmtree(profile_dir)

    >>> old_config = config.pop('profile_dir')

    >>> os.stat_float_times(old_stat_float_times)
