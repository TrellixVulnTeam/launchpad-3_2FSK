QueueBuilder Tests
==================

QueueBuilder is a script to sanely initialise new build jobs, it
verifies the available DistroArchReleases, for which we are able to
build packages, repairs broken Builds entries that makes sense,
verifies the packages pending to build, install the jobs in
BuildQueue table and scores the build acording a bunch of
parameters.

  >>> from canonical.launchpad.scripts.builddmaster import BuilddMaster

import the bunch of required database classes:

  >>> from canonical.launchpad.database import (
  ...      SourcePackageRelease, SourcePackageName, DistroRelease,
  ...      SourcePackagePublishing, SecureSourcePackagePublishingHistory,
  ...      PocketChroot, DistroArchRelease, Build, BuildQueue,
  ...      SourcePackageReleaseFile)

  >>> from canonical.lp.dbschema import (
  ...      PackagePublishingPocket, PackagePublishingStatus,
  ...      SourcePackageFileType)

  >>> from canonical.database.constants import UTC_NOW


The Master side of Buildd requires access to Launchpad Database, the
user designed for this kind of access is 'fiera', as in all test the
transaction should be retrieved.

  >>> import transaction

The master also requires an 'logging' instance to not compromise the
standard output with noisely output.

  >>> import logging

Now we have satisfied all needs for BuildMaster, let's instantiate it.

  >>> bm = BuilddMaster(logging.getLogger(), transaction)

Emulates a PocketChroot entry to validate the distroarchrelese
Ubuntu/Warty/i386/RELEASE and Debian/Woody/i386/RELEASE:

  >>> warty = DistroRelease.selectOneBy(name='warty')
  >>> warty_dar = DistroArchRelease.selectOneBy(distroreleaseID=warty.id,
  ...                                           architecturetag='i386')

  >>> woody = DistroRelease.selectOneBy(name='woody')
  >>> woody_dar = DistroArchRelease.selectOneBy(distroreleaseID=woody.id,
  ...                                           architecturetag='i386')


Pick up any existent librarian file as chroot.

  >>> pocket = PocketChroot(distroarchreleaseID=warty_dar.id,
  ...                       chroot=1)

  >>> pocket = PocketChroot(distroarchreleaseID=woody_dar.id,
  ...                       chroot=2)

Produce a set of available DistroArchRelease, for which the
build jobs will be created.

  >>> distroreleases = set()
  >>> for dar in DistroArchRelease.select():
  ...     distroreleases.add(dar.distrorelease)
  ...     bm.addDistroArchRelease(dar)
  ...
  WARNING:root:Disabling: No CHROOT found for The Hoary Hedgehog Release for i386 (x86) pocket 'Release'

Only Ubuntu/Warty/i386 and Debian/Woody/i386 have an available CHROOT.

  >>> sorted((arch.distrorelease.name, arch.architecturetag)
  ...        for arch in bm._archreleases)
  [(u'warty', u'i386'), (u'woody', u'i386')]

Adding a new dummy sourcepackagerelease and publish it in Ubuntu/Warty/i386:

  >>> name = SourcePackageName(name="test-buildd")

Note that the magic number "1" is used to pick up an arbitrary required
entity from the existent sampledata, we don't care about
them. (creator=1 is sabdfl, manifest=1 is the first dummy manifest
added by the current sample data and so on)

  >>> srcpkgrel = SourcePackageRelease(creator=1, version='666',
  ...                                  section=1, maintainer=1, component=1,
  ...                                  uploaddistrorelease=1,
  ...                                  sourcepackagename=name.id,
  ...                                  architecturehintlist="all",
  ...                                  builddependsindep='foo (<< 1.0)',
  ...                                  builddepends=None, dsc=None,
  ...                                  changelog=None, manifest=1,
  ...                                  dscsigningkey=None)

  >>> tar = SourcePackageFileType.TARBALL
  >>> srcfile = SourcePackageReleaseFile(sourcepackagerelease=srcpkgrel.id,
  ...                                    libraryfile=1,
  ...                                    filetype=tar)
  >>> srcfile.libraryfile.filename, srcfile.sourcepackagerelease.name
  (u'netapplet-1.0.0.tar.gz', u'test-buildd')

  >>> published = PackagePublishingStatus.PUBLISHED
  >>> release_pocket = PackagePublishingPocket.RELEASE
  >>> p = SecureSourcePackagePublishingHistory(
  ...                                    sourcepackagerelease=srcpkgrel.id,
  ...                                    distroreleaseID=warty.id,
  ...                                    status=published,
  ...                                    pocket=release_pocket,
  ...                                    component=srcpkgrel.component,
  ...                                    section=srcpkgrel.section,
  ...                                    datecreated=UTC_NOW)

Verify how many Build entries we have from sampledata:

  >>> Build.select().count()
  5

Create missing builds (packages w/o build entry) for those distroreleases.
As we just insert a new sourcepackagerelease in run-time we expect to
have a new build for the sane Warty and a warning about the
absence of nominatedarchindep field for Woody:

  >>> for dr in distroreleases:
  ...      bm.createMissingBuilds(dr)
  WARNING:root:No Nominated Architecture Independent, skipping distrorelease WOODY

Check if we create a new Build entry for just added sourcepackagerelease:

  >>> Build.select().count()
  6

  >>> b = Build.selectOneBy(sourcepackagereleaseID=srcpkgrel.id)
  >>> (b.sourcepackagerelease.name, b.distroarchrelease.distrorelease.name)
  (u'test-buildd', u'warty')

Now we have Build table properly set and probably with some entries
marked as NEEDSBUILD we can create BuildQueue entries for it

  >>> bm.addMissingBuildQueueEntries()
  >>> BuildQueue.select().count()
  2

A separate process is responsible for cleaning up the BuildQueue and
scroring the jobs properly.

The default score value is 0 (zero), attempt for the fact we already
have a build queue entry added by the sampledata, that's why the 2nd
element of the result.

  >>> job = BuildQueue.select(orderBy='id')[1]
  >>> job.lastscore
  0

After sanitising the jobs, only the ones containing
sourcepackagerelease files should remain:

  >>> new_jobs = bm.sanitiseAndScoreCandidates()
  WARNING:root:MISSED DEP: [('foo', '1.0', '<<')] in warty i386

  >>> len(new_jobs)
  1

  >>> job = new_jobs[0]
  >>> job.build.sourcepackagerelease.name
  u'test-buildd'

And we grant some score depending on: time pending on the buildqueue,
component the package belongs to, and the urgency of the upload.
There is still some work to do here, for further information see the
launchpad/scripts/builddmaster.py code. The job presented should won
exactly ** 995 ** points last turn (5 for the default urgency 'LOW'
1000 for the 'Main' component and minus 10 for unsatisfied dependency,
further tests for scoring are in buildd-scoring.txt)

  >>> job.lastscore
  995



