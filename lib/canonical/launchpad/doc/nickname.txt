Nickname
========

For each Person we create a unique nickname that must be generated using
foaf.nickname.generate_nick.

A valid nick can contain lower case letters, dashes, and numbers,
must start with a letter or a number, and must be a minimum of
four characters.

    >>> from canonical.foaf.nickname import generate_nick

    >>> generate_nick("foop@example@com")
    Traceback (most recent call last):
        ...
    NicknameGenerationError: foop@example@com is not a valid email address
    >>> generate_nick("foop@example.com")
    'foop'
    >>> generate_nick("bar@example.com")
    'bar'
    >>> generate_nick("spam@example.com")
    'spam'
    >>> generate_nick("foo.bar@canonical.com")
    'foo-bar'
    >>> generate_nick("foo+bar@example.com")
    'foo+bar'
    >>> generate_nick("--foo@example.com")
    'foo'

We already have a salgado, so generate_nick needs to try a little harder.

    >>> generate_nick("salgado@async.co.br")
    'salgado-async'


And it needs to maintain a minimum length

    >>> generate_nick("i@tv")
    'i-tv'


    >>> _counter = 0
    >>> def new_person(email):
    ...     import time
    ...     from canonical.launchpad.interfaces import IPersonSet
    ...     from canonical.launchpad.interfaces import IEmailAddressSet
    ...     from canonical.lp.dbschema import PersonCreationRationale
    ...     UNKNOWN = PersonCreationRationale.UNKNOWN
    ...     person_set = getUtility(IPersonSet)
    ...     person, ignored = person_set.createPersonAndEmail(
    ...         email, UNKNOWN)
    ...     # Switch the email to avoid conflicts when generating clashing names
    ...     email_address_set = getUtility(IEmailAddressSet)
    ...     global _counter
    ...     for email_address in email_address_set.getByPerson(person):
    ...         email_address.email = 'nodupe%d@example.com' % _counter
    ...         _counter += 1
    ...     flush_database_updates()
    ...     assert email_address_set.getByEmail(email) is None, 'Oops'
    ...     return person


The email address is used to generate nicknames. If domain is used to
attempt to avoid clashes.

    >>> new_person('bongo@example.com').name
    u'bongo'
    >>> new_person('bongo@example.com').name
    u'bongo-example'
    >>> new_person('bongo@example.com').name
    u'bongo-example-com'


It should be nearly impossible to make the method fail even in the
extreme cases where using all components of the domain name fails.
If nicknames still clash, random suffixes are tried:

    >>> new_person('bongo@example.com').name
    u'bongo-example-com-c'


Random prefixes are tried:

    >>> new_person('bongo@example.com').name
    u'q-bongo-example-com'


And random mutations are tried:

    >>> new_person('bongo@example.com').name
    u'bongo-examale-com'


The only way it can fail is if some idiot admin goes and registers a
'match-everything' pattern in the blacklist:

    >>> from canonical.database.sqlbase import cursor
    >>> cur = cursor()
    >>> cur.execute("INSERT INTO NameBlacklist (regexp) VALUES ('.')")
    >>> generate_nick("foo@example.com")
    Traceback (most recent call last):
    ...
    NicknameGenerationError: No nickname could be generated...

