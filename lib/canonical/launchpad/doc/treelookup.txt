= Doing lookups in a tree =

  >>> from canonical.launchpad.components.treelookup import (
  ...     LookupTree, LookupBranch)

`LookupTree` encapsulated a simple tree structure that can be used to
do lookups using one or more keys. This was originally created to
support mapping statuses from remote bug trackers into Launchpad
statuses.

Another main criteria was documentation. We want to be able to
automatically generate documentation from the lookup trees that are
specified.

Originally a simple dictionary lookup was attempted, but it proved
difficult to create some of the moderately complex mapping rules we
needed. Supporting defaults and such required additional logic, and
ordering was lost, which may be useful to document.

Secondly, a structure of tuples was attempted, and this proved easier
to construct. However, it proved difficult to see what was going on,
with brackets everywhere!

The final design is a compromise. The `LookupTree` class and helper
class `LookupBranch` both inherit from `tuple`, but also encapsulate
the searching algorithm and a few other conveniences. This makes the
generation of lookup trees quite pleasant on the eye, makes debugging
easier, and means they can be customised.


== Creation ==

  >>> tree = LookupTree(
  ...     ('Snack', LookupTree(
  ...             ('Mars Bar', 'Snickers', 'Bad'),
  ...             ('Apple', 'Banana', 'Good'))),
  ...     LookupBranch('Lunch', 'Dinner', LookupTree(
  ...             ('Fish and chips', "Penne all'arrabbiata", 'Nice'),
  ...             ('Raw liver', 'Not so nice'))),
  ...     ('Make up your mind!',),
  ...     )

Behind the scenes, `LookupTree` promotes plain tuples (or any
iterable) into `LookupBranch` instances. This means that the last
member of the tuple is the result of the branch. All the other members
are keys.

Tuples/branches without keys are default choices. They must come
last. It doesn't make sense for a default to appear in any other
position, because it would completely obscure the subsequent branches
in the tree. Hence, attempting to specify a default branch before the
last position is treated as an error.

  >>> broken_tree = LookupTree(
  ...     ('Free agents',),
  ...     ('Alice', 'Bob', 'Allies of Schneier'))
  Traceback (most recent call last):
  ...
  TypeError: Default branch must be last.

To help when constructing more complex trees, an existing `LookupTree`
instance can be passed in when constructing a new one. Its branches
are copied into the new `LookupTree` at that point.

  >>> breakfast_tree = LookupTree(
  ...     ('Breakfast', 'Corn flakes'),
  ...     tree,
  ...     )

  >>> len(tree)
  3
  >>> len(breakfast_tree)
  4


== Searching ==

Just call the tree.

  >>> tree('Snack', 'Banana')
  'Good'

If you specify more keys than you need to reach a leaf, you still get
the result.

  >>> tree('Snack', 'Banana', 'Big', 'Yellow', 'Taxi')
  'Good'

But an exception is raised if it does not reach a leaf.

  >>> tree('Snack')
  Traceback (most recent call last):
  ...
  KeyError: 'Snack'


== Development ==

`LookupTree` makes development easy, because __repr__ gives a complete
description of the tree you've created.

  >>> print repr(tree)
  tree(
      branch(Snack => tree(
          branch('Mars Bar', Snickers => 'Bad')
          branch(Apple, Banana => 'Good')
          ))
      branch(Lunch, Dinner => tree(
          branch('Fish and chips', "Penne all'arrabbiata" => 'Nice')
          branch('Raw liver' => 'Not so nice')
          ))
      branch(* => 'Make up your mind!')
      )

We can also see that the result of constructing a new lookup using an
existing one is the same as if we had constructed it independently.

  >>> print repr(breakfast_tree)
  tree(
      branch(Breakfast => 'Corn flakes')
      branch(Snack => tree(
          branch('Mars Bar', Snickers => 'Bad')
          branch(Apple, Banana => 'Good')
          ))
      branch(Lunch, Dinner => tree(
          branch('Fish and chips', "Penne all'arrabbiata" => 'Nice')
          branch('Raw liver' => 'Not so nice')
          ))
      branch(* => 'Make up your mind!')
      )

Simple keys are shown without quotes, to aid readability, and default
branches are shown with '*' as the key.


== Documentation ==

You can discover the minimum and maximum depth of a tree.

  >>> tree.min_depth
  1
  >>> tree.max_depth
  2

`LookupTree` has a `flattened` property that may be useful when
generating documentation. It yields tuples of keys that represent
paths to leaves.

  >>> for elems in tree.flattened:
  ...     path, result = elems[:-1], elems[-1]
  ...     print ' => '.join(
  ...         [repr(tuple(node)) for node in path] + [repr(result)])
  ('Snack',) => ('Mars Bar', 'Snickers') => 'Bad'
  ('Snack',) => ('Apple', 'Banana') => 'Good'
  ('Lunch', 'Dinner') => ('Fish and chips', "Penne all'arrabbiata") => 'Nice'
  ('Lunch', 'Dinner') => ('Raw liver',) => 'Not so nice'
  () => 'Make up your mind!'
