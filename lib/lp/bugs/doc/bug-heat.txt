Calculating bug heat
====================

Launchpad bugs each have a 'heat' rating. This is an indicator of how
problematic a given bug is to the community and can be used to determine
which bugs should be tackled first.

A bug's heat is calculated automatically when it is created.

    >>> bug_owner = factory.makePerson()
    >>> bug = factory.makeBug(owner=bug_owner)
    >>> bug.heat
    6

Its heat_last_updated time will be the same as its datecreated attribute.

    >>> bug.heat_last_updated == bug.datecreated
    True

The bug's heat can be set by calling its setHeat() method. We'll commit
the transaction first so that heat_last_updated gets changed.

    >>> import transaction
    >>> transaction.commit()

    >>> bug.setHeat(42)
    >>> bug.heat
    42

Its heat_last_updated will also have been updated.

    >>> bug.heat_last_updated == bug.datecreated
    False

    >>> bug.heat_last_updated
    datetime.datetime(..., tzinfo=<UTC>)


Updating bug heat on-the-fly
----------------------------

The IBug.updateHeat() method updates a Bug's heat using data already in
the database. Where setHeat() can be used for setting bug heat to a
specific value, updateHeat() uses a stored procedure in the database to
calculate the heat overall.

We'll create a new bug with a heat of 0 for the sake of testing.

    >>> bug_owner = factory.makePerson()
    >>> bug = factory.makeBug(owner=bug_owner)
    >>> bug.setHeat(0)

    >>> bug.heat
    0

Calling updateHeat() will update the bug's heat. Since this new bug has
one subscriber (the bug owner) and one affected user (ditto) its
heat after update will be 6.

    >>> bug.updateHeat()
    >>> bug.heat
    6


Events which trigger bug heat updates
-------------------------------------

We current use a feature flag for some privacy related subscription stuff.

    >>> from lp.services.features.testing import FeatureFixture
    >>> feature_flag = {'disclosure.enhanced_private_bug_subscriptions.enabled': 'on'}
    >>> flags = FeatureFixture(feature_flag)
    >>> flags.setUp()

There are several events which will cause a bug's heat to be updated.
First, as stated above, heat will be calculated when the bug is created.

    >>> bug = factory.makeBug(owner=bug_owner)
    >>> bug.heat
    6

When the bug is marked private it gains a subscriber - the owner of the
product against which it's filed, whose subscription is converted from
an indirect to a direct subscription.

Marking a bug as private also gives it an extra 150 heat points.

    >>> changed = bug.setPrivate(True, bug_owner)
    >>> bug.heat
    158

Setting the bug as security related adds another 250 heat points.

    >>> changed = bug.setSecurityRelated(True, bug_owner)
    >>> bug.heat
    408

Marking the bug public removes 150 heat points.

    >>> changed = bug.setPrivate(False, bug_owner)
    >>> bug.heat
    258

And marking it not security-related removes 250 points.

    >>> changed = bug.setSecurityRelated(False, bug_owner)
    >>> bug.heat
    8

Adding a subscriber to the bug increases its heat by 2 points.

    >>> new_subscriber = factory.makePerson()
    >>> subscription = bug.subscribe(new_subscriber, new_subscriber)
    >>> bug.heat
    10

When a user unsubscribes, the bug loses 2 points of heat.

    >>> bug.unsubscribe(new_subscriber, new_subscriber)
    >>> bug.heat
    8

Should a user mark themselves as affected by the bug, it will gain 4
points of heat.

    >>> bug.markUserAffected(new_subscriber)
    >>> bug.heat
    12

If a user who was previously affected marks themself as not affected,
the bug loses 4 points of heat.

    >>> bug.markUserAffected(new_subscriber, False)
    >>> bug.heat
    8

If a user who wasn't affected by the bug marks themselve as explicitly
unaffected, the bug's heat doesn't change.

    >>> unaffected_person = factory.makePerson()
    >>> bug.markUserAffected(unaffected_person, False)
    >>> bug.heat
    8

Marking the bug as a duplicate will set its heat to zero, whilst also
adding 10 points of heat to the bug it duplicates, 6 points for the
duplication and 4 points for the subscribers that the duplicated bug
inherits.

    >>> duplicated_bug = factory.makeBug()
    >>> duplicated_bug.heat
    6

    >>> bug.markAsDuplicate(duplicated_bug)
    >>> bug.heat
    0

    >>> duplicated_bug.heat
    16

Unmarking the bug as a duplicate restores its heat and updates the
duplicated bug's heat.

    >>> bug.markAsDuplicate(None)
    >>> bug.heat
    8

    >>> duplicated_bug.heat
    6

A number of other changes, handled by the Bug's addChange() method, will
cause heat to be recalculated, even if the heat itself may not actually
change.

For example, updating the bug's description calls the addChange() event,
and will cause the bug's heat to be recalculated.

We'll set the bug's heat to 0 first to demonstrate this.

    >>> bug.setHeat(0)
    >>> bug.heat
    0

    >>> from datetime import datetime, timedelta
    >>> from pytz import timezone
    >>> from lp.services.utils import utc_now

    >>> from lp.bugs.adapters.bugchange import BugDescriptionChange
    >>> change = BugDescriptionChange(
    ...     when=utc_now(),
    ...     person=bug.owner, what_changed='description',
    ...     old_value=bug.description, new_value='Some text')
    >>> bug.addChange(change)
    >>> bug.heat
    8

Clean up the feature flag.

    >>> flags.cleanUp()


Getting bugs whose heat is outdated
-----------------------------------

It's possible to get the set of bugs whose heat hasn't been updated for
a given amount of time by calling IBugSet's getBugsWithOutdatedHeat()
method.

First, we'll set the heat of all bugs so that none of them are out of
date.

    >>> from lp.bugs.interfaces.bug import IBugSet
    >>> for bug in getUtility(IBugSet).dangerousGetAllBugs():
    ...     bug.setHeat(0)

If we call getBugsWithOutdatedHeat() now, the set that is returned will
be empty because all the bugs have been recently updated.
getBugsWithOutdatedHeat() takes a single parameter, max_heat_age, which
is the maximum age, in days, that a bug's heat can be before it gets
included in the returned set.

    >>> getUtility(IBugSet).getBugsWithOutdatedHeat(1).count()
    0

IBug.setHeat() takes a timestamp parameter so that we can set the
heat_last_updated date manually for the purposes of testing. If we make
a bug's heat older than the max_heat_age that we pass to
getBugsWithOutdatedHeat() it will appear in the set returned by
getBugsWithOutdatedHeat().

    >>> old_heat_bug = factory.makeBug()
    >>> old_heat_bug.setHeat(
    ...     0, datetime.now(timezone('UTC')) - timedelta(days=2))

    >>> outdated_bugs = getUtility(IBugSet).getBugsWithOutdatedHeat(1)
    >>> outdated_bugs.count()
    1

    >>> outdated_bugs[0] == old_heat_bug
    True

getBugsWithOutdatedHeat() also returns bugs whose heat has never been
updated.

    >>> new_bug = factory.makeBug()

We'll set the new bug's heat_last_updated to None manually.

    >>> new_bug.heat_last_updated = None

    >>> outdated_bugs = getUtility(IBugSet).getBugsWithOutdatedHeat(1)
    >>> outdated_bugs.count()
    2

    >>> new_bug in outdated_bugs
    True


The BugHeatUpdater class
---------------------------

The BugHeatUpdater class is used to create bug heat calculation jobs for
bugs with out-of-date heat.

    >>> from lp.scripts.garbo import BugHeatUpdater
    >>> from lp.services.log.logger import FakeLogger

We'll commit the transaction so that the BugHeatUpdater updates the
right bugs.

    >>> transaction.commit()
    >>> update_bug_heat = BugHeatUpdater(FakeLogger(), max_heat_age=1)

BugHeatUpdater implements ITunableLoop and as such is callable. Calling
it as a method will recalculate the heat for all the out-of-date bugs.

There are two bugs with heat more than a day old:

    >>> getUtility(IBugSet).getBugsWithOutdatedHeat(1).count()
    2

Calling our BugHeatUpdater will update the heat of those bugs.

    >>> update_bug_heat(chunk_size=1)
    DEBUG Updating heat for 1 bugs

IBugSet.getBugsWithOutdatedHeat() will now return 1 item.

    >>> getUtility(IBugSet).getBugsWithOutdatedHeat(1).count()
    1

Update the rest in one big chunk.

    >>> update_bug_heat(chunk_size=1000)
    DEBUG Updating heat for 1 bugs

IBugSet.getBugsWithOutdatedHeat() will now return an empty set since all
the bugs have been updated.

    >>> getUtility(IBugSet).getBugsWithOutdatedHeat(1).count()
    0


Caculating the maximum heat for a target
----------------------------------------

When we update the heat value for a bug, the maximum heat value for the
targets for all of its tasks is calculated and cached.

    >>> product = factory.makeProduct()
    >>> bug = factory.makeBug(product=product)
    >>> bug.setHeat(123)
    >>> print product.max_bug_heat
    123

The maximum heat for a project is the value for tasks on all its products.

    >>> project = factory.makeProject()
    >>> product.project = project
    >>> bug.setHeat(123)
    >>> print project.max_bug_heat
    123

A DistributionSourcePackage has its own maximum heat.

    >>> dsp = factory.makeDistributionSourcePackage()
    >>> dsp_task = bug.addTask(bug.owner, dsp)
    >>> print dsp.max_bug_heat
    123

A DistributionSourcePackage also has a cached value for bug_count and
total_bug_heat.

    >>> print dsp.bug_count
    1
    >>> print dsp.total_bug_heat
    123
    >>> dsp_task2 = factory.makeBugTask(target=dsp)
    >>> dsp_task2.bug.setHeat(7)
    >>> print dsp.bug_count
    2
    >>> print dsp.total_bug_heat
    130

Transitioning from one target to another, calculates the value for the new
target.

    >>> another_product = factory.makeProduct()
    >>> transaction.commit()
    >>> bug.bugtasks[0].transitionToTarget(another_product)
    >>> print another_product.max_bug_heat
    123

ProductSeries and DistroSeries simply delegate to their corresponding Product
or Distribution.

    >>> product_series = factory.makeProductSeries()
    >>> ps_task = bug.addTask(bug.owner, product_series)
    >>> print product_series.max_bug_heat
    123
    >>> print product_series.product.max_bug_heat
    123

    >>> distro_series = factory.makeDistroSeries()
    >>> ds_task = bug.addTask(bug.owner, distro_series)
    >>> print distro_series.max_bug_heat
    123
    >>> print distro_series.distribution.max_bug_heat
    123

Maximum heat is limited to bugs of a specific target.

    >>> product = factory.makeProduct()
    >>> product_bug = factory.makeBug(product=product)
    >>> product_bug.setHeat(123)
    >>> distro = factory.makeDistribution()
    >>> distro_bug = factory.makeBug()
    >>> distro_task = distro_bug.addTask(bug.owner, distro)
    >>> distro_bug.setHeat(456)
    >>> print product.max_bug_heat
    123
    >>> print distro.max_bug_heat
    456
