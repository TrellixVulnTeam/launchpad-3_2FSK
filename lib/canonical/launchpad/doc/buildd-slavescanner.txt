Buildd Slave Scanner
====================

The Buildd Slave scanner is able to run over the build jobs being
processed in the current BuildFarm and collect information about the
status of the process, collect the results of finished jobs and
automaticaly dispatch new jobs to idle slaves.

  >>> from canonical.buildmaster.master import BuilddMaster

The Master side of Buildd requires access to Launchpad Database, the
user designed for this kind of access is 'fiera', as in all test the
transaction should be retrieved.

  >>> from canonical.database.sqlbase import ZopelessTransactionManager
  >>> local_transaction = ZopelessTransactionManager._installed

We check for sent mails in some places, so load the stub mailer:

  >>> from canonical.launchpad.mail import stub

And create a utility function to make tests easier to read.

  >>> def check_mail_sent(last_stub_mail_count):
  ...    local_transaction.commit()
  ...    return len(stub.test_emails) == last_stub_mail_count + 3

The master also requires an 'logging' instance to not compromise the
standard output with noisely output.

  >>> import logging

We use StringIO later to simulate bits of the build slave file retrieval

  >>> from StringIO import StringIO

First let's test an essential part of the BuilddMaster class, the
BuilderGroup() class, by creating an empty BuilderGroup object

  >>> from canonical.buildmaster.buildergroup import BuilderGroup

  >>> buildergroup = BuilderGroup(
  ...     logging.getLogger(), local_transaction)

Mock Builder, a class to emulate the Builder behaviour:

  >>> class MockBuilder:
  ...     def __init__(self, name, slave):
  ...         self.slave = slave
  ...         self.builderok = True
  ...         self.manual = False
  ...         self.url = 'http://fake:0000'
  ...         slave.urlbase = self.url
  ...         self.name = name
  ...         self.trusted = False
  ...     def failbuilder(self, reason):
  ...         self.builderok = False
  ...         self.failnotes = reason
  ...     def slaveStatusSentence(self):
  ...         return self.slave.status()
  ...     def cleanSlave(self):
  ...         return self.slave.clean()
  ...     def requestAbort(self):
  ...         return self.slave.abort()
  ...     def resetSlaveHost(self, logger):
  ...         pass

Let's play with a BuilderGroup method designed to rescue build slaves
that are processing unknown jobs. In real conditions, this situation
only happens if the slave is processing deleted or modified BuildQueue
entry, since Build entries are never removed. It might be caused by
exceptions in slavescanner or queuebuilder scripts.

When we figured this situation out, the procedure to rescue is to
request the slave XMLRPC method 'clean', reseting the slave completely.

We figured out if the building information is correct and sane by
checking the job identifier field from status message information,
which consists of "<Build.id>-<BuildQueue.id>".

First let's emulate a sane and a lost slave. The SaneSlave returns a
job identifier that exists in our sampledata, but the LostSlave
returns a completly bogus one.

The the mock slave.clean() method is modified to print a message for
testing purposes.

Initializing the sane_builder. It was not rescued, since the job
identifier is sane (Build.id == 8 and BuildQueue.id == 1 exist):

  >>> class SaneBuildingSlave:
  ...     """A mock slave that is currently building."""
  ...     def status(self):
  ...         return ('BuilderStatus.BUILDING', '8-1')
  ...     def clean(self):
  ...         print 'Rescuing SaneSlave'

  >>> sanebuilding_builder = MockBuilder('Sane Building Slave',
  ...                                    SaneBuildingSlave())

  >>> buildergroup.rescueBuilderIfLost(sanebuilding_builder) is None
  True

A sane WAITING slave:

  >>> class SaneWaitingSlave:
  ...     """A mock slave that is currently waiting."""
  ...     def status(self):
  ...         return ('BuilderStatus.WAITING', 'BuildStatus.OK', '8-1')
  ...     def clean(self):
  ...         print 'Rescuing SaneSlave'

  >>> sanewaiting_builder = MockBuilder('Sane Waiting Slave',
  ...                                   SaneWaitingSlave())

  >>> buildergroup.rescueBuilderIfLost(sanewaiting_builder) is None
  True

A sane WAITING slave but with wrong BuildQueue/Build relation:

  >>> class SaneWaitingSlave:
  ...     """A mock slave waiting with a bogus Build/BuildQueue relation."""
  ...     def status(self):
  ...         return ('BuilderStatus.WAITING', 'BuildStatus.OK', '7-1')
  ...     def clean(self):
  ...         pass

  >>> sanewaiting_builder = MockBuilder('Sane Waiting Slave',
  ...                                   SaneWaitingSlave())

  >>> buildergroup.rescueBuilderIfLost(sanewaiting_builder)
  WARNING:root:Builder 'Sane Waiting Slave' rescued from '7-1: Job build entry mismatch'

It was rescued because the BuildQueue.id == 1 isn't related to
Build.id == 7, so this pair relation is wrong.

Let's test slaves with job identifier pointing non-existent
Build/BuildQueue entries. first a lost slave in status 'BUILDING':

  >>> class LostBuildingSlave:
  ...     """A mock slave building bogus Build/BuildQueue IDs."""
  ...     def status(self):
  ...         return ('BuilderStatus.BUILDING', '1000-10000')
  ...     def abort(self):
  ...         pass

  >>> lostbuilding_builder = MockBuilder('Lost Building Slave',
  ...                                    LostBuildingSlave())

  >>> buildergroup.rescueBuilderIfLost(lostbuilding_builder)
  WARNING:root:Builder 'Lost Building Slave' rescued from '1000-10000: 'The object Build by the ID 1000 does not exist''

Then a lost slave in status 'WAITING':

  >>> class LostWaitingSlave:
  ...     """A mock slave waiting with bogus Build/BuildQueue IDs."""
  ...     def status(self):
  ...         return ('BuilderStatus.WAITING', 'BuildStatus.OK', '1000-10000')
  ...     def clean(self):
  ...         pass

  >>> lostwaiting_builder = MockBuilder('Lost Waiting Slave',
  ...                                    LostWaitingSlave())

  >>> buildergroup.rescueBuilderIfLost(lostwaiting_builder)
  WARNING:root:Builder 'Lost Waiting Slave' rescued from '1000-10000: 'The object Build by the ID 1000 does not exist''

Both got rescued, as expected.


Let's create a bunch of mock slaves for testing the Builder State Handler:

  >>> import xmlrpclib
  >>> class BrokenSlave:
  ...     """A mock slave that reports that it is broken."""
  ...     def status(self):
  ...         raise xmlrpclib.Fault(8001, "Broken slave")


Make ensurePresent() always return True, it theoretically means the
slave has the requested file in cache.  This mock slave will also print
whether it has been passed an 'archives' property in the args dictionary.
The archives are passed from the buildmaster and controls what archives
exist in the apt sources.list.  If nothing is passed, the slave's default
list applies, otherwise the passed list is used.  This behaviour is required
in build slaves because some jobs may only depend on certain archives and
hence certain package dependencies.

  >>> class OkSlave:
  ...     """An idle mock slave that prints information about itself."""
  ...     def status(self):
  ...         return ('BuilderStatus.IDLE', '')
  ...     def ensurepresent(self, sha1, url):
  ...         print "ensurepresent called"
  ...         return True, None
  ...     def build(self, buildid, buildtype, chroot, filemap, args):
  ...         info = 'OkSlave BUILDING'
  ...         print info
  ...         if 'archives' in args:
  ...             print "Archives: %s" % sorted(args['archives'])
  ...         else:
  ...             print "No archives set."
  ...         print "Suite: %s" % args['suite']
  ...         print "Archive Purpose: %s" % args['archive_purpose']
  ...         return ('BuildStatus.Building', info)
  ...     def fetchlogtail(self, size):
  ...         return 'BOGUS'
  ...     def clean(self):
  ...         pass
  ...     def info(self):
  ...         return ('1.0', 'i386', 'debian')


  >>> class BuildingSlave(OkSlave):
  ...     """A mock slave that looks like it's currently building."""
  ...     def status(self):
  ...         buildlog = xmlrpclib.Binary("This is a build log")
  ...         return ('BuilderStatus.BUILDING', '1-1', buildlog)
  ...     def getFile(self, sum):
  ...         if sum == "buildlog":
  ...             s = StringIO("This is a build log")
  ...             s.headers={'content-length':19}
  ...             return s


  >>> class AbortedSlave(OkSlave):
  ...     """A mock slave that looks like it's aborted."""
  ...     def status(self):
  ...         return ('BuilderStatus.ABORTED', '1-1')


  >>> class WaitingSlave(OkSlave):
  ...     """A mock slave that looks like it's currently waiting."""
  ...     def __init__(self, state, dependencies=None):
  ...         self.state = state
  ...         self.dependencies = dependencies
  ...     def status(self):
  ...         return ('BuilderStatus.WAITING', self.state, '1-1', {},
  ...                 self.dependencies )
  ...     def getFile(self, sum):
  ...         if sum == "buildlog":
  ...             s = StringIO("This is a build log")
  ...             s.headers={'content-length':19}
  ...             return s

  >>> class AbortingSlave(OkSlave):
  ...     """A mock slave that looks like it's in the process of aborting."""
  ...     def status(self):
  ...         return ('BuilderStatus.ABORTING', '1-1')


  >>> builder1 = MockBuilder('Broken Slave', BrokenSlave())

  >>> builder2 = MockBuilder('Idle Slave', OkSlave())

  >>> builder3 = MockBuilder('Package Failed',
  ...                        WaitingSlave('BuildStatus.PACKAGEFAIL'))

  >>> builder4 = MockBuilder('Missing Dependency build',
  ...                        WaitingSlave('BuildStatus.DEPFAIL',
  ...                                     'baz (>= 1.0.1)'))

  >>> builder5 = MockBuilder('Bad Chroot',
  ...                        WaitingSlave('BuildStatus.CHROOTFAIL'))

  >>> builder6 = MockBuilder('I am out of order',
  ...                        WaitingSlave('BuildStatus.BUILDERFAIL'))

  >>> builder7 = MockBuilder('I am busy', BuildingSlave())

  >>> builder8 = MockBuilder('I was aborted', AbortedSlave())

  >>> builder9 = MockBuilder('I am trying to terminate the child process',
  ...                        AbortingSlave())

  >>> builder10 = MockBuilder('Package Successfully Built',
  ...                         WaitingSlave('BuildStatus.OK'))

  >>> builder11 = MockBuilder('I am giving this job back',
  ...		               WaitingSlave('BuildStatus.GIVENBACK'))


  >>> buildergroup.builders = [builder1, builder2, builder3, builder4,
  ...                          builder5, builder6, builder7, builder8,
  ...                          builder9, builder10, builder11]

  >>> buildergroup.firstAvailable() is builder2
  True

  Stub classes to emulate Build and BuildQueue

  >>> from canonical.launchpad.interfaces import IBuildSet, IBuilderSet

The slavescanner system also perform build-notification for the
following states: FAILEDTOBUILD and CHROOTWAIT

  >>> class MockBuild:
  ...     def __init__(self, id):
  ...         self.id = id
  ...         self.buildstate = None
  ...         self.builder = None
  ...         self.datebuilt = None
  ...         self.buildduration = None
  ...         self.buildlog = None
  ...         self.dependencies = None
  ...         tmp_build = getUtility(IBuildSet).getByBuildID(7)
  ...         self.archive = tmp_build.archive
  ...         self.distroarchseries = tmp_build.distroarchseries
  ...         self.sourcepackagerelease = tmp_build.sourcepackagerelease
  ...         self.pocket = tmp_build.pocket
  ...         self.title = 'Mock Build'
  ...         self.notification_sent = False
  ...         self.is_trusted = tmp_build.is_trusted
  ...         self.binarypackages = ['one', 'two', 'three']
  ...     @property
  ...     def distroseries(self):
  ...         return self.distroarchseries.distroseries
  ...     @property
  ...     def distribution(self):
  ...         return self.distroarchseries.distroseries.distribution
  ...     def notify(self, extra_info=None):
  ...         from sqlobject import SQLObjectNotFound
  ...         self.notification_sent = True
  ...         try:
  ...             real_build = getUtility(IBuildSet).getByBuildID(self.id)
  ...         except SQLObjectNotFound, e:
  ...             pass
  ...         else:
  ...             real_build.notify(extra_info=extra_info)

  >>> import datetime, pytz
  >>> UTC = pytz.timezone('UTC')

We want to get a Build and make BuildQueue items for it:

  >>> from canonical.launchpad.interfaces import IBuildSet
  >>> a_build = getUtility(IBuildSet).getByBuildID(8)

To make testing easier we provide a convenience function to put a BuildQueue
object into a preset fixed state:

  >>> default_start = datetime.datetime(2005, 1, 1, 8, 0, 0, tzinfo=UTC)
  >>> def setupBuildQueue(build_queue, builder):
  ...      build_queue.builder = builder
  ...      build_queue.buildstart = default_start

  >>> from canonical import encoding

XXX cprov 20070615: Historically we used a MockBuildQueue class, this
is deprecated, please do not extend it and try to reduce its usage.
We should apply efforts to use the real BuildQueue object instead.

  >>> class MockBuildQueue:
  ...     def __init__(self, id, builder, build):
  ...         self.id = id
  ...         self.build = build
  ...         self.name = "unimportant-name"
  ...         self.files = []
  ...         self.component_name = "main"
  ...         self.archhintlist = ""
  ...         self.is_trusted = build.is_trusted
  ...         self.archseries = build.distroarchseries
  ...         self.version = build.sourcepackagerelease.version
  ...         setupBuildQueue(self, builder)
  ...     def destroySelf(self):
  ...         pass


Remove any previous buildmaster ROOT directory, to avoid any garbage
lock conflict (it would be recreated automatically if necessary)

  >>> from canonical.config import config
  >>> import shutil
  >>> import os
  >>> if os.access(config.builddmaster.root, os.F_OK):
  ...     shutil.rmtree(config.builddmaster.root)

Let's check the procedures to verify/collect running build process:

  WAITING - PACKAGEFAIL -> Package has failed to build, notice from
  builder is stored, but Build.buildstate is mark as 'Failed to Build':

Get a builder from the sample data:

  >>> a_builder = getUtility(IBuilderSet).get(1)

Make sure that a_builder has no active builds:

  >>> if a_builder.currentjob is not None:
  ...     a_builder.currentjob.buildstart = None
  ...     a_builder.currentjob.builder = None

Force the test builder to be 'ok' as the code required to do this
automatically is not yet factored into the content class.

  >>> a_builder.builderok = True

Create a mock slave so the builder can operate - one with a failed package.

  >>> a_builder.setSlaveForTesting(WaitingSlave('BuildStatus.PACKAGEFAIL'))

  >>> bqItem3 = a_build.createBuildQueueEntry()
  >>> setupBuildQueue(bqItem3, a_builder)
  >>> last_stub_mail_count = len(stub.test_emails)

Do the test execution:

  >>> buildergroup.updateBuild(bqItem3)
  >>> bqItem3.build.builder is not None
  True
  >>> bqItem3.build.datebuilt is not None
  True
  >>> bqItem3.build.buildduration is not None
  True
  >>> bqItem3.build.buildlog is not None
  True
  >>> check_mail_sent(last_stub_mail_count)
  True
  >>> bqItem3.build.buildstate.title
  'Failed to build'

Cleanup in preparation for the next test:

  >>> bqItem3.destroySelf()


  WAITING - DEPWAIT -> a required dependency is missing, again notice
  from builder, but Build.buildstate has the right state:

  >>> bqItem4 = a_build.createBuildQueueEntry()
  >>> setupBuildQueue(bqItem4, a_builder)
  >>> last_stub_mail_count = len(stub.test_emails)

Create a mock slave so the builder can operate - one with a dependency error.

  >>> bqItem4.builder.setSlaveForTesting(
  ...                        WaitingSlave('BuildStatus.DEPFAIL',
  ...                                     'baz (>= 1.0.1)'))

Do the test execution:

  >>> buildergroup.updateBuild(bqItem4)
  CRITICAL:root:***** bob is MANUALDEPWAIT *****
  >>> bqItem4.build.builder is not None
  True
  >>> bqItem4.build.datebuilt is not None
  True
  >>> bqItem4.build.buildduration is not None
  True
  >>> bqItem4.build.buildlog is not None
  True
  >>> check_mail_sent(last_stub_mail_count)
  False
  >>> bqItem4.build.dependencies
  u'baz (>= 1.0.1)'
  >>> bqItem4.build.buildstate.title
  'Dependency wait'


Cleanup in preparation for the next test:

  >>> bqItem4.destroySelf()

WAITING - CHROOTFAIL -> the Chroot for this distroseries is damage, nor
builder, but right state stored in Build entry:

  >>> bqItem5 = a_build.createBuildQueueEntry()
  >>> setupBuildQueue(bqItem5, a_builder)
  >>> last_stub_mail_count = len(stub.test_emails)

  Create a mock slave so the builder can operate - one with a failed chroot.

  >>> bqItem5.builder.setSlaveForTesting(WaitingSlave('BuildStatus.CHROOTFAIL'))
  >>> buildergroup.updateBuild(bqItem5)
  CRITICAL:root:***** bob is CHROOTWAIT *****
  >>> bqItem5.build.builder is not None
  True
  >>> bqItem5.build.datebuilt is not None
  True
  >>> bqItem5.build.buildduration is not None
  True
  >>> bqItem5.build.buildlog is not None
  True
  >>> check_mail_sent(last_stub_mail_count)
  True
  >>> bqItem5.build.buildstate.title
  'Chroot problem'

Cleanup in preparation for the next test:

  >>> bqItem5.destroySelf()

  WAITING - BUILDERFAIL -> builder has failed by internal error, job is
  available for next build round:

  >>> bqItem6 = a_build.createBuildQueueEntry()
  >>> setupBuildQueue(bqItem6, a_builder)
  >>> last_stub_mail_count = len(stub.test_emails)

  Create a mock slave so the builder can operate - one with a builder error.

  >>> bqItem6.builder.setSlaveForTesting(WaitingSlave('BuildStatus.BUILDERFAIL'))

  >>> buildergroup.updateBuild(bqItem6)
  WARNING:root:***** bob has failed *****

  >>> from canonical.launchpad.ftests import sync
  >>> sync(a_builder)
  >>> a_builder.failnotes
  u'Builder returned BUILDERFAIL when asked for its status'

  >>> bqItem6.builder is None
  True
  >>> check_mail_sent(last_stub_mail_count)
  False
  >>> bqItem6.build.buildstate.title
  'Needs building'

Cleanup in preparation for the next test:

  >>> bqItem6.destroySelf()
  >>> a_builder.builderok = True


  BUILDING -> builder still processing the job, simply collect the logtail:

  >>> bqItem7 = a_build.createBuildQueueEntry()
  >>> setupBuildQueue(bqItem7, a_builder)
  >>> last_stub_mail_count = len(stub.test_emails)

  Create a mock slave so the builder can operate - one which is building.

  >>> bqItem7.builder.setSlaveForTesting(BuildingSlave())
  >>> builder_id = bqItem7.builder.id
  >>> buildergroup.updateBuild(bqItem7)

Due to updateBuild doing a commit we cannot compare the object instance.

  >>> bqItem7.builder.id is builder_id
  True
  >>> check_mail_sent(last_stub_mail_count)
  False
  >>> bqItem7.logtail
  u'This is a build log'

Cleanup in preparation for the next test:

  >>> bqItem7.destroySelf()


  ABORTED -> builder was aborted, release builder and reset job for
  the next build round:

  >>> bqItem8 = a_build.createBuildQueueEntry()
  >>> setupBuildQueue(bqItem8, a_builder)
  >>> last_stub_mail_count = len(stub.test_emails)

  >>> bqItem8.builder.setSlaveForTesting(AbortedSlave())
  >>> bqItem8.builder.name
  u'bob'
  >>> buildergroup.updateBuild(bqItem8)
  >>> bqItem8.builder is None
  True

Cleanup in preparation for the next test:

  >>> bqItem8.destroySelf()


  ABORTING -> builder is trying to terminate its children process, the
  only action master can perform is polling the slave status until it gets
  ABORTED

  >>> bqItem9 = a_build.createBuildQueueEntry()
  >>> setupBuildQueue(bqItem9, a_builder)
  >>> last_stub_mail_count = len(stub.test_emails)

  >>> bqItem9.builder.setSlaveForTesting(AbortingSlave())
  >>> bqItem9.builder.name
  u'bob'
  >>> buildergroup.updateBuild(bqItem9)
  >>> check_mail_sent(last_stub_mail_count)
  False
  >>> bqItem9.logtail
  u'Waiting for slave process to be terminated'

Cleanup in preparation for the next test:

  >>> bqItem9.destroySelf()


== Builder WAITING in OK state ==

This situation happens when the builder has finished the job and is
waiting for the master to collect its results.

The build record in question can end up in the following states:

 * FULLYBUILT: when binaries were collected and uploaded correctly;
 * FAILEDTOUPLOAD: binaries were collected but the upload was rejected/failed.


=== Failed to Upload (FAILEDTOUPLOAD) ===


  >>> bqItem10 = a_build.createBuildQueueEntry()
  >>> setupBuildQueue(bqItem10, a_builder)
  >>> last_stub_mail_count = len(stub.test_emails)

Create a mock slave so the builder gets the right responses for this test.

  >>> bqItem10.builder.setSlaveForTesting(WaitingSlave('BuildStatus.OK'))

If the build record wasn't updated before/during the updateBuild
(precisely on binary upload time), the build will be considered
FAILEDTOUPLOAD:

  >>> buildergroup.updateBuild(bqItem10)
  >>> bqItem10.build.builder is not None
  True
  >>> bqItem10.build.datebuilt is not None
  True
  >>> bqItem10.build.buildduration is not None
  True
  >>> bqItem10.build.buildlog is not None
  True
  >>> check_mail_sent(last_stub_mail_count)
  True
  >>> bqItem10.build.buildstate.title
  'Failed to upload'


Let's check the emails generated by this 'failure'
(see build-failedtoupload-workflow.txt for more information):

  >>> from canonical.launchpad.mail import stub
  >>> from operator import itemgetter
  >>> local_test_emails = stub.test_emails[last_stub_mail_count:]
  >>> local_test_emails.sort(key=itemgetter(1), reverse=True)
  >>> for from_addr, to_addrs, raw_msg in local_test_emails:
  ...      print to_addrs
  ['mark@hbd.com']
  ['foo.bar@canonical.com']
  ['celso.providelo@canonical.com']

Note that a real failed-to-upload notification contains the respective
upload log information:

  >>> one_email = stub.test_emails.pop()
  >>> from_addr, to_addrs, raw_msg = one_email
  >>> print raw_msg
  Content-Type: text/plain; charset="utf-8"
  ...
  X-Launchpad-Build-State: FAILEDTOUPLOAD
  ...
   * Build Log: http://localhost:58000/.../buildlog_ubuntu-hoary-i386.mozilla-=
  firefox_0.9_BUILDING.txt.gz
  ...
  Upload log:
  INFO    creating lockfile
  DEBUG   Initialising connection.
  ...
  DEBUG   Removing lock file: /var/lock/process-upload-buildd.lock
  ...

What we can clearly notice is that the buildlog is still containing
the old build state (BUILDING) in its name. This is a minor problem
that can be sorted by modifying the execution order of procedures
inside Buildergroup.buildStatus_OK method.

Cleanup in preparation for the next test:

  >>> bqItem10.destroySelf()


=== Successfully collected and uploaded  (FULLYBUILT) ===

Build item 6 has binary packages available in the sample data, letting us test
this case cleanly. We need to set the pocket to updates for this test as its
uploading to warty.

  >>> bqItem10 = getUtility(IBuildSet).getByBuildID(6).createBuildQueueEntry()

XXX: The pocket attribute is not intended to be changed in regular code, but
for this test we want to change it on the fly. An alternative would be to add
new sample data for a build that can be uploaded with binary packages attached
to it.

  >>> from zope.security.proxy import removeSecurityProxy
  >>> from canonical.launchpad.interfaces import PackagePublishingPocket
  >>> removeSecurityProxy(bqItem10.build).pocket = PackagePublishingPocket.UPDATES
  >>> setupBuildQueue(bqItem10, a_builder)
  >>> last_stub_mail_count = len(stub.test_emails)

Create a mock slave so the builder gets the right responses for this test.

  >>> bqItem10.builder.setSlaveForTesting(WaitingSlave('BuildStatus.OK'))

Now in order to emulate a successfully binary upload we will update
the build record to FULLYBUILT, as the process-upload would do:

  >>> from canonical.launchpad.interfaces import BuildStatus
  >>> bqItem10.build.buildstate = BuildStatus.FULLYBUILT

Now the updateBuild should recognise this build record as a
Successfully built and uploaded procedure, not sending any
notification and updating the build information:

  >>> buildergroup.updateBuild(bqItem10)
  >>> bqItem10.build.builder is not None
  True
  >>> bqItem10.build.datebuilt is not None
  True
  >>> bqItem10.build.buildduration is not None
  True
  >>> bqItem10.build.buildlog is not None
  True
  >>> bqItem10.build.buildstate.title
  'Successfully built'
  >>> check_mail_sent(last_stub_mail_count)
  False

Cleanup in preparation for the next test:

  >>> bqItem10.destroySelf()


  WAITING -> GIVENBACK - slave requested build record to be
  reschedulled.

  >>> bqItem11 = a_build.createBuildQueueEntry()
  >>> setupBuildQueue(bqItem11, a_builder)
  >>> last_stub_mail_count = len(stub.test_emails)

Create a mock slave so the builder gets the right responses for this test.

  >>> bqItem11.builder.setSlaveForTesting(WaitingSlave('BuildStatus.GIVENBACK'))
  >>> buildergroup.updateBuild(bqItem11)
  WARNING:root:***** 1-1 is GIVENBACK by bob *****

Ensure GIVENBACK build preserves the history for future use. (we
can't be sure if logtail will contain any information, because it
depends on how long the build took to be processed and how often we
scanned it)

  >>> bqItem11.builder is None
  True
  >>> bqItem11.buildstart is None
  True
  >>> bqItem11.lastscore
  0
  >>> check_mail_sent(last_stub_mail_count)
  False
  >>> bqItem11.build.buildstate.title
  'Needs building'

Cleanup in preparation for the next test:

  >>> bqItem11.destroySelf()


The Builddmaster should crash when collecting builds which are denied in
the given distroseries/pocket. Anytime it happens we need to manually
investigate why this build end up built. (should never happen in real
cases, and even so should be refused when we try to upload it.)


  >>> bqItem12 = getUtility(IBuildSet).getByBuildID(2).createBuildQueueEntry()
  >>> setupBuildQueue(bqItem12, a_builder)
  >>> last_stub_mail_count = len(stub.test_emails)

Create a mock slave so the builder gets the right responses for this test.

  >>> bqItem12.builder.setSlaveForTesting(WaitingSlave('BuildStatus.OK'))
  >>> buildergroup.updateBuild(bqItem12)
  Traceback (most recent call last):
  ...
  AssertionError: i386 build of mozilla-firefox 0.9 in ubuntu warty RELEASE (2) can not be built for pocket RELEASE: illegal status


The buildlog is collected and compressed locally using gzip algorithm,
let's see how this method works:

  >>> bqItem10.builder.setSlaveForTesting(WaitingSlave('BuildStatus.OK'))
  >>> logfile_alias = buildergroup.getLogFromSlave(bqItem10)

  >>> from canonical.launchpad.interfaces import ILibraryFileAliasSet

  >>> logfile = getUtility(ILibraryFileAliasSet)[logfile_alias]

  >>> logfile.filename, logfile.mimetype
  (u'buildlog_ubuntu-warty-i386.foobar_1.0_FULLYBUILT.txt.gz', u'text/plain')


Needed so that the Librarian can serve the new file.

  >>> local_transaction.commit()

Since LibrarianFileAlias does not implement required attributes for
gzip.open() (like tell() or seek()) we are obligated to read it again
in our filesystem.

  >>> import gzip, tempfile, os
  >>> fd, fname = tempfile.mkstemp()
  >>> tmp = open(fname, 'wb')
  >>> tmp.write(logfile.read())
  >>> tmp.close()
  >>> gzip.open(fname).read() == builder10.slave.getFile('buildlog').read()
  True

The happens with urllib instance, we need to download it to the
filesystem before uncompress.

  >>> import urllib
  >>> from_web = urllib.urlopen(logfile.http_url)
  >>> tmp = open(fname, 'wb')
  >>> tmp.write(from_web.read())
  >>> tmp.close()
  >>> gzip.open(fname).read() == builder10.slave.getFile('buildlog').read()
  True

Both access methods work as expected, remove the temporary file used here.

  >>> os.remove(fname)

Check the log from the uploader run has made it into the upload directory:

  >>> failed_dir = os.path.join(config.builddmaster.root, 'failed')
  >>> failed_uploads = sorted(os.listdir(failed_dir))
  >>> len(failed_uploads)
  2

  >>> failed_upload = failed_uploads[0]
  >>> uploader_log = open(os.path.join(failed_dir, failed_upload,
  ...                                  'uploader.log'))

  >>> print uploader_log.read()
  INFO    creating lockfile
  DEBUG   Initialising connection.
  DEBUG   Beginning processing
  DEBUG   Creating directory /var/tmp/builddmaster/accepted
  DEBUG   Creating directory /var/tmp/builddmaster/rejected
  DEBUG   Creating directory /var/tmp/builddmaster/failed
  ...
  DEBUG   Rolling back any remaining transactions.
  DEBUG   Removing lock file: /var/lock/process-upload-buildd.lock
  <BLANKLINE>

Remove build upload results root

  >>> shutil.rmtree(config.builddmaster.root)


    BuilddMaster class
    ===================

  >>> bm = BuilddMaster(logging.getLogger(), local_transaction)

Retrive a known DistroArchSeries

  >>> from canonical.launchpad.interfaces import IDistributionSet
  >>> hoary_i386 = getUtility(IDistributionSet)['ubuntu']['hoary']['i386']

Create a totally bogus CHROOT

  >>> from canonical.launchpad.database import LibraryFileAlias
  >>> from canonical.launchpad.database import PocketChroot
  >>> from canonical.launchpad.interfaces import PackagePublishingPocket
  >>> pocket = PackagePublishingPocket.RELEASE
  >>> chroot = LibraryFileAlias.get(1)
  >>> p = PocketChroot(distroarchseriesID=hoary_i386.id,
  ...                  pocket=pocket, chroot=chroot)


As we do when building the BuildQueue entries we need to recognise
all available distroarchseriess and figure out which slave builder
is able to build stuff properly for that one.


Initialiase the BuildMaster with all available distroarchseriess.
Because the sampledata builders are busy we issue and warning stating that.

  >>> from canonical.launchpad.interfaces import IDistroArchSeriesSet
  >>> for dar in sorted(getUtility(IDistroArchSeriesSet),
  ...                   key=lambda dar: (dar.distroseries.distribution.name,
  ...                                    dar.distroseries.name,
  ...                                    dar.architecturetag)):
  ...     bm.addDistroArchSeries(dar)
  ...     bm.setupBuilders(dar)
  WARNING:root.builders.x86:No builders are available

Inspect private attribute _archseries contents. Remember
archseries was fetched in the beginning of the test.

  >>> len(bm._archserieses)
  1

It should be hoary/x86:

  >>> bm._archserieses.keys()[0].title
  u'The Hoary Hedgehog Release for i386 (x86)'

  >>> real_buildergroup = bm._archserieses[hoary_i386]['builders']

  >>> real_buildergroup.firstAvailable() is None
  True

Scan active builders looking for information about current jobs,
collect result of finished jobs, everything is stored directly in
the Launchpad DB. (simply check if it doesn't explode)

  >>> bm.scanActiveBuilders()

Create a list of jobs separated by processor to turn the dispatch
process easier, then try to dispatch them according his processor and
the available builder slaves at moment.

  >>> byproc = bm.sortAndSplitByProcessor()
  >>> len(byproc)
  1

Inspect the organized list content:

  >>> for proc, queueItems in byproc.iteritems():
  ...     for item in queueItems:
  ...         proc.name, item.id, item.build.buildstate.name
  (u'x86', 2, 'NEEDSBUILD')
  (u'x86', 1, 'NEEDSBUILD')

Invoke dispacher on the available list: (no builder available atm)

  >>> for proc, queueItems in byproc.iteritems():
  ...     bm.dispatchByProcessor(proc, queueItems)

We wish now to check what happens if we dispatchByProcessor and there
are builds for now superseded source package releases in the queue.

This involves subbing in a scarily large amount of crud, so here
goes nothing.

  >>> from canonical.launchpad.interfaces import PackagePublishingStatus

  >>> class MockBG:
  ...     def firstAvailable(self, is_trusted=False):
  ...         return "Something which is not None"

  >>> class MockProcessor:
  ...     id = "fakeprocessor"
  ...     name = "fakeprocessor"

  >>> class MockPubRecord:
  ...     def __init__(self):
  ...         self.status = PackagePublishingStatus.SUPERSEDED

  >>> class MockSPR:
  ...     publishings = [MockPubRecord()]

  >>> from canonical.buildd.utils import notes
  >>> notes[MockProcessor()]["builders"] = MockBG()
  >>> qitem = MockBuildQueue(1000, None, MockBuild(1001))
  >>> qbuild = qitem.build
  >>> queue = [qitem]
  >>> qitem.build.sourcepackagerelease = MockSPR()
  >>> bm.dispatchByProcessor(MockProcessor(), queue)

  >>> print qbuild.buildstate.name
  SUPERSEDED


Get a BuildQueue to test with:

  >>> bqItem3 = a_build.createBuildQueueEntry()
  >>> setupBuildQueue(bqItem3, a_builder)
  >>> last_stub_mail_count = len(stub.test_emails)

Override the builder's slave with one that will claim to be 'OK'

  >>> bqItem3.builder.setSlaveForTesting(OkSlave())

This build is building in the release pocket for the main component in
the primary archive.  It will pass an 'archives' property to the slave
that contains sources.list entries for each pocket required in the
primary archive.

We also pass a property called 'suite' which is the current distroseries and
pocket, (e.g. edgy-updates) and 'archive_purpose' which contains the build's
archive.purpose (e.g. PRIMARY or PPA).  These latter two properties are
used in the chroot to determine whether it needs to turn on some features
or not (like pkgstriptranslations and pkgmaintainermangler).

  >>> bm.startBuild(real_buildergroup, a_builder, bqItem3)
  ensurepresent called
  ensurepresent called
  OkSlave BUILDING
  Archives: [u'deb http://ftpmaster.internal/ubuntu hoary main']
  Suite: hoary
  Archive Purpose: PRIMARY

Cleanup in preparation for the next test:

  >>> bqItem3.destroySelf()

Partner archive builds will set up the 'archives' property such that it
references all the required pockets/components in the primary archive, in
addition to a reference to the release pocket in the partner archive itself.

  >>> ubuntu = getUtility(IDistributionSet)['ubuntu']
  >>> partner_archive = ubuntu.getArchiveByComponent('partner')
  >>> removeSecurityProxy(a_build).archive = partner_archive
  >>> local_transaction.commit()
  >>> bqItem3 = a_build.createBuildQueueEntry()
  >>> setupBuildQueue(bqItem3, a_builder)
  >>> last_stub_mail_count = len(stub.test_emails)
  >>> bqItem3.builder.setSlaveForTesting(OkSlave())
  >>> bm.startBuild(real_buildergroup, a_builder, bqItem3)
  ensurepresent called
  ensurepresent called
  OkSlave BUILDING
  Archives: [u'deb http://ftpmaster.internal/ubuntu hoary main restricted universe multiverse', u'deb http://ftpmaster.internal/ubuntu hoary-security main restricted universe multiverse', u'deb http://ftpmaster.internal/ubuntu hoary-updates main restricted universe multiverse', u'deb http://launchpad.dev/ubuntu-partner hoary main']
  Suite: hoary
  Archive Purpose: PARTNER

  >>> bqItem3.destroySelf()
  >>> removeSecurityProxy(a_build).archive = ubuntu.main_archive
  >>> local_transaction.commit()

Similarly, PPA builds pass the archives property:

  >>> from canonical.launchpad.interfaces import IPersonSet
  >>> cprov_archive = getUtility(IPersonSet).getByName('cprov').archive
  >>> removeSecurityProxy(a_build).archive = cprov_archive
  >>> local_transaction.commit()
  >>> bqItem3 = a_build.createBuildQueueEntry()
  >>> a_builder.trusted = False
  >>> setupBuildQueue(bqItem3, a_builder)
  >>> last_stub_mail_count = len(stub.test_emails)
  >>> bqItem3.builder.setSlaveForTesting(OkSlave())
  >>> bm.startBuild(real_buildergroup, a_builder, bqItem3)
  ensurepresent called
  ensurepresent called
  OkSlave BUILDING
  Archives: [u'deb http://ftpmaster.internal/ubuntu hoary main restricted universe multiverse', u'deb http://ftpmaster.internal/ubuntu hoary-security main restricted universe multiverse', u'deb http://ftpmaster.internal/ubuntu hoary-updates main restricted universe multiverse', u'deb http://ppa.launchpad.dev/cprov/ubuntu hoary main']
  Suite: hoary
  Archive Purpose: PPA

Clean up before continuing:

  >>> bqItem3.destroySelf()
  >>> a_builder.trusted = True
  >>> a_builder.builderok = True
  >>> removeSecurityProxy(a_build).archive = ubuntu.main_archive
  >>> local_transaction.commit()

When there is no chroot it should not alter the buildstate:

  >>> from canonical.launchpad.interfaces import PackagePublishingPocket
  >>> PocketChroot.selectBy(
  ...     distroarchseries=bqItem3.archseries,
  ...     pocket=PackagePublishingPocket.UPDATES).count()
  0

  >>> bqItem3 = a_build.createBuildQueueEntry()
  >>> setupBuildQueue(bqItem3, a_builder)
  >>> last_stub_mail_count = len(stub.test_emails)

Override the builder's slave with one that will claim to be 'OK'

  >>> bqItem3.builder.setSlaveForTesting(OkSlave())

Make a build in the updates pocket:

  >>> hoary = hoary_i386.distroseries
  >>> hoary_evo = hoary.getSourcePackage(
  ...    'evolution').currentrelease.sourcepackagerelease
  >>> updates_build = hoary_evo.createBuild(
  ...     distroarchseries=hoary_i386,
  ...     pocket=PackagePublishingPocket.UPDATES,
  ...     processor=hoary_i386.default_processor,
  ...     archive=hoary_i386.main_archive)
  >>> updates_bqItem = updates_build.createBuildQueueEntry()

Builddmaster stops before starting to build a denied build.
Since hoary is in development, we are not able to dispatch
builds for post-release pockets:

  >>> hoary_i386.distroseries.status.name
  'DEVELOPMENT'
  >>> bm.startBuild(real_buildergroup, a_builder, updates_bqItem)
  Traceback (most recent call last):
  ...
  AssertionError: i386 build of evolution 1.0 in ubuntu hoary UPDATES (31) can not be built for pocket UPDATES: invalid pocket due to the series status of hoary.

== Pocket dependencies ==

When passing the archives property to a slave, the required pockets
are dependent on the pocket that we are building in, such that:

  >>> def show_pocket_deps():
  ...     print "Pocket    |   Dependencies"
  ...     print "----------+---------------"
  ...     for (key, value) in a_builder.pocket_dependencies.items():
  ...         print "%7s |" % (key.name,),
  ...         for pocket in value:
  ...             print pocket.name,
  ...         print

  >>> show_pocket_deps()
  Pocket    |   Dependencies
  ----------+---------------
    RELEASE | RELEASE
  BACKPORTS | RELEASE SECURITY UPDATES BACKPORTS
   SECURITY | RELEASE SECURITY
    UPDATES | RELEASE SECURITY UPDATES
   PROPOSED | RELEASE SECURITY UPDATES PROPOSED


Change the distroseries status for testing. FROZEN allows building in
all pockets:

  >>> from canonical.launchpad.interfaces import DistroSeriesStatus
  >>> hoary_i386.distroseries.status = DistroSeriesStatus.FROZEN

Now we can start a build in other pockets, and see what archives are
passed to the slave.

A build in the updates pocket:

  >>> bqItem3 = a_build.createBuildQueueEntry()
  >>> removeSecurityProxy(bqItem3.build).pocket = (
  ...     PackagePublishingPocket.UPDATES)
  >>> setupBuildQueue(bqItem3, a_builder)
  >>> last_stub_mail_count = len(stub.test_emails)
  >>> bm.startBuild(real_buildergroup, a_builder, bqItem3)
  ensurepresent called
  ensurepresent called
  OkSlave BUILDING
  Archives: [u'deb http://ftpmaster.internal/ubuntu hoary main', u'deb http://ftpmaster.internal/ubuntu hoary-security main', u'deb http://ftpmaster.internal/ubuntu hoary-updates main']
  Suite: hoary-updates
  Archive Purpose: PRIMARY

A build in the proposed pocket:

  >>> bqItem3 = a_build.createBuildQueueEntry()
  >>> removeSecurityProxy(bqItem3.build).pocket = (
  ...     PackagePublishingPocket.PROPOSED)
  >>> setupBuildQueue(bqItem3, a_builder)
  >>> last_stub_mail_count = len(stub.test_emails)
  >>> bm.startBuild(real_buildergroup, a_builder, bqItem3)
  ensurepresent called
  ensurepresent called
  OkSlave BUILDING
  Archives: [u'deb http://ftpmaster.internal/ubuntu hoary main', u'deb http://ftpmaster.internal/ubuntu hoary-proposed main', u'deb http://ftpmaster.internal/ubuntu hoary-security main', u'deb http://ftpmaster.internal/ubuntu hoary-updates main']
  Suite: hoary-proposed
  Archive Purpose: PRIMARY

A build in the security pocket:

  >>> bqItem3 = a_build.createBuildQueueEntry()
  >>> removeSecurityProxy(bqItem3.build).buildstate = (
  ...     BuildStatus.NEEDSBUILD)
  >>> removeSecurityProxy(bqItem3.build).pocket = (
  ...     PackagePublishingPocket.SECURITY)
  >>> setupBuildQueue(bqItem3, a_builder)
  >>> last_stub_mail_count = len(stub.test_emails)
  >>> bm.startBuild(real_buildergroup, a_builder, bqItem3)

XXX cprov 20071025: The pocket-dependency infrastructure is ready to
deal with SECURITY pocket, however we explicitly skip security builds
when dispatching because Embargoed-Archives and Restricted-UI
implementations are not yet ready.

Builds for security pocket will remain pending for now:

  >>> bqItem3.build.buildstate.name
  'NEEDSBUILD'


A build in the backports pocket:

  >>> bqItem3 = a_build.createBuildQueueEntry()
  >>> removeSecurityProxy(bqItem3.build).pocket = (
  ...     PackagePublishingPocket.BACKPORTS)
  >>> setupBuildQueue(bqItem3, a_builder)
  >>> last_stub_mail_count = len(stub.test_emails)
  >>> bm.startBuild(real_buildergroup, a_builder, bqItem3)
  ensurepresent called
  ensurepresent called
  OkSlave BUILDING
  Archives: [u'deb http://ftpmaster.internal/ubuntu hoary main', u'deb http://ftpmaster.internal/ubuntu hoary-backports main', u'deb http://ftpmaster.internal/ubuntu hoary-security main', u'deb http://ftpmaster.internal/ubuntu hoary-updates main']
  Suite: hoary-backports
  Archive Purpose: PRIMARY


== Builder Status Handler ==

IBuilder.slaveStatus should return a size homogeneous tuple despite of
the current slave state. This tuple should contain, in this order:

 * slave status string:  'BuilderStatus.IDLE'
 * job identifier string: '1-1'
 * job status string: 'BuildStatus.OK' or None
 * logtail (last 1K output of the ongoing build) as xmlrpclib.Binary or None
 * result file list: {'foo.deb', 'foo.changes'} or None
 * dependencies string: 'bar baz zaz' or None


  >>> a_builder.setSlaveForTesting(OkSlave())
  >>> a_builder.slaveStatus()
  ('BuilderStatus.IDLE', '', None, None, None, None)

  >>> a_builder.setSlaveForTesting(BuildingSlave())
  >>> a_builder.slaveStatus()
  ('BuilderStatus.BUILDING', '1-1', None, <xmlrpclib.Binary ...>, None, None)

  >>> a_builder.setSlaveForTesting(WaitingSlave(state='BuildStatus.OK'))
  >>> a_builder.slaveStatus()
  ('BuilderStatus.WAITING', '1-1', 'BuildStatus.OK', None, {}, None)

  >>> a_builder.setSlaveForTesting(AbortingSlave())
  >>> a_builder.slaveStatus()
  ('BuilderStatus.ABORTING', '1-1', None, None, None, None)

  >>> a_builder.setSlaveForTesting(AbortedSlave())
  >>> a_builder.slaveStatus()
  ('BuilderStatus.ABORTED', '1-1', None, None, None, None)
