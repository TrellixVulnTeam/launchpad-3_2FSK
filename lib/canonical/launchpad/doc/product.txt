= Product =

Launchpad keeps track of the "upstream" world as well as the "distro" world.
The anchorpiece of the "upstream" world is the Product, which is a piece of
software. It can be part of a Project or it can be standalone.

    >>> from zope.component import getUtility
    >>> from zope.interface.verify import verifyObject
    >>> from canonical.launchpad.interfaces import (
    ...     IProductSet, IProduct, IPersonSet, NotFoundError)
    >>> from canonical.launchpad.ftests import login
    >>> from canonical.database.sqlbase import flush_database_updates

Let's log in as Foo Bar to ensure we have the privileges to do what we're
going to demonstrate.

    >>> login("foo.bar@canonical.com")

Now lets get the utility we use to interact with sets of products.

    >>> productset = getUtility(IProductSet)

Verify that p (a Product object) correctly implements IProduct.

    >>> p = productset.get(5)
    >>> verifyObject(IProduct, p)
    True

Make sure that a product provides the IProduct interface.

    >>> IProduct.providedBy(p)
    True

Let's get a product from the sample data. We happen to know that product
with id 5 should be evolution:

    >>> p.name
    u'evolution'

Let's call that evo from now onwards just so the tests can be clearer.

    >>> evo = p

We'll also fetch the a52dec product from the database.

    >>> a52dec = productset.get(12)

Since we have some POTemplates for evolution, we should have a primary
translatable for that product:

    >>> evo.primary_translatable.displayname
    u'trunk'

We can also see how many translatables it has:

But for a52dec, where we have no translatable release or Ubuntu package, the
primary_translatable is nonexistent:

    >>> print a52dec.primary_translatable
    None

Now, to test the active flag. If we disabled a product:

    >>> a52dec.active = False
    >>> flush_database_updates()

It should no longer be retrievable via ProductSet's __getitem__:

    >>> try:
    ...   productset[a52dec.name]
    ... except NotFoundError:
    ...   pass

But it should be retrievable via getByname().

    >>> productset.getByName('a52dec').name
    u'a52dec'

getByName() also accepts an argument to ignore inactive products.

    >>> print productset.getByName('a52dec', ignore_inactive=True)
    None

You can also use the IProductSet to see some statistics on products.

    >>> print productset.count_translatable()
    3
    >>> print productset.count_bounties()
    2
    >>> print productset.count_buggy()
    5
    >>> print productset.count_reviewed()
    1

It provides information on all the translatables available, too:

    >>> for product in productset.translatables():
    ...    print product.name
    evolution
    netapplet
    alsa-utils


== Package links ==

The packaging table allows us to list source and distro source packages
related to a certain upstream:

   >>> alsa = productset.getByName('alsa-utils')
   >>> [(sp.name, sp.distrorelease.name) for sp in alsa.sourcepackages]
   [(u'alsa-utils', u'sid'), (u'alsa-utils', u'warty')]
   >>> [(sp.name, sp.distribution.name) for sp in alsa.distrosourcepackages]
   [(u'alsa-utils', u'debian'), (u'alsa-utils', u'ubuntu')]

== External Bug Tracker ==

If a product doesn't use Malone, it can specify that it uses an
external bug tracker. It can either use its own bug tracker, or use its
project's bug tracker. In order to make this logic easier for call
sites, there is a method that takes care of it called
getExternalBugTracker.


Firefox uses Malone as it's bug tracker, so it can't have an external
one.

    >>> firefox = getUtility(IProductSet).getByName('firefox')
    >>> firefox.official_malone
    True

    >>> firefox.getExternalBugTracker() is None
    True

This is true even if its project has a bug tracker specified.

    >>> from canonical.launchpad.interfaces import IBugTrackerSet
    >>> gnome_bugzilla = getUtility(IBugTrackerSet).getByName('gnome-bugzilla')
    >>> firefox.project.bugtracker = gnome_bugzilla
    >>> firefox.getExternalBugTracker() is None
    True

Now, if we say that Firefox doesn't use Malone, its project's bug
tracker will be returned.

    >>> firefox.official_malone = False
    >>> firefox.bugtracker is None
    True
    >>> firefox.getExternalBugTracker().name
    u'gnome-bugzilla'


If Firefox isn't happy with its project's bug tracker it can choose to
specify its own.

    >>> debbugs = getUtility(IBugTrackerSet).getByName('debbugs')
    >>> firefox.bugtracker = debbugs
    >>> firefox.getExternalBugTracker().name
    u'debbugs'


If neither the project nor the product have specified a bug tracker,
None will of course be returned.

    >>> firefox.project.bugtracker = None
    >>> firefox.bugtracker = None
    >>> firefox.getExternalBugTracker() is None
    True


== Product Creation ==

We can create new products with the createProduct() method:

    >>> owner = getUtility(IPersonSet).getByEmail('test@canonical.com')
    >>> product = productset.createProduct(
    ...     owner=owner,
    ...     name='test-product',
    ...     displayname='Test Product',
    ...     title='Test Product',
    ...     summary='A test product',
    ...     description='A description of the test product')

When creating a product, a default product series is created for it:

    >>> product.serieslist.count()
    1
    >>> trunk = product.serieslist[0]
    >>> print trunk.name
    trunk

This series is set as the development focus for the product:

    >>> product.development_focus == trunk
    True


== Specification Listings ==

We should be able to get lists of specifications in different states
related to a product.

Basically, we can filter by completeness, and by whether or not the spec is
informational.

 >>> firefox = productset.getByName('firefox')
 >>> from canonical.lp.dbschema import SpecificationFilter

First, there should be only one informational spec for firefox:

 >>> filter = [SpecificationFilter.INFORMATIONAL]
 >>> for spec in firefox.specifications(filter=filter):
 ...    print spec.name
 extension-manager-upgrades


There are no completed specs for firefox:

 >>> filter = [SpecificationFilter.COMPLETE]
 >>> for spec in firefox.specifications(filter=filter):
 ...    print spec.name


And there are five incomplete specs:

 >>> filter = [SpecificationFilter.INCOMPLETE]
 >>> firefox.specifications(filter=filter).count()
 5

We can filter for specifications that contain specific text:

 >>> for spec in firefox.specifications(filter=['new']):
 ...     print spec.name
 canvas
 e4x


== Milestones ==

We can use IProduct.milestones to get all milestones associated with any
ProductSeries of a product.

    >>> from datetime import datetime
    >>> [milestone.name for milestone in firefox.milestones]
    [u'1.0']

    >>> firefox_one_zero = firefox.getSeries('1.0')
    >>> firefox_milestone = firefox_one_zero.newMilestone(
    ...     name='1.0-rc1', dateexpected=datetime(2018, 10, 1))

They're ordered by dateexpected.

    >>> [(milestone.name, milestone.dateexpected.strftime('%Y-%m-%d'))
    ...  for milestone in firefox.milestones]
    [(u'1.0-rc1', '2018-10-01'), (u'1.0', '2056-10-16')]

Only milestones which have visible=True are returned by the .milestones
property.

    >>> firefox_milestone.visible = False
    >>> flush_database_updates()
    >>> [milestone.name for milestone in firefox.milestones]
    [u'1.0']

To get all milestones of a given product we have the .all_milestones property.

    >>> [milestone.name for milestone in firefox.all_milestones]
    [u'1.0-rc1', u'1.0']

== Products With Branches ==

We can also find all the products that have branches.

 >>> productset.getProductsWithBranches().count()
 5
 >>> for product in productset.getProductsWithBranches():
 ...     print product.name
 evolution
 firefox
 gnome-terminal
 iso-codes
 thunderbird
