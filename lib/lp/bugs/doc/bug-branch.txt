= Bugs and Branches =

Branches can be linked to Bugs, to track work in progress on branches,
and when fixes are committed.

    >>> from lp.bugs.interfaces.bugbranch import IBugBranchSet


== BugBranch ==

BugBranch links a bug and a branch.

    >>> from lp.bugs.interfaces.bug import IBugSet
    >>> from lp.registry.interfaces.person import IPersonSet
    >>> from lp.code.interfaces.branchlookup import IBranchLookup

    >>> login("no-priv@canonical.com")

    >>> bugset = getUtility(IBugSet)
    >>> bug = bugset.get(1)
    >>> branch = getUtility(IBranchLookup).get(10)


== Bugs Related to Branches ==

The bugs related to a branch are accessible via the linked_bugs
property.

    >>> sorted([bug.id for bug in branch.linked_bugs])
    [1, 4, 5]


== Getting bug branches associated with multiple branches ==

Sometimes we want to get the associated bug branch links for a set of branches.
The getBugBranchesForBranches method can do this.

Firstly we need to get the branches.

    >>> branches = [getUtility(IBranchLookup).getByUniqueName(
    ...                 '~carlos/iso-codes/0.35'),
    ...             getUtility(IBranchLookup).getByUniqueName(
    ...                 '~mark/firefox/release-0.9.2')]

The bug branches returned are only those where the user can see the
bugs that are associated.  This way if there are bugs associated with
a branch that the user cannot see, then they are not shown.

    >>> user = getUtility(IPersonSet).getByEmail('test@canonical.com')
    >>> bugbranches = getUtility(IBugBranchSet).getBugBranchesForBranches(
    ...     branches, user)
    >>> for bugbranch in sorted(bugbranches,
    ...                         key=lambda b: (b.branch.id, b.bug.id)):
    ...     print "%s <-> %s" % (
    ...         bugbranch.branch.unique_name, bugbranch.bug.id)
    ~mark/firefox/release-0.9.2 <-> 1
    ~mark/firefox/release-0.9.2 <-> 4


== Getting bug branches associated with multiple bugs ==

Sometimes we want to get the associated bug branch links for a set of bugs.
The getBugBranchesForBugs method can do this.

Firstly we need to get the branches.  We'll look up the relationships
for bugs 1, 2, 3 and 4.

    >>> bugtasks = list(getUtility(IBugSet).get(1).bugtasks)
    >>> bugtasks.extend(getUtility(IBugSet).get(2).bugtasks)
    >>> bugtasks.extend(getUtility(IBugSet).get(3).bugtasks)
    >>> bugtasks.extend(getUtility(IBugSet).get(4).bugtasks)
    >>> bugbranches2 = getUtility(IBugBranchSet).getBugBranchesForBugTasks(
    ...     bugtasks)
    >>> for bugbranch2 in sorted(bugbranches2,
    ...                         key=lambda b: (b.branch.id, b.bug.id)):
    ...     print "%s <-> %s" % (bugbranch2.branch.unique_name, bugbranch2.bug.id)
    ~name12/firefox/main <-> 1
    ~name12/firefox/main <-> 4
    ~mark/firefox/release-0.9.2 <-> 1
    ~mark/firefox/release-0.9.2 <-> 4

