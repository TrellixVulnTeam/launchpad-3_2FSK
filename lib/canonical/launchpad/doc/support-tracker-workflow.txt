= Support Tracker Workflow =

The state of a support ticket is tracked through its status attribute.
Six statuses are used to model a ticket lifecycle. These are defined
in the TicketStatus enumeration.

    >>> from canonical.lp.dbschema import TicketStatus
    >>> print "\n".join([status.name for status in TicketStatus.items])
    OPEN
    NEEDSINFO
    ANSWERED
    SOLVED
    EXPIRED
    INVALID

Status change occurs in consequence of a user action. The possible
actions are defined in the TicketAction enumeration.

    >>> from canonical.lp.dbschema import TicketAction
    >>> print "\n".join([status.name for status in TicketAction.items])
    REQUESTINFO
    GIVEINFO
    COMMENT
    ANSWER
    CONFIRM
    REJECT
    EXPIRE
    REOPEN
    SETSTATUS

There is a method available to execute each of these defined actions.

Let's define the actors that we are going to use to demonstrate the
support tracker workflow. The 'No Privileges Person' will be the
submitter of requests, 'Sample Person' will be a support contact for
the Ubuntu distribution, and 'Marilize Coetze' will be another user
providing support. Stub is a launchpad administrator that isn't also in
the Ubuntu Team that owns the distribution.

    >>> login('no-priv@canonical.com')

    >>> from canonical.launchpad.interfaces import (
    ...     IDistributionSet, IPersonSet)

    >>> personset = getUtility(IPersonSet)
    >>> sample_person = personset.getByEmail('test@canonical.com')
    >>> no_priv = personset.getByEmail('no-priv@canonical.com')
    >>> marilize = personset.getByEmail('marilize@hbd.com')
    >>> stub = personset.getByName('stub')

    >>> ubuntu = getUtility(IDistributionSet)['ubuntu']
    >>> ubuntu.addSupportContact(sample_person)
    True

    # Sanity check: the admin isn't in the team owning the distribution.
    >>> stub.inTeam(ubuntu.owner)
    False

A ticket starts its lifecycle in the Open state.

    >>> from datetime import datetime, timedelta
    >>> from pytz import UTC
    >>> now = datetime.now(UTC)
    >>> new_ticket_args = {
    ...     'owner': no_priv,
    ...     'title': 'Unable to boot installer',
    ...     'description': "I've tried installing Ubuntu on a Mac. "
    ...     "But the installer never boots.",
    ...     'datecreated': now}
    >>> ticket = ubuntu.newTicket(**new_ticket_args)
    >>> print ticket.status.title
    Open

From there, we have four representative scenarios.

== 1) Another user helps the submitter with his request ==

The most common scenario is where another user comes to help the
submitter and answers his support request. This may involve exchanging
information with the submitter to clarify the request.

The requestInfo() method is used to ask the user for more information.
This method takes two mandatory parameters: the user making the request
and his question. It can also takes a 'datecreated' parameter specifying
the creation date of the request (which defaults to now).

    >>> ticket = ubuntu.newTicket(**new_ticket_args)
    >>> now_plus_one_hour = now + timedelta(hours=1)
    >>> request_message = ticket.requestInfo(
    ...     sample_person, 'What is your Mac model?',
    ...     datecreated=now_plus_one_hour)

It returns the ITicketMessage that was added to the ticket messages
history:

    >>> from zope.interface.verify import verifyObject
    >>> from canonical.launchpad.interfaces import ITicketMessage
    >>> verifyObject(ITicketMessage, request_message)
    True
    >>> request_message == ticket.messages[-1]
    True
    >>> request_message.datecreated == now_plus_one_hour
    True
    >>> print request_message.owner.displayname
    Sample Person

The ticket message contains the action that was executed in the action
attribute and the status of the ticket after the action was executed in
the new_status attribute:

    >>> print request_message.action.name
    REQUESTINFO
    >>> print request_message.new_status.name
    NEEDSINFO

    >>> print request_message.text_contents
    What is your Mac model?

The subject of the message was generated automatically:

    >>> print request_message.subject
    Re: Unable to boot installer

The ticket is moved to the NEEDSINFO state and the datelastresponse
attribute is updated to the message timestamp.

    >>> print ticket.status.name
    NEEDSINFO
    >>> ticket.datelastresponse == now_plus_one_hour
    True

The ticket owner can reply to this information by using the giveInfo()
method which adds an ITicketMessage with action GIVEINFO.

    >>> login('no-priv@canonical.com')
    >>> now_plus_two_hours = now + timedelta(hours=2)
    >>> reply_message = ticket.giveInfo(
    ...     "I have a PowerMac 7200.", datecreated=now_plus_two_hours)

    >>> print reply_message.action.name
    GIVEINFO
    >>> print reply_message.new_status.name
    OPEN
    >>> reply_message == ticket.messages[-1]
    True
    >>> print reply_message.owner.displayname
    No Privileges Person

The ticket is moved back to the OPEN state and the 'datelastquery'
attribute is updated to the message's creation date:

    >>> print ticket.status.name
    OPEN
    >>> ticket.datelastquery == now_plus_two_hours
    True

The other user has now enough information to give an answer to the
support request. The giveAnswer() method is used for that purpose. Like
the requestInfo() method, it takes two mandatory parameters: the user
providing the answer and the answer itself.

    >>> login('test@canonical.com')
    >>> now_plus_three_hours = now + timedelta(hours=3)
    >>> answer_message = ticket.giveAnswer(
    ...     sample_person, "You need some configuration on the Mac side "
    ...     "to boot the installer on that model. Consult "
    ...     "https://help.ubuntu.com/community/Installation/OldWorldMacs "
    ...     "for all the details.", datecreated=now_plus_three_hours)
    >>> print answer_message.action.name
    ANSWER
    >>> print answer_message.new_status.name
    ANSWERED

After that action, the ticket's status is changed to ANSWERED and the
datelastresponse is updated to contain the date of the message.

    >>> print ticket.status.name
    ANSWERED
    >>> ticket.datelastresponse == now_plus_three_hours
    True

At that point, the support request is considered answered, but we don't
have feedback from the user on whether it solved his problem or not. If
it doesn't the user can reopen the request. The reopen() method is used
for that purpose.

    >>> login('no-priv@canonical.com')
    >>> tomorrow = now + timedelta(days=1)
    >>> reopen_message = ticket.reopen(
    ...     "I installed BootX and I've progressed somewhat. I now get the "
    ...     "boot screen. But soon after the Ubuntu progress bar appears, I "
    ...     "get a OOM Killer message appearing on the screen.",
    ...      datecreated=tomorrow)
    >>> print reopen_message.action.name
    REOPEN
    >>> print reopen_message.new_status.name
    OPEN
    >>> print reopen_message.owner.displayname
    No Privileges Person

This moves back the ticket to the OPEN state and the datelastquery
attribute is updated to the message creation date.

    >>> print ticket.status.name
    OPEN
    >>> ticket.datelastquery == tomorrow
    True

The giveAnswer() will again be used to give an answer.

    >>> login('test@canonical.com')
    >>> tomorrow_plus_one_hour = tomorrow + timedelta(hours=1)
    >>> answer2_message = ticket.giveAnswer(
    ...     marilize, "You probably do not have enough RAM to use the "
    ...     "graphical installer. You can try the alternate CD with the "
    ...     "text installer.")

This again moves the ticket to the ANSWERED state.

    >>> print ticket.status.name
    ANSWERED

The submitter will hopefully come back to confirm that his problem is
solved. The submitter can specify which message helped him solved his
problem. The confirmAnswer() method is used for that purpose.

    >>> login('no-priv@canonical.com')
    >>> two_weeks_from_now = now + timedelta(days=14)
    >>> confirm_message = ticket.confirmAnswer(
    ...     "I upgraded to 512M of RAM (found on eBay) and I've "
    ...     "succesfully managed to install Ubuntu. Thanks for all the help.",
    ...     datecreated=two_weeks_from_now, answer=answer_message)
    >>> print confirm_message.action.name
    CONFIRM
    >>> print confirm_message.new_status.name
    SOLVED
    >>> print confirm_message.owner.displayname
    No Privileges Person

The ticket is moved to the SOLVED state, the message that
solved the request is saved in the answer attribute, the dateanswered
and answerer attributes are also updated.

    >>> print ticket.status.name
    SOLVED
    >>> ticket.dateanswered == two_weeks_from_now
    True
    >>> print ticket.answerer.displayname
    Sample Person
    >>> ticket.answer == answer_message
    True

== 2) Self-answer ==

Another scenario is for the case when the user comes back to answer the
request himself. The giveAnswer() method is also used for that case.

    >>> ticket = ubuntu.newTicket(**new_ticket_args)
    >>> self_answer_message = ticket.giveAnswer(
    ...     no_priv, "I found some instructions on the Wiki on how to "
    ...     "install BootX to boot the installation CD on OldWorld Mac: "
    ...     "https://help.ubuntu.com/community/Installation/OldWorldMacs "
    ...     "This is complicated and since it's a very old machine, not "
    ...     "worth the trouble.",
    ...     datecreated=now_plus_one_hour)

In that case, the user is considered to have confirmed that the problem
is solved and the ticket is moved straight to the SOLVED state. The
'dateanswered' attribute will contain the date of the message,
the 'answerer' attribute will be identical to the ticket owner and
the 'answer' attribute will contain the message that closed the request.

    >>> print self_answer_message.action.name
    CONFIRM
    >>> print self_answer_message.new_status.name
    SOLVED
    >>> print ticket.status.name
    SOLVED
    >>> print ticket.answerer.displayname
    No Privileges Person
    >>> ticket.dateanswered == now_plus_one_hour
    True
    >>> ticket.answer == self_answer_message
    True

== 3) The request expires ==

Another case is when nobody comes to answer the message, either because
the request is too complex or too vague. These requests can be expired
by using the expireTicket() method. (See support-tracker-expiration.txt
for the documentation of the cron script handling this task.)

    >>> login('no-priv@canonical.com')
    >>> ticket = ubuntu.newTicket(**new_ticket_args)
    >>> expire_message = ticket.expireTicket(
    ...     sample_person, "There was no activity on this ticket for two "
    ...     "weeks and this ticket was expired. If you are still having "
    ...     "this problem you should reopen the request and provide more "
    ...     "information about your problem.",
    ...     datecreated=two_weeks_from_now)
    >>> print expire_message.action.name
    EXPIRE
    >>> print expire_message.new_status.name
    EXPIRED

The ticket is moved to the EXPIRED state and the 'datelastresponse'
attribute is updated to the message creation date.

    >>> print ticket.status.name
    EXPIRED
    >>> ticket.datelastresponse == two_weeks_from_now
    True

If the user comes back and provide more information, the ticket will be
reopened.

    >>> much_later = now + timedelta(days=30)
    >>> reopen_message = ticket.reopen(
    ...     "I'm installing on PowerMac 7200/120 with 32 Megs of RAM. After "
    ...     "I insert the CD and restart the computer, it boots straight "
    ...     "into Mac OS/9 instead of booting the installer.",
    ...     datecreated=much_later)
    >>> print reopen_message.action.name
    REOPEN

The ticket status is changed back to OPEN and the 'datelastquery'
attribute is updated.

    >>> print ticket.status.name
    OPEN
    >>> ticket.datelastquery == much_later
    True


== 4) The request is invalid ==

Another scenario to handle is the case where the user posts a message
that isn't really appropriate for the support tracker like a SPAM
message or a request for Ubuntu CDs.

    >>> spam_ticket = ubuntu.newTicket(
    ...     no_priv, 'CDs', 'Please send 10 Ubuntu Dapper CDs.',
    ...     datecreated=now)

The reject() method is used for such purpose. Only a support contact,
a product or distribution owner, or an administrator can reject a ticket.

The canReject() method can be used to test if a user is allowed to
reject the request. It takes as parameter the user who would reject the
request:

    >>> spam_ticket.canReject(no_priv)
    False
    >>> spam_ticket.canReject(marilize)
    False

    # Support contact
    >>> spam_ticket.canReject(sample_person)
    True
    >>> spam_ticket.canReject(ubuntu.owner)
    True

    # Administrator
    >>> spam_ticket.canReject(stub)
    True

    >>> login(marilize.preferredemail.email)
    >>> spam_ticket.reject(
    ...     marilize, 'Use https://shipit.launchpad.net/ to order CD')
    Traceback (most recent call last):
      ...
    Unauthorized: ...

The reject() method takes a comment explaining the reason behind the
rejection.

    >>> login('test@canonical.com')
    >>> reject_message = spam_ticket.reject(
    ...     sample_person, 'Use https://shipit.launchpad.net/ to order CD',
    ...     datecreated=now_plus_one_hour)
    >>> print reject_message.action.name
    REJECT
    >>> print reject_message.new_status.name
    INVALID

After rejection, the ticket is marked as invalid and the
'datelastresponse' attribute is updated.

    >>> print spam_ticket.status.name
    INVALID
    >>> spam_ticket.datelastresponse == now_plus_one_hour
    True

The rejection message is also considered as answering the message, so the
dateanswered, answerer and answer attributes are also updated.

    >>> spam_ticket.answer == reject_message
    True
    >>> print spam_ticket.answerer.displayname
    Sample Person
    >>> spam_ticket.dateanswered == now_plus_one_hour
    True

== Other scenarios ==

Many other scenarios are possible and some of those are probably more
common than the ones we exposed. For example, it is likely that a user
will answer directly a support request (without asking for other
information first). Or that the ticket user won't come back to confirm
that an answer solved his problem. Another likely scenario is where
the request will expire in the NEEDSINFO state when the ticket owner
doesn't reply to the request for more information. All of these
scenarios are covered by this API. It is not necessary to cover all
these various possibilities here.
(The ../interfaces/ftests/test_ticket_workflow.py functional test
exercices all the various possible transitions.)

== Changing the ticket status ==

It is not possible to change the status attribute directly:

    >>> login('foo.bar@canonical.com')
    >>> ticket = ubuntu.newTicket(**new_ticket_args)
    >>> ticket.status = TicketStatus.INVALID
    Traceback (most recent call last):
      ...
    ForbiddenAttribute...

A user which has launchpad.Admin permission on the ticket, can set the
ticket status to an arbitrary value by using the setStatus() method.
That method takes as parameters the new status and a comment explaining
the status change.

    >>> old_datelastquery = ticket.datelastquery
    >>> login(stub.preferredemail.email)
    >>> status_change_message = ticket.setStatus(
    ...      stub, TicketStatus.INVALID, 'Changed status to INVALID',
    ...     datecreated=now_plus_one_hour)

The method returns the ITicketMessage recording the change:

    >>> print status_change_message.action.name
    SETSTATUS
    >>> print status_change_message.new_status.name
    INVALID
    >>> print ticket.status.name
    INVALID

The status change doesn't update the datelastresponse nor the
datelastquery attributes:

    >>> ticket.datelastresponse is None
    True
    >>> ticket.datelastquery == old_datelastquery
    True

If an answer was present on the ticket, the status change also clears
the answer and dateanswered attributes.

    >>> msg = ticket.setStatus(stub, TicketStatus.OPEN, 'Status change.')
    >>> answer_message = ticket.giveAnswer(sample_person, 'Install BootX.')

    >>> login('no-priv@canonical.com')
    >>> msg = ticket.confirmAnswer('This worked.', answer=answer_message)
    >>> ticket.dateanswered is not None
    True
    >>> ticket.answer == answer_message
    True

    >>> login(stub.preferredemail.email)
    >>> status_change_message = ticket.setStatus(
    ...     stub, TicketStatus.OPEN, 'Reopen the request',
    ...     datecreated=now_plus_one_hour)

    >>> ticket.dateanswered is None
    True
    >>> ticket.answer is None
    True

But when the status is changed by a user who doesn't have the
launchpad.Admin permission, an Unauthorized error is thrown:

    >>> login('test@canonical.com')
    >>> ticket.setStatus(sample_person, TicketStatus.EXPIRED, 'Expire.')
    Traceback (most recent call last):
      ...
    Unauthorized...

== Adding Comments Without Changing the Status ==

There is an addComment() method that can be use to add a message to the
ticket without changing its status.

    >>> login('no-priv@canonical.com')
    >>> old_status = ticket.status
    >>> old_datelastresponse = ticket.datelastresponse
    >>> old_datelastquery = ticket.datelastquery
    >>> comment = ticket.addComment(
    ...     no_priv, 'This is a comment.',
    ...     datecreated=now_plus_two_hours)

    >>> print comment.action.name
    COMMENT
    >>> comment.new_status == old_status
    True

This method does not update the datelastresponse and datelastquery
attributes.

    >>> ticket.datelastresponse == old_datelastresponse
    True
    >>> ticket.datelastquery == old_datelastquery
    True

== Events ==

Each of the workflow methods will trigger a SQLObjectCreatedEvent for
the message they create and a SQLObjectModifiedEvent for the ticket.

    # Register an event listener that will print event it receives.
    >>> from canonical.launchpad.event.interfaces import (
    ...     ISQLObjectCreatedEvent, ISQLObjectModifiedEvent)
    >>> from canonical.launchpad.interfaces import ITicket
    >>> from canonical.launchpad.ftests.event import TestEventListener
    >>> def print_event(object, event):
    ...     print "Received %s on %s" % (
    ...         event.__class__.__name__.split('.')[-1],
    ...         object.__class__.__name__.split('.')[-1])
    >>> ticketmessage_event_listener = TestEventListener(
    ...     ITicketMessage, ISQLObjectCreatedEvent, print_event)
    >>> ticket_event_listener = TestEventListener(
    ...     ITicket, ISQLObjectModifiedEvent, print_event)

Changing the status triggers the event:

    >>> login(stub.preferredemail.email)
    >>> msg = ticket.setStatus(stub, TicketStatus.EXPIRED, 'Status change.')
    Received SQLObjectCreatedEvent on TicketMessage
    Received SQLObjectModifiedEvent on Ticket

Example of a workflow method that triggers the events:

    >>> msg = ticket.reject(stub, 'Close this ticket.')
    Received SQLObjectCreatedEvent on TicketMessage
    Received SQLObjectModifiedEvent on Ticket

Even only adding a comment without changing the status will send
these events.

    >>> login('test@canonical.com')
    >>> msg = ticket.addComment(sample_person, 'A comment')
    Received SQLObjectCreatedEvent on TicketMessage
    Received SQLObjectModifiedEvent on Ticket

    # Cleanup
    >>> ticketmessage_event_listener.unregister()
    >>> ticket_event_listener.unregister()

== Reopenings ==

Whenever a ticket considered answered (in the SOLVED or INVALID state)
is reopened, a TicketReopening is created.

    # Let's register an event listener to notify us whenever a
    # TicketReopening is created.
    >>> from canonical.launchpad.interfaces import ITicketReopening
    >>> reopening_event_listener = TestEventListener(
    ...     ITicketReopening, ISQLObjectCreatedEvent, print_event)

The most common use case is when a user confirms a solution, and then
comes back to say that it doesn't work in fact.

    >>> login('no-priv@canonical.com')
    >>> ticket = ubuntu.newTicket(**new_ticket_args)
    >>> answer_message = ticket.giveAnswer(
    ...    sample_person, "You need some setup on the Mac side. "
    ...    "Follow the instructions at "
    ...     "https://help.ubuntu.com/community/Installation/OldWorldMacs",
    ...     datecreated=now_plus_one_hour)
    >>> confirm_message = ticket.confirmAnswer(
    ...     "I've installed BootX and the installer now boot properly.",
    ...     answer=answer_message, datecreated=now_plus_two_hours)
    >>> reopen_message = ticket.reopen(
    ...     "Actually, altough the installer boots properly. I'm not able "
    ...     "to pass beyond the partitioning.",
    ...     datecreated=now_plus_three_hours)
    Received SQLObjectCreatedEvent on TicketReopening

The reopening record is available through the reopenings attribute.

    >>> list(ticket.reopenings)
    [<TicketReopening...>]
    >>> reopening = ticket.reopenings[0]
    >>> verifyObject(ITicketReopening, reopening)
    True

The reopening contain the date of the reopening in the datecreated
attribute and the person who made the reopening in the reopener
attribute.

    >>> reopening.datecreated == now_plus_three_hours
    True
    >>> print reopening.reopener.displayname
    No Privileges Person

It contains the ticket prior answerer, datecreated, as well as the
prior status in the priorstate attribute:

    >>> print reopening.answerer.displayname
    Sample Person
    >>> reopening.dateanswered == now_plus_two_hours
    True
    >>> print reopening.priorstate.name
    SOLVED

Another example of a reopening, would be when the ticket status is set
back to OPEN after having been rejected.

    >>> login('test@canonical.com')
    >>> ticket = ubuntu.newTicket(**new_ticket_args)
    >>> reject_message = ticket.reject(
    ...     sample_person, 'This is a frivoulous request.',
    ...     datecreated=now_plus_one_hour)

    >>> login(stub.preferredemail.email)
    >>> status_change_message = ticket.setStatus(
    ...     stub, TicketStatus.OPEN, 'Disregard previous rejection. '
    ...     'Sample Person was having a bad day.',
    ...     datecreated=now_plus_two_hours)
    Received SQLObjectCreatedEvent on TicketReopening

    >>> reopening = ticket.reopenings[0]
    >>> print reopening.reopener.name
    stub
    >>> reopening.datecreated == now_plus_two_hours
    True
    >>> print reopening.answerer.displayname
    Sample Person
    >>> reopening.dateanswered == now_plus_one_hour
    True
    >>> print reopening.priorstate.name
    INVALID

    # Cleanup
    >>> reopening_event_listener.unregister()

== Using an IMessage as Explanation ==

In all the workflow methods, it is possible to pass an IMessage instead of
a string.

    >>> from canonical.launchpad.interfaces import IMessageSet
    >>> login('test@canonical.com')
    >>> messageset = getUtility(IMessageSet)
    >>> ticket = ubuntu.newTicket(**new_ticket_args)
    >>> reject_message = messageset.fromText(
    ...     'Reject', 'Because I feel like it.', sample_person)
    >>> ticket_message = ticket.reject(sample_person,reject_message)
    >>> print ticket_message.subject
    Reject
    >>> print ticket_message.text_contents
    Because I feel like it.
    >>> ticket_message.rfc822msgid == reject_message.rfc822msgid
    True

The IMessage owner must be the same than the person passed to the workflow
method.

    >>> login(stub.preferredemail.email)
    >>> ticket.setStatus(stub, TicketStatus.OPEN, reject_message)
    Traceback (most recent call last):
      ...
    AssertionError...
