Adding BugTasks
===============

If a bug occurs in more than one place, you can request a fix in some
other software. You can request a fix in either a product or a
distribution. Let's start with a product, this is done using
+upstreamtask.

    >>> login('test@canonical.com')
    >>> from zope.component import getView
    >>> from canonical.launchpad.interfaces import IBugSet
    >>> bug_four = getUtility(IBugSet).get(4)
    >>> len(bug_four.bugtasks)
    1
    >>> firefox_task = bug_four.bugtasks[0]
    >>> from canonical.launchpad.webapp.servers import LaunchpadTestRequest
    >>> request = LaunchpadTestRequest()

Some of the setup is done just before the view is rendered. Let's
create a helper function that makes sure the view is set up properly.
We don't care about the actual rendering of the page, so we override
the view.template().

    >>> def get_and_setup_view(context, name, request):
    ...     view = getView(context, name, request)
    ...     view.index = lambda: ''
    ...     view.confirmation_page = lambda: 'CONFIRMATION PAGE'
    ...     view()
    ...     return view
    >>> add_task_view = get_and_setup_view(
    ...     firefox_task, '+upstreamtask', request)

We haven't posted the form, so process_status will be empty.

    >>> add_task_view.process_status
    ''

If we POST the form without entering any information, it will complain
that product is required:

    >>> request = LaunchpadTestRequest(
    ...     form={'FORM_SUBMIT': '', 'field.bugtracker': '2'})
    >>> add_task_view = get_and_setup_view(
    ...     firefox_task, '+upstreamtask', request)
    >>> add_task_view.process_status
    u'Please fix the problems below and try again.'
    >>> add_task_view.errors
    MissingInputError: ('product', u'Product', 'the field is required')

In order to show that all the events get fired off, let's create an
event listener and register it:

    >>> from zope.interface import Interface
    >>> from canonical.launchpad.event.interfaces import ISQLObjectCreatedEvent
    >>> from canonical.launchpad.ftests.event import TestEventListener

    >>> def on_created_event(object, event):
    ...     print "SQLObjectCreatedEvent: %r" % object

    >>> on_created_listener = TestEventListener(
    ...     Interface, ISQLObjectCreatedEvent, on_created_event)


If we specify a valid product, no errors will occur, and a bugtask will
be created:

    >>> request = LaunchpadTestRequest(
    ...     form={'FORM_SUBMIT': '', 'field.product': 'evolution',
    ...           'field.bugtracker': '2'})
    >>> add_task_view = get_and_setup_view(
    ...     firefox_task, '+upstreamtask', request)
    SQLObjectCreatedEvent: <BugTask at ...>

    >>> for bugtask in bug_four.bugtasks:
    ...     print bugtask.targetname
    evolution (upstream)
    firefox (upstream)

This worked without any problems since Evolution does use Malone as its
offical bug tracker.

    >>> evolution_task = bug_four.bugtasks[0]
    >>> evolution_task.target.official_malone
    True

If we try to add a task for ALSA, which doesn't use Malone, it won't go
as smoothly as above.

    >>> add_task_view.show_confirmation
    False
    >>> request = LaunchpadTestRequest(
    ...     form={'FORM_SUBMIT': '', 'field.product': 'alsa-utils',
    ...           'field.bugtracker': '2'})
    >>> add_task_view = get_and_setup_view(
    ...     firefox_task, '+upstreamtask', request)

    >>> for bugtask in bug_four.bugtasks:
    ...     print bugtask.targetname
    evolution (upstream)
    firefox (upstream)

As you can see no ALSA was added to the bug. In order to add such a task, the user will have to go through a confirmation screen.

    >>> len(add_task_view.errors)
    0
    >>> add_task_view.show_confirmation
    True
    >>> add_task_view.nextURL() is None
    True
    >>> add_task_view()
    'CONFIRMATION PAGE'

If the user chooses "No", he will be returned to the add page, and no
task was added to the bug.

    >>> request = LaunchpadTestRequest(
    ...     form={'CANCEL': 'No', 'field.product': 'alsa-utils',
    ...           'field.bugtracker': '2'})
    >>> add_task_view = get_and_setup_view(
    ...     firefox_task, '+upstreamtask', request)
    >>> add_task_view.show_confirmation
    False
    >>> add_task_view.nextURL() is None
    True

    >>> for bugtask in bug_four.bugtasks:
    ...     print bugtask.targetname
    evolution (upstream)
    firefox (upstream)

If the user chooses "Yes", a bugtask will be added to the bug.

    >>> request = LaunchpadTestRequest(
    ...     form={'CONFIRM': '', 'field.product': 'alsa-utils',
    ...           'field.bugtracker': '2'})
    >>> add_task_view = get_and_setup_view(
    ...     firefox_task, '+upstreamtask', request)
    SQLObjectCreatedEvent: <BugTask at ...>
    >>> add_task_view.show_confirmation
    False
    >>> add_task_view.nextURL() is not None
    True

    >>> for bugtask in bug_four.bugtasks:
    ...     print bugtask.targetname
    alsa-utils (upstream)
    evolution (upstream)
    firefox (upstream)

But since no bug watch was specified, the status and importance
are set to the default values.

    >>> alsa_task = bug_four.bugtasks[0]
    >>> alsa_task.target.official_malone
    False
    >>> alsa_task.status.title
    'Unconfirmed'
    >>> alsa_task.importance.title
    'Untriaged'

On the same form, we can add a bug watch. If we specify a remote bug
tracker, but omit the remote bug number, an error message is given:

    >>> request = LaunchpadTestRequest(
    ...     form={'FORM_SUBMIT': '', 'field.product': 'thunderbird',
    ...           'field.link_to_bugwatch': 'on',
    ...           'field.bugtracker-empty-marker': '1',
    ...           'field.bugtracker': '2'})
    >>> add_task_view = get_and_setup_view(
    ...     firefox_task, '+upstreamtask', request)
    >>> add_task_view.process_status
    u'Please fix the problems below and try again.'
    >>> add_task_view.top_of_page_errors
    LaunchpadValidationError:
    ...Please specify the remote bug number in the remote bug tracker...

Note that this caused the transaction to be aborted, thus the bugtasks
that got added earlier are now gone:

    >>> len(bug_four.bugtasks)
    1

If we specify a remote bug number as well, both the task and the bug
watch will be added without any confirmation neede:

    >>> request = LaunchpadTestRequest(
    ...     form={'FORM_SUBMIT': '', 'field.product': 'thunderbird',
    ...           'field.link_to_bugwatch': 'on',
    ...           'field.bugtracker-empty-marker': 1, 'field.bugtracker': 2,
    ...           'field.remotebug': '84'})
    >>> add_task_view = get_and_setup_view(
    ...     firefox_task, '+upstreamtask', request)
    SQLObjectCreatedEvent: <BugWatch at ...>
    SQLObjectCreatedEvent: <BugTask at ...>

    >>> add_task_view.show_confirmation
    False

    >>> for bugtask in bug_four.bugtasks:
    ...     print bugtask.targetname
    firefox (upstream)
    thunderbird (upstream)

    >>> for bugwatch in bug_four.watches:
    ...     print "%s: %s" % (bugwatch.bugtracker.title, bugwatch.remotebug)
    GnomeGBug GTracker: 84

The bug watch got linked to the create task, and all the bug task's
attribute got initialised to Unknown. The bugtask will be synced with
the bug watch's status later.

    >>> thunderbird_task = bug_four.bugtasks[1]
    >>> thunderbird_task.product.official_malone
    False
    >>> thunderbird_task.bugwatch == bug_four.watches[0]
    True

    >>> thunderbird_task.status.title
    'Unknown'
    >>> thunderbird_task.importance.title
    'Unknown'


If we try to add a bug watch together with a product which does use
Malone, an error will occur.

    >>> request = LaunchpadTestRequest(
    ...     form={'FORM_SUBMIT': '', 'field.product': 'evolution',
    ...           'field.link_to_bugwatch': 'on',
    ...           'field.bugtracker-empty-marker': 1, 'field.bugtracker': 2,
    ...           'field.remotebug': '42'})
    >>> add_task_view = get_and_setup_view(
    ...     firefox_task, '+upstreamtask', request)
    >>> add_task_view.process_status
    u'Please fix the problems below and try again.'
    >>> add_task_view.top_of_page_errors
    LaunchpadValidationError:
    ...Evolution uses Malone as its bug tracker...

There's a method for easily retrieving the target display name for use
on the confirmation page. If we request a fix in an upstream product,
its display name is returned:

    >>> request = LaunchpadTestRequest(
    ...     form={'FORM_SUBMIT': '', 'field.product': 'alsa-utils',
    ...           'field.bugtracker': 2})
    >>> add_task_view = get_and_setup_view(
    ...     firefox_task, '+upstreamtask', request)
    >>> add_task_view.getBugTargetName()
    u'alsa-utils'

If we request a fix in a source package, the distribution's display
name is returned.

    >>> request = LaunchpadTestRequest(
    ...     form={'FORM_SUBMIT': '', 'field.distribution': 'debian',
    ...           'field.sourcepackagename': 'evolution',
    ...           'field.bugtracker': 2})
    >>> add_task_view = get_and_setup_view(
    ...     firefox_task, '+distrotask', request)
    >>> add_task_view.getBugTargetName()
    u'Debian'

    >>> on_created_listener.unregister()
