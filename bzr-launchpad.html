<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

  
  
  <html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Launchpad's Bazaar</title><link rel="stylesheet" href="texmacs.css" type="text/css" /></head><body>
    
      <h1>Launchpad's Bazaar</h1>
    
    
    <p>
      This document explains what are the existing components of
      <a href="https://wiki.launchpad.canonical.com/TheBazaar">TheBazaar</a>,
      the Bazaar integration in Launchpad, how they relate to one another, and
      some of the future plans. It was written by David Allouche at the end of
      January 2006.
    </p>
    
    <p>
      There is a strong bias towards the internal details of the components
      I'm familiar with and the issues I know about, and this documentation
      does not pretend being complete by any means. Corrections and additions
      are welcome.
    </p>
    
    
      <h2>1. Bazaar Overview</h2>
    
    
    
      <h3>1.1. The Big Picture</h3>
    
    
    <p>
      First, let's have a bird's eye view of the various moving parts
      providing Bazaar integration in Launchpad. That's simplistic, but that
      gives us a place to start.
    </p>
    
    
      <div class="big-figure"><div class="figure-body"><img src="launchpad-bzr.png" alt="launchpad-bzr.png" /></div><div class="figure-caption"><b>Figure 1: </b>Don't
      panic</div></div>
    
    
    <p>
      There is a dotted arrow in this diagram, it means ``handwaving here''.
      The details of what it means will be covered a bit later.
    </p>
    
    <p>
      The dashed line is the Launchpad system boundary. Anything that is
      inside the dashed box we control and we run. Anything that is outside
      the dashed box is out there on the wild internet.
    </p>
    
    <p>
      The two important storage areas are:
    </p>
    
    
      <ul>
        <li>
          Launchpad, the all-encompassing database. You know it, you
          can use its schema to cover the walls of a very large conference
          room. Every component in the system is driven by Lauchpad data.
        </li>
        
        <li>
          Branch Warehouse, essentially just a big hard drive that
          stores Bazaar branches. It is represented here because it is an
          important information bus. It is also known as the ``Supermirror
          filesystem''.
        </li>
      </ul>
    
    
    <p>
      The important world-facing systems are:
    </p>
    
    
      <ul>
        <li>
          Branch Puller, periodically runs <tt>bzr
          pull</tt> to copy remote branches registered in Launchpad onto
          the Branch Warehouse. It is the specific service for ``pull
          branches''.
        </li>
        
        <li>
          SFTP Server, allows <tt>bzr</tt> to directly push
          branches on Launchpad, effectively providing a free community
          hosting service for Bazaar branches. It is the specific component
          for ``push branches''.
        </li>
        
        <li>
          Branch publisher, exposes a HTTP server from which all
          branches stored in the Warehouse can be checked out. It is the
          Supermirror front-end, serving Bazaar goodness to the world, whereas
          the the Branch Puller and the SFTP Server are back-ends used to
          place data on the Supermirror.
        </li>
        
        <li>
          RCS importer, sucks the living CPU out of CVS and Subversion
          server out there to free source code from the centralized versioning
          oppression. It produces Bazaar branches from upstream repositories
          specified in Launchpad and stuff the Branch Warehouse with the
          resulting gigabytes of uninteresting historical details.
        </li>
      </ul>
    
    
    <p>
      Finally, the Branch Syncher in an internal system that scans branches
      stored in the Warehouse and stores summary historical information into
      the Launchpad database.
    </p>
    
    
      <h3>1.2. Supermirror?</h3>
    
    
    <p>
      The Supermirror is the historic name for the the subsystem now
      implemented by the Branch Puller, the SFTP Server, the Branch Warehouse,
      and the Branch Publisher. The original Arch Supermirror was independent
      from Launchpad, while the Bazaar Supermirror is deeply integrated with
      Launchpad.
    </p>
    
    <p>
      In the rest of this document, as in casual conversation, the term
      ``Supermirror'' is used interchangeably to denote the whole subsystem or
      just the Branch Warehouse, its central component.
    </p>
    
    <p>
      Although the Supermirror name is familiar to some people and useful as
      an internal project name, public communication should favor terms like
      ``Launchpad branches'' rather than ``Supermirror'', in the same way that
      ``Launchpad bug tracker'' is used in preference to ``Malone''.
    </p>
    
    
      <h3>1.3. Bazaar Hosts</h3>
    
    
    <p>
      There are currently three public servers whose name is
      <tt>bazaar</tt>.
    </p>
    
    
      <dl>
        <dt>bazaar.canonical.com</dt><dd>
          The Wiki of the Bazaar
          revision control system. This is the place of the Bazaar development
          community and is not related to Launchpad.
        </dd>
        
        <dt>bazaar.ubuntu.com</dt><dd>
          The host the Arch RCS Importer
          historically used to publish branches, those branches were
          automatically registered on the Arch Supermirror.
        </dd>
        
        <dt>bazaar.launchpad.net</dt><dd>
          The host providing the
          Branch Publisher and the SFTP Server for <tt>bzr</tt>.
        </dd>
      </dl>
    
    
    <p>
      I am confident that our team will find a use for a
      <tt>bazaar</tt> host in all the other domains that Canonical
      will use in the future. This document is mainly interested in
      <tt>bazaar.launchpad.net</tt>, but
      <tt>bazaar.ubuntu.com</tt> is also mentioned for historical
      reasons in the RCS Importer section.
    </p>
    
    
      <h2>2. Break up by Service</h2>
    
    
    <p>
      The scary diagram at the beginning is actually the superimposition of
      diagrams for several nearly independent services. Before examining
      individual components and their relations, we will have a quick tour of
      each service.
    </p>
    
    
      <h3>2.1. Pull Branch Mirroring</h3>
    
    
    <p>
      One of the services is the mirroring of remote branches. Remote branches
      registered in Launchpad are pulled into the Supermirror and published on
      <tt>bazaar.launchpad.net</tt>.
    </p>
    
    
      <div class="big-figure"><div class="figure-body"><img src="pull-branch.png" alt="pull-branch.png" /></div><div class="figure-caption"><b>Figure 2: </b>Pull
      branch mirroring</div></div>
    
    
    <p>
      Pull branches are periodically updated in the Warehouse by the Branch
      Puller. The Branch Publisher serves the Warehouse data to Bazaar clients
      that want to use the Supermirror rather than accessing the master
      branch.
    </p>
    
    <p>
      For example, the <tt>bzr</tt> mainline is hosted on
      <tt>http://bazaar-ng.org/bzr/bzr.dev/</tt>, this is the
      branch URL. It is registered in Launchpad as
      <tt>/people/mbp/+branch/bzr/dev</tt>, this is the Launchpad
      Branch page. It is published as
      <tt>http://bazaar.launchpad.nate/~mbp/bzr/dev</tt>, this is
      the Launchpad mirror (or Supermirror) URL.
    </p>
    
    
      <h3>2.2. Push Branch Hosting</h3>
    
    
    <p>
      Launchpad provides a hosting service for Bazaar branches. A Bazaar user
      wishing to publish a branch, but unable use a personal web space, can
      push the branch on <tt>bazaar.launchpad.net</tt> using the
      SFTP transport.
    </p>
    
    
      <div class="big-figure"><div class="figure-body"><img src="push-branch.png" alt="push-branch.png" /></div><div class="figure-caption"><b>Figure 3: </b>Push
      branch hosting</div></div>
    
    
    <p>
      The SFTP server writes to a private filesystem. The Branch Puller is
      used to copy branches from the private SFTP area to the Branch
      Warehouse, ensuring that only usable Bazaar branch data gets
      published.
    </p>
    
    <p>
      Once it is stored in the Warehouse, the branch is published in the same
      way as for pull branches.
    </p>
    
    
      <h3>2.3. RCS Imports</h3>
    
    
    <p>
      The famous RCS import service produces publicly accessible Bazaar
      branches from the source code history stored in remote CVS or Subversion
      servers.
    </p>
    
    
      <div class="big-figure"><div class="figure-body"><img src="rcs-import.png" alt="rcs-import.png" /></div><div class="figure-caption"><b>Figure 4: </b>RCS
      import</div></div>
    
    
    <p>
      A bit earlier, I told you not to worry about the dotted line. Now is the
      moment of truth where its meaning will be uncovered. The RCS import
      branches must be published on the Branch Warehouse so they will be
      accessible to the Branch Syncher, and served on the same host as the
      other branches on the Supermirror. But the way the import branches will
      be copied to the Warehouse is still undecided at the moment.
    </p>
    
    
      <h3>2.4. Branch Scanning</h3>
    
    
    <p>
      The last service in the system, at the moment at least, is the Branch
      Syncher. It updates the Launchpad database record of the ancestry of all
      branches present in the Branch Warehouse.
    </p>
    
    
      <div class="big-figure"><div class="figure-body"><img src="branch-scan.png" alt="branch-scan.png" /></div><div class="figure-caption"><b>Figure 5: </b>Branch
      scanning</div></div>
    
    
    <p>The ancestry record in Launchpad is currently only used to display the most recent revisions on each branch. But many future features will use this data as well. For example measuring the activity of branches, grouping branches, marking merged branches, etc. </p>
    
    
      <h2>3. Break up by Component</h2>
    
    
    <p>
      At this point, you should have a reasonable feeling of how the various
      components relate to one another. So we can start with the really
      technical stuff.
    </p>
    
    
      <h3>3.1. Branch Publisher</h3>
    
    
    <p>
      The Branch Publisher is the web server on
      <tt>bazaar.launchpad.net</tt>. It only provides Bazaar
      branches for use by <tt>bzr</tt>, and no resource meant for
      direct human consumption.
    </p>
    
    
      <div class="big-figure"><div class="figure-body"><img src="branch-publisher.png" alt="branch-publisher.png" /></div><div class="figure-caption"><b>Figure 6: </b>Branch
      Publisher</div></div>
    
    
    <p>
      The Branch Publisher has no knowledge of the Bazaar branch format, it is
      a dumb HTTP server. Each published branch is associated with a Branch
      object in the Launchpad database. Branches are served as
      <tt>http://bazaar.launchpad.net/~owner/product/branch</tt>.
    </p>
    
    
      <ul>
        <li>
          <tt>owner</tt> is the string
          <tt>branch.owner.name</tt>.
        </li>
        
        <li>
          <tt>product</tt> is the string
          <tt>branch.product.name</tt>, or
          <tt>\"+junk\"</tt> if the branch is not associated with
          a Product.
        </li>
        
        <li>
          <tt>branch</tt> is the string
          <tt>branch.name</tt>.
        </li>
      </ul>
    
    
    <p>
      The URL where a branch is served changes when any of those values
      change: because the branch, product or owner's name attribute changes,
      or a branch gets associated with a different owner or product.
    </p>
    
    <p>
      The Supermirror filesystem hierarchy was designed to be indifferent to
      those renamings. Branches in the Warehouse are stored by database id.
      Specifically, if a branch's id is <tt>0x89ABCDEF</tt>, the
      branch is a directory whose path is of the form
      <tt>$base/89/ab/cd/ef</tt>.
    </p>
    
    <p>
      The mapping between filesystem names and URL is done by a
      <tt>mod_rewrite</tt> rule which is periodically updated from
      the Launchpad branch data.
    </p>
    
    <p>
      <strong>Relation: </strong>Branch Publisher serves branches stored
      in the Branch Warehouse.
    </p>
    
    <p>
      <strong>Relation: </strong>Branch Publisher reads Launchpad Branch
      details to rewrites public URLs requested by Bazaar clients into
      Warehouse filesystem names. Only branches with an associated Branch
      database record are published.
    </p>
    
    <p>
      <strong>Constraint: </strong>The public name of branches can change
      at any time.
    </p>
    
    <p>
      <strong>Constraint: </strong>The Supermirror filesystem hierarchy
      should be encapsulated. Launchpad branch ids must not be exposed to the
      user.
    </p>
    
    <p>
      <strong>Constraint: </strong>Branches stored in the Warehouse must
      be valid at all times. The only legal way to modify branch data in the
      Warehouse is using <tt>bzr push</tt>.
    </p>
    
    
      <h3>3.2. SFTP Server</h3>
    
    
    <p>
      The SFTP Server allows Launchpad users to host their branches on
      Launchpad. It is a custom SFTP server based on Twisted.
    </p>
    
    
      <div class="big-figure"><div class="figure-body"><img src="sftp-server.png" alt="sftp-server.png" /></div><div class="figure-caption"><b>Figure 7: </b>SFTP
      Server</div></div>
    
    
    <p>
      A user can log in using an SSH key whose public key is registered in
      Launchpad. Only paths of the form
      <tt>~owner/product/branch</tt> (as for the Branch Publisher)
      can be used, where <tt>owner</tt> identifies the user whose
      SSH keys are used for authentication. If <tt>owner</tt> is a
      team, the SSH keys of all members of the team can be used.
    </p>
    
    <p>
      <strong>Relation: </strong>SFTP Server asks Launchpad for team
      members and SSH public keys or users.
    </p>
    
    <p>
      The SFTP server writes to a private filesystem that uses the same layout
      as the Supermirror. The mapping from the virtual filesystem exposed by
      SFTP and the actual filesystem layout is performed during
      authentication. That makes the SFTP server robust against branch renames
      occurring concurrently to an SFTP session.
    </p>
    
    <p>
      <strong>Relation: </strong>SFTP Server asks Launchpad for name, id
      and product name of branches owned by a person and the teams it belongs
      to.
    </p>
    
    <p>
      Existing branches with a non-<tt>NULL</tt> URLs are pull
      branches. Their associated directories are inaccessible on the SFTP
      server. Branches with a <tt>NULL</tt> URL are push branches
      and are associated with writable directories. When a user tries to
      create a non-existent branch <tt>~owner/product/branch</tt>,
      and <tt>owner</tt> is the authenticated user or a team it
      belongs to, and the named product exists (or is
      <tt>+junk</tt>), a branch is automatically created in the
      Launchpad database with the given owner, product and name and with no
      title or description.
    </p>
    
    <p>
      <strong>Relation: </strong>SFTP creates Branch records in
      Launchpad.
    </p>
    
    <p>
      If a user tries to create a branch in a product that does not exist,
      <tt>bzr</tt> will fail when trying to create a branch in a
      directory that does not exist.
    </p>
    
    <p>
      <strong>Note. </strong>The SFTP Server is an untrusted world-facing
      system, it does not access the Launchpad database directly but goes
      through the AuthServer. In the future, the AuthServer will be renamed to
      reflect its role as an all-purposes internal XMLRPC server.
    </p>
    
    
      <h3>3.3. Branch Puller</h3>
    
    
    
      <div class="big-figure"><div class="figure-body"><img src="branch-puller.png" alt="branch-puller.png" /></div><div class="figure-caption"><b>Figure 8: </b>Branch
      Puller</div></div>
    
    
    
      <h4>3.3.1. Branch Puller and Launchpad</h4>
    
    
    <p>
      The Branch Puller is the component that writes to the Branch Warehouse.
      It processes two kinds of branches:
    </p>
    
    
      <ul>
        <li>
          Remote branches, from untrusted public servers on the
          internet, using URLs registered in the Launchpad database.
        </li>
        
        <li>
          SFTP branches, on the filesystem of the SFTP server, using
          the id of Launchpad branches without a URL.
        </li>
      </ul>
    
    
    <p>
      <strong>Relation: </strong>Branch Puller asks Launchpad for Branch
      ids and URLs.
    </p>
    
    <p>
      <strong>Relation: </strong>Branch Puller pulls
      <tt>bzr</tt> branches from the private SFTP Server
      filesystem and from public web spaces on the internet.
    </p>
    
    <p>
      At the time of writing (2005-01-31), the Branch Puller gets the list of
      branches to pull from the private Launchpad page
      <tt>/supermirror-pull-list.txt</tt>, formatted as a list of
      branch ids and URLs.
    </p>
    
    
      <h4>3.3.2. Branch Puller and Branch Warehouse</h4>
    
    
    <p>
      The Branch Puller writes directly to the id-based Branch Warehouse
      filesystem.
    </p>
    
    <p>
      It uses <tt>bzr get</tt> to create new branches in the
      Warehouse and <tt>bzr pull --overwrite</tt> to update
      existing branches. The use of <tt>bzr</tt> to copy the data
      ensures that only Bazaar branches that are well-formed enough to be
      checked out are published. Warez swappers would need to use
      <tt>bzr</tt> to be published, and blatantly corrupt branch
      data would not be published.
    </p>
    
    <p>
      <strong>Relation: </strong>Branch Puller writes sanitized branch
      data in the Branch Warehouse.
    </p>
    
    
      <h3>3.4. Branch Syncher</h3>
    
    
    <p>
      The Branch Syncher, also known as <tt>bzrsyncd</tt> (the
      user running the script) and <tt>update-branches.py</tt>
      (the name of script) updates the Launchpad tables that describe the
      summary history of branches published by the Supermirror. This metadata
      includes the revisions ids in the history of a branch, commit messages,
      committers, dates and ancestry relationships.
    </p>
    
    
      <div class="big-figure"><div class="figure-body"><img src="branch-syncher.png" alt="branch-syncher.png" /></div><div class="figure-caption"><b>Figure 9: </b>Branch
      Syncher</div></div>
    
    
    <p>
      <strong>Relation: </strong>Branch Syncher asks Launchpad for a list
      of branches to scan.
    </p>
    
    <p>
      <strong>Relation: </strong>Branch Syncher reads the
      revision-history and revision entries from published branches.
    </p>
    
    <p>
      The Branch Syncher does not access the Branch Warehouse directly.
      Instead it uses a special rewriting rule of the Branch Publisher that
      gives it access to branches by hexadecimal id but hides the details of
      the real filesystem layout.
    </p>
    
    <p>
      <strong>Relation: </strong>Branch Syncher updates the Revision,
      RevisionNumber, RevisionParent and RevisionAuthor tables in the
      Launchpad database.
    </p>
    
    <p>
      In particular, the Branch Syncher needs to be able to delete
      RevisionNumber records because the revision-history of a branch is not
      append-only. However, Revision and RevisionParent records are never
      deleted or modified.
    </p>
    
    <p>
      Since the published branches were sanitized by the Branch Puller, the
      Branch Syncher should not normally fail.
    </p>
    
    <p>
      This process is separate from the Branch Puller for two reasons:
    </p>
    
    
      <ul>
        <li>
          It needs database permissions, in particular
          <tt>DELETE</tt> permissions, which are not required by
          the Branch Puller, and the Branch Puller is considered compromised
          because it handles untrusted data and communicates directly with
          potentially hostile web servers.
        </li>
        
        <li>
          The Branch Puller and Branch Syncher were developed and
          deployed by different individuals. Keeping them separate prevents
          crossing responsibility boundaries.
        </li>
      </ul>
    
    
    
      <h3>3.5. RCS Importer</h3>
    
    
    <p>
      The RCS Importer creates and update Bazaar branches from the historical
      information available in third party version control systems. Currently,
      imports from CVS and Subversion are supported. It is also known as
      <tt>importd</tt>, and uses Buildbot and
      CSCVS.
    </p>
    
    
      <div class="big-figure"><div class="figure-body"><img src="rcs-importer.png" alt="rcs-importer.png" /></div><div class="figure-caption"><b>Figure 10: </b>RCS
      Importer</div></div>
    
    
    <p>
      This is the oldest component of the system, and predates Launchpad
      itself. It is still importing into <tt>baz</tt> branches and
      the transition to <tt>bzr</tt> is in progress. Over time, it
      has accumulated many design and implementation problems that prevent
      delivering a good quality of service and make maintenance painful.
    </p>
    
    <p>
      <strong>Relation: </strong>RCS Importer asks Launchpad for RCS to
      import from and branches to import into.
    </p>
    
    <p>
      <strong>Relation: </strong>RCS Importer gets and updates import
      status in Launchpad.
    </p>
    
    <p>
      <strong>Relation: </strong>RCS Importer retrieves version control
      history from remote repositories.
    </p>
    
    <p>
      <strong>Relation: </strong>RCS Importer publishes imported branches
      on the Supermirror.
    </p>
    
    <p>
      <strong>Relation: </strong>RCS Importer retrieves published
      branches from the Supermirror for rollback. Importd rollback is
      explained later.
    </p>
    
    <p>
      Historically, the role of the Branch Syncher was performed in the RCS
      Importer, by a component called Taxi. When the Launchpad database schema
      was updated to model Bazaar branch instead of Arch branches, Taxi was
      removed.
    </p>
    
    <p>
      RCS import is a very expensive and time consuming task that is bound on
      network, CPU and disk I/O at different times.
    </p>
    
    
      <ul>
        <li>
          It is network bound when checking out trees from remote RCS
          repositories, retrieving historical data from remote servers and
          publishing imports.
        </li>
        
        <li>
          It is CPU bound when synthesizing changesets from CVS log and
          when committing revisions.
        </li>
        
        <li>
          It is I/O bound when comitting revisions.
        </li>
      </ul>
    
    
    <p>
      The initial import of a branch can take up to several days if the source
      tree is large, the history is long, or the remote server is slow. These
      issues also tend to come in groups: projects with a large source tree
      often have a long history and an overloaded server, leading to initial
      imports taking up to several weeks.
    </p>
    
    
      <h4>3.5.1. Buildbot, Importd, and CSCVS</h4>
    
    
    <p>
      The components of the RCS Importer are Buildbot, Importd, and CSCVS.
    </p>
    
    <p>
      Buildbot is used as an infrastructure for Importd. It implements a
      master/slave architecture where a single master process (run on
      macquarie) sends tasks to several slave systems. Its roles are:
    </p>
    
    
      <ul>
        <li>
          Control conversion tasks, and automatically run periodic
          conversions.
        </li>
        
        <li>
          Spread tasks on multiple slave systems.
        </li>
        
        <li>
          Provide a web-accessible control panel, to manually start
          conversions and report historical conversion status and logs.
        </li>
      </ul>
    
    
    <p>
      Importd specializes Buildbot to:
    </p>
    
    
      <ul>
        <li>
          Load jobs from Launchpad.
        </li>
        
        <li>
          Prepare data and run CSCVS.
        </li>
        
        <li>
          Update the importstatus in Launchpad.
        </li>
        
        <li>
          Register and publish branches.
        </li>
        
        <li>
          Display jobs in Buildbot's web control panel.
        </li>
      </ul>
    
    
    <p>
      CSCVS is an independent system that performs the actual RCS conversion.
      Its roles are:
    </p>
    
    
      <ul>
        <li>
          Create initial Bazaar branches recording all the history of
          an upstream RCS.
        </li>
        
        <li>
          Update import branches for new commits in the upstream RCS.
        </li>
        
        <li>
          Check that imported source is consistent with source stored
          in the upstream RCS.
        </li>
      </ul>
    
    
    
      <h4>3.5.2. ProductSeries and Branches</h4>
    
    
    <p>
      The upstream RCS details required for an import are stored in the
      ProductSeries table. This table also stores details about the status of
      an import.
    </p>
    
    <p>
      <strong>Arch legacy: </strong>The ProductSeries targetarchsomething
      fields are used to record the Arch name of the import branch.
    </p>
    
    <p>
      When an the initial import of a RCS has succeeded and the branch is
      published, a corresponding Branch record must be created and linked from
      the branch field of the ProductSeries.
    </p>
    
    <p>
      <strong>Opinion: </strong>David Allouche thinks the coupling of RCS
      imports with ProductSeries is unecessary. Most of the time, users that
      want to get a RCS import do not care about ProductSeries and their
      baggage. Instead, RCS import details should be recorded in a separate
      table, and it should be possible associate a Branch and ProductSeries
      manually. This would require a specification.
    </p>
    
    
      <h4>3.5.3. Import Status</h4>
    
    
    <p>
      RCS imports have historically followed a workflow recorded by the
      <tt>importstatus</tt> field and a number of timestamps in
      the ProductSeries table. The state machine of
      <tt>importstatus</tt> is documented on
      <a href="https://wiki.launchpad.canonical.com/SourceSourceRefactoring">SourceSourceRefactoring</a>.
    </p>
    
    
      <div class="big-figure"><div class="figure-body"><img src="importstatus.png" alt="importstatus.png" /></div><div class="figure-caption"><b>Figure 11: </b>ProductSeries.importstatus</div></div>
    
    
    <p>
      Roomba and Hoover are two Importd instances, they are covered in depth
      in the following sections.
    </p>
    
    <p>
      The critical transition is the <em>manual review</em> between
      <tt>AUTOTESTED</tt> and <tt>PROCESSING</tt>.
      This manual review is needed for a few reasons:
    </p>
    
    
      <ul>
        <li>
          As policy, the RCS import service is only provided for
          products for which a reasonably good product description was
          created. It is the reponsibility of the Launchpad administrator to
          communicate with the user to get a better description if needed and
          mark the product as reviewed.
        </li>
        
        <li>
          To perform an import that can published, we need to allocate
          a Arch namespace. To help keep the namespace used for imports
          vaguely organised, and prevent conflicts, namespace allocation was
          done by Buttsource administrators.
        </li>
      </ul>
    
    
    <p>
      <strong>Arch legacy: </strong>The second point is no longer
      relevant with Bazaar, misnamed branches with useless data can be
      published, renamed, and removed without problem.
    </p>
    
    
      <h4>3.5.4. Roomba and Hoover</h4>
    
    
    <p>
      <em>Roomba</em> and <em>Hoover</em> are two Importd instances that use
      separate slave systems. That separation was required so large numbers of
      lengthy test imports could be run without blocking daily updates of
      syncing imports. Buildbot scheduling is not flexible enough to meet this
      goal with a single instance.
    </p>
    
    <p>
      <strong>Arch legacy: </strong>This separation was useful for
      privilege separation: the Roomba slaves do not (should not?) have the
      SFTP key to publish branches or the privileges for Taxi to write
      revision information to the database. The only information coming out of
      test imports is status changes in ProductSeries effected by the Buildbot
      master. That helped guarantee that no branch would leak out before being
      validated by a Buttsource administrator.
    </p>
    
    
      <div class="big-figure"><div class="figure-body"><img src="importd-deployment.png" alt="importd-deployment.png" /></div><div class="figure-caption"><b>Figure 12: </b>Importd
      deployment</div></div>
    
    
    <p>
      The elements in gray in the Importd deployment diagram represent the way
      branches were historically published: they were uploaded to
      <tt>bazaar.ubuntu.com</tt>, where the Arch Supermirror
      automatically registered and published them.
    </p>
    
    <p>
      Communication with the Launchpad database is not represented on this
      diagram. Only macquarie, galapagos and neumayer access the database.
      Macquarie so the Botmasters can load jobs and update import status in
      ProductSeries. Galapagos and Neumayer so Taxi could create Branch and
      Revision records.
    </p>
    
    <p>
      The Roomba and Hoover botmaster each expose a web user interface to
      monitor import progress, examine past logs, initiate manual builds, and
      reload the job list.
    </p>
    
    
      <h4>3.5.5. Import Validation</h4>
    
    
    <p>
      Before publishing an imported branch, the source contents of the latest
      imported revision are compared to the source retrieved from the Upstream
      RCS at the start of the import. Deviations in the imported history are
      tolerated as it is impossible to retrieve past full tree revision from
      CVS in the general case.
    </p>
    
    <p>
      <strong>Open issue: </strong>Better sanity checking could be
      performed. On CVS, comparison of annotated source could be reliably
      implemented. On Subversion it is generally possible to retrieve past
      full tree revisions.
    </p>
    
    
      <h4>3.5.6. Import Workflow</h4>
    
    
    <p>
      The workflow of an import starts by a user setting up RCS details in
      Launchpad, and ends by the registration and publication of the import
      branch. The following diagram illustrates the simplest set of
      interactions in that workflow, in the case where no failure
      occurs.
    </p>
    
    
      <div class="big-figure"><div class="figure-body"><img src="import-workflow.png" alt="import-workflow.png" /></div><div class="figure-caption"><b>Figure 13: </b>Import
      workflow</div></div>
    
    
    <p>
      First the User sets up RCS details in Launchpad. That sets the
      <tt>importstatus</tt> of the ProductSeries to
      <tt>TESTING</tt>. Then nothing happens until Roomba is
      ``reloaded''.
    </p>
    
    <p>
      The operator must ``reload'' Roomba by posting a form in the Buildbot
      web UI. This will update the job list from the database. Only
      ProductSeries that are <tt>TESTING</tt> or
      <tt>TESTFAILED</tt> create Roomba jobs. Jobs in
      <tt>TESTING</tt> state are started automatically shortly
      after reloading. When the Roomba job succeeds, the ProductSeries is set
      to <tt>AUTOTESTED</tt> and awaits human review.
    </p>
    
    <p>
      <strong>Arch legacy: </strong>If a ProductSeries does not specify
      the <tt>targetarchsomething</tt> fields, the Arch branch
      name is automatically generated. The automatic branch name generation
      sometimes produces invalid names, causing autotest jobs to never succeed
      unless debugged, but that will no longer a problem with Bazaar.
    </p>
    
    <p>
      The operator must also periodically review ProductSeries that have
      passed autotest. Launchpad provides a user interface at
      <tt>https://launchpad.net/bazaar/series</tt> to easily view
      all the ProductSeries with a given <tt>importstatus</tt>
      value. After a number of clicks, the occasional editorial work,
      sometimes chatting with the User to ask for clarifications or
      improvements in the product description, the Product is marked as
      ``reviewed'' in the <tt>$product/+review</tt> form and the
      ProductSeries is set to <tt>PROCESSING</tt> in the
      <tt>$series/+sourceadmin</tt> form.
    </p>
    
    <p>
      <strong>Arch legacy: </strong>This review step was the point where
      a Buttsource administrator was required to attribute Canonical branch
      name to the import branch.
    </p>
    
    <p>
      Then the operator must ~reload Hoover to create the job for the newly
      approved import. When the initial import completes, the
      <tt>importstatus</tt> is set to <tt>SYNCING</tt>
      and an entirely distasteful hack is used to update the job in place
      without having to wait for a manual reload, and to immediately start the
      initial sync job. At the end of the sync job, the Branch record is
      created in Launchpad and the import branch is published.
    </p>
    
    <p>
      <strong>Arch legacy: </strong>The initial import starts from
      scratch, so a branch had to be fully imported twice before being
      published: once in Roomba and once on Hoover. That was necessary with
      Arch since the branch name generally changed during the review step.
    </p>
    
    <p>
      That could obviously use some streamlining, and I have not even
      mentioned the work required when one of the jobs fails.
    </p>
    
    <p>
      <strong>Open issue: </strong>A Launchpag bug exists related to the
      support of the <tt>importstatus</tt> workflow in the
      Launchpad user interface: <a href="https://launchpad.net/products/launchpad/+bug/378">bug
      378</a>.
      It was partially and incorrectly implemented: it is currently entirely
      impossible (even for a Buttsource member) to update the RCS import
      details for a ProductSeries whose status is
      <tt>SYNCING</tt>. However it is possible to update those
      details by direct database manipulation as the
      <tt>importd</tt> user.
    </p>
    
    
      <h4>3.5.7. Importd Rollback</h4>
    
    
    <p>
      When an import fails (and many of them fail, eventually), the Upstream
      RCS checkout and the partially converted branch are left in place to
      allow diagnosing the failure.
    </p>
    
    <p>
      Some conversion errors are detected only after committing an incorrect
      revision: for example a later revision attempts to patch an non-existing
      file, or the error is is only detected at validation time. After CSCVS
      is fixed to correct the error, Importd needs to ``rollback'': revert the
      branch to a previous known-good state. There are three different cases
      of rollback:
    </p>
    
    
      <dl>
        <dt>Import</dt><dd>
          An import starts from scratch, the branch
          where the conversion will be published must not exist yet.
        </dd>
        
        <dt>Sync</dt><dd>
          A sync starts from the currently published
          branch. The branch must already be published.
        </dd>
        
        <dt>Initial sync</dt><dd>
          Since branches are published on
          sync, the initial sync cannot rollback. Instead, it will update the
          branch produced by the import step. The initial sync is not allowed
          to fail, if it does, the <tt>importstatus</tt> must be
          manually reverted to <tt>PROCESSING</tt> and the import
          must be restarted.
        </dd>
      </dl>
    
    
    <p>
      <strong>Open issue: </strong>An import branch is only published
      after the initial sync. If the initial sync fails, the subsequent sync
      has no published branch data to rollback to, and all subsequent syncs
      will fail, or worse, the branch will eventually be published with known
      bad data. Branch should be published after Import.
    </p>
    
    
      <h4>3.5.8. Persistent CSCVS Data</h4>
    
    
    <p>
      Running a CSCVS sync on a system without local data involves a few
      steps:
    </p>
    
    
      <ul>
        <li>
          Get a copy of the target Bazaar branch from the publication
          site.
        </li>
        
        <li>
          Checkout the Upstream RCS branch.
        </li>
        
        <li>
          Build the CSCVS cache. That is the part where CSCVS does dark
          magic to conjure changesets out of a CVS log.
        </li>
        
        <li>
          Commit the missing changesets to the Bazaar branch.
        </li>
        
        <li>
          Validate the import by comparing the final Bazaar branch to
          the Upstream RCS checkout.
        </li>
      </ul>
    
    
    <p>
      The Upstream RCS checkout and, in particular, the CSCVS cache build are
      expensive tasks whose cost is independent of the amount of new changes,
      but dependent on the tree size and history size. They are optimized by
      updating the Upstream RCS checkout (for example with <tt>cvs
      up</tt>) and the cache (with the appropriate
      <tt>cscvs</tt> invocation) when they are available.
    </p>
    
    
      <h4>3.5.9. The Split Changeset Bug</h4>
    
    
    <p>
      Preserving the CSCVS cache is not just an optimisation, it is also
      required to work around a CSCVS bug.
    </p>
    
    <p>
      CSCVS identifies CVS changesets with a sequential id and creates them by
      grouping related commits from the same user, with the same message, and
      occuring within a short time period. When a sync occurs concurrently to
      a group of related CVS commits, the part of the commit group that is
      completed at the time of the sync is interpreted as a changeset, and the
      rest of group is interpreted as a separate changeset on the next sync. I
      will call this situation a ``split changeset''.
    </p>
    
    <p>
      If the cache is generated from scratch at a later date, the changeset is
      properly grouped in the cache. But since the split changeset was
      imported in two commits by the previous syncs, all subsequent changesets
      do not have matching ids in the branch and in the cache. If there was
      one split commit, the first new changeset to import has, in the cache,
      the id of the last committed changeset in the branch, so the first new
      changeset is not imported.
    </p>
    
    <p>
      In principle it should be possible to ignore recent commits that may be
      grouped with future commits, but David Allouche looked at the problem in
      the past and was unable to understand how changesets where generated.
    </p>
    
    <p>
      Regardless, it is almost certain that several import branches now
      contain such split changesets. So being able to delete the CSCVS cache
      would require a way to deal with existing split changesets, just
      preventing the creation of new ones would not be sufficient.
    </p>
    
    <p>
      Publishing split changesets is not a big problem in itself, so this
      fixing this bug needs not be a high priority.
    </p>
    
    
      <h4>3.5.10. The Renaming Bug</h4>
    
    
    <p>
      Importd spreads jobs on slaves by hashing the job name, which is of the
      form <tt>[<i>project</i>-]<i>product</i>-<i>series</i></tt>. Since projects, products and
      series can be renamed, and their associations can change, the slave
      assigned to a RCS import job can change.
    </p>
    
    <p>
      Because of the Split Changest Bug, we need to transport the CSCVS cache
      when migrating a job between slaves. Since we do not know what was the
      previous name of a job, we do not know which slave to download and
      remove this data from. In the current situation, supporting job
      migration would require maintaining a central repository of CSCVS caches
      and updating it with <tt>rsync</tt> after each import or
      sync. Ensuring Arch namespace consistency would also have required the
      local master archive to be migrated. This functionality is not
      implemented, therefore job migration requires careful manual operation.
    </p>
    
    <p>
      Since job migration would currently require manual operation some
      ``undocumented features'' in Importd, related to Arch archive
      registration, have not been fixed since they effectively provide early
      failure in the cases where a manual job migration needs to be done.
    </p>
    
    <p>
      This the reason why renaming or reassociating
      ProductSeries associated with a RCS import are strongly discouraged.
      They generally break the RCS import.
    </p>
    
    
      <h3>3.6. RCS Importer Transition to Bazaar</h3>
    
    
    
      <p class="dark-red">
          <strong>Todo: </strong>Document tools that have been
          implemented for the bzr transition so far.
        </p>
    
    
    
      <h2>4. Future Plans and Open Issues</h2>
    
    
    
      <h3>4.1. Branch Puller's Future</h3>
    
    
    <p>
      <strong>Open issue: </strong>The Bazaar branch data on remote
      branches and on the SFTP server can be altered in essentially arbitrary
      ways. A branch can be replaced by a completely unrelated branch. More
      practically, branches can be altered to remove ``Nuclear Launch Codes'',
      ``Nuclear Waste'' and garbage revisions that are not part of the
      branch's ancestry. However, although <tt>bzr pull
      --overwrite</tt> treats the revision-history as rewritable, it
      treats the store as append only. The Branch Puller would need explicit
      support to allow users to remove Nuclear Launch Codes and Nuclear Waste
      from their branch on the Supermirror.
    </p>
    
    
      <h4>4.1.1. Future Plan: Launchpad Reporting</h4>
    
    
    <p>
      The Branch Puller should be able to store reporting information in
      Launchpad. The information that would be useful to store include:
    </p>
    
    
      <ul>
        <li>
          Date of latest successful pull.
        </li>
        
        <li>
          Date of latest pull attempt.
        </li>
        
        <li>
          Success status of the latest pull attempt.
        </li>
        
        <li>
          Diagnostic data for the latest pull attempt if it was a
          failure. In the simplest case, that could be a simple Python
          backtrace.
        </li>
      </ul>
    
    
    <p>
      Internal system failures, like failed communication with Launchpad, may
      be reported to the <tt>launchpad-error-reports</tt> mailing
      list and not recorded in the database.
    </p>
    
    <p>
      Normal pull failures should also be reported to the mailing list to
      allow fast response to users. That would allow James Blackwell to notice
      that an interesting new branch is failing and to contact the branch
      owner directly to fix the problem.
    </p>
    
    <p>
      Steve Alexander suggests that pull failures and internal system failures
      be reported using the OOPS system.
    </p>
    
    <p>
      This error reporting is mentioned as the
      <tt>branchPulled</tt> XMLRPC call in
      <a href="https://wiki.launchpad.canonical.com/SupermirrorXmlRpc">SupermirrorXmlRpc</a>
      and
      <a href="https://wiki.launchpad.canonical.com/BranchXmlRpc">BranchXmlRpc</a>,
      and as an open issue on
      <a href="https://wiki.launchpad.canonical.com/BazaarTaskList">BazaarTaskList</a>.
    </p>
    
    <p>
      <strong>Relation: </strong>Branch Pullers stores status reports in
      Launchpad.
    </p>
    
    
      <h4>4.1.2. Future Plan: Ignore Expected Failures</h4>
    
    
    <p>
      In normal usage, some branches are not worth trying to pull. Mainly,
      restricted branches like those stored on
      <tt>sftp://chinstrap.ubuntu.com/</tt>, but also blatantly
      incorrect branches, like those pointing to a Subversion repository.
    </p>
    
    <p>
      Those branches are characterized by pull attempts that are never
      successful. The details of how the successive failures are counted, and
      how they affect pull frequency, are still a bit uncertain. Eventually, a
      branch that is never successfully pulled will no longer be attempted.
      Otherwise error reports would quickly be drowned in expected failures.
    </p>
    
    <p>
      This is mentioned as an open issue on
      <a href="https://wiki.launchpad.canonical.com/BazaarTaskList">BazaarTaskList</a>.
    </p>
    
    
      <h4>4.1.3. Future Plan: Pull Now</h4>
    
    
    <p>
      Daniel registered a <tt>bzr</tt> branch of
      <tt>gedit</tt> to support MoinMoin syntax highlighting, then
      he comes back a couple of weeks later to find that his branch was never
      successfully pulled: all attempts failed with a 403 HTTP error because
      there was a bug in the <tt>.htaccess</tt> file on his
      webspace. In the meantime, all the pull attempts on that branch have
      failed and it was classified as an expected failure. Daniel fixes the
      <tt>.htaccess</tt> setting, requests a new pull attempt, and
      monitors the outcome of the pull.
    </p>
    
    <p>
      Henry has a branch of <tt>gnome-panel</tt> that preserves
      layout when changing the screen resolution. He publishes it using the
      Launchpad SFTP Server. Immediately after publishing he goes on the
      <tt>#gnome-devel</tt> IRC chat room to ask people to look at
      the fix and gives the URL of his branch page:
      <tt>https://launcphad.net/people/henry/+branches/gnome-panel/layout-bugfix</tt>.
      A GNOME developer commit want to review the changes, looks at the page
      and sees that a pull is pending, then waits until the pull is complete
      to merge that branch into a fresh import of mainline and review the
      changes.
    </p>
    
    <p>
      Both those use cases require some new functionality:
    </p>
    
    
      <ul>
        <li>
          Requesting an immediate branch pull through the Launchpad UI
          or through the SFTP Server.
        </li>
        
        <li>
          Feedback in the Launchpad UI when a pull is in progress.
        </li>
      </ul>
    
    
    <p>
      Part of this functionality is addressed in
      <a href="https://wiki.launchpad.canonical.com/SupermirrorXmlRpc">SupermirrorXmlRpc</a>
      and
      <a href="https://wiki.launchpad.canonical.com/BranchXmlRpc">BranchXmlRpc</a>.
    </p>
    
    
      <h4>4.1.4. Future Plan: Concurrent Tasks</h4>
    
    
    <p>
      Pulling a branch is a network-bound task that can take a long time. It
      can also be CPU intensive in some cases.
    </p>
    
    <p>
      To allow pull-now requests to be handled quickly, it would be necessary
      to implement the Branch Puller as a service, as opposed to a
      <tt>cron</tt> job, which would be able to schedule tasks in
      a flexible way. Long running tasks should not prevent new tasks from
      running.
    </p>
    
    <p>
      This needs to be taken in account in the design of
      <a href="https://wiki.launchpad.canonical.com/ImportdRefactoring">Buildd-NG</a>.
    </p>
    
    
      <h3>4.2. Branch Syncher's Future</h3>
    
    
    
      <h4>4.2.1. Future Plan: Launchpad Reporting</h4>
    
    
    <p>
      The date of the latest successful synch should be displayed in the
      Launchpad UI to explain that the displayed branch details might be out
      of date.
    </p>
    
    
      <h4>4.2.2. Future plan: Sync Now</h4>
    
    
    <p>
      The Branch Puller should be able to report when a branch on the
      Supermirror has changed and needs to be scanned again. Currently, all
      branches are scanned periodically by a <tt>cron</tt> job.
      This takes a significant time (one hour as of 2005-01-31), so synching
      is done every two hour.
    </p>
    
    <p>
      Marking branches that needs to be synched allows reducing the run time
      of a synching batch, increasing the frequency of the periodic job,
      therefore reducing the latency in the common case.
    </p>
    
    <p>
      The ``branch changed'' information would be set by the
      <tt>branchPulled</tt> XMLRPC call described in
      <a href="https://wiki.launchpad.canonical.com/SupermirrorXmlRpc">SupermirrorXmlRpc</a>
      and
      <a href="https://wiki.launchpad.canonical.com/BranchXmlRpc">BranchXmlRpc</a>.
    </p>
    
    
      <h4>4.2.3. Future Plan: Concurrent Tasks</h4>
    
    
    <p>
      The Branch Syncher needs to traverse the complete ancestry of branches
      so old revisions can be created in the database in response to ghost
      filling in a Supermirror branch. This process is database-bound and can
      take a significant amount of time (probably several tens of minutes for
      very large branches).
    </p>
    
    <p>
      To allow sync-now requests to be handled quickly, it would be necessary
      to implement the Branch Syncher as a service with flexible scheduling
      abilities. Long running tasks should not prevent new tasks from running.
    </p>
    
    <p>
      This needs to be taken in account in the design of
      <a href="https://wiki.launchpad.canonical.com/ImportdRefactoring">Buildd-NG</a>.
    </p>
    
    
      <h3>4.3. RCS Importer's Future</h3>
    
    
    
      <p class="dark-red">
          <strong>Todo: </strong>Flesh out this section.
        </p>
    
    
    <p>
      <strong>Open issue: </strong>Number of sync failures.
    </p>
    
    <p>
      <strong>Open issue: </strong>Failure triage.
    </p>
    
    <p>
      <strong>Open issue: </strong>Workflow of new imports, removing
      review step?
    </p>
    
    <p>
      <strong>Open issue: </strong>Restarting imports.
    </p>
  </body></html>
  
  
  
  
  
  

