= ExternalBugTracker: Mantis =

This covers the implementation of the Mantis bug watch updater.


== Basics ==

The class that implements ExternalBugTracker for Mantis is called,
surprisingly, Mantis! It doesn't do any version probing and simply
stores a base URL which it will use to construct URLs to pull a CSV
export from.

    >>> from canonical.launchpad.components.externalbugtracker import Mantis
    >>> alsa_mantis = Mantis("https://bugtrack.alsa-project.org/alsa-bug/")

As with all ExternalBugTrackers, Mantis contains a function for converting one
of its own status to a Malone status. Mantis' function takes a string
in the form "status" or "status: resolution" as follows:

    >>> alsa_mantis.convertRemoteStatus('assigned').title
    'In Progress'
    >>> alsa_mantis.convertRemoteStatus("resolved: won't fix").title
    "Won't Fix"
    >>> alsa_mantis.convertRemoteStatus('confirmed').title
    'Confirmed'
    >>> alsa_mantis.convertRemoteStatus('closed: suspended').title
    'Invalid'
    >>> alsa_mantis.convertRemoteStatus('closed: fixed').title
    'Fix Released'

If the status can't be converted, Unknown is returned, and a warning
is logged.

    >>> alsa_mantis.convertRemoteStatus(('foo: bar')).title
    WARNING:...:Unknown status/resolution foo/bar
    'Unknown'

UNKNOWN_REMOTE_STATUS maps to Unknown without generating a warning.

    >>> from canonical.launchpad.interfaces import UNKNOWN_REMOTE_STATUS
    >>> alsa_mantis.convertRemoteStatus(UNKNOWN_REMOTE_STATUS).title
    'Unknown'


== Updating Bug Watches ==

Let's set up a BugTracker and some watches for the Example.com Bug
Tracker:

    >>> from canonical.launchpad.database import BugTracker
    >>> from canonical.launchpad.interfaces import IBugSet, IPersonSet
    >>> from canonical.launchpad.ftests.externalbugtracker import TestMantis
    >>> from canonical.lp.dbschema import BugTrackerType

    >>> sample_person = getUtility(IPersonSet).getByEmail('test@canonical.com')

    >>> example_bug_tracker = BugTracker(
    ...     name="example-bugs",
    ...     title="Example.com Bug Tracker",
    ...     bugtrackertype=BugTrackerType.MANTIS,
    ...     baseurl="http://bugs.example.com/",
    ...     summary="Contains bugs for Example.com",
    ...     contactdetails="foo.bar@example.com",
    ...     owner=sample_person)

    >>> login('foo.bar@canonical.com')

    >>> example_bug = getUtility(IBugSet).get(10)
    >>> example_bugwatch = example_bug.addWatch(
    ...     example_bug_tracker, 3224, sample_person)

    >>> login('no-priv@canonical.com')

We use a specially hacked Mantis instance that doesn't do network
calls to verify here:

    >>> example_ext_bug_tracker = TestMantis(example_bug_tracker.baseurl)

Collect the Example.com watches:

    >>> for bug_watch in example_bug_tracker.watches:
    ...     print "%s: %s" % (bug_watch.remotebug, bug_watch.remotestatus)
    3224: None

And have our special Mantis instance process them:

    >>> example_ext_bug_tracker.updateBugWatches(example_bug_tracker.watches)
    >>> for bug_watch in example_bug_tracker.watches:
    ...     print "%s: %s" % (bug_watch.remotebug, bug_watch.remotestatus)
    3224: assigned: open

Let's add a few more watches:

    >>> from canonical.launchpad.interfaces import IBugSet, IBugWatchSet

    >>> bug_watch_set = getUtility(IBugWatchSet)
    >>> expected_remote_statuses = dict(
    ...     (int(bug_watch.remotebug), bug_watch.remotestatus)
    ...     for bug_watch in example_bug_tracker.watches)

    >>> expected_remote_statuses
    {3224: u'assigned: open'}

    >>> remote_bugs = [
    ...     (7346, dict(status='assigned', resolution='open')),
    ...     (6685, dict(status='new', resolution='open')),
    ...     (8104, dict(status='assigned', resolution='open')),
    ...     (6919, dict(status='assigned', resolution='open')),
    ...     (8006, dict(status='resolved', resolution='no change required')),
    ... ]

    >>> for remote_bug_id, remote_bug in remote_bugs:
    ...     bug_watch = bug_watch_set.createBugWatch(
    ...         bug=example_bug, owner=sample_person,
    ...         bugtracker=example_bug_tracker,
    ...         remotebug=str(remote_bug_id))
    ...     example_ext_bug_tracker.bugs[remote_bug_id] = remote_bug
    ...     expected_remote_statuses[remote_bug_id] = (
    ...         "%s: %s" % (remote_bug['status'], remote_bug['resolution']))

Instead of issuing one request per bug watch, like was done before,
updateBugWatches() issues only one request to update all watches:

    >>> example_ext_bug_tracker.trace_calls = True
    >>> example_ext_bug_tracker.updateBugWatches(example_bug_tracker.watches)
    CALLED _getPage('login.php?username=guest&password=guest')
    CALLED _getPage('login_anon.php')
    CALLED _postPage('view_all_set.php?f=3', ...)
    CALLED _getPage('csv_export.php')

    >>> remote_statuses = dict(
    ...     (int(bug_watch.remotebug), bug_watch.remotestatus)
    ...     for bug_watch in example_bug_tracker.watches)
    >>> remote_statuses == expected_remote_statuses
    True

    >>> example_ext_bug_tracker.trace_calls = False

updateBugWatches() updates the lastchecked attribute on the watches, so
now no bug watches are in need of updating:

    >>> from canonical.database.sqlbase import flush_database_updates
    >>> flush_database_updates()
    >>> example_bug_tracker.getBugWatchesNeedingUpdate(23).count()
    0

If the status isn't different, the lastchanged attribute doesn't get
updated:

    >>> import pytz
    >>> from datetime import datetime, timedelta
    >>> bug_watch = example_bug_tracker.watches[0]
    >>> now = datetime.now(pytz.timezone('UTC'))
    >>> bug_watch.lastchanged = now - timedelta(weeks=2)
    >>> old_last_changed = bug_watch.lastchanged
    >>> example_ext_bug_tracker.updateBugWatches([bug_watch])
    >>> bug_watch.lastchanged == old_last_changed
    True

XXX: Don't understand from here on...

Now let's take a look at what happens when a bug watch is linked to
from a bug task.

    >>> login('foo.bar@canonical.com')
    >>> bug_nine = getUtility(IBugSet).get(9)
    >>> thunderbird_task = bug_nine.bugtasks[0]
    >>> print thunderbird_task.status.title
    Unknown
    >>> thunderbird_task.bugwatch.remotestatus is None
    True

We don't yet support updating the importance for Bugzilla bugs, so let's set it
to some bogus value, to see that it gets set to UNKNOWN.

    >>> from canonical.lp.dbschema import BugTaskImportance
    >>> thunderbird_task.importance = BugTaskImportance.HIGH

We need to create a new ExternalBugtracker for the Mozilla tracker:

    >>> from canonical.launchpad.interfaces import IBugTrackerSet
    >>> mozilla_bugzilla = getUtility(IBugTrackerSet).getByName(
    ...     'mozilla.org')
    >>> example_ext_bug_tracker = TestMantis(
    ...     mozilla_bugzilla.baseurl, version)
    >>> example_ext_bug_tracker.bugzilla_bugs = {1234: ('ASSIGNED', '')}

Let's update the bug watch, and see that the linked bug watch got
synced:

    >>> example_ext_bug_tracker.updateBugWatches([thunderbird_task.bugwatch])
    >>> print thunderbird_task.status.title
    In Progress
    >>> print thunderbird_task.importance.title
    Unknown
    >>> print thunderbird_task.bugwatch.remotestatus
    ASSIGNED

If we change the bugtask status, it will be updated again even though
the remote status hasn't changed. This can happen if we change the
status mapping.

    >>> from canonical.lp.dbschema import BugTaskStatus
    >>> thunderbird_task.transitionToStatus(BugTaskStatus.CONFIRMED)
    >>> example_ext_bug_tracker.updateBugWatches([thunderbird_task.bugwatch])
    >>> print thunderbird_task.status.title
    In Progress
    >>> print thunderbird_task.bugwatch.remotestatus
    ASSIGNED

If there are two bug watches, linked to different bugs, pointing to the
same remote bug, both will of course be updated.

    >>> example_ext_bug_tracker.bugzilla_bugs[42] = ('RESOLVED', 'FIXED')
    >>> bug_watch1 = bug_watch_set.createBugWatch(
    ...     bug=example_bug, owner=sample_person, bugtracker=mozilla_bugzilla,
    ...     remotebug='42')
    >>> bug_two = getUtility(IBugSet).get(2)
    >>> bug_watch2 = bug_watch_set.createBugWatch(
    ...     bug=bug_two, owner=sample_person, bugtracker=mozilla_bugzilla,
    ...     remotebug='42')
    >>> example_ext_bug_tracker.updateBugWatches([bug_watch1, bug_watch2])
    >>> print bug_watch1.remotestatus
    RESOLVED FIXED
    >>> print bug_watch2.remotestatus
    RESOLVED FIXED

If updateBugWatches() can't parse the XML file returned from the remote
bug tracker, an error is logged.

    >>> example_ext_bug_tracker._postPage = (
    ...     lambda self, data: '<invalid xml>')
    >>> example_ext_bug_tracker.updateBugWatches(example_bug_tracker.watches)
    Traceback (most recent call last):
    ...
    UnparseableBugData:
    Failed to parse XML description for https://bugzilla.mozilla.org...

