= Launchpad Publication =

Launchpad uses the generic Zope3 publisher. It registers several
factories that are responsible for instantiating the appropriate
implementation of zope.publisher.IRequest and
zope.publisher.IPublication for the request.


== Virtual host configurations ==

The configuration defines a number of domains, one for the main
Launchpad site and one for the sites of the various applications.

    >>> from canonical.config import config
    >>> config.launchpad.vhosts.mainsite.hostname
    'launchpad.dev'
    >>> config.launchpad.vhosts.blueprints.hostname
    'blueprints.launchpad.dev'

It also says whether we use http or https (although this setting can be
overridden for the root URL of a particular host).

    >>> config.launchpad.vhosts.use_https
    False

These are parsed into webapp.vhost.allvhosts.

    >>> from canonical.launchpad.webapp.vhosts import allvhosts
    >>> allvhosts.use_https
    False
    >>> for confname, vhost in sorted(allvhosts.configs.items()):
    ...     print confname, '@', vhost.hostname
    ...     print 'rooturl:', vhost.rooturl
    ...     print 'althosts:', (', '.join(vhost.althostnames))
    ...     print '----'
    answers @ answers.launchpad.dev
    rooturl: http://answers.launchpad.dev/
    althosts:
    ----
    blueprints @ blueprints.launchpad.dev
    rooturl: http://blueprints.launchpad.dev/
    althosts:
    ----
    bugs @ bugs.launchpad.dev
    rooturl: http://bugs.launchpad.dev/
    althosts:
    ----
    code @ code.launchpad.dev
    rooturl: http://code.launchpad.dev/
    althosts:
    ----
    feeds @ feeds.launchpad.dev
    rooturl: http://feeds.launchpad.dev/
    althosts:
    ----
    mainsite @ launchpad.dev
    rooturl: http://launchpad.dev/
    althosts: localhost
    ----
    openid @ openid.launchpad.dev
    rooturl: http://openid.launchpad.dev/
    althosts:
    ----
    shipitedubuntu @ shipit.edubuntu.dev
    rooturl: http://shipit.edubuntu.dev/
    althosts:
    ----
    shipitkubuntu @ shipit.kubuntu.dev
    rooturl: http://shipit.kubuntu.dev/
    althosts:
    ----
    shipitubuntu @ shipit.ubuntu.dev
    rooturl: http://shipit.ubuntu.dev/
    althosts:
    ----
    translations @ translations.launchpad.dev
    rooturl: http://translations.launchpad.dev/
    althosts:
    ----
    xmlrpc @ xmlrpc.launchpad.dev
    rooturl: http://launchpad.dev/
    althosts:
    ----
    xmlrpc_private @ xmlrpc-private.launchpad.dev
    rooturl: http://xmlrpc-private.launchpad.dev/
    althosts:
    ----

The hostnames and alternative hostnames for all virtual hosts are
collected into a set.  This provides a quick way to determine if a
request is headed to one of the officialy-used Launchpad host names:

    >>> for hostname in sorted(allvhosts.hostnames):
    ...     print hostname
    answers.launchpad.dev
    blueprints.launchpad.dev
    bugs.launchpad.dev
    code.launchpad.dev
    feeds.launchpad.dev
    launchpad.dev
    localhost
    openid.launchpad.dev
    shipit.edubuntu.dev
    shipit.kubuntu.dev
    shipit.ubuntu.dev
    translations.launchpad.dev
    xmlrpc-private.launchpad.dev
    xmlrpc.launchpad.dev


== VirtualHostRequestPublicationFactory ==

A number of VirtualHostRequestPublicationFactories are registered with
Zope to handle requests for a particular vhost, port, and set of HTTP
methods.

    >>> from cStringIO import StringIO
    >>> from canonical.launchpad.webapp.publication import (
    ...     LaunchpadBrowserPublication)
    >>> from canonical.launchpad.webapp.servers import (
    ...     LaunchpadBrowserRequest, VirtualHostRequestPublicationFactory)
    >>> from canonical.launchpad.webapp.testing import verifyObject
    >>> from zope.app.publication.interfaces import IRequestPublicationFactory

Those factories provide the IRequestPublicationFactory interface.

    >>> factory = VirtualHostRequestPublicationFactory(
    ...     'mainsite', LaunchpadBrowserRequest, LaunchpadBrowserPublication)
    >>> verifyObject(IRequestPublicationFactory, factory)
    True

By default, the request publication factory will only handle requests
to all the host names registered for a particular virtual host.

    >>> environment = {'REQUEST_METHOD': 'GET',
    ...                'HTTP_HOST': 'launchpad.dev'}
    >>> factory.canHandle(environment)
    True

A request publication factory that was initialized with
handle_default_host=True will handle a request that specifies no virtual
host. By default, handle_default_host is False.

    >>> environment = {'REQUEST_METHOD': 'GET',
    ...                'HTTP_HOST': ''}
    >>> factory.canHandle(environment)
    False

    >>> default_handling_factory = VirtualHostRequestPublicationFactory(
    ...    'mainsite', LaunchpadBrowserRequest, LaunchpadBrowserPublication,
    ...    handle_default_host=True)
    >>> default_handling_factory.canHandle(environment)
    True

By default, a request publication factory handles requests to any port
on its registered hosts.

    >>> environment = {'REQUEST_METHOD': 'GET',
    ...                'SERVER_PORT': '1234',
    ...                'HTTP_HOST': 'launchpad.dev'}
    >>> factory.canHandle(environment)
    True

It's a shortcoming of Zope that a request publication factory can only
consider aspects of the HTTP request when deciding whether or not to
handle the request (that is, in canHandle()). Our factories need to
consider the HTTP request when deciding what kind of publication and
request factory to send (that is, in __call__()). So we abuse
canHandle() by saving the environment to a thread-local variable. This
information is retrieved later on, in __call__().

    >>> for key, value in sorted(factory._thread_local.environment.items()):
    ...     print '%s: %s' % (key, value)
    HTTP_HOST: launchpad.dev
    REQUEST_METHOD: GET
    SERVER_PORT: 1234

When the request publication factory is called, it normally returns
the configured request and publication factories.

    >>> requestfactory, publicationfactory = factory()
    >>> publicationfactory
    <class 'canonical.launchpad.webapp.publication.LaunchpadBrowserPublication'>

Actually, the request factory is wrapped into an
ApplicationServerSettingRequestFactory that will on instantiation set
the base URL of the request to the virtual host configured settings.

    >>> type(requestfactory)
    <class 'canonical.launchpad.webapp.servers.ApplicationServerSettingRequestFactory'>
    >>> request = requestfactory(StringIO(''), environment)
    >>> type(request)
    <class 'canonical.launchpad.webapp.servers.LaunchpadBrowserRequest'>
    >>> request.getApplicationURL()
    'http://launchpad.dev'

A request publication factory will not handle requests unless they're
directed to one of its registered host names.

    >>> environment = {'REQUEST_METHOD': 'GET',
    ...                'HTTP_HOST': 'answers.launchpad.dev'}
    >>> factory.canHandle(environment)
    False

Calling the factory on a request it can't handle will result in an
error:

    >>> requestfactory, publicationfactory = factory()
    Traceback (most recent call last):
      ...
    AssertionError: This factory declined the request.

The factory accepts a port parameter that will restrict the handled
requests to request to a particular port.

    >>> factory = VirtualHostRequestPublicationFactory(
    ...     'mainsite', LaunchpadBrowserRequest, LaunchpadBrowserPublication,
    ...     port=1234)
    >>> environment = {'REQUEST_METHOD': 'GET',
    ...                'HTTP_HOST': 'launchpad.dev'}
    >>> factory.canHandle(environment)
    False
    >>> environment['SERVER_PORT'] = '80'
    >>> factory.canHandle(environment)
    False
    >>> environment['SERVER_PORT'] = '1234'
    >>> factory.canHandle(environment)
    True

The port is also checked for in the HTTP_HOST variable:

    >>> environment = {'REQUEST_METHOD': 'GET',
    ...                'HTTP_HOST': 'launchpad.dev:1234'}
    >>> factory.canHandle(environment)
    True
    >>> environment['HTTP_HOST'] = 'launchpad.dev:one_two_three_four'
    >>> factory.canHandle(environment)
    False

If the port is given twice (in SERVER_PORT and the Host header), and
the ports don't match, an AssertionError is the result. This prevents
sneaky outsiders from making requests to ports only exposed
internally.

    >>> environment = {'REQUEST_METHOD': 'GET',
    ...                'SERVER_PORT' : 1234,
    ...                'HTTP_HOST': 'launchpad.dev:80'}
    >>> factory.canHandle(environment)
    Traceback (most recent call last):
    ...
    AssertionError: Port specified in SERVER_PORT does not match
    port specified in HTTP_HOST

It's okay to specify the port in both places if the ports are the same:

    >>> environment = {'REQUEST_METHOD': 'GET',
    ...                'SERVER_PORT' : 1234,
    ...                'HTTP_HOST': 'launchpad.dev:1234'}
    >>> factory.canHandle(environment)
    True

The VirtualHostRequestPublicationFactory constructor also accepts a
`methods` parameter that restrict the set of allowed methods. This
doesn't affect canHandle, but it does affect which requests will make
the request publication factory return a
ProtocolErrorPublicationFactory when called. The
ProtocolErrorPublicationFactory is a parameterized object that
publishes a document describing a particular HTTP-level error.

    >>> environment = {'REQUEST_METHOD': 'DELETE',
    ...                'HTTP_HOST': 'launchpad.dev',
    ...                'SERVER_PORT' : '1234'}
    >>> factory.canHandle(environment)
    True

    >>> requestfactory, publicationfactory = factory()
    >>> publicationfactory
    <canonical.launchpad.webapp.servers.ProtocolErrorPublicationFactory ...>

    >>> factory = VirtualHostRequestPublicationFactory(
    ...     'mainsite', LaunchpadBrowserRequest, LaunchpadBrowserPublication,
    ...     methods=['DELETE'])
    >>> environment = {'REQUEST_METHOD': 'GET',
    ...                'HTTP_HOST': 'launchpad.dev'}
    >>> factory.canHandle(environment)
    True
    >>> requestfactory, publicationfactory = factory()
    >>> publicationfactory
    <canonical.launchpad.webapp.servers.ProtocolErrorPublicationFactory ...>

    >>> environment['REQUEST_METHOD'] = 'DELETE'
    >>> factory.canHandle(environment)
    True
    >>> requestfactory, publicationfactory = factory()
    >>> publicationfactory
    <class 'canonical.launchpad.webapp.publication.LaunchpadBrowserPublication'>


== Zope Publisher integration ==

A factory is registered for each of our available virtual host. This
is done by the register_launchpad_request_publication_factories
function called when the servers module is loaded.

(We need to call it here once again, because the test layer clears out
the registered factories.)

    >>> from canonical.launchpad.webapp.servers import (
    ...     register_launchpad_request_publication_factories)
    >>> register_launchpad_request_publication_factories()

    # Z3 doesn't make this available as a utility.
    >>> from zope.app.publication.requestpublicationregistry import (
    ...     factoryRegistry)

    # Defines an helper function that returns the appropriate
    # IRequest and IPublication.
    >>> def get_request_and_publication(host='localhost', port=None,
    ...                                 method='GET', mime_type='text/html',
    ...                                 in_stream=''):
    ...     environment = {'HTTP_HOST': host,
    ...                    'REQUEST_METHOD': method,
    ...                    'SERVER_PORT': port,
    ...                    'CONTENT_TYPE': mime_type}
    ...     launchpad_factory = factoryRegistry.lookup(
    ...         method, mime_type, environment)
    ...     request_factory, publication_factory = launchpad_factory()
    ...     request = request_factory(StringIO(in_stream), environment)
    ...     # Since Launchpad doesn't use ZODB, we use None here.
    ...     publication = publication_factory(None)
    ...     return request, publication

    >>> from canonical.launchpad.webapp.servers import ProtocolErrorPublication
    >>> def print_request_and_publication(host='localhost', port=None,
    ...                                   method='GET', mime_type='text/html'):
    ...     """Helper giving short names for the request and publication."""
    ...     request, publication = get_request_and_publication(
    ...         host, port, method, mime_type)
    ...     print type(request).__name__.split('.')[-1]
    ...     publication_classname = type(publication).__name__.split('.')[-1]
    ...     if isinstance(publication, ProtocolErrorPublication):
    ...         print "%s: status=%d" % (
    ...             publication_classname, publication.status)
    ...         for name, value in publication.headers.items():
    ...             print "  %s: %s" % (name, value)
    ...     else:
    ...         print publication_classname
    >>> print_request_and_publication('launchpad.dev')
    LaunchpadBrowserRequest
    MainLaunchpadPublication

    >>> print_request_and_publication('')
    LaunchpadBrowserRequest
    MainLaunchpadPublication

    >>> print_request_and_publication('launchpad.dev', method='DELETE')
    ProtocolErrorRequest
    ProtocolErrorPublication: status=405
      Allow: GET HEAD POST

    >>> print_request_and_publication('answers.launchpad.dev')
    AnswersBrowserRequest
    AnswersPublication

    >>> print_request_and_publication('blueprints.launchpad.dev')
    BlueprintBrowserRequest
    BlueprintPublication

    >>> print_request_and_publication('bugs.launchpad.dev')
    BugsBrowserRequest
    BugsPublication

    >>> print_request_and_publication('code.launchpad.dev')
    CodeBrowserRequest
    CodePublication

    >>> print_request_and_publication('feeds.launchpad.dev')
    FeedsBrowserRequest
    FeedsPublication

    >>> print_request_and_publication('openid.launchpad.dev')
    OpenIdBrowserRequest
    OpenIdPublication

    >>> print_request_and_publication('translations.launchpad.dev')
    TranslationsBrowserRequest
    TranslationsPublication

    >>> print_request_and_publication('shipit.ubuntu.dev')
    UbuntuShipItBrowserRequest
    ShipItPublication

    >>> print_request_and_publication('shipit.edubuntu.dev')
    EdubuntuShipItBrowserRequest
    ShipItPublication

    >>> print_request_and_publication('shipit.kubuntu.dev')
    KubuntuShipItBrowserRequest
    ShipItPublication

The XML-RPC RequestPublicationFactory only responds to POST requests,
and then only when the MIME type is text/xml.

    >>> print_request_and_publication(
    ...     'xmlrpc.launchpad.dev', method='POST', mime_type='text/xml')
    PublicXMLRPCRequest
    PublicXMLRPCPublication

    >>> print_request_and_publication(
    ...     'xmlrpc.launchpad.dev', method='GET')
    ProtocolErrorRequest
    ProtocolErrorPublication: status=405
      Allow: POST

    >>> print_request_and_publication(
    ...     'xmlrpc.launchpad.dev', method='POST', mime_type='application/xml')
    ProtocolErrorRequest
    ProtocolErrorPublication: status=415

The private XML-RPC server works just like the public one, but it only
listens on a particular port.

Find the port the Private XMLRPC service is listening on.

    >>> for server in config.servers:
    ...     if server.type == 'PrivateXMLRPC':
    ...         private_port = server.address[1]

    >>> print_request_and_publication(
    ...     'xmlrpc-private.launchpad.dev', method='POST',
    ...     mime_type='application/xml')
    ProtocolErrorRequest
    ProtocolErrorPublication: status=404

Try a normal request:

    >>> print_request_and_publication(
    ...     'xmlrpc-private.launchpad.dev', port=private_port, method='POST',
    ...     mime_type='text/xml')
    PrivateXMLRPCRequest
    PrivateXMLRPCPublication

A request to an unknown host results in a 404 error.

    >>> print_request_and_publication('nosuchhost.launchpad.dev')
    ProtocolErrorRequest
    ProtocolErrorPublication: status=404

A request that uses the wrong method results in a 405 error. I'm going
to temporarily bump up the log level so that the 405 error isn't
logged as an exception--that would make this test look less nice.

    >>> import logging
    >>> logger = logging.getLogger('SiteError')
    >>> old_level = logger.level
    >>> logger.setLevel(logging.CRITICAL)

    >>> logout()
    >>> print http("GET /foo/bar HTTP/1.1\n"
    ...            "Host: xmlrpc.launchpad.dev\n"
    ...            "X-zope-handle-errors: False")
    HTTP/1.1 405 Method Not Allowed
    Allow: POST
    ...
    Your request didn't fit the protocol expected by this server.
    ...

(A bit of cleanup so the test can continue:)

    >>> logger.setLevel(old_level)
    >>> login(ANONYMOUS)

== ILaunchpadBrowserApplicationRequest ==

All Launchpad requests provides the ILaunchpadBrowserApplicationRequest
interface. That interface is an extension of the zope standard
IBrowserApplicationRequest.

    >>> from canonical.launchpad.webapp.interfaces import (
    ...     ILaunchpadBrowserApplicationRequest)

    >>> request, publication = get_request_and_publication()
    >>> verifyObject(ILaunchpadBrowserApplicationRequest, request)
    True

== Handling form data using IBrowserFormNG ==

Submitted form data is available in the form_ng request attribute. This
is an object providing the IBrowserFormNG interface which offers two
methods to obtain form data. (Form data is also available through the
regular Zope3 form attribute using the dictionary interface.)

    >>> from canonical.launchpad.webapp.interfaces import IBrowserFormNG
    >>> verifyObject(IBrowserFormNG, request.form_ng)
    True

You can check the presence of an uploaded field using the regular
python 'in' operator.

    >>> from canonical.launchpad.webapp.servers import (
    ...     LaunchpadBrowserRequest)
    >>> from urllib import urlencode
    >>> environment = {'QUERY_STRING': urlencode({
    ...     'a_field': 'a_value',
    ...     'items_field': [1, 2, 3]}, doseq=True)}
    >>> request = LaunchpadBrowserRequest('', environment)
    >>> request.processInputs()

    >>> 'a_field' in request.form_ng
    True
    >>> 'another_field' in request.form_ng
    False

The advantage of the IBrowserFormNG API is that it offers methods that
checks the number of values you are expecting. The getOne() method
should be used when you expect only one value for the field.

    >>> request.form_ng.getOne('a_field')
    u'a_value'

UnexpectedFormData is raised if more than one value was submitted for
the field:

    >>> request.form_ng.getOne('items_field')
    Traceback (most recent call last):
      ...
    UnexpectedFormData:...

None is returned if the field wasn't submitted:

    >>> request.form_ng.getOne('another_field') is None
    True

You can provide a default value that is returned if the field wasn't
submitted:

    >>> request.form_ng.getOne('another_field', u'default')
    u'default'

The getAll() method should be used when you are expecting a list of
values.

    >>> request.form_ng.getAll('items_field')
    [u'1', u'2', u'3']

If only one value was submitted, it will still be returned as part of
a list:

    >>> request.form_ng.getAll('a_field')
    [u'a_value']

An empty list is returned when no value was submitted for the field:

    >>> request.form_ng.getAll('another_field')
    []

That method also accepts a default value that is to be returned when
no value was submitted with the field.

    >>> request.form_ng.getAll('another_field', [u'default'])
    [u'default']

All the submitted field names can be iterated over:

    >>> for name in sorted(request.form_ng):
    ...     print name
    a_field
    items_field


== Transaction Logging ==

The publication implementation is responsible for putting the name
of the logged in user in the transaction. (The afterCall() hook is
responsible for that part. In these examples, None is passed as the
published object, because the implementation doesn't make use of it.)

The user attribute is an empty string, when no user is logged in.

    >>> import transaction
    >>> txn = transaction.begin()
    >>> print request.principal
    None
    >>> request, publication = get_request_and_publication()
    >>> publication.afterCall(request, None)
    >>> txn.user
    ''

But if there is a logged in user, the transaction user attribute will
contains its ID (as well as an empty '/' path, which is a Zope artefact
allowing different authentication based on the traversed objects):

    >>> from canonical.launchpad.interfaces import IPersonSet
    >>> personset = getUtility(IPersonSet)
    >>> txn = transaction.begin()
    >>> foo_bar = personset.getByEmail('foo.bar@canonical.com')
    >>> foo_bar.id
    16
    >>> request.setPrincipal(foo_bar)
    >>> publication.afterCall(request, None)
    >>> print txn.user
     / 16


== Read-Only Requests ==

Our publication implementation make sure that requests supposed to be
read-only (GET and HEAD) don't change anything in the database.
(Actually, if the published method calls transaction.commit() itself,
that assumption won't hold.)

Again this is handled by the afterCall() publication hook.

For example, the following database modification will be automatically
reverted in a GET request.

    >>> from canonical.launchpad.ftests import syncUpdate

    >>> login('foo.bar@canonical.com')
    >>> txn = transaction.begin()
    >>> foo_bar = personset.getByEmail('foo.bar@canonical.com')
    >>> print foo_bar.city
    None
    >>> foo_bar.city = 'Montreal'
    >>> syncUpdate(foo_bar)

    >>> request, publication = get_request_and_publication(method='GET')
    >>> publication.afterCall(request, None)
    >>> publication.clearSQLOSCache()
    >>> txn = transaction.begin()
    >>> foo_bar = personset.getByEmail('foo.bar@canonical.com')
    >>> print foo_bar.city
    None

But not if the request uses POST, the changes will be preserved.

    >>> foo_bar.city = 'Montreal'
    >>> syncUpdate(foo_bar)

    >>> request, publication = get_request_and_publication(method='POST')
    >>> publication.afterCall(request, None)
    >>> publication.clearSQLOSCache()
    >>> txn = transaction.begin()
    >>> foo_bar = personset.getByEmail('foo.bar@canonical.com')
    >>> print foo_bar.city
    Montreal

== HEAD requests have empty body ==

The publication implementation also makes sure that no body is
returned as part of HEAD requests. (Again this is handled by the
afterCall() publication hook.)

    >>> txn = transaction.begin()
    >>> request, publication = get_request_and_publication(method='HEAD')
    >>> response = request.response
    >>> response.setResult('Content that will disappear.')
    >>> publication.afterCall(request, None)
    >>> request.response.consumeBody()
    ''

In other cases, like a GET, the body would be unchanged.

    >>> txn = transaction.begin()
    >>> request, publication = get_request_and_publication(method='GET')
    >>> response = request.response
    >>> response.setResult('Some boring content.')
    >>> publication.afterCall(request, None)
    >>> print request.response.consumeBody()
    Some boring content.
