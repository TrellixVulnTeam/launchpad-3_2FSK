= Archive View Classes and Pages =

Let's use Celso's PPA for the tests.

    >>> from canonical.launchpad.interfaces import IPersonSet
    >>> cprov = getUtility(IPersonSet).getByName('cprov')


== ArchiveView ==

The ArchiveView includes a few helper methods that make it easier to
display different types of archives (copy archives, ppas).

First let's create a copy archive:

    >>> from lp.registry.interfaces.distribution import (
    ...     IDistributionSet)
    >>> ubuntu = getUtility(IDistributionSet)['ubuntu']
    >>> copy_location = factory.makeCopyArchiveLocation(
    ...     distribution=ubuntu,
    ...     name="intrepid-security-rebuild")
    >>> copy_archive = copy_location.archive

And let's create two views to compare:

    >>> ppa_archive_view = create_initialized_view(cprov.archive,
    ...                                            name="+index")
    >>> copy_archive_view = create_initialized_view(copy_archive,
    ...                                             name="+index")

The ArchiveView includes an archive_url property that will return the
archive url if it is available (ie. an active archive that is not a copy)
and None otherwise:

    >>> print ppa_archive_view.archive_url
    http://ppa.launchpad.dev/cprov/ppa/ubuntu
    >>> print copy_archive_view.archive_url
    None

The ArchiveView includes an archive_label property that returns either
the string 'PPA' or 'Archive' depending on whether the archive is a PPA
(this is mainly for branding purposes):

    >>> print ppa_archive_view.archive_label
    PPA
    >>> print copy_archive_view.archive_label
    Archive

For convenience the ArchiveView also includes a build_counters property
that returns a dict of the build count summary for the archive:

    >>> print ppa_archive_view.build_counters
    {'failed': 1L, 'superseded': 0, 'total': 4L, ...

An ArchiveView also includes an easy way to get any
IPackageCopyRequest's associated with an archive:

    >>> package_copy_request = ubuntu.main_archive.requestPackageCopy(
    ...     copy_location, copy_archive.owner)
    >>> copy_archive_view.package_copy_requests.count()
    1
    >>> ppa_archive_view.package_copy_requests.count()
    0

An ArchiveView provides a helper method returning a simplified status
vocabulary for selecting a status filter:

    >>> for term in ppa_archive_view.simplified_status_vocabulary:
    ...     print term.title
    Published
    Superseded
    Any Status

An ArchiveView provides a helper method returning a distribution series
vocabulary for selecting a series filter:

    >>> for term in ppa_archive_view.series_vocabulary:
    ...     print term.title
    Any Series
    Breezy Badger Autotest
    Warty

An ArchiveView provides helpers to display the counts of source and
binary packages within the archive:

    >>> print ppa_archive_view.source_count_text
    3 source packages

    >>> print ppa_archive_view.binary_count_text
    3 binary packages

An ArchiveView provides a batched_sources property that can be used
to get the current batch of publishing records for an archive:

    >>> for publishing in ppa_archive_view.batched_sources:
    ...     print publishing.source_package_name
    cdrkit
    iceweasel
    pmount

The batched_sources property will also be filtered by distroseries when
appropriate:

    >>> filtered_view = create_initialized_view(
    ...     cprov.archive,
    ...     name="+index",
    ...     method='GET',
    ...     query_string='field.series_filter=warty')
    >>> for publishing in filtered_view.batched_sources:
    ...     print publishing.source_package_name
    iceweasel
    pmount


== ArchivePackageDeletionView ==

We use ArchivePackageDeletionView to provide the mechnisms used to
delete packages from a PPA via the UI.

This view is only accessible by users with 'launchpad.Edit' permission
in the archive, that would be only the PPA owner (or administrators of
the Team owning the PPA) and Launchpad administrators. See further
tests in pagetests/xx-delete-packages.txt.

We will use the PPA owner, Celso user, to satisfy the references
required for deleting packages.

    >>> login('celso.providelo@canonical.com')

Issuing a empty request we can inspect the internal attributes used to
build the page.

    >>> view = create_initialized_view(
    ...     cprov.archive, name="+delete-packages")

We query the available PUBLISHED sources and use them to build the
'selected_sources' widget.

    >>> [pub.id for pub in view.batched_sources]
    [27, 28, 29]

    >>> view.has_sources_for_display
    True

    >>> len(view.widgets.get('selected_sources').vocabulary)
    3

This view also provides package filtering by source package name, so
the user can refine the available options presented. By default all
available sources are presented with empty filter.

    >>> for pub in view.batched_sources:
    ...     print pub.displayname
    cdrkit 1.0 in breezy-autotest
    iceweasel 1.0 in warty
    pmount 0.1-1 in warty

Whatever is passed as 'name_filter' results in a corresponding set of
filtered results.

    >>> view = create_initialized_view(
    ...     cprov.archive, name="+delete-packages",
    ...     query_string="field.name_filter=pmount")

    >>> for pub in view.batched_sources:
    ...     print pub.displayname
    pmount 0.1-1 in warty

Similarly, the sources can be filtered by series:

    >>> view = create_initialized_view(
    ...     cprov.archive, name="+delete-packages",
    ...     query_string="field.series_filter=warty")

    >>> for pub in view.batched_sources:
    ...     print pub.displayname
    iceweasel 1.0 in warty
    pmount 0.1-1 in warty

The page also uses all the built in batching features:

    >>> view = create_initialized_view(
    ...     cprov.archive, name="+delete-packages",
    ...     query_string="field.series_filter=warty",
    ...     form={'batch': '1', 'start': '1'})

    >>> for pub in view.batched_sources:
    ...     print pub.displayname
    pmount 0.1-1 in warty

When submitted, deletions immediately take effect resulting in a page
which the available options already exclude the deleted items.

    >>> view = create_initialized_view(
    ...     cprov.archive, name="+delete-packages",
    ...     form={
    ...         'field.actions.delete': 'Delete Packages',
    ...         'field.name_filter': '',
    ...         'field.status_filter': 'any',
    ...         'field.deletion_comment': 'Go away',
    ...         'field.selected_sources': ['27', '28', '29'],
    ...         'field.selected_sources-empty-marker': 1,
    ...         })

    >>> view.has_sources_for_display
    False

    >>> import transaction
    >>> transaction.commit()

If by any chance, the form containing already deleted items, is
re-POSTed to the page, the code is able to identify such invalid
situation and ignore it. See bug #185922 for reference.

    >>> view.initialize()

    >>> view.has_sources_for_display
    False

    >>> len(view.errors)
    2


== ArchiveEditDependenciesView ==

We use ArchiveEditDependenciesView to provide the mechnisms used to
add and/or remove archive dependencies for a PPA via the UI.

This view is only accessible by users with 'launchpad.Edit' permission
in the archive, that would be only the PPA owner (or administrators of
the Team owning the PPA) and Launchpad administrators. See further
tests in pagetests/xx-edit-dependencies.txt.

We will use the PPA owner, Celso user, to play with edit-dependencies
corner-cases.

    >>> login('celso.providelo@canonical.com')

Issuing a empty request we can inspect the internal attributes used to
build the page.

    >>> view = create_initialized_view(
    ...     cprov.archive, name="+edit-dependencies")

There is a property indicating whether or not the context PPA has
recorded dependencies.

    >>> view.has_dependencies
    False

Also the 'selected_dependencies' form field is present, even if it is empty.

    >>> len(view.widgets.get('selected_dependencies').vocabulary)
    0

When there is no dependencies the form focus is set to the
'dependency_candidate' input field. Where the user can directly type
the owner of the PPA he wants to mark as dependency.

    >>> print view.focusedElementScript()
    <!--
    setFocusByName('field.dependency_candidate');
    // -->

Let's emulate a dependency addition. Note that the form contains, a
empty 'selected_dependencies' (as it was rendered in the empty
request) and 'dependency_candidate' contains a valid PPA owner name.
Validation checks are documented in
pagetests/ppa/xx-edit-dependencies.txt.

    >>> view = create_initialized_view(
    ...     cprov.archive, name="+edit-dependencies",
    ...     form={
    ...         'field.selected_dependencies': [],
    ...         'field.dependency_candidate': 'sabdfl/ppa',
    ...         'field.primary_dependencies': 'UPDATES',
    ...         'field.primary_components': 'ALL_COMPONENTS',
    ...         'field.actions.save': 'Save',
    ...         })

    >>> transaction.commit()

After processing the POST the view will redirect to itself.

    >>> view.next_url is not None
    True

Let's refresh the view class as it would be done in browsers.

    >>> view = create_initialized_view(
    ...     cprov.archive, name="+edit-dependencies")

Now we can see that the view properties correctly indicate the
presence of a PPA dependency.

    >>> view.has_dependencies
    True

The 'selected_dependencies' widget has one element representing a PPA
dependency. Each element has:

 * value: dependency IArchive,
 * token: dependency IArchive.owner,
 * title: link to the dependency IArchive in Launchpad redered as the
          dependency title.

    >>> [dependency] = view.widgets.get('selected_dependencies').vocabulary

    >>> print dependency.value.displayname
    PPA for Mark Shuttleworth

    >>> print dependency.token
    sabdfl/ppa

    >>> print dependency.title
    <a href="http://launchpad.dev/~sabdfl/+archive/ppa">PPA for Mark Shuttleworth</a>

The form focus, now that we have a recorded dependencies, is set to the
first listed dependency.

    >>> print view.focusedElementScript()
    <!--
    setFocusByName('field.selected_dependencies');
    // -->

If we remove the just-added dependency, the view gets back to its
initial/empty state.

    >>> view = create_initialized_view(
    ...     cprov.archive, name="+edit-dependencies",
    ...     form={
    ...         'field.selected_dependencies': ['sabdfl/ppa'],
    ...         'field.dependency_candidate': '',
    ...         'field.primary_dependencies': 'UPDATES',
    ...         'field.primary_components': 'ALL_COMPONENTS',
    ...         'field.actions.save': 'Save',
    ...         })

After processing the POST the view will redirect to itself.

    >>> view.next_url is not None
    True

Again, the view would be refreshed by browsers.

    >>> view = create_initialized_view(
    ...     cprov.archive, name="+edit-dependencies")

Now all the updated fields can be inspected.

    >>> view.has_dependencies
    False

    >>> print view.focusedElementScript()
    <!--
    setFocusByName('field.dependency_candidate');
    // -->

Primary dependencies can be adjusted in the same form according to a
set of pre-defined options. By default all PPAs use the dependencies
for UPDATES pocket (see archive-dependencies.txt for more information).

    >>> primary_dependencies = view.widgets.get(
    ...     'primary_dependencies').vocabulary
    >>> for dependency in primary_dependencies:
    ...     print dependency.value
    Release
    Security
    Updates
    Proposed
    Backports

    >>> view.widgets.get('primary_dependencies')._getCurrentValue()
    <DBItem PackagePublishingPocket.UPDATES, (20) Updates>

A similar widget is used for the primary archive component overrides ,
which contains two pre-defined options. By default all PPAs use all
ubuntu components available to satisfy build dependencies, i.e. the
'multiverse' component.

    >>> primary_components = view.widgets.get(
    ...     'primary_components').vocabulary
    >>> for term in primary_components:
    ...     if term.value is not None:
    ...         print term.value.name
    ...     else:
    ...         print term.value
    multiverse
    None

    >>> print view.widgets.get(
    ...     'primary_components')._getCurrentValue().name
    multiverse

The form validation code identifies attempts to change the primary
dependency to the same value and doesn't change anything. Even when
there is no explicit primary dependency set.

    >>> add_updates_view = create_initialized_view(
    ...     cprov.archive, name="+edit-dependencies",
    ...     form={
    ...         'field.selected_dependencies': [],
    ...         'field.dependency_candidate': '',
    ...         'field.primary_dependencies': 'UPDATES',
    ...         'field.primary_components': 'ALL_COMPONENTS',
    ...         'field.actions.save': 'Save',
    ...         })

    >>> add_updates_view.widgets.get(
    ...     'primary_dependencies')._getCurrentValue()
    <DBItem PackagePublishingPocket.UPDATES, (20) Updates>

Any other pre-defined primary dependency can be selected.

    >>> add_proposed_view = create_initialized_view(
    ...     cprov.archive, name="+edit-dependencies",
    ...     form={
    ...         'field.selected_dependencies': [],
    ...         'field.dependency_candidate': '',
    ...         'field.primary_dependencies': 'PROPOSED',
    ...         'field.primary_components': 'ALL_COMPONENTS',
    ...         'field.actions.save': 'Save',
    ...         })

    >>> transaction.commit()

Once the page is reloaded, the selected primary dependency is the
current value of 'primary_dependencies' widget.

    >>> view = create_initialized_view(
    ...     cprov.archive, name="+edit-dependencies")

    >>> view.widgets.get('primary_dependencies')._getCurrentValue()
    <DBItem PackagePublishingPocket.PROPOSED, (30) Proposed>

Primary dependencies are not listed in the 'selected_dependencies'
widget. They can only be modified via the 'primary_dependencies'
options.

    >>> len(view.widgets.get('selected_dependencies').vocabulary)
    0

As mentioned, attempts to override primary dependencies to the same
value are detected in the form validation and nothing is changed, even
when there is an explicit override.

    >>> add_proposed_view.initialize()

    >>> add_proposed_view.widgets.get(
    ...     'primary_dependencies')._getCurrentValue()
    <DBItem PackagePublishingPocket.PROPOSED, (30) Proposed>

Attempts to override only the component dependencies are also detected
and processed correctly.

    >>> add_proposed_primary_view = create_initialized_view(
    ...     cprov.archive, name="+edit-dependencies",
    ...     form={
    ...         'field.selected_dependencies': [],
    ...         'field.dependency_candidate': '',
    ...         'field.primary_dependencies': 'PROPOSED',
    ...         'field.primary_components': 'FOLLOW_PRIMARY',
    ...         'field.actions.save': 'Save',
    ...         })

    >>> transaction.commit()

    >>> view = create_initialized_view(
    ...     cprov.archive, name="+edit-dependencies")

    >>> print view.widgets.get(
    ...     'primary_dependencies')._getCurrentValue().title
    Proposed

    >>> print view.widgets.get('primary_components')._getCurrentValue()
    None

Overriding the primary dependencies back to the 'default' value
(UPDATES pocket) will result in the override removal and the 'default'
option to be selected.

    >>> add_updates_view.initialize()
    >>> transaction.commit()

    >>> view = create_initialized_view(
    ...     cprov.archive, name="+edit-dependencies")

    >>> view.widgets.get('primary_dependencies')._getCurrentValue()
    <DBItem PackagePublishingPocket.UPDATES, (20) Updates>

Dependencies on private PPAs can be only set if the user performing
the action also have permission to view the private PPA and if the
context PPA is also private.

The latter guarantee that the P3A buildd_secret won't get exposed in
the buildlogs. The remaining risk is to have untrusted people in the
context PPA which would have a chance to expose the contents of the
other P3As dependencies while their sources get built.

Before testing we will create a new team owned by Mark Shutteworth,
with a private PPA attached to it.

    >>> login('foo.bar@canonical.com')
    >>> sabdfl = getUtility(IPersonSet).getByName('sabdfl')
    >>> a_team = factory.makeTeam(sabdfl, name="pirulito-team")
    >>> from canonical.launchpad.interfaces.archive import (
    ...     IArchiveSet, ArchivePurpose)
    >>> team_ppa = getUtility(IArchiveSet).new(ArchivePurpose.PPA, a_team)
    >>> team_ppa.buildd_secret = 'boing'
    >>> team_ppa.private = True
    >>> transaction.commit()
    >>> login('celso.providelo@canonical.com')

Now, when Celso tries to make the new private PPA a dependency of his
PPA the form fails because he has no permission to view its contents.

    >>> add_private_form = {
    ...     'field.selected_dependencies': [],
    ...     'field.dependency_candidate': 'pirulito-team/ppa',
    ...     'field.primary_dependencies': 'UPDATES',
    ...     'field.primary_components': 'FOLLOW_PRIMARY',
    ...     'field.actions.save': 'Save',
    ...     }

    >>> view = create_initialized_view(
    ...     cprov.archive, name="+edit-dependencies",
    ...     form=add_private_form)

    >>> for error in view.errors:
    ...     print error
    You don't have permission to use this dependency.

When we grant access to Celso for viewing the private PPA, by making
him a memeber of the new team, setting the private PPA as dependency
still denied since Celso's PPA still public and thus the dependencies
buildd_secret would leak through the public buildlogs.

    >>> login('foo.bar@canonical.com')
    >>> a_team.addMember(cprov, sabdfl)
    >>> login('celso.providelo@canonical.com')

    >>> view = create_initialized_view(
    ...     cprov.archive, name="+edit-dependencies",
    ...     form=add_private_form)

    >>> for error in view.errors:
    ...     print error
    Public PPAs cannot depend on private ones.

Finally, we make Celso's PPA private. That's enough for allowing Celso
to set PPA for Pirulito Team as dependency of his PPA.

    >>> login('foo.bar@canonical.com')
    >>> cprov.archive.buildd_secret = 'boing'
    >>> cprov.archive.private = True
    >>> login('celso.providelo@canonical.com')

    >>> view = create_initialized_view(
    ...     cprov.archive, name="+edit-dependencies",
    ...     form=add_private_form)

    >>> len(view.errors)
    0

    >>> view = create_initialized_view(
    ...     cprov.archive, name="+edit-dependencies")

    >>> dependencies = view.widgets.get('selected_dependencies').vocabulary
    >>> for dependency in dependencies:
    ...     print dependency.value.displayname
    PPA for Pirulito Team

Remove Celso's membership on the new team and made his PPA public
again to not affect subsequent tests.

    >>> cprov.leave(a_team)

    >>> login('foo.bar@canonical.com')
    >>> cprov.archive.private = False
    >>> cprov.archive.buildd_secret = ''
    >>> login('celso.providelo@canonical.com')


== ArchivePackageCopyingView ==

This class extends ArchiveSourceSelectionFormView, and thus uses the
same mechanisms for presenting and filtering available sources for
copying, the 'selected_sources' widget. Related features don't need to
be re-tested.

    >>> login('celso.providelo@canonical.com')

Issuing a empty request we can inspect the internal attributes used to
build the page.

    >>> view = create_initialized_view(
    ...     cprov.archive, name="+copy-packages")

The main difference for ArchivePackageDeletionView  is that this uses a
different 'source' provider, which may include deleted sources, and a
different default status filter (only published sources are presented
by default).

    >>> view.has_sources_for_display
    False

In this case, the template can use the has_sources
property to identify that, even though there aren't any sources to
display, it's not because the archive isn't active, but rather just
that the user has filtered the sources:

    >>> view.has_sources
    True

All sources in Celso's PPA were just-deleted, so we have to tweak the
'status_filter' to see them.

    >>> view = create_initialized_view(
    ...     cprov.archive, name="+copy-packages",
    ...     query_string="field.status_filter=any")

    >>> [pub.status.name for pub in view.batched_sources]
    ['DELETED', 'DELETED', 'DELETED']

This view contains three properties. The first is a list of the PPAs
in which the current user has upload/copy rights (see
`IArchiveSet.getPPAsForUser`).

    >>> [ppa.owner.name for ppa in view.ppas_for_user]
    [u'cprov']

The second shows whether or not the current user is allowed to perform
copies. They must participate in at least one PPA for this to be True.

    >>> view.can_copy
    True

And finally if the user has the right to upload/copy to the context
PPA.

    >>> view.can_copy_to_context_ppa
    True

Lets exercise the properties. 'No Privileges Person' user has his own
PPA, thus he can copy to it, but not to Celso's PPA.

    >>> login('no-priv@canonical.com')
    >>> view = create_initialized_view(
    ...     cprov.archive, name="+copy-packages")

    >>> [ppa.owner.name for ppa in view.ppas_for_user]
    [u'no-priv']

    >>> view.can_copy
    True

    >>> view.can_copy_to_context_ppa
    False

'Foo Bar' user has no PPA, so he cannot perform copies at all.

    >>> login('foo.bar@canonical.com')

    >>> view = create_initialized_view(
    ...     cprov.archive, name="+copy-packages")

    >>> [ppa.owner.name for ppa in view.ppas_for_user]
    []

    >>> view.can_copy
    False

    >>> view.can_copy_to_context_ppa
    False

When we activate the Ubuntu team PPA, in which Celso participates,
he will be able to copy not only to his PPA but also to the PPA for a
team he is member of.

    >>> ubuntu_team = getUtility(IPersonSet).getByName('ubuntu-team')

    >>> from canonical.launchpad.interfaces import (
    ...     ArchivePurpose, IArchiveSet)
    >>> ubuntu_team_ppa = getUtility(IArchiveSet).new(
    ...     owner=ubuntu_team, distribution=None, purpose=ArchivePurpose.PPA,
    ...     description="Don't we have a distribution ?")

    >>> login('celso.providelo@canonical.com')
    >>> view = create_initialized_view(
    ...     cprov.archive, name="+copy-packages")

    >>> [ppa.owner.name for ppa in view.ppas_for_user]
    [u'cprov', u'ubuntu-team']

    >>> view.can_copy
    True

    >>> view.can_copy_to_context_ppa
    True

We will prepare a empty POST and inspect the default form values.

    >>> view = create_initialized_view(
    ...     cprov.archive, name="+copy-packages",
    ...     form={
    ...         'field.destination_archive': '',
    ...         'field.destination_series': '',
    ...         })

The 'destination_archive' widget contents are directly based on the
'ppas_for_user', but it excludes the context PPA from the list of
options making it the default option, 'This PPA' rendered option.

    >>> archive_widget = view.widgets['destination_archive']

    >>> archive_widget.required
    False

    >>> print archive_widget.translate(archive_widget._messageNoValue)
    This PPA

    >>> for item in archive_widget.vocabulary:
    ...     print item.title
    PPA for Ubuntu Team

    >>> print archive_widget.getInputValue() == cprov.archive
    True

The 'destination_series' widget behaves similarly, it contains all
series available for the PPA distribution and default to 'The same
series', which ends up being None in the browser domain.

    >>> series_widget = view.widgets['destination_series']

    >>> series_widget.required
    False

    >>> print archive_widget.translate(series_widget._messageNoValue)
    The same series

    >>> for item in series_widget.vocabulary:
    ...     print item.title
    Breezy Badger Autotest
    Grumpy
    Hoary
    Warty

    >>> print series_widget.getInputValue()
    None

The 'destination_archive' widget behaves differently depending on
whether or not the user has permission to perform copies to the
context PPA.

No Privileges user can't copy package to the Celso's PPA, thus
'destination' widget will become required and will fail if an empty
value is submitted.

    >>> login('no-priv@canonical.com')

    >>> view = create_initialized_view(
    ...     cprov.archive, name="+copy-packages",
    ...     form={
    ...         'field.destination_archive': '',
    ...         'field.destination_series': '',
    ...         })

    >>> archive_widget = view.widgets['destination_archive']
    >>> archive_widget.required
    True

    >>> for item in archive_widget.vocabulary:
    ...     print item.title
    PPA for No Privileges Person

    >>> print archive_widget.getInputValue()
    Traceback (most recent call last):
    ...
    WidgetInputError: ('destination_archive', u'Destination PPA', )


=== Copy privacy mismatch ===

Users are only allowed to copy private sources into private PPAs,
otherwise builders won't be able to retrieve the files for
building. See `testCopyFromPrivateToPublicPPAs` for more information.

First we will make Celso's PPA private.

    >>> login('foo.bar@canonical.com')

    >>> cprov.archive.buildd_secret = 'boing'
    >>> cprov.archive.private = True

Then we will create a testing publication, that will be restricted.

    >>> from canonical.launchpad.tests.test_publishing import (
    ...     SoyuzTestPublisher)
    >>> test_publisher = SoyuzTestPublisher()
    >>> hoary = ubuntu.getSeries('hoary')
    >>> test_publisher.addFakeChroots(hoary)
    >>> unused = test_publisher.setUpDefaultDistroSeries(hoary)
    >>> private_source = test_publisher.getPubSource(
    ...     sourcename="private", version="1.0", archive=cprov.archive)

    >>> transaction.commit()

Now, as Celso we will try to copy the just created 'private' source to
the public Ubuntu-team PPA, which is empty.

    >>> print private_source.displayname
    private 1.0 in hoary

    >>> ubuntu_team_ppa.getPublishedSources().count()
    0

    >>> login('celso.providelo@canonical.com')
    >>> view = create_initialized_view(
    ...     cprov.archive, name="+copy-packages",
    ...     form={
    ...         'field.status_filter': 'any',
    ...         'field.selected_sources': [str(private_source.id)],
    ...         'field.destination_archive': 'ubuntu-team/ppa',
    ...         'field.destination_series': '',
    ...         'field.include_binaries': 'REBUILD_SOURCES',
    ...         'field.actions.copy': 'Copy',
    ...         })

The action cannot be performed due to the 'private mismatch'
error. Nothing was copied to Ubuntu-team PPA.

    >>> for error in view.errors:
    ...     print error
    The following source cannot be copied: private 1.0 in hoary
    (Cannot copy private source into public archives.)

    >>> ubuntu_team_ppa.getPublishedSources().count()
    0
