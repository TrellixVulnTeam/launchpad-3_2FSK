= Bugzilla bugtrackers with the Launchpad plugin =

These tests cover the BugzillaLPPlugin ExternalBugTracker, which handles
Bugzilla instances that have the Launchpad plugin installed.

For testing purposes, a custom XML-RPC transport can be passed to it,
so that we can avoid network traffic in tests.

    >>> from canonical.launchpad.components.externalbugtracker import (
    ...     BugzillaLPPlugin)
    >>> from canonical.launchpad.ftests.externalbugtracker import (
    ...     TestBugzillaXMLRPCTransport)
    >>> test_transport = TestBugzillaXMLRPCTransport()
    >>> bugzilla = BugzillaLPPlugin(
    ...     'http://example.com/', xmlrpc_transport=test_transport)
    >>> bugzilla.xmlrpc_transport == test_transport
    True


== Authentication ==

XML-RPC methods that modify data on the remote server require
authentication. To authenticate, we create a LoginToken of type
BUGTRACKER and pass it to the remote service's Launchapd.login() method.
The remote service then checks that this token is valid and returns an
appropriate response.

We use the internal XML-RPC service to generate the token, which allows
us to sidestep the issue of committing the new token to the database in
order to make it visible to the remote Bugzilla.

BugzillaLPPlugin has an _authenticate() method, which is responsible for
doing the authentication work with the remote server. We'll override the
_handleLoginToken() method of TestBugzillaXMLRPCTransport so that it can
work with the right database user.

    >>> from canonical.config import config
    >>> from canonical.testing import LaunchpadZopelessLayer
    >>> from canonical.launchpad.ftests.externalbugtracker import (
    ...     TestInternalXMLRPCTransport)

    >>> class ZopelessBugzillaXMLRPCTransport(TestBugzillaXMLRPCTransport):
    ...     def _handleLoginToken(self, token_text):
    ...         LaunchpadZopelessLayer.switchDbUser('launchpad')
    ...         self._consumeLoginToken(token_text)
    ...         LaunchpadZopelessLayer.switchDbUser(
    ...             config.checkwatches.dbuser)

    >>> test_transport = ZopelessBugzillaXMLRPCTransport()
    >>> test_transport.print_method_calls = True
    >>> bugzilla = BugzillaLPPlugin(
    ...     'http://example.com/', xmlrpc_transport=test_transport,
    ...     internal_xmlrpc_transport=TestInternalXMLRPCTransport())

    >>> bugzilla._authenticate()
    Using XML-RPC to generate token.
    CALLED Launchpad.login({'token': '...'})
    Successfully validated the token.


The authorisation cookie will be stored in the auth_cookie property of
the XML-RPC transport.

    >>> print test_transport.auth_cookie
    Bugzilla_login=...
    Bugzilla_logincookie=...

The externalbugtracker.bugzilla module contains a decorator,
needs_authentication, which can be used to ensure that a
BugzillaLPPlugin instance will attempt to authenticate with the remote
server if it encounters an method which requires it to be logged in.

We can demonstrate this by subclassing BugzillaLPPlugin and adding a
method which requires authentication.

    >>> from canonical.launchpad.components.externalbugtracker.bugzilla import (
    ...     needs_authentication)
    >>> class AuthenticatingBugzillaLPPlugin(BugzillaLPPlugin):
    ...
    ...     @needs_authentication
    ...     def testAuthentication(self):
    ...         return self.server.Test.login_required()

    >>> test_bugzilla = AuthenticatingBugzillaLPPlugin(
    ...     'http://example.com/', xmlrpc_transport=test_transport,
    ...     internal_xmlrpc_transport=TestInternalXMLRPCTransport())

The Test.login_required() method on the server requires the user to be
authenticated. We'll expire the current auth_cookie so that
login_required() raises a fault.

    >>> test_transport.expireCookie(test_transport.auth_cookie)
    >>> test_bugzilla.server.Test.login_required()
    Traceback (most recent call last):
      ...
    Fault: <Fault 410: 'Login Required'>

Because the testAuthentication() method of
AuthenticatingBugzillaLPPlugin is decorated with needs_authentication,
it will automatically try authenticating when it receives the Fault from
login_required() and will retry the method call.

    >>> return_value = test_bugzilla.testAuthentication()
    Using XML-RPC to generate token.
    CALLED Launchpad.login({'token': '...'})
    Successfully validated the token.
    CALLED Test.login_required()

    >>> print return_value
    Wonderful, you've logged in! Aren't you a clever biped?

    >>> test_transport.print_method_calls = False


== Getting the current time ==

The BugzillaLPPlugin ExternalBugTracker, like all other
ExternalBugTrackers, has a getCurrentDBTime() method, which returns the
current time on the remote server.

    >>> from datetime import datetime
    >>> # It seems there's no way to create a UTC timestamp without
    >>> # monkey-patching the TZ environment variable. Rather than do
    >>> # that, we create our own timestamp and work with that.
    >>> datetime.utcfromtimestamp(1210953200.0)
    datetime.datetime(2008, 5, 16, 15, 53, 20)

    >>> test_transport.utc_offset = 60**2
    >>> test_transport.timezone = 'CET'
    >>> test_transport.seconds_since_epoch = 1210956800.0
    >>> bugzilla.getCurrentDBTime()
    datetime.datetime(2008, 5, 16, 15, 53, 20, tzinfo=<UTC>)


== Initializing the remote bug database ==

The BugzillaLPPlugin implements the standard initializeRemoteBugDB()
method, taking a list of the bug ids that need to be updated. It uses
the Bugzilla Bug.get_bugs() API to retrieve bugs from the remote system.

    >>> bugzilla.xmlrpc_transport.print_method_calls = True
    >>> bugzilla.initializeRemoteBugDB([1, 2])
    CALLED Bug.get_bugs({'ids': [1, 2], 'permissive': True})

The bug data is stored as a list of dicts:

    >>> for bug in sorted(bugzilla.bugs.keys()):
    ...     print "Bug %s:" % bug
    ...     for key in sorted(bugzilla.bugs[bug].keys()):
    ...         print "    %s: %s" % (key, bugzilla.bugs[bug][key])
    ...     print "\n"
    Bug 1:
        alias: 
        assigned_to: test@canonical.com
        component: GPPSystems
        creation_time: 20080610T16:19:53
        id: 1
        internals:...
        is_open: True
        last_change_time: 20080610T16:19:53
        priority: P1
        product: HeartOfGold
        resolution: FIXED
        severity: normal
        status: RESOLVED
        summary: That bloody robot still exists.
    <BLANKLINE>
    Bug 2:
        alias: bug-two
        assigned_to: marvin@heartofgold.ship
        component: Crew
        creation_time: 20080611T09:23:12
        id: 2
        internals:...
        is_open: True
        last_change_time: 20080611T09:24:29
        priority: P1
        product: HeartOfGold
        resolution: 
        severity: high
        status: NEW
        summary: Collect unknown persons in docking bay 2.
    <BLANKLINE>
    <BLANKLINE>

initializeRemoteBugDB() will only store a bug once, even if it is
requested both by alias and ID.

    >>> bugzilla.initializeRemoteBugDB([2, 'bug-two'])
    CALLED Bug.get_bugs({'ids': [2, 'bug-two'], 'permissive': True})

    >>> for bug in sorted(bugzilla.bugs.keys()):
    ...     print "Bug %r:" % bug
    ...     for key in sorted(bugzilla.bugs[bug].keys()):
    ...         print "    %s: %s" % (key, bugzilla.bugs[bug][key])
    ...     print "\n"
    Bug 2:
        alias: bug-two
        assigned_to: marvin@heartofgold.ship
        component: Crew
        creation_time: 20080611T09:23:12
        id: 2
        internals:...
        is_open: True
        last_change_time: 20080611T09:24:29
        priority: P1
        product: HeartOfGold
        resolution: 
        severity: high
        status: NEW
        summary: Collect unknown persons in docking bay 2.
    <BLANKLINE>
    <BLANKLINE>

Aliases are stored in a separate dict, which contains a mapping between
the alias and the bug's actual ID.

    >>> for alias, bug_id in bugzilla.bug_aliases.items():
    ...     print "%s: %s" % (alias, bug_id)
    bug-two: 2

The method _getActualBugId() returns the correct bug ID for a passed bug
ID or alias.

    >>> bugzilla._getActualBugId('bug-two')
    2

    >>> bugzilla._getActualBugId(2)
    2


== Getting remote statuses ==

BugzillaLPPlugin.getRemoteStatus() will return the remote status of a
given bug as a string. If the bug has a resolution, that will be
returned too.

    >>> bugzilla.initializeRemoteBugDB([1, 2])
    CALLED Bug.get_bugs({'ids': [1, 2], 'permissive': True})

    >>> print bugzilla.getRemoteStatus(1)
    RESOLVED FIXED

    >>> print bugzilla.getRemoteStatus(2)
    NEW

If a bug can't be found a BugNotFound error will be raised.

    >>> bugzilla.getRemoteStatus('no-such-bug')
    Traceback (most recent call last):
      ...
    BugNotFound: no-such-bug


== Retrieving remote comments ==

BugzillaLPPlugin implments the ISupportsCommentImport interface, which
means that we can use it to import comments from the remote Bugzilla
instance.

    >>> from canonical.launchpad.interfaces import ISupportsCommentImport
    >>> ISupportsCommentImport.providedBy(bugzilla)
    True

To test the comment importing methods we need to add an example bug,
bugtracker and a couple of bugwatches.

    >>> from canonical.config import config
    >>> from canonical.database.sqlbase import commit
    >>> from canonical.launchpad.interfaces.bug import CreateBugParams
    >>> from canonical.launchpad.interfaces.bugtracker import BugTrackerType
    >>> from canonical.launchpad.interfaces.person import IPersonSet
    >>> from canonical.launchpad.interfaces.product import IProductSet
    >>> from canonical.launchpad.ftests.externalbugtracker import (
    ...     new_bugtracker)
    >>> from canonical.testing import LaunchpadZopelessLayer

    >>> bug_tracker = new_bugtracker(BugTrackerType.BUGZILLA)

    >>> LaunchpadZopelessLayer.switchDbUser('launchpad')

    >>> sample_person = getUtility(IPersonSet).getByEmail(
    ...     'test@canonical.com')
    >>> firefox = getUtility(IProductSet).getByName('firefox')
    >>> bug = firefox.createBug(
    ...     CreateBugParams(sample_person, "Yet another test bug",
    ...         "Yet another test description.",
    ...         subscribe_reporter=False))

    >>> bug_watch = bug.addWatch(bug_tracker, '1', sample_person)
    >>> bug_watch_two = bug.addWatch(bug_tracker, '2', sample_person)
    >>> bug_watch_broken = bug.addWatch(bug_tracker, '42', sample_person)
    >>> commit()

    >>> LaunchpadZopelessLayer.switchDbUser(config.checkwatches.dbuser)


=== getCommentIds() ===

ISupportsCommentImport.getCommentIds() is the method used to get all the
comment IDs for a given bug on a remote bugtracker.

    >>> bugzilla.xmlrpc_transport.print_method_calls = False
    >>> bug_comment_ids = bugzilla.getCommentIds(bug_watch)
    >>> print sorted(bug_comment_ids)
    [1, 3]

getCommentIds() can only be called if initializeRemoteBugDB() has been
called and the bug exists locally.

    >>> bugzilla.getCommentIds(bug_watch_broken)
    Traceback (most recent call last):
      ...
    BugNotFound: 42


=== fetchComments() ===

ISupportsCommentImport.fetchComments() is the method used to fetch a
given set of comments from the remote bugtracker. It takes a bug watch
and a list of the comment IDs to retrieve for that bug watch.

    >>> bugzilla.fetchComments(bug_watch, [1, 3])

The comments will be stored in the bugs dict as a dict of comment id =>
comment dict mappings under the key 'comments'.

    >>> comments = bugzilla.bugs[1]['comments']
    >>> for comment_id in sorted(comments.keys()):
    ...     print "Comment %s:" % comment_id
    ...     comment = comments[comment_id]
    ...     for key in sorted(comment.keys()):
    ...         print "    %s: %s" % (key, comment[key])
    Comment 1:
        author: trillian
        id: 1
        number: 1
        text: I'd really appreciate it if Marvin would enjoy life a bit.
        time: 20080616T12:44:29
    Comment 3:
        author: marvin
        id: 3
        number: 2
        text: Life? Don't talk to me about life.
        time: 20080616T13:22:29


=== getPosterForComment() ===

ISupportsCommentImport.getPosterForComment() returns a tuple of
(displayname, email) for the author of a remote comment.

    >>> bugzilla.fetchComments(bug_watch_two, [2, 4])
    >>> displayname, email = bugzilla.getPosterForComment(bug_watch_two, 4)
    >>> print displayname, email
    Ford Prefect ford.prefect@h2g2.com

If the author's name as stored in the comment isn't a valid email
address then the method will return displayname = None and will return
the whole of the author's name in the email field.

    >>> displayname, email = bugzilla.getPosterForComment(bug_watch_two, 2)
    >>> print displayname, email
    None trillian


=== getMessageForComment() ===

ISupportsCommentImport.getMessageForComment() returns a Launchpad
IMessage instance for a given comment. It takes a bug watch, a comment
ID and a Person object generated from the return value of
getPosterForComment(), above. For the sake of this test we'll use
Sample Person as our poster.

    >>> message = bugzilla.getMessageForComment(
    ...     bug_watch_two, 2, sample_person)
    >>> print message.text_contents
    Bring the passengers to the bridge please Marvin.

    >>> print message.owner.displayname
    Sample Person

The datecreated attribute of the Message will be the same as the 'time'
field on the imported comment.

    >>> print bugzilla.bugs[2]['comments'][2]['time']
    20080616T13:08:08

    >>> print message.datecreated
    2008-06-16 13:08:08+00:00
