= Introduction =

Bugs are some of the more complex objects in Launchpad. They have a
lot of state and many relationships to other objects.

  >>> from pprint import PrettyPrinter
  >>> pprint = PrettyPrinter(width=72).pprint
  >>> def show(thing):
  ...     if isinstance(thing, dict):
  ...         thing = sorted(thing.iteritems())
  ...     pprint(thing)


== Bugs themselves ==

At the top level we provide a collection of bugs.

  >>> import operator
  >>> bugs = webservice.get("/beta/bugs").jsonBody()
  >>> bugs['total_size']
  15
  >>> bug_entries = sorted(bugs['entries'], key=operator.itemgetter('id'))
  >>> show(bug_entries[0])
  [(u'bug_tasks_collection_link',
    u'http://api.launchpad.dev/beta/bugs/11/bug_tasks'),
   (u'bug_watches_collection_link',
    u'http://api.launchpad.dev/beta/bugs/11/bug_watches'),
   (u'can_expire', False),
   (u'date_created', u'2007-03-15T20:33:56.678930+00:00'),
   (u'date_last_message', None),
   (u'date_last_updated', u'2007-03-15T20:37:51.603369+00:00'),
   (u'date_made_private', None),
   (u'description', u"I've had problems when switching..."),
   (u'duplicate_of_link', None),
   (u'duplicates_collection_link',
    u'http://api.launchpad.dev/beta/bugs/11/duplicates'),
   (u'id', 11),
   (u'is_complete', False),
   (u'messages_collection_link',
    u'http://api.launchpad.dev/beta/bugs/11/messages'),
   (u'name', None),
   (u'owner_link', u'http://api.launchpad.dev/beta/~name16'),
   (u'permits_expiration', False),
   (u'private', False),
   (u'resource_type_link',
    u'http://api.launchpad.dev/beta/#BugEntryAdapter'),
   (u'security_related', False),
   (u'self_link', u'http://api.launchpad.dev/beta/bugs/11'),
   (u'subscriptions_collection_link',
    u'http://api.launchpad.dev/beta/bugs/11/subscriptions'),
   (u'tags', []),
   (u'title', u'Make Jokosher use autoaudiosink'),
   (u'who_made_private_link', None)]

Bugs are indexed by number beneath the top-level collection.

  >>> bug_one = webservice.get("/beta/bugs/1").jsonBody()
  >>> bug_one['id']
  1

Bugs have relationships to other bugs, like "duplicate_of".

  >>> duplicates_of_five = webservice.get(
  ...     "/beta/bugs/5/duplicates").jsonBody()['entries']
  >>> len(duplicates_of_five)
  1
  >>> duplicates_of_five[0]['id']
  6

  >>> from urlparse import urlsplit
  >>> def get_path(url):
  ...     scheme, netloc, path, query, fragment = urlsplit(url)
  ...     return path

  >>> bug_six_url = get_path(duplicates_of_five[0]['self_link'])
  >>> bug_six = webservice.get(bug_six_url).jsonBody()
  >>> bug_six['duplicate_of_link']
  u'http://api.launchpad.dev/beta/bugs/5'


== Bugs as message targets ==

Each bug has a collection of messages.

  >>> messages = webservice.get("/beta/bugs/5/messages").jsonBody()['entries']
  >>> show(messages[0])
  [(u'content',
    u'All ways of downloading firefox should provide...'),
   (u'datecreated', u'2005-01-14T17:27:03.702622+00:00'),
   (u'owner_link', u'http://api.launchpad.dev/beta/~name12'),
   (u'parent_link', None),
   (u'resource_type_link',
    u'http://api.launchpad.dev/beta/#MessageEntryAdapter'),
   (u'self_link',
    u'http://api.launchpad.dev/beta/firefox/+bug/5/comments/0'),
   (u'subject', u'Firefox install instructions should be complete')]

The messages are stored beneath the bug-specific collection. Their
URLs are based on their position with respect to the
bug. /firefox/+bug/5/comments/0 is the first message for bug 5, and it's
different from /firefox/+bug/1/comments/0.

  >>> message_path = get_path(messages[0]['self_link'])
  >>> message_path
  u'/beta/firefox/+bug/5/comments/0'

  >>> message = webservice.get(message_path).jsonBody()
  >>> message == messages[0]
  True

There is no top-level collection of messages; they only exist in
relation to some bug.

  >>> webservice.get("/beta/messages").getStatus()
  404


== Bug tasks ==

Each bug may be associated with one or more bug tasks. Much of the
data in a bug task is derived from the bug.

  >>> bug_one_bugtasks_url = get_path(bug_one['bug_tasks_collection_link'])
  >>> bug_one_bugtasks = sorted(webservice.get(
  ...     bug_one_bugtasks_url).jsonBody()['entries'])
  >>> len(bug_one_bugtasks)
  3

  >>> show(bug_one_bugtasks[0])
  [(u'assignee_link', None),
   (u'bug_link', u'http://api.launchpad.dev/beta/bugs/1'),
   (u'bug_target_display_name', u'mozilla-firefox (Debian)'),
   (u'bug_target_name', u'mozilla-firefox (Debian)'),
   (u'bug_watch_link', u'http://api.launchpad.dev/beta/bugs/1/+watch/8'),
   (u'date_assigned', u'2005-01-04T11:07:20.584746+00:00'),
   (u'date_closed', None),
   (u'date_confirmed', None),
   (u'date_created', u'2004-01-04T03:49:22.790240+00:00'),
   (u'date_fix_committed', None),
   (u'date_fix_released', None),
   (u'date_in_progress', None),
   (u'date_left_new', None),
   (u'date_triaged', None),
   (u'importance', u'Low'),
   (u'is_complete', False),
   (u'owner_link', u'http://api.launchpad.dev/beta/~name12'),
   (u'related_tasks_collection_link',
    u'http://api.../debian/+source/mozilla-firefox/+bug/1/related_tasks'),
   (u'resource_type_link',
    u'http://api.launchpad.dev/beta/#BugTaskEntryAdapter'),
   (u'self_link',
    u'http://api.../debian/+source/mozilla-firefox/+bug/1'),
   (u'status', u'Confirmed'),
   (u'title',
    u'Bug #1 in mozilla-firefox (Debian): "Firefox does not support SVG"')]

  >>> bugtask_path = get_path(bug_one_bugtasks[0]['self_link'])
  >>> bugtask = webservice.get(bugtask_path).jsonBody()
  >>> bugtask == bug_one_bugtasks[0]
  True

The collection of bug tasks is not exposed as a resource:

  >>> webservice.get("/beta/bug_tasks").getStatus()
  404

It's possible to change the task's assignee.

  >>> print webservice.named_post(
  ...     bugtask_path, 'transitionToAssignee', assignee='http://api.launchpad.dev/beta/~cprov')
  HTTP/1.1 200 Ok
  ...
  Content-Type: application/json
  <BLANKLINE>
  null

  >>> print webservice.get(bugtask_path).jsonBody()['assignee_link']
  http://api.launchpad.dev/beta/~cprov

Let's try modifying the importance of a task.

  >>> body = webservice.get(bugtask_path).jsonBody()
  >>> body['importance']
  u'Low'
  >>> body = {'importance': 'High'}

  >>> from simplejson import dumps

  >>> response = webservice.patch(
  ...     bugtask_path, 'application/json', dumps(body))
  >>> body = webservice.get(bugtask_path).jsonBody()
  >>> body['importance']
  u'High'


== Bug subscriptions ==

We can get the the collection of subscriptions to a bug.

  >>> bug_one_subscriptions_url = urlsplit(
  ...     bug_one['subscriptions_collection_link'])[2]
  >>> subscriptions = webservice.get(bug_one_subscriptions_url).jsonBody()
  >>> pprint(sorted(entry.items() for entry in subscriptions['entries']))
  [[(u'self_link',
     u'http://api.launchpad.dev/beta/bugs/1/+subscription/name12'),
    (u'person_link', u'http://api.launchpad.dev/beta/~name12'),
    (u'bug_link', u'http://api.launchpad.dev/beta/bugs/1'),
    (u'resource_type_link',
     u'http://api.launchpad.dev/beta/#BugSubscriptionEntryAdapter'),
    (u'subscribed_by_link', u'http://api.launchpad.dev/beta/~janitor')]...]


Each subscription can be accessed individually.

  >>> subscription = webservice.get(subscriptions['entries'][0]['self_link']).jsonBody()
  >>> pprint(sorted(subscription.items()))
  [(u'bug_link', u'http://api.launchpad.dev/beta/bugs/1'),
   (u'person_link', u'http://api.launchpad.dev/beta/~stevea'),
   (u'resource_type_link', u'http://api.launchpad.dev/beta/#BugSubscriptionEntryAdapter'),
   (u'self_link', u'http://api.launchpad.dev/beta/bugs/1/+subscription/stevea'),
   (u'subscribed_by_link', u'http://api.launchpad.dev/beta/~janitor')]

We can also create new subscriptions.

    >>> new_subscription = webservice.named_post(
    ...     bug_one['self_link'], 'subscribe',
    ...     person='http://api.launchpad.dev/beta/~cprov').jsonBody()
    >>> pprint(new_subscription)
    {...u'self_link':
        u'http://api.launchpad.dev/beta/bugs/1/+subscription/cprov'...}

But we can only unsubscribe ourselves.

    >>> print webservice.named_post(
    ...     bug_one['self_link'], 'unsubscribe')
    HTTP/1.1 200 Ok...


== Bug Watches ==

Bugs can have bug watches associated with them. Each bugwatch can also
be optionally associated with one of the bugtasks in a bug, in which
case aspects of the bugtask (like status) are slaved to the remote bug
report described by the bugwatch.

  >>> bug_one_bug_watches_url = get_path(
  ...     bug_one['bug_watches_collection_link'])
  >>> bug_one_bug_watches = sorted(webservice.get(
  ...     bug_one_bug_watches_url).jsonBody()['entries'])
  >>> len(bug_one_bug_watches)
  4

  >>> [bug_watch_2000] = [
  ...     bug_watch for bug_watch in bug_one_bug_watches
  ...     if bug_watch['remote_bug'] == u'2000']

  >>> show(bug_watch_2000)
  [(u'bug_link', u'http://api.launchpad.dev/beta/bugs/1'),
   (u'bug_tracker_link',
    u'http://api.launchpad.dev/beta/bugs/bugtrackers/mozilla.org'),
   (u'bugtasks_collection_link',
    u'http://api.launchpad.dev/beta/bugs/1/+watch/2/bugtasks'),
   (u'date_created', u'2004-10-04T01:00:00+00:00'),
   (u'date_last_changed', u'2004-10-04T01:00:00+00:00'),
   (u'date_last_checked', u'2004-10-04T01:00:00+00:00'),
   (u'last_error_type', None),
   (u'owner_link', u'http://api.launchpad.dev/beta/~sabdfl'),
   (u'remote_bug', u'2000'),
   (u'remote_importance', None),
   (u'remote_status', u''),
   (u'resource_type_link',
    u'http://api.launchpad.dev/beta/#BugWatchEntryAdapter'),
   (u'self_link', u'http://api.launchpad.dev/beta/bugs/1/+watch/2'),
   (u'title', u'The Mozilla.org Bug Tracker #2000'),
   (u'url', u'https://bugzilla.mozilla.org/show_bug.cgi?id=2000')]

  >>> bug_watch_path = get_path(bug_watch_2000['self_link'])
  >>> bug_watch = webservice.get(bug_watch_path).jsonBody()
  >>> bug_watch == bug_watch_2000
  True

The collection of bug watches is not exposed as a resource:

  >>> webservice.get("/beta/bug_watches").getStatus()
  404

We can modify the remote bug.

  >>> bug_watch['remote_bug']
  u'2000'

  >>> patch = {u'remote_bug': u'1234'}
  >>> response = webservice.patch(
  ...     bug_watch_path, 'application/json', dumps(patch))

  >>> bug_watch = webservice.get(bug_watch_path).jsonBody()
  >>> bug_watch['remote_bug']
  u'1234'

But we can't change other things, like the URL.

  >>> patch = {u'url': u'http://www.example.com/'}
  >>> response = webservice.patch(
  ...     bug_watch_path, 'application/json', dumps(patch))
  >>> print response.getOutput()
  HTTP/1.1 400 Bad Request
  Content-Length: 47
  Content-Type: text/plain
  <BLANKLINE>
  url: You tried to modify a read-only attribute.

We can use the factory function `addWatch` to create a new bug watch
associated with a bug.

  >>> response = webservice.named_post(
  ...     bug_one['self_link'], 'addWatch',
  ...     bug_tracker=('http://api.launchpad.dev'
  ...                  '/beta/bugs/bugtrackers/mozilla.org'),
  ...     remote_bug='9876')
  >>> print response.getOutput()
  HTTP/1.1 201 Created
  Content-Length: 0
  Content-Type: text/plain;charset=utf-8
  Location: http://api.launchpad.dev/beta/bugs/1/+watch/13

Following the redirect, we can see the new bug watch:

  >>> new_bug_watch_path = get_path(response.getHeader('Location'))
  >>> new_bug_watch = webservice.get(new_bug_watch_path).jsonBody()
  >>> show(new_bug_watch)
  [(u'bug_link', u'http://api.launchpad.dev/beta/bugs/1'),
   (u'bug_tracker_link',
    u'http://api.launchpad.dev/beta/bugs/bugtrackers/mozilla.org'),
   (u'bugtasks_collection_link',
    u'http://api.launchpad.dev/beta/bugs/1/+watch/13/bugtasks'),
   (u'date_created', u'...'),
   (u'date_last_changed', None),
   (u'date_last_checked', None),
   (u'last_error_type', None),
   (u'owner_link', u'http://api.launchpad.dev/beta/~salgado'),
   (u'remote_bug', u'9876'),
   (u'remote_importance', None),
   (u'remote_status', None),
   (u'resource_type_link',
    u'http://api.launchpad.dev/beta/#BugWatchEntryAdapter'),
   (u'self_link', u'http://api.launchpad.dev/beta/bugs/1/+watch/13'),
   (u'title', u'The Mozilla.org Bug Tracker #9876'),
   (u'url', u'https://bugzilla.mozilla.org/show_bug.cgi?id=9876')]


== Bug Trackers ==

  >>> bug_tracker_url = get_path(bug_watch['bug_tracker_link'])
  >>> bug_tracker = webservice.get(bug_tracker_url).jsonBody()

  >>> show(bug_tracker)
  [(u'base_url', u'https://bugzilla.mozilla.org/'),
   (u'base_url_aliases', []),
   (u'bug_tracker_type', u'Bugzilla'),
   (u'contact_details', u'Carrier pigeon only'),
   (u'name', u'mozilla.org'),
   (u'resource_type_link',
    u'http://api.launchpad.dev/beta/#BugTrackerEntryAdapter'),
   (u'self_link',
    u'http://api.launchpad.dev/beta/bugs/bugtrackers/mozilla.org'),
   (u'summary',
    u'The Mozilla.org bug tracker is the grand-daddy of bugzillas...'),
   (u'title', u'The Mozilla.org Bug Tracker'),
   (u'watches_collection_link',
    u'http://api.launchpad.dev/beta/bugs/bugtrackers/mozilla.org/watches')]

  >>> bug_tracker_path = get_path(bug_tracker['self_link'])

We can change various aspects of bug trackers.

  >>> patch = {
  ...     u'name': u'bob',
  ...     u'title': u"Bob's Tracker",
  ...     u'summary': u"Where Bob files his bugs.",
  ...     u'base_url': u'http://bugs.example.com/',
  ...     u'base_url_aliases': [u'http://bugs.example.com/bugs/',
  ...                           u'http://www.example.com/bugtracker/'],
  ...     u'contact_details': u'bob@example.com',
  ...     }
  >>> response = webservice.patch(
  ...     bug_tracker_path, 'application/json', dumps(patch))
  >>> print response.getOutput()
  HTTP/1.1 301 Moved Permanently
  Content-Length: 0
  Content-Type: text/plain
  Location: http://api.launchpad.dev/beta/bugs/bugtrackers/bob
  <BLANKLINE>

Note the 301 response. We changed the name, so the API URL at which
the bug tracker can be found has changed.

  >>> print webservice.get(bug_tracker_path).getOutput()
  HTTP/1.1 404 Not Found
  Content-Length: ...
  Content-Type: text/plain
  X-Lazr-Oopsid: OOPS-...
  <BLANKLINE>
  Object: <...BugTrackerSet object at ...>, name: u'mozilla.org'
  <BLANKLINE>
  Traceback (most recent call last):
  ...
  NotFound: Object: <...BugTrackerSet object at ...>, name: u'mozilla.org'
  <BLANKLINE>

Naturally, if we follow the Location: header then we'll get the
renamed bug tracker.

  >>> bug_tracker_path = get_path(response.getHeader('Location'))
  >>> bug_tracker = webservice.get(bug_tracker_path).jsonBody()
  >>> show(bug_tracker)
  [(u'base_url', u'http://bugs.example.com/'),
   (u'base_url_aliases',
    [u'http://bugs.example.com/bugs/',
     u'http://www.example.com/bugtracker/']),
   (u'bug_tracker_type', u'Bugzilla'),
   (u'contact_details', u'bob@example.com'),
   (u'name', u'bob'),
   (u'resource_type_link',
    u'http://api.launchpad.dev/beta/#BugTrackerEntryAdapter'),
   (u'self_link', u'http://api.launchpad.dev/beta/bugs/bugtrackers/bob'),
   (u'summary', u'Where Bob files his bugs.'),
   (u'title', u"Bob's Tracker"),
   (u'watches_collection_link',
    u'http://api.launchpad.dev/beta/bugs/bugtrackers/bob/watches')]
