= The Build table =

The build table contains the information pertaining to a given build
of a sourcepackagerelease on a distroarchseries.

The build record may have many BinaryPackageRelease records pointing
at it and it may reference a build log if the build was done on a
launchpad build daemon.

    >>> from canonical.launchpad.webapp.testing import verifyObject
    >>> from canonical.launchpad.interfaces import (
    ...    BuildStatus, IArchiveSet, IBuildSet, IDistributionSet)

    >>> ubuntu = getUtility(IDistributionSet)['ubuntu']
    >>> warty = ubuntu['warty']
    >>> hoary = ubuntu['hoary']
    >>> breezy = ubuntu['breezy-autotest']

    >>> from zope.security.proxy import removeSecurityProxy
    >>> from canonical.database.sqlbase import cursor, sqlvalues, commit
    >>> archive_id = \
    ...     sqlvalues(removeSecurityProxy(hoary).distribution.main_archive)[0]

    >>> def print_counts_for_archive(archive_id):
    ...     archive = getUtility(IArchiveSet).get(archive_id)
    ...     print ("total: %s, pending: %s, succeeded: %s, building: %s "
    ...            "failed: %s" % (archive.total_count,
    ...            archive.pending_count, archive.succeeded_count,
    ...            archive.building_count, archive.failed_count))

    >>> initq = """
    ... CREATE OR REPLACE FUNCTION init_archive_stats() RETURNS void AS $$
    ...   DECLARE
    ...     -- Build states of interest.
    ...     BS_NEEDSBUILD Integer;
    ...     BS_FULLYBUILT Integer;
    ...     BS_SUPERSEDED Integer;
    ...     BS_BUILDING Integer;
    ...     archive_id Integer;
    ...     -- Temporary counters.
    ...     tmp_total_count Integer;
    ...     tmp_pending_count Integer;
    ...     tmp_succeeded_count Integer;
    ...     tmp_failed_count Integer;
    ...     tmp_building_count Integer;
    ...   BEGIN
    ...     BS_NEEDSBUILD := 0;
    ...     BS_FULLYBUILT := 1;
    ...     BS_SUPERSEDED := 5;
    ...     BS_BUILDING := 6;
    ...
    ...     FOR archive_id IN SELECT id FROM archive LOOP
    ...       -- How many builds in total for the given archive (ignore
    ...       -- superseded builds)?
    ...       SELECT COUNT(id) INTO tmp_total_count FROM build
    ...       WHERE
    ...         build.archive = archive_id AND
    ...         build.buildstate != BS_SUPERSEDED;
    ...       -- How many pending builds for the given archive?
    ...       SELECT COUNT(id) INTO tmp_pending_count FROM build
    ...       WHERE
    ...         build.archive = archive_id AND
    ...         build.buildstate = BS_NEEDSBUILD;
    ...       -- How many successful builds for the given archive?
    ...       SELECT COUNT(id) INTO tmp_succeeded_count FROM build
    ...       WHERE
    ...         build.archive = archive_id AND
    ...         build.buildstate = BS_FULLYBUILT;
    ...       -- How many currently building builds for the given archive?
    ...       SELECT COUNT(id) INTO tmp_building_count FROM build
    ...       WHERE
    ...         build.archive = archive_id AND
    ...         build.buildstate = BS_BUILDING;
    ...       tmp_failed_count := tmp_total_count - tmp_pending_count -
    ...         tmp_succeeded_count - tmp_building_count;
    ...
    ...       -- Now set the various counters for the given archive.
    ...       UPDATE archive
    ...       SET
    ...         total_count = tmp_total_count,
    ...         pending_count = tmp_pending_count,
    ...         succeeded_count = tmp_succeeded_count,
    ...         building_count = tmp_building_count,
    ...         failed_count = tmp_failed_count
    ...       WHERE id = archive_id;
    ...     END LOOP;
    ...
    ...   END;
    ... $$ LANGUAGE plpgsql;
    ...
    ... SELECT init_archive_stats();"""

Before the archive build counters are initialized they will be all
zero.

    >>> print_counts_for_archive(archive_id)
    total: 0, pending: 0, succeeded: 0, building: 0 failed: 0

Now the archive counters are initialized.

    >>> cur = cursor()
    >>> cur.execute(initq)
    >>> commit()

Then show the archive build counters.

    >>> print_counts_for_archive(archive_id)
    total: 15, pending: 1, succeeded: 8, building: 1 failed: 5

First up, can we get the builds out of the sample data?

    >>> firefox_build = getUtility(IBuildSet).getByBuildID(18)
    >>> pmount_build = getUtility(IBuildSet).getByBuildID(19)
    >>> pending_build = getUtility(IBuildSet).getByBuildID(11)

Let's check the complex properties of a build object.

    >>> firefox_build.distroseries.name
    u'breezy-autotest'

    >>> firefox_build.title
    u'i386 build of mozilla-firefox 0.9 in ubuntu breezy-autotest RELEASE'

    >>> firefox_build.was_built
    True

    >>> firefox_build.buildlog = 34
    >>> firefox_build.buildlog.http_url
    'http://localhost:58000/34/evolution-2.2-test.pot'

    >>> firefox_build.changesfile
    <LibraryFileAlias ...>

    >>> firefox_build.calculated_buildstart
    datetime.datetime(...)

    >>> firefox_build.is_virtualized
    False

The 'firefox_build' is already finished and requesting the estimated build
start time makes no sense. Hence an exception is raised.

    >>> firefox_build.getEstimatedBuildStartTime()
    Traceback (most recent call last):
    ...
    AssertionError: The start time is only estimated for pending builds.

The 'pending_build' record is a build job in state `NEEDSBUILD`. We can
hence ask for its estimated build start time. The latter will be
undefined however because the corresponding build pool is empty.

    >>> pending_build.getEstimatedBuildStartTime() is None
    True

The currently published component is provided via the 'current_component'
property.  It looks over the publishing records and finds the current
publication of the source in question.

    >>> print firefox_build.current_component.name
    main

It is not necessarily the same as:

    >>> print firefox_build.sourcepackagerelease.component.name
    main

which is the component the source was originally uploaded to, before
any overriding action.

`IBuild.component_dependencies` is a dictionary mapping the available
components and a list of components it can depend of.

    >>> def printComponentDependencies(build):
    ...     print " Component | Dependency"
    ...     print "-----------+---------------"
    ...     components = sorted(build.component_dependencies)
    ...     for component in components:
    ...         dependencies = " ".join(
    ...             build.component_dependencies[component])
    ...	        print '%10s | %s' % (component, dependencies)

    >>> printComponentDependencies(firefox_build)
     Component | Dependency
    -----------+---------------
          main | main
    multiverse | main restricted universe multiverse
       partner | partner
    restricted | main restricted
      universe | main universe

`IBuild.ogre_components` is the list of allowed components for
building this source. It simply submits the `IBuild.current_component`
to the `IBuild.components_dependencies` table.

    >>> print firefox_build.ogre_components
    ['main']

See further information about 'Ogre Components' in a section below.

The build can report any corresponding uploads using the package_upload
property:

    >>> firefox_build.package_upload
    <PackageUpload ...>

    Zope proxied package uploads do not give permission to see them if you
    are not logged in, except for the status attribute.  Firefox's build
    upload is in the NEW state:

    >>> firefox_build.package_upload.status
    <DBItem PackageUploadStatus.NEW, (0) New>

If the build does not have any uploads, None is returned:

    >>> at_build = getUtility(IBuildSet).getByBuildID(15)
    >>> print at_build.package_upload
    None

Test "retry" functionality:

    >>> firefox_build.can_be_retried
    False

    >>> frozen_build = getUtility(IBuildSet).getByBuildID(9)
    >>> frozen_build.title
    u'i386 build of pmount 0.1-1 in ubuntu warty RELEASE'
    >>> frozen_build.buildstate.title
    'Failed to build'
    >>> frozen_build.can_be_retried
    False

See section 'AssertionErrors in IBuild' for further documentation about
consequences of an denied 'retry' action.

    >>> active_build = getUtility(IBuildSet).getByBuildID(9)
    >>> active_build.title
    u'i386 build of pmount 0.1-1 in ubuntu warty RELEASE'
    >>> active_build.buildstate.title
    'Failed to build'
    >>> active_build.builder.name
    u'bob'

Since ubuntu/warty is already released the failed build can't be
retried.

    >>> active_build.can_be_retried
    False

We will reactivate ubuntu/warty allowing the pmount build to be
retried.

    >>> from canonical.launchpad.interfaces import DistroSeriesStatus
    >>> login('foo.bar@canonical.com')
    >>> warty.status = DistroSeriesStatus.DEVELOPMENT
    >>> flush_database_updates()
    >>> login(ANONYMOUS)

    >>> active_build.can_be_retried
    True

These are the archive build counters before the build is retried.

    >>> commit()
    >>> print_counts_for_archive(archive_id)
    total: 15, pending: 1, succeeded: 8, building: 1 failed: 5

Retry Build record in question:

    >>> active_build.retry()

Build record has no history and is NEEDSBUILD and a corresponding
BuildQueue record was created.

    >>> active_build.builder is None
    True

    >>> active_build.buildstate.value is 0
    True

    >>> active_build.buildqueue_record is not None
    True

We will restore ubuntu/warty previously changes status, SUPPORTED, so
it won't interfere in the next tests.

    >>> login('foo.bar@canonical.com')
    >>> warty.status = DistroSeriesStatus.SUPPORTED
    >>> flush_database_updates()
    >>> login(ANONYMOUS)

The archive build counters will reflect the retried build.

    >>> print_counts_for_archive(archive_id)
    total: 15, pending: 2, succeeded: 8, building: 1 failed: 4

Initialize all the required arguments to create a binary package for a
given build record entry.

    >>> from canonical.launchpad.interfaces import IBinaryPackageNameSet
    >>> binarypackagename = getUtility(IBinaryPackageNameSet).ensure('demo').id
    >>> version = '0.0.1-demo'
    >>> summary = 'Summmmmmmmary'
    >>> description = 'Descripppppppption'
    >>> from canonical.launchpad.interfaces import BinaryPackageFormat
    >>> binpackageformat = BinaryPackageFormat.DEB
    >>> component = firefox_build.sourcepackagerelease.component.id
    >>> section = firefox_build.sourcepackagerelease.section.id
    >>> from canonical.launchpad.interfaces import PackagePublishingPriority
    >>> priority = PackagePublishingPriority.STANDARD
    >>> shlibdeps = None
    >>> depends = None
    >>> recommends = None
    >>> suggests = None
    >>> conflicts = None
    >>> replaces = None
    >>> provides = None
    >>> essential = False
    >>> installedsize = 0
    >>> architecturespecific = False
    >>> pre_depends = None
    >>> enhances = None
    >>> breaks = None

Invoke createBinaryPackageRelease with all required arguments.

    >>> bin = pmount_build.createBinaryPackageRelease(
    ...     binarypackagename, version, summary, description,
    ...     binpackageformat, component, section, priority, shlibdeps,
    ...     depends, recommends, suggests, conflicts, replaces, provides,
    ...     pre_depends, enhances, breaks, essential, installedsize,
    ...     architecturespecific)

    >>> from canonical.launchpad.interfaces import IBinaryPackageRelease
    >>> verifyObject(IBinaryPackageRelease, bin)
    True


Commit previous transaction, data we want to preserve:
XXX: flush_database_updates() shouldn't be needed. This seems to be
Bug 3989 -- StuarBishop 20060713

    >>> flush_database_updates()
    >>> transaction.commit()

Check binarypackages property:

    >>> for b in pmount_build.binarypackages:
    ...     b.version
    u'0.0.1-demo'
    u'0.1-1'

Emulate a huge list of binaries for 'pmount':

    >>> bpnameset = getUtility(IBinaryPackageNameSet)
    >>> for i in range(15):
    ...     version = "%d" % i
    ...     binarypackagename = bpnameset.ensure("test-%d" % i).id
    ...     b = pmount_build.createBinaryPackageRelease(
    ...         binarypackagename, version, summary, description,
    ...         binpackageformat, component, section, priority, shlibdeps,
    ...         depends, recommends, suggests, conflicts, replaces, provides,
    ...         pre_depends, enhances, breaks, essential, installedsize,
    ...         architecturespecific)


Check if the property still working:

    >>> len(pmount_build.binarypackages)
    17

Ensure the list is ordered by 'name'

    >>> for b in pmount_build.binarypackages:
    ...     b.name, b.version
    (u'demo', u'0.0.1-demo')
    (u'pmount', u'0.1-1')
    (u'test-0', u'0')
    (u'test-1', u'1')
    (u'test-10', u'10')
    (u'test-11', u'11')
    (u'test-12', u'12')
    (u'test-13', u'13')
    (u'test-14', u'14')
    (u'test-2', u'2')
    (u'test-3', u'3')
    (u'test-4', u'4')
    (u'test-5', u'5')
    (u'test-6', u'6')
    (u'test-7', u'7')
    (u'test-8', u'8')
    (u'test-9', u'9')

Rollback transaction to no disturb the other tests:

    >>> transaction.abort()


== The BuildSet Class ==

The BuildSet class gives us some useful ways to consider the
collection of builds.

    >>> bs = getUtility(IBuildSet)

We can find builds given a source package release and architecture tag.

    >>> bs.getBuildBySRAndArchtag(20,'i386').count()
    4

IHasBuildRecords uses a base method provided by IBuildSet,
getBuildsByArchIds():

It receives list of architectures IDs:

    >>> arch_ids = [arch.id for arch in hoary.architectures]
    >>> bs.getBuildsByArchIds(arch_ids).count()
    5

It still working for empty list or None:

    >>> bs.getBuildsByArchIds([]).count()
    0

    >>> bs.getBuildsByArchIds(None).count()
    0

Using build status, only the successfully built ones:

    >>> bs.getBuildsByArchIds(arch_ids,
    ...     status=BuildStatus.FULLYBUILT).count()
    2

Check the result content:

    >>> [b.title for b in bs.getBuildsByArchIds(arch_ids,
    ...     status=BuildStatus.FULLYBUILT)]
    [u'i386 build of pmount 0.1-1 in ubuntu hoary RELEASE', u'hppa build
    of pmount 0.1-1 in ubuntu hoary RELEASE']

Using optional 'name' filter (matching with SQL LIKE %||filter||%)

    >>> bs.getBuildsByArchIds(arch_ids,
    ...     status=BuildStatus.FULLYBUILT,
    ...     name='pmo').count()
    2

Checking optional 'pocket' restriction:

    >>> from canonical.launchpad.interfaces import PackagePublishingPocket
    >>> bs.getBuildsByArchIds(arch_ids,
    ...     pocket=PackagePublishingPocket.UPDATES).count()
    0

    >>> bs.getBuildsByArchIds(arch_ids,
    ...     pocket=PackagePublishingPocket.RELEASE).count()
    5

getBuildsByArchIds will also return builds for archives other than the
primary archive.

    >>> arch_ids = [arch.id for arch in breezy.architectures]
    >>> [(build.archive.purpose.name, build.title) for build in
    ...    bs.getBuildsByArchIds(arch_ids, name='commercialpackage')]
    [('PARTNER', u'i386 build of commercialpackage 1.0-1 in ubuntu breezy-autotest RELEASE')]


== IHadBuildRecords.getBuildRecords() Implementations ==

We can find recent and pending builds for a given distroseries.

    >>> hoary.getBuildRecords().count()
    5

Or for a given distroarchseries.

    >>> hoaryi386 = hoary['i386']
    >>> hoaryi386.title
    u'The Hoary Hedgehog Release for i386 (x86)'

Exercises IHasBuildRecords abilities for distroarchseriess

    >>> hoaryi386.getBuildRecords().count()
    4

    >>> hoaryi386.getBuildRecords(build_state=BuildStatus.FULLYBUILT).count()
    1

    >>> hoaryi386.getBuildRecords(name='pm').count()
    1

    >>> hoaryi386.getBuildRecords(
    ...     pocket=PackagePublishingPocket.RELEASE).count()
    4

    >>> hoaryi386.getBuildRecords(
    ...     pocket=PackagePublishingPocket.UPDATES).count()
    0


Same for distroseries:

    >>> hoary.getBuildRecords().count()
    5

    >>> hoary.getBuildRecords(build_state=BuildStatus.FULLYBUILT).count()
    2

    >>> hoary.getBuildRecords(name='pm').count()
    2

    >>> hoary.getBuildRecords(
    ...     pocket=PackagePublishingPocket.RELEASE).count()
    5

    >>> hoary.getBuildRecords(
    ...     pocket=PackagePublishingPocket.UPDATES).count()
    0


For sourcepackage:

    >>> firefox = warty.getSourcePackage('mozilla-firefox')

    >>> firefox.getBuildRecords().count()
    10

    >>> firefox.getBuildRecords(build_state=BuildStatus.FULLYBUILT).count()
    8

    >>> firefox.getBuildRecords(
    ...     pocket=PackagePublishingPocket.RELEASE).count()
    10

    >>> firefox.getBuildRecords(
    ...     pocket=PackagePublishingPocket.UPDATES).count()
    0

getBuildRecords will return builds for packages that are no longer currently
published. "pmount" is published twice in hoary, one is PUBLISHED and the
other is SUPERSEDED.  The published package does not have any builds but
the superseded one does.

    >>> from zope.security.proxy import removeSecurityProxy
    >>> from canonical.launchpad.interfaces import PackagePublishingStatus
    >>> hoary_pmount = removeSecurityProxy(hoary.getSourcePackage('pmount'))
    >>> published_hoary_pmount = hoary_pmount._getPublishingHistory(
    ...     include_status=[PackagePublishingStatus.PUBLISHED])
    >>> published_hoary_pmount.count()
    1
    >>> published_hoary_pmount[0].sourcepackagerelease.builds.count()
    0
    >>> hoary_pmount.getBuildRecords().count()
    5


For a given distribution as well:

    >>> ubuntu.getBuildRecords().count()
    17

    >>> L = ubuntu.getBuildRecords(build_state=BuildStatus.FULLYBUILT)
    >>> for l in L:
    ...     print l.datebuilt, l.id, l.buildstate.value
    2007-08-10 00:00:13+00:00 30 1
    2007-08-09 23:59:59+00:00 29 1
    2005-03-25 00:00:01+00:00 7 1
    2005-03-25 00:00:01+00:00 16 1
    2005-03-25 00:00:01+00:00 19 1
    2004-09-27 11:57:13+00:00 2 1
    2004-09-27 11:57:13+00:00 18 1

Retrieve the current PENDING builds

    >>> builds = ubuntu.getBuildRecords(build_state=BuildStatus.NEEDSBUILD)
    >>> builds.count()
    2

Note, by ordering the build by BuildQueue.lastscore, it already notice
the existence of a new pending build, since retry already creates a
new BuildQueue record:

    >>> builds = ubuntu.getBuildRecords(build_state=BuildStatus.NEEDSBUILD)
    >>> builds.count()
    2

Note that they are ordered by DESC lastscore, as expected:

    >>> for b in builds:
    ...     b.id, b.buildstate.value, b.buildqueue_record.lastscore
    (11, 0, 10)
    (9, 0, 0)

Using the optional name argument to filter build results:

    >>> builds = ubuntu.getBuildRecords(name='pm')
    >>> builds.count()
    4
    >>> [(b.sourcepackagerelease.name, b.distroseries.name) for b in builds]
    [(u'pmount', u'warty'), (u'pmount', u'hoary'), (u'pmount', u'hoary'),
    (u'pmount', u'breezy-autotest')]

or using optional pocket argument:

    >>> from canonical.launchpad.interfaces import PackagePublishingPocket

    >>> ubuntu.getBuildRecords(
    ...    build_state=BuildStatus.NEEDSBUILD,
    ...    pocket=PackagePublishingPocket.RELEASE).count()
    2

    >>> ubuntu.getBuildRecords(
    ...    build_state=BuildStatus.NEEDSBUILD,
    ...    pocket=PackagePublishingPocket.SECURITY).count()
    0

IHasBuildRecords is implemented by Builder.  It can filter on build state
and name.  A user can also be passed for security checks on private builds;
if user is not passed then the query runs anonymously which means private
builds are excluded from anything returned.

Log in as admin to avoid security on IBuild for the moment.

    >>> login('foo.bar@canonical.com')

Let's make cprov's archive private (and hence its builds become private):

    >>> from canonical.launchpad.interfaces import IPersonSet
    >>> cprov = removeSecurityProxy(getUtility(IPersonSet).getByName('cprov'))
    >>> cprov.archive.buildd_secret = "secret"
    >>> cprov.archive.private = True
    >>> flush_database_updates()

Now define a helper function to print out build details:

    >>> def print_build_details(builds):
    ...     for build in builds:
    ...         if build.archive.owner:
    ...             print "%s: %s" % (build.archive.owner.name, build.title)
    ...         else:
    ...             print "main: %s" % (build.title)

The default set of builds with no user specified excludes private builds:

    >>> from canonical.launchpad.interfaces import IBuilderSet
    >>> bob = getUtility(IBuilderSet)['bob']
    >>> bob_builds = bob.getBuildRecords()
    >>> print_build_details(bob_builds)
    ubuntu-team: hppa build of mozilla-firefox 0.9 in ubuntu warty RELEASE
    no-priv: i386 build of cdrkit 1.0 in ubuntu warty RELEASE
    ubuntu-team: i386 build of cdrkit 1.0 in ubuntu breezy-autotest RELEASE
    ...
    ubuntu-team: i386 build of mozilla-firefox 0.9 in ubuntu warty RELEASE

    >>> bob_builds.count()
    13

If we include an admin user, we can see all the builds.  Here, we get
three additional private builds for cprov:

    >>> from canonical.launchpad.interfaces import ILaunchpadCelebrities
    >>> admin = getUtility(ILaunchpadCelebrities).admin
    >>> bob_builds = bob.getBuildRecords(user=admin)
    >>> print_build_details(bob_builds)
    cprov: hppa build of mozilla-firefox 0.9 in ubuntu warty RELEASE
    ubuntu-team: hppa build of mozilla-firefox 0.9 in ubuntu warty RELEASE
    cprov: i386 build of pmount 0.1-1 in ubuntu warty RELEASE
    cprov: i386 build of cdrkit 1.0 in ubuntu breezy-autotest RELEASE
    no-priv: i386 build of cdrkit 1.0 in ubuntu warty RELEASE
    ubuntu-team: i386 build of cdrkit 1.0 in ubuntu breezy-autotest RELEASE
    ...
    ubuntu-team: i386 build of mozilla-firefox 0.9 in ubuntu warty RELEASE

    >>> bob_builds.count()
    16

Cprov can also see his own builds of course:

    >>> bob_builds = bob.getBuildRecords(user=cprov)
    >>> print_build_details(bob_builds)
    cprov: hppa build of mozilla-firefox 0.9 in ubuntu warty RELEASE
    ubuntu-team: hppa build of mozilla-firefox 0.9 in ubuntu warty RELEASE
    cprov: i386 build of pmount 0.1-1 in ubuntu warty RELEASE
    cprov: i386 build of cdrkit 1.0 in ubuntu breezy-autotest RELEASE
    no-priv: i386 build of cdrkit 1.0 in ubuntu warty RELEASE
    ubuntu-team: i386 build of cdrkit 1.0 in ubuntu breezy-autotest RELEASE
    ...
    ubuntu-team: i386 build of mozilla-firefox 0.9 in ubuntu warty RELEASE

You can filter on build state:

    >>> bob_failed_builds = bob.getBuildRecords(
    ...     build_state=BuildStatus.FAILEDTOBUILD, user=admin)
    >>> bob_failed_builds.count()
    3

You can filter on package name:

    >>> bob_pmount_builds = bob.getBuildRecords(name='pmount', user=admin)
    >>> bob_pmount_builds.count()
    4

You can filter on build state and package name:

    >>> bob_pmount_ok_builds = bob.getBuildRecords(
    ...    build_state=BuildStatus.FULLYBUILT, name='pmount', user=admin)
    >>> bob_pmount_ok_builds.count()
    4

Restore cprov to non-private:

    >>> login('foo.bar@canonical.com')
    >>> removeSecurityProxy(cprov).archive.private = False
    >>> flush_database_updates()
    >>> login(ANONYMOUS)


== AssertionErrors in IBuild ==

Build records inserted by gina don't provide calculated_buildstart
value, since they miss fields used in its calculation.

    >>> gina_build = getUtility(IBuildSet).getByBuildID(10)
    >>> gina_build.title
    u'i386 build of cnews cr.g7-37 in ubuntu warty RELEASE'

even if IBuild.was_built return true:

    >>> gina_build.was_built
    True

this method is protected by an assertion on valid buildduration and
datebuilt, it makes the diagnosis of problems in current DB easier.

    >>> gina_build.calculated_buildstart
    Traceback (most recent call last):
    ...
    AssertionError: value is not suitable for this build record (10)

Only builds in failed_states (FAILEDTOBUILD, MANUALDEPWAIT and
CHROOTWAIT) can be retried. We must check if Soyuz is able to accept
its result in case of success, i.e., we should not be able to retry a
build for a released pocket.

All those conditions are controlled by IBuild.can_be_retried() property
(see above).

    >>> failed_build = getUtility(IBuildSet).getByBuildID(6)

    >>> failed_build.title
    u'i386 build of foobar 1.0 in ubuntu warty RELEASE'

    >>> failed_build.buildstate.name
    'FAILEDTOBUILD'

    >>> failed_build.can_be_retried
    False

Attempt to retry this build record will fail with an AssertionError:

    >>> failed_build.retry()
    Traceback (most recent call last):
    ...
    AssertionError: Build 6 cannot be retried

Partner archive builds are an exception to this rule; they can be retried
in the release pocket for a released distro.  Let's turn build 9 into a
partner archive build:

    >>> partner_archive = ubuntu.getArchiveByComponent('partner')
    >>> removeSecurityProxy(failed_build).archive = partner_archive

The build can now be re-tried:

    >>> failed_build.can_be_retried
    True

Similarly to PPA builds, they can be retried for release pockets since
they will happen in another archive.

    >>> removeSecurityProxy(failed_build).archive = cprov.archive

    >>> failed_build.can_be_retried
    True


== 'Ogre' components ==

The ubuntu 'ogre-model' ensures that build dependencies are
consistently spread according the source target component, i.e. a
source published in 'main' component is only allowed to depend on
binaries also published in 'main', on the other hand a source
published in 'universe' is allowed to depend on binaries published in
'main' and 'universe' components.

A proper name for this "model" would be 'cross-component-dependency'.

    >>> from canonical.launchpad.interfaces import IComponentSet
    >>> from canonical.launchpad.ftests import syncUpdate
    >>> from canonical.database.sqlbase import flush_database_caches

    >>> login('foo.bar@canonical.com')

    >>> build = getUtility(IBuildSet).getByBuildID(12)

    >>> source_pub = hoary.getSourcePackage(
    ...     'libstdc++').currentrelease.current_published

    >>> ubuntu_components = [
    ...     'main', 'restricted', 'universe', 'multiverse', 'partner']

    >>> def testOgreComponents():
    ...     print " Component | Ogre-Model"
    ...     print "-----------+---------------"
    ...     for component in ubuntu_components:
    ...         component = getUtility(IComponentSet)[component]
    ...         source_pub.secure_record.component = component
    ...         syncUpdate(source_pub.secure_record)
    ...         flush_database_caches()
    ...         print '%10s | %s' % (build.current_component.name,
    ...                              " ".join(build.ogre_components))

    >>> testOgreComponents()
     Component | Ogre-Model
    -----------+---------------
          main | main
    restricted | main restricted
      universe | main universe
    multiverse | main restricted universe multiverse
       partner | partner

As reported in bug #198936, builds for the BACKPORTS pocket are
allowed to use any component available, independently of the component they are
currently published. This special-case is important because it
avoids changes to accommodate the backported source in the already
released series.

    >>> release_pocket = build.pocket
    >>> naked_build = removeSecurityProxy(build)
    >>> naked_build.pocket = PackagePublishingPocket.BACKPORTS
    >>> syncUpdate(build)

Ultimately, it means that a build targeted to the BACKPORTS pocket
will behave as if it were published in the multiverse component,
despite the component it is actually published in.

    >>> testOgreComponents()
     Component | Ogre-Model
    -----------+---------------
          main | main restricted universe multiverse
    restricted | main restricted universe multiverse
      universe | main restricted universe multiverse
    multiverse | main restricted universe multiverse
       partner | main restricted universe multiverse

Restoring the original target component to the source used in this
section, so there won't be any unexpected effects in subsequent
tests.

    >>> main_component = getUtility(IComponentSet)['main']
    >>> source_pub.secure_record.component = main_component
    >>> syncUpdate(source_pub.secure_record)
    >>> naked_build = removeSecurityProxy(build)
    >>> naked_build.pocket = release_pocket
    >>> syncUpdate(build)
    >>> flush_database_caches()
    >>> login(ANONYMOUS)


== Updating build-dependencies line ==

The IBuild.dependencies field is only filled when a build job is
collected as MANUALDEPWAIT, its content is informed by the
buildd-slave in the apt-dependencies format.

    >>> depwait_build = getUtility(IBuildSet).getByBuildID(12)
    >>> print depwait_build.dependencies
    cpp (>= 4:4.0.1-3), gcc-4.0 (>= 4.0.1-2)

IBuild.updateDependencies is designed to process this field and
eliminate dependencies that can be satisfied. It is used as part of the
auto-depwait processing where all builds marked as MANUALDEPWAIT are
re-processed and the ones with empty dependencies are re-queued.

If nothing has changed, which is the case of the current
depwait_build, the 'dependencies' field remains the same.

    >>> old_dep = depwait_build.dependencies
    >>> depwait_build.updateDependencies()
    >>> depwait_build.dependencies == old_dep
    True

A dependency can only be used if it is an a component allowed in our
context (see above on 'Ogre' components). If we do a build using a
dependency available in the sample data but published in an unreachable
component, we will see that the dependency is considered to be unsatisfied.
See also bug 177827.

    >>> depwait_build.dependencies = 'pmount'
    >>> flush_database_updates()

'pmount' in hoary/i386 is published in the 'universe' component:

    >>> hoary_i386 = depwait_build.distroarchseries
    >>> pmount_pub = hoary_i386[
    ...     'pmount'].currentrelease.current_publishing_record
    >>> print pmount_pub.component.name
    universe

The build is only allowed to depend on packages published in 'main':

    >>> print depwait_build.current_component.name
    main

    >>> print depwait_build.ogre_components
    ['main']

Thus the 'pmount' dependency remains unsatisfied.

    >>> depwait_build.updateDependencies()
    >>> print depwait_build.dependencies
    pmount

If we make pmount in hoary/i386 reachable, by moving it to the 'main'
component, we can see that it will be excluded from the dependencies
list.

    >>> login('foo.bar@canonical.com')
    >>> pmount_pub.secure_record.component = main_component
    >>> from canonical.database.sqlbase import flush_database_caches
    >>> flush_database_caches()
    >>> login(ANONYMOUS)

    >>> depwait_build.dependencies = 'mozilla-firefox, pmount'
    >>> flush_database_updates()

Note that only the satisfied dependencies are removed the build
dependency list.

    >>> depwait_build.updateDependencies()
    >>> print depwait_build.dependencies
    mozilla-firefox

'pmount' dependency is also satisfied in the Celso's PPA context,
even when it is published in a component not allowed in its current
component domain ('ogre_components'). That's because PPAs implicitly
depend on all components of its distribution PRIMARY archive.

    >>> depwait_build.dependencies = 'biscuit, pmount'

    >>> login('foo.bar@canonical.com')
    >>> universe_component = getUtility(IComponentSet)['universe']
    >>> pmount_pub.secure_record.component = universe_component
    >>> removeSecurityProxy(depwait_build).archive = cprov.archive
    >>> flush_database_caches()
    >>> login(ANONYMOUS)

    >>> print depwait_build.ogre_components
    ['main']

    >>> print pmount_pub.component.name
    universe

    >>> depwait_build.updateDependencies()
    >>> print depwait_build.dependencies
    biscuit

Restore depwait_build previous state.

    >>> login('foo.bar@canonical.com')
    >>> pmount_pub.secure_record.component = main_component
    >>> removeSecurityProxy(depwait_build).archive = hoary.main_archive
    >>> flush_database_caches()
    >>> login(ANONYMOUS)

=== Retrying DEPWAIT builds ===

It depends on the callsite to decide whether or not to 'retry' a
build after calling updateDependencies, to encapsulate such decision
for performing the mentioned  auto-depwait procedure we have a utility
in IBuildSet called retryDepWaiting().

    >>> print depwait_build.buildstate.name
    MANUALDEPWAIT
    >>> print depwait_build.distroarchseries.title
    The Hoary Hedgehog Release for i386 (x86)

In order to allow depwait_build to be retried we will forge a
'fully-satisfiable' dependencies field.

    >>> depwait_build.dependencies = 'pmount'
    >>> flush_database_updates()

These are the archive build counters before retrying the DEPWAIT build.

    >>> print_counts_for_archive(archive_id)
    total: 15, pending: 2, succeeded: 8, building: 1 failed: 4

Then we can run the utility method for the target distroarchseries and
expect depwait_build to be 'retried' and scored.

    >>> getUtility(IBuildSet).retryDepWaiting(hoaryi386)

    >>> print depwait_build.buildstate.name
    NEEDSBUILD

    >>> depwait_build.buildqueue_record.lastscore
    4005

The 'retryDepWaiting' task is performed periodically via cronjob by
cronscript/buildd-retry-depwait.py. It can be run in parallel with
other buildd tasks because the procedure is 'atomic' enough, i.e.,
after the commit the retried jobs are ready to be dispatched.

The archive build counters will reflect the retried build.

    >>> print_counts_for_archive(archive_id)
    total: 15, pending: 3, succeeded: 8, building: 1 failed: 3

Please note that the repeated setting of the same build state value
has no bearing on the archive counters.

    >>> depwait_build.buildstate = BuildStatus.NEEDSBUILD
    >>> depwait_build.buildstate = BuildStatus.NEEDSBUILD
    >>> print_counts_for_archive(archive_id)
    total: 15, pending: 3, succeeded: 8, building: 1 failed: 3

Invalid build state transitions will result in an assertion error,
e.g.:

    >>> depwait_build.buildstate = BuildStatus.FULLYBUILT
    Traceback (most recent call last):
    ...
    AssertionError: ... failure (Needs building -> Successfully built)


== Build record security ==

IBuild's content class is wrapped in a Zope security wrapper that prevents
access to private builds for unauthorised users.

cprov's archive is private which makes its builds private.

    >>> login('foo.bar@canonical.com')
    >>> removeSecurityProxy(cprov).archive.private = True
    >>> flush_database_updates()

Accessing the cprov builds when logged in as admin will see the records:

    >>> bob_builds = bob.getBuildRecords(user=admin)
    >>> print_build_details(bob_builds)
    cprov: hppa build of mozilla-firefox 0.9 in ubuntu warty RELEASE
    ubuntu-team: hppa build of mozilla-firefox 0.9 in ubuntu warty RELEASE
    cprov: i386 build of pmount 0.1-1 in ubuntu warty RELEASE
    cprov: i386 build of cdrkit 1.0 in ubuntu breezy-autotest RELEASE
    ...

Likewise when logged in as cprov:

    >>> login('celso.providelo@canonical.com')
    >>> bob_builds = bob.getBuildRecords(user=admin)
    >>> print_build_details(bob_builds)
    cprov: hppa build of mozilla-firefox 0.9 in ubuntu warty RELEASE
    ubuntu-team: hppa build of mozilla-firefox 0.9 in ubuntu warty RELEASE
    cprov: i386 build of pmount 0.1-1 in ubuntu warty RELEASE
    cprov: i386 build of cdrkit 1.0 in ubuntu breezy-autotest RELEASE
    ...

When logged in as anonymous this will generate a securtity exception
when accessing the builds:

    >>> from zope.security.interfaces import Unauthorized
    >>> login(ANONYMOUS)
    >>> bob_builds = bob.getBuildRecords(user=admin)
    >>> try:
    ...     print_build_details(bob_builds)
    ... except Unauthorized:
    ...     print "Generated Unauthorized exception as expected"
    ... else:
    ...     print "FAIL: should raise Unauthorized exception"
    cprov: hppa build of mozilla-firefox 0.9 in ubuntu warty RELEASE
    ubuntu-team: hppa build of mozilla-firefox 0.9 in ubuntu warty RELEASE
    Generated Unauthorized exception as expected

== Estimated Build Duration ==

Newly created builds should have their 'estimated_build_duration' times
set from previous builds' 'buildduration' values.

We will use SoyuzTestPublisher to generate coherent publications to
test this behaviour.

    >>> from canonical.launchpad.tests.test_publishing import (
    ...      SoyuzTestPublisher)
    >>> test_publisher = SoyuzTestPublisher()
    >>> login('foo.bar@canonical.com')
    >>> test_publisher.prepareBreezyAutotest()

Create oldest SourcePackageRelease instance.

    >>> oldest_spr = test_publisher.getPubSource(
    ...     status=PackagePublishingStatus.PUBLISHED,
    ...     sourcename='ebdtest')

Create oldest build instance.

    >>> from datetime import datetime, timedelta
    >>> import pytz
    >>> UTC = pytz.timezone('UTC')
    >>> oldest_build = oldest_spr.sourcepackagerelease.createBuild(
    ...         test_publisher.breezy_autotest_hppa,
    ...         PackagePublishingPocket.UPDATES,
    ...         test_publisher.breezy_autotest.main_archive,
    ...         status=BuildStatus.FULLYBUILT)
    >>> oldest_build.buildduration = timedelta(minutes=72)
    >>> oldest_build.datebuilt = datetime(2008, 4, 1, 10, 45, 39, tzinfo=UTC)

Check that the oldest build instance's 'estimated_build_duration'
is initialized based on its package size. Since the latter is very
small (less than a KB) the 'estimated_build_duration' will be a
minute.

    >>> oldest_build.estimated_build_duration
    datetime.timedelta(0, 60)

Create intermediate SourcePackageRelease instance.

    >>> medium_spr = test_publisher.getPubSource(
    ...     status=PackagePublishingStatus.PUBLISHED,
    ...     sourcename='ebdtest')

Create intermediate build instance.

    >>> medium_build = medium_spr.sourcepackagerelease.createBuild(
    ...         test_publisher.breezy_autotest_hppa,
    ...         PackagePublishingPocket.UPDATES,
    ...         test_publisher.breezy_autotest.main_archive,
    ...         status=BuildStatus.FULLYBUILT)
    >>> medium_build.buildduration = timedelta(minutes=60)
    >>> medium_build.datebuilt = datetime(2008, 4, 2, 11, 56, 33, tzinfo=UTC)

Check whether the intermediate build instance's 'estimated_build_duration'
value equals the oldest instance's 'buildduration'.

    >>> medium_build.estimated_build_duration
    datetime.timedelta(0, 4320)

Create most recent SourcePackageRelease instance.

    >>> recent_spr = test_publisher.getPubSource(
    ...     status=PackagePublishingStatus.PUBLISHED,
    ...     sourcename='ebdtest')

Create most recent build instance. Please note: this one is in state
NEEDSBUILD.

    >>> recent_build = recent_spr.sourcepackagerelease.createBuild(
    ...         test_publisher.breezy_autotest_hppa,
    ...         PackagePublishingPocket.UPDATES,
    ...         test_publisher.breezy_autotest.main_archive,
    ...         status=BuildStatus.NEEDSBUILD)

Check whether the most recent build instance's 'estimated_build_duration'
value equals the intermediate instance's 'buildduration'.

    >>> recent_build.estimated_build_duration
    datetime.timedelta(0, 3600)

Create a SourcePackageRelease instance in a PPA.

    >>> ppa_spr = test_publisher.getPubSource(
    ...     status=PackagePublishingStatus.PUBLISHED,
    ...     sourcename='ebdtest')

Create most recent build instance.

    >>> ppa_build = ppa_spr.sourcepackagerelease.createBuild(
    ...         test_publisher.breezy_autotest_hppa,
    ...         PackagePublishingPocket.UPDATES,
    ...         cprov.archive,
    ...         status=BuildStatus.NEEDSBUILD)

Check whether the PPA build instance's 'estimated_build_duration'
value was set from the intermediate instance's 'buildduration' in
the main archive.

    >>> ppa_build.estimated_build_duration
    datetime.timedelta(0, 3600)
