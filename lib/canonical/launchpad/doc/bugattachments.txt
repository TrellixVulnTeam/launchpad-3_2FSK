Bug Attachments
===============

Files can be attached to bugs. There are two types of attachment, Patch
and Unspecified. Patch means a proposed fix to the bug, Unspecified
means a file files that relates to the bug in some other way, like a log
file or a screenshot.

Let's look at a bug that has no attachments:
    >>> from canonical.launchpad.ftests import login
    >>> login("foo.bar@canonical.com")

    >>> from canonical.launchpad.interfaces import (
    ...     IBugSet, IBugAttachmentSet, IBugAttachment, ILibraryFileAliasSet,
    ...     IMessageSet, IPersonSet)
    >>> bugset = getUtility(IBugSet)
    >>> bug_one = bugset.get(1)
    >>> bug_one.attachments.count()
    0

Creating attachments
--------------------

To create an attachment, call IBug.addAttachment. It will emit an
SQLObjectCreatedEvent in order to trigger email notifications:

    >>> from StringIO import StringIO

    >>> from canonical.launchpad.ftests.event import TestEventListener
    >>> from canonical.launchpad.event.interfaces import (
    ...     ISQLObjectCreatedEvent)
    >>> def attachment_added(attachment, event):
    ...     print "Attachment added: %r" % attachment.libraryfile.filename
    >>> event_listener = TestEventListener(
    ...     IBugAttachment, ISQLObjectCreatedEvent, attachment_added)

    >>> filecontent = "Some useful information."
    >>> file_ = StringIO(filecontent)

    >>> foobar = getUtility(IPersonSet).getByName("name16")

    >>> message = getUtility(IMessageSet).fromText(
    ...    subject="test subject",
    ...    content="a comment for the attachment",
    ...    owner=foobar)

    >>> bug_one.addAttachment(
    ...     owner=foobar,
    ...     file_=file_,
    ...     filename="foo.bar",
    ...     description="this fixes the bug",
    ...     comment=message,
    ...     is_patch=False)
    Attachment added: u'foo.bar'
    <BugAttachment ...>

    >>> import transaction
    >>> transaction.commit()

    >>> bug_one.attachments.count()
    1
    >>> attachment = bug_one.attachments[0]
    >>> attachment.type.title
    'Unspecified'

IBug.addAttachment's comment parameter can also be a string.

    >>> file_ = StringIO(filecontent)
    >>> bug_one.addAttachment(
    ...     owner=foobar,
    ...     file_=file_,
    ...     filename="foo.baz",
    ...     description="this fixes the bug",
    ...     comment="a string comment",
    ...     is_patch=False)
    Attachment added: u'foo.baz'
    <BugAttachment ...>

If no description is given, the title is set to the filename.

    >>> file_ = StringIO(filecontent)
    >>> screenshot = bug_one.addAttachment(
    ...     owner=foobar,
    ...     file_=file_,
    ...     filename="screenshot.jpg",
    ...     comment="a string comment",
    ...     is_patch=False)
    Attachment added: u'screenshot.jpg'
    >>> screenshot.title
    u'screenshot.jpg'

The librarian won't allow empty files, so the view that creates the
attachment needs to handle that:

    >>> from zope.app.zapi import getView
    >>> from canonical.launchpad.webapp.servers import LaunchpadTestRequest

    >>> login('test@canonical.com')
    >>> filecontent = StringIO('')
    >>> filecontent.filename = 'foo.bar'
    >>> add_request = LaunchpadTestRequest(
    ...     method="POST",
    ...     form={'field.subject': u'Title',
    ...           'field.comment': u'Some comment.',
    ...           'field.filecontent': filecontent,
    ...           'field.patch': u'',
    ...           'field.actions.save': 'Save Changes'})

Note that the +addcomment-form view is actually registered on a "bug in
context", i.e. an IBugTask, so let's grab the first bugtask on bug_one
and work with that:

    >>> bugtask = bug_one.bugtasks[0]
    >>> from canonical.launchpad.browser import BugMessageAddFormView

    >>> add_comment_view = getView(bugtask, '+addcomment-form', add_request)
    >>> add_comment_view.initialize()
    >>> len(add_comment_view.errors)
    1
    >>> add_comment_view.error_count
    'There is 1 error.'
    >>> add_comment_view.getWidgetError('filecontent')
    u'Cannot upload empty file.'

It's possible to limit the maximum size of the attachments by setting
max_bug_attachment_size in launchpad.conf. The default value for the
testrunner is 1024, so let's create a file larger than that and try to
upload it:

    >>> filecontent = StringIO('x'*1025)
    >>> filecontent.filename = 'foo.txt'
    >>> add_request = LaunchpadTestRequest(
    ...     method="POST",
    ...     form={'field.subject': u'Title',
    ...           'field.comment': u'Some comment.',
    ...           'field.include_attachment': 'on',
    ...           'field.filecontent': filecontent,
    ...           'field.attachment_description': 'blah',
    ...           'field.patch': u'',
    ...           'field.actions.save' : 'Save Changes'})
    >>> add_comment_view = getView(bugtask, '+addcomment-form', add_request)
    >>> add_comment_view.initialize()
    >>> len(add_comment_view.errors)
    1
    >>> [error.doc() for error in add_comment_view.errors]
    [u'Cannot upload files larger than 1024 bytes']

If we set the limit to 0 we can upload it, though, since a value of 0
means no limit:

    >>> from canonical.config import config
    >>> old_max_bug_attachment_size = config.launchpad.max_bug_attachment_size
    >>> config.launchpad.max_bug_attachment_size = 0
    >>> add_request = LaunchpadTestRequest(
    ...     method="POST",
    ...     form={'field.subject': u'Title',
    ...           'field.comment': u'Some comment.',
    ...           'field.include_attachment': 'on',
    ...           'field.filecontent': filecontent,
    ...           'field.attachment_description': 'blah',
    ...           'field.patch': u'',
    ...           'field.actions.save' : 'Save Changes'})
    >>> add_comment_view = getView(bugtask, '+addcomment-form', add_request)
    >>> add_comment_view.initialize()
    Attachment added: u'foo.txt'
    >>> len(add_comment_view.errors)
    0

The request must contain either a comment or an attachment or both, but it
must have at least one.

    >>> add_request = LaunchpadTestRequest(
    ...     method="POST",
    ...     form={'field.subject': u'Title',
    ...           'field.patch': u'',
    ...           'field.actions.save': 'Save Changes'})
    >>> add_comment_view = getView(bugtask, '+addcomment-form', add_request)
    >>> add_comment_view.initialize()
    >>> len(add_comment_view.errors)
    1
    >>> [error for error in add_comment_view.errors]
    ['Either a comment or attachment must be provided.']
    
If the request contains no attachment description the filename should be used.
    
    >>> filecontent = StringIO("No, sir. That's one bonehead name, but that ain't me any more.")
    >>> filecontent.filename = 'RA.txt'
    >>> add_request = LaunchpadTestRequest(
    ...     method="POST",
    ...     form={'field.subject': u'Title',
    ...           'field.comment': u'Some comment.',
    ...           'field.filecontent': filecontent,
    ...           'field.patch': u'',
    ...           'field.actions.save': 'Save Changes'})
    >>> add_comment_view = getView(bugtask, '+addcomment-form', add_request)
    >>> add_comment_view.initialize()
    Attachment added: u'RA.txt'
    >>> len(add_comment_view.errors)
    0
    >>> bug_one.attachments[-1].title
    u'RA.txt'


Since the SQLObjectCreatedEvent was generated, a notification about the
attachment was added.

    >>> from canonical.launchpad.database import BugNotification
    >>> latest_notification = BugNotification.selectFirst(orderBy='-id')
    >>> print latest_notification.message.text_contents
    ** Attachment added: "RA.txt"
       http://.../RA.txt

Let's try uploading a file with some weird characters in them:

    >>> filecontent.filename = u'fo\xf6 bar'
    >>> add_request = LaunchpadTestRequest(
    ...     method="POST",
    ...     form={'field.subject': u'Title',
    ...           'field.comment': u'Some comment.',
    ...           'field.include_attachment': 'on',
    ...           'field.filecontent': filecontent,
    ...           'field.attachment_description': 'blah',
    ...           'field.patch': u'',
    ...           'field.actions.save' : 'Save Changes'})
    >>> add_comment_view = getView(bugtask, '+addcomment-form', add_request)
    >>> len(add_comment_view.errors)
    0
    >>> add_comment_view.initialize()
    Attachment added: u'fo\xf6 bar'
    >>> len(add_comment_view.errors)
    0
    >>> bug_one.attachments[-1].libraryfile.filename
    u'fo\xf6 bar'
    >>> bug_one.attachments[-1].libraryfile.http_url
    'http://.../fo%C3%B6%20bar'

If a filename contains a slash, it will be converted to a dash instead.
We do this since otherwise it won't be possible to download the file
from the librarian.

    >>> filecontent.filename = u'foo/bar/baz'
    >>> add_request = LaunchpadTestRequest(
    ...     method="POST",
    ...     form={'field.subject': u'Title',
    ...           'field.comment': u'Some comment.',
    ...           'field.include_attachment': 'on',
    ...           'field.filecontent': filecontent,
    ...           'field.attachment_description': 'blah',
    ...           'field.patch': u'',
    ...           'field.actions.save' : 'Save Changes'})
    >>> add_comment_view = getView(bugtask, '+addcomment-form', add_request)
    >>> add_comment_view.initialize()
    Attachment added: u'foo-bar-baz'
    >>> len(add_comment_view.errors)
    0
    >>> bug_one.attachments[-1].libraryfile.filename
    u'foo-bar-baz'
    >>> bug_one.attachments[-1].libraryfile.http_url
    'http://.../foo-bar-baz'

    >>> config.launchpad.max_bug_attachment_size = old_max_bug_attachment_size
    >>> event_listener.unregister()

Security
--------

If a user can view/edit the bug the attachment is attached to, he can
also view/edit the attachment. At the moment the bug_one is public, so
anonymous can read the attachment's attributes, but he can't set them:

    >>> login(ANONYMOUS)
    >>> attachment.title
    u'this fixes the bug'
    >>> attachment.title = 'Better Title'
    Traceback (most recent call last):
    ...
    Unauthorized: (..., 'title',...

Both Sample Person and Foo Bar can access and set the attributes, though:

    >>> login('test@canonical.com')
    >>> attachment.title
    u'this fixes the bug'
    >>> attachment.title = 'Better Title'

    >>> login('foo.bar@canonical.com')
    >>> attachment.title
    u'Better Title'
    >>> attachment.title = 'Even Better Title'

Now let's make the bug private instead:

    >>> bug_one.setPrivate(True, getUtility(ILaunchBag).user)
    True

Foo Bar isn't explicitly subscribed to the bug, BUT he is an admin, so he can
access and set the attachment's attributes:

    >>> attachment.title
    u'Even Better Title'
    >>> attachment.title = 'Even Better Title'

Mr. No Privs, who is not subscribed to bug_one, cannot access or set the
attachments attributes:

    >>> login("no-priv@canonical.com")

    >>> attachment.title
    Traceback (most recent call last):
    ...
    Unauthorized: (..., 'title',...
    >>> attachment.title = 'Better Title'
    Traceback (most recent call last):
    ...
    Unauthorized: (..., 'title',...

Of course, anonymous is also not allowed to access or set the them:

    >>> login(ANONYMOUS)
    >>> attachment.title
    Traceback (most recent call last):
    ...
    Unauthorized: (..., 'title',...
    >>> attachment.title = 'Some info.'
    Traceback (most recent call last):
    ...
    Unauthorized: (..., 'title',...

Sample Person is explicitly subscribed, so he can both access and set
the attributes:

    >>> login('test@canonical.com')
    >>> attachment.title
    u'Even Better Title'
    >>> attachment.title = 'Better Title'


Let's make the bug public again:

    >>> bug_one.setPrivate(False, getUtility(ILaunchBag).user)
    True


Search for attachments
----------------------

We can search for attachment of a specific types:

    >>> from canonical.launchpad.interfaces import (
    ...     IBugTaskSet, BugTaskSearchParams)
    >>> from canonical.lp.dbschema import BugAttachmentType
    >>> bugtaskset = getUtility(IBugTaskSet)
    >>> attachmenttype = BugAttachmentType.UNSPECIFIED
    >>> params = BugTaskSearchParams(attachmenttype=attachmenttype, user=None)
    >>> bugtasks = bugtaskset.search(params)
    >>> bugs = set([bugtask.bug for bugtask in bugtasks])
    >>> bugs = list(bugs)
    >>> len(bugs)
    1
    >>> bugs[0].id
    1

    >>> from canonical.launchpad.searchbuilder import any
    >>> attachmenttype = any(*BugAttachmentType.items)
    >>> params = BugTaskSearchParams(attachmenttype=attachmenttype, user=None)
    >>> bugtasks = bugtaskset.search(params)
    >>> bugs = set([bugtask.bug for bugtask in bugtasks])
    >>> bugs = list(bugs)
    >>> len(bugs)
    1
    >>> bugs[0].id
    1

There are no patches attached to any bugs:

    >>> attachmenttype = BugAttachmentType.PATCH
    >>> params = BugTaskSearchParams(attachmenttype=attachmenttype, user=None)
    >>> bugtasks = bugtaskset.search(params)
    >>> bugs = set([bugtask.bug for bugtask in bugtasks])
    >>> bugs = list(bugs)
    >>> len(bugs)
    0

Let's make our attachment a patch and search again:

    >>> from canonical.database.sqlbase import flush_database_updates
    >>> login('test@canonical.com')
    >>> attachment.type = BugAttachmentType.PATCH
    >>> flush_database_updates()
    >>> attachmenttype = BugAttachmentType.PATCH
    >>> params = BugTaskSearchParams(attachmenttype=attachmenttype, user=None)
    >>> bugtasks = bugtaskset.search(params)
    >>> bugs = set([bugtask.bug for bugtask in bugtasks])
    >>> bugs = list(bugs)
    >>> len(bugs)
    1
    >>> bugs[0].id
    1

Deleting attachments
--------------------

It's also possible to delete attachments.

    >>> file_ = StringIO(filecontent)
    >>> bug_two = getUtility(IBugSet).get(2)
    >>> attachment = bug_two.addAttachment(
    ...     owner=foobar,
    ...     file_=file_,
    ...     filename="foo.baz",
    ...     description="Attachment to be deleted",
    ...     comment="a string comment",
    ...     is_patch=False)
    >>> for attachment in bug_two.attachments:
    ...     print attachment.title
    Attachment to be deleted

    >>> attachment.removeFromBug()
    >>> bug_two.attachments.count()
    0

Deleting an attachment causes a notification to be sent. It's worth
noting that the notification still includes the URL to the attachment,
which will be valid until the Librarian garbage collector kicks in and
deletes the file entirely. This gives people a chance of undoing an
incorrect removal by downloading and re-attach the file.

    >>> from canonical.launchpad.database import BugNotification
    >>> latest_notification = BugNotification
    >>> latest_notification = BugNotification.selectFirst(orderBy='-id')
    >>> latest_notification.is_comment
    False
    >>> print latest_notification.message.text_contents
    ** Attachment removed: "Attachment to be deleted"
       http://.../foo.baz



    
