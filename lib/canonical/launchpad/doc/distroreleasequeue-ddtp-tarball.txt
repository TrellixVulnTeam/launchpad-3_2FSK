== DDTP-TARBALL upload ==

This test will describe how launchpad treats an upload of DDTP
tarball.

DDTP (Debian Description Translation Project) tarball upload is
consisted of a tarball (specified in the changesfile as a
DDTP-TARBALL) containing all the supported index files for the DDTP
contents driven by component.

The index-files needs to be published in the ubuntu archive, according
its target suite and component, under the 'i18n' (see
http://en.wikipedia.org/wiki/Internationalization_and_localization)
directory.

Soonish APT will be able to download and follow the indexes files,
then present the appropriated translated package description the users
in ubuntu.

For further info about DDTP see:
  https://wiki.ubuntu.com/TranslatedPackageDescriptionsSpec

  >>> from canonical.launchpad.interfaces import (
  ...     IDistributionSet, IDistroReleaseSet, ISourcePackageNameSet)

  >>> from canonical.archivepublisher.nascentupload import NascentUpload
  >>> from canonical.archivepublisher.uploadpolicy import findPolicyByName
  >>> from canonical.archivepublisher.tests import datadir

  >>> distro_release_set = getUtility(IDistroReleaseSet)
  >>> ubuntutest = getUtility(IDistributionSet)['ubuntutest']
  >>> breezy_autotest = ubuntutest['breezy-autotest']

  >>> import logging

  >>> class MockOptions:
  ...     distro = "ubuntutest"

  >>> from canonical.librarian.ftests.harness import LibrarianTestSetup
  >>> LibrarianTestSetup().setUp()

  >>> from canonical.launchpad.interfaces import IGPGKeySet
  >>> from canonical.lp.dbschema import GPGKeyAlgorithm
  >>> discarded_key = getUtility(IGPGKeySet).new(16, '6C64A8C5',
  ...     '340CA3BB270E2716C9EE0B768E7EB7086C64A8C5', 1024, GPGKeyAlgorithm.D)


  >>> from canonical.launchpad.ftests import import_public_test_keys
  >>> import_public_test_keys()

Login as an admin (or ubuntutest.archive_admin if we have one), since
we need to access and modify DistroReleaseQueue records and other tables.

  >>> login('foo.bar@canonical.com')

First, test the rejection of a missapplied changesfile name, which
doesn't follow the accepted format,  "<pkg>_<version>_<arch>.changes"

  >>> upload = NascentUpload(
  ...     findPolicyByName('sync'), datadir(''),
  ...     "translations-main_20060728.changes",
  ...     logging.getLogger())
  >>> mock_options = MockOptions()
  >>> upload.policy.setOptions(mock_options)

  >>> from canonical.archivepublisher.nascentupload import UploadError
  >>> try:
  ...    upload.process()
  ... except UploadError, info:
  ...    print 'BOOM:', info
  BOOM: translations-main_20060728.changes -> missapplied changesfile name, should follow "<pkg>_<version>_<arch>.changes" format


Now do a proper upload into the system.

  >>> class MockLogger:
  ...     def debug(self, s):
  ...         print "DEBUG:", s

  >>> upload = NascentUpload(
  ...     findPolicyByName('insecure'), datadir(''),
  ...     "translations-main_20060728_all.changes",
  ...     MockLogger())


  >>> upload.changes_filename == datadir(
  ...     "translations-main_20060728_all.changes")
  True

  >>> upload.policy.setOptions(mock_options)
  >>> upload.process()
  DEBUG: Beginning processing.
  DEBUG: Checking signature on changes file.
  DEBUG: Verifying signature on translations-main_20060728_all.changes
  DEBUG: Verifying the changes file.
  DEBUG: Verifying files in upload.
  DEBUG: Single Custom Upload detected.
  DEBUG: Finding and applying overrides.
  DEBUG: Foo Bar (16) is in main's uploaders.
  DEBUG: Finished checking upload.

It was not rejected.

  >>> upload.rejected
  False

  >>> success, msgs = upload.do_accept()
  DEBUG: Building recipients list.
  DEBUG: Adding recipient: 'Foo Bar <foo.bar@canonical.com>'
  DEBUG: Creating a New queue entry
  DEBUG: Setting it to ACCEPTED

And all things worked.

  >>> success
  True

  >>> not upload.rejection_message
  True

We need to commit the transaction to be able to use the librarian files.

  >>> import transaction
  >>> transaction.commit()


Let's use the script to fetch the dist-upgrader upload:

  >>> import subprocess
  >>> import os
  >>> import sys
  >>> from canonical.config import config

  >>> script = os.path.join(config.root, "scripts", "ftpmaster-tools",
  ...                       "queue")

  >>> process = subprocess.Popen([sys.executable, script, "-Q", "accepted",
  ...                             "-R", "breezy-autotest", "fetch", "trans",
  ...                             "-D", "ubuntutest"],
  ...                            stdout=subprocess.PIPE)
  >>> stdout, stderr = process.communicate()
  >>> process.returncode
  0
  >>> print stdout
  Initialising connection to queue accepted
  Running: "fetch trans"
  Fetching ubuntutest/breezy-autotest (ACCEPTED) 1/1
  ---------------------------------------------------------------------------
  Constructing translations-main_20060728_all.changes
  Constructing translations_main_20060728.tar.gz
  ---------------------------------------------------------------------------
                                                                 1/1 total
  <BLANKLINE>


Check if the files were written:

  >>> os.path.exists('translations-main_20060728_all.changes')
  True
  >>> os.path.exists('translations_main_20060728.tar.gz')
  True

Cleanup the mess:

  >>> os.remove('translations-main_20060728_all.changes')
  >>> os.remove('translations_main_20060728.tar.gz')


Inspect the QUEUE looking for an ACCEPTED entry corresponding to the
previous upload:

  >>> from canonical.lp.dbschema import DistroReleaseQueueStatus
  >>> queue_item = breezy_autotest.getQueueItems(
  ...      status=DistroReleaseQueueStatus.ACCEPTED)[0]
  >>> queue_item.customfiles[0].libraryfilealias.filename
  u'translations_main_20060728.tar.gz'

Do the publish, i.e process the CustomUpload decompressing and writing
the tarball contents in the archive:

  >>> queue_item.realiseUpload()


Check what was published in the target directory:

  >>> import os
  >>> archive_dir = '/var/tmp/archive/'

DDTP are published in the "i18n" diretory inside archive dists:

  >>> upgrade_dir = 'ubuntutest/dists/breezy-autotest/main/i18n'
  >>> target_dir = os.path.join(archive_dir, upgrade_dir)

We simply decompress the contents of the tarball, the files follow
the format:

  Translation-<lang-code>{'', '.gz', '.bz2'}

  >>> dir_list = os.listdir(target_dir)
  >>> for filename in sorted(dir_list):
  ...    print filename
  Translation-en
  Translation-en.bz2
  Translation-en.gz
  Translation-pt_BR
  Translation-pt_BR.bz2
  Translation-pt_BR.gz


Remove the directory to keep the test working.

  >>> import shutil
  >>> shutil.rmtree(target_dir)

Switch Librarian off

  >>> LibrarianTestSetup().tearDown()



