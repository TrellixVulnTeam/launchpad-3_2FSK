Bug Filing Pages
================

Filing a Bug
------------

There are three objects on which you can file a bug. An
SQLObjectCreatedEvent is published when the bug is filed. Let's register
an event listener to demonstrate this.

    >>> from canonical.database.sqlbase import flush_database_updates
    >>> import transaction

    >>> from canonical.launchpad.ftests.event import TestEventListener
    >>> from canonical.launchpad.event.interfaces import ISQLObjectCreatedEvent
    >>> from canonical.launchpad.interfaces import IBug
    >>> def on_created_event(object, event):
    ...     print "SQLObjectCreatedEvent: %r" % object
    >>> on_created_listener = TestEventListener(
    ...     IBug, ISQLObjectCreatedEvent, on_created_event)

1. Filing a bug on a distribution.

The distribution filebug page will attach a bugtask to a sourcepackage
if the user provides a valid package name when reporting the bug.

If the package name entered by the user happens to be a binary package
name, that information is recorded in the description, and the first
comment, of the bug report.

    >>> from zope.component import getView, getUtility
    >>> from canonical.launchpad.interfaces import (
    ...     IBugTaskSet, IBugSet, IDistributionSet, BugTaskSearchParams,
    ...     IProductSet, ILaunchBag)
    >>> from canonical.launchpad.webapp.servers import LaunchpadTestRequest

    >>> login("foo.bar@canonical.com")

    >>> ubuntu = getUtility(IDistributionSet).getByName("ubuntu")
    >>> request = LaunchpadTestRequest(form={
    ...     'field.title': 'bug in bin pkg',
    ...     'field.comment': 'a bug in a bin pkg',
    ...     'packagename_option': 'choose',
    ...     'field.packagename': 'linux-2.6.12',
    ...     'FORM_SUBMIT': 'Submit Bug Report'})

    >>> ubuntu_filebug = getView(ubuntu, "+filebug", request)

    >>> ubuntu_filebug.process_form()
    SQLObjectCreatedEvent: <Bug at ...>

    >>> current_user = getUtility(ILaunchBag).user
    >>> search_params = BugTaskSearchParams(
    ...     searchtext="bin pkg", user=current_user)

    >>> latest_ubuntu_bugtask = ubuntu.searchTasks(
    ...     search_params)[0]

The user specified a binary package name, so that's been added to the
bug description and the first comment:

    >>> print latest_ubuntu_bugtask.bug.description
    Binary package hint: linux-2.6.12
    <BLANKLINE>
    <BLANKLINE>
    a bug in a bin pkg

the source package from which the binary was built has been set on
the bugtask.

    >>> print latest_ubuntu_bugtask.sourcepackagename.name
    linux-source-2.6.15

2. Filing a bug on a product.

    >>> firefox = getUtility(IProductSet).getByName("firefox")
    >>> request = LaunchpadTestRequest(form={
    ...     'field.title': 'a firefox bug',
    ...     'field.comment': 'a test bug',
    ...     'FORM_SUBMIT': 'Submit Bug Report'})

    >>> firefox_filebug = getView(firefox, "+filebug", request)

    >>> firefox_filebug.process_form()
    SQLObjectCreatedEvent: <Bug at ...>

3. Filing a bug on a distribution source package.

    >>> ubuntu_firefox = ubuntu.getSourcePackage("mozilla-firefox")

    >>> request = LaunchpadTestRequest(form={
    ...     'field.title': 'a firefox bug',
    ...     'field.comment': 'a test bug',
    ...     'FORM_SUBMIT': 'Submit Bug Report'})

    >>> ubuntu_firefox_filebug = getView(
    ...     ubuntu_firefox, "+filebug", request)

    >>> ubuntu_firefox_filebug.process_form()
    SQLObjectCreatedEvent: <Bug at ...>

Adding Comments
---------------

Let's flush all changes so far to ensure we're looking at a consistent view of
the database.

    >>> flush_database_updates()
    >>> transaction.commit()

To add new comments, users POST to the +addcomment page:

    >>> request = LaunchpadTestRequest(form={
    ...                 "field.subject": latest_ubuntu_bugtask.bug.title,
    ...                 "field.comment": "I can reproduce this bug.",
    ...                 'FORM_SUBMIT': 'Save Changes'})
    ...             })
    >>> ubuntu_addcomment = getView(latest_ubuntu_bugtask, "+addcomment-form", request)
    >>> ubuntu_addcomment.process_form()

They may even, by mistake, post the same comment twice:

    >>> request = LaunchpadTestRequest(form={
    ...                 "field.subject": latest_ubuntu_bugtask.bug.title,
    ...                 "field.comment": "I can reproduce this bug.",
    ...                 'FORM_SUBMIT': 'Save Changes'})
    ...             })
    >>> ubuntu_addcomment = getView(latest_ubuntu_bugtask, "+addcomment-form", request)
    >>> ubuntu_addcomment.process_form()

Comments are cached in the view, so we need to flush updates and then
grab a new view to actually see them:

    >>> flush_database_updates()
    >>> transaction.commit()

    >>> ubuntu_bugview = getView(latest_ubuntu_bugtask, "+index", request)
    >>> print len(ubuntu_bugview.comments)
    3
    >>> [(c.index, c.owner.name, c.text_contents) for c in ubuntu_bugview.comments]
    [(0, u'name16', u'Binary package hint: linux-2.6.12\n\na bug in a bin pkg'),
     (1, u'name16', u'I can reproduce this bug.'),
     (2, u'name16', u'I can reproduce this bug.')]

Description and Comment Display
-------------------------------

When a user posts a new bug, the first comment and the description are
identical. Take as an example the first bug posted above:

    >>> print latest_ubuntu_bugtask.bug.description
    Binary package hint: linux-2.6.12
    <BLANKLINE>
    <BLANKLINE>
    a bug in a bin pkg

Its description has the same contents as the bug's first comment:

    >>> print latest_ubuntu_bugtask.bug.messages[0].text_contents
    Binary package hint: linux-2.6.12
    <BLANKLINE>
    <BLANKLINE>
    a bug in a bin pkg

The view class offers a method to check exactly that:

    >>> ubuntu_bugview.wasDescriptionModified()
    False

If we go ahead and modify the description, however:

    >>> latest_ubuntu_bugtask.bug.description = "A bug in the linux kernel"
    >>> flush_database_updates()
    >>> transaction.commit()

    >>> ubuntu_bugview.wasDescriptionModified()
    True

The displayable comments for a bug are returned doing:

    >>> viewable_comments = ubuntu_bugview.getBugCommentsForDisplay()

Because we omit the first comment, and because the third comment is
indentical to the second, we really only display one comment:

    >>> print len(viewable_comments)
    1
    >>> [(c.index, c.owner.name, c.text_contents) for c in viewable_comments]
    [(1, u'name16', u'I can reproduce this bug.')]

(Unregister our listener, since we no longer need it.)

    >>> on_created_listener.unregister()

Bug Portlets
============

Duplicates Portlet
------------------

The duplicate bugs portlet lists duplicates of the current bug. If the
duplicate bug affects the current context, the link to the dupe will
remain in the current context. If the dupe has not been reported in
the current context, the dupe link will be to the generic
/bugs/$bug.id redirect link.

    >>> bugset = getUtility(IBugSet)
    >>> bugtaskset = getUtility(IBugTaskSet)
    >>> request = LaunchpadTestRequest()

Bug 6 is a duplicate of bug 5, and since both bugs affect Firefox, the
duplicate link remains in the current context.

    >>> bug_five_in_firefox = bugtaskset.get(14)

    >>> print bug_five_in_firefox.bug.id
    5
    >>> print bug_five_in_firefox.product.name
    firefox


    >>> bug_page_view = getView(
    ...     bug_five_in_firefox, "+portlet-duplicates", request)

    >>> bug_six = bugset.get(6)

    >>> from canonical.launchpad.interfaces import IOpenLaunchBag

    >>> getUtility(IOpenLaunchBag).add(bug_five_in_firefox)

    >>> print bug_page_view.getDupeBugLink(bug_six)
    http://.../products/firefox/+bug/6

Bug 2 is not reported in Firefox. Let's mark bug 2 as a dupe of bug 5,
and see how the returned link changes.

    >>> bug_two = bugset.get(2)
    >>> bug_two.duplicateof = 5

    >>> bug_page_view = getView(
    ...     bug_five_in_firefox, "+portlet-duplicates", request)

    >>> print bug_page_view.getDupeBugLink(bug_two)
    http://.../bugs/2

Bug Navigation
--------------

The +subscribe link has different text depending on if the user is
subscribe to the bug, or if a team is subscribed to it.

If the user isn't subscribed to the bug and neither of his teams are
subscribed to it, 'Subscribe' is shown.

    >>> login("foo.bar@canonical.com")
    >>> from canonical.launchpad.interfaces import IPersonSet
    >>> foo_bar = getUtility(IPersonSet).getByEmail('foo.bar@canonical.com')
    >>> bug_one = getUtility(IBugSet).get(1)
    >>> bug_one.isSubscribed(foo_bar)
    False
    >>> for team in foo_bar.teams_participated_in:
    ...     if bug_one.isSubscribed(team):
    ...         print "%s is subsribed to the bug" % team.displayname
    ...         break
    ... else:
    ...     print "No teams are subscribed to the bug."
    No teams are subscribed to the bug.

    >>> from canonical.launchpad.browser import BugContextMenu
    >>> bug_one_bugtask = bug_one.bugtasks[0]
    >>> getUtility(IOpenLaunchBag).clear()
    >>> getUtility(IOpenLaunchBag).add(bug_one_bugtask)
    >>> bug_menu = BugContextMenu(bug_one_bugtask)
    >>> bug_menu.subscription().text
    'Subscribe'

    >>> bug_menu.subscription().icon
    'add'

If we subscribe Foo Bar, 'Unsubscribe' is shown.

    >>> bug_one.subscribe(foo_bar)
    <BugSubscription at ...>
    >>> bug_menu = BugContextMenu(bug_one_bugtask)
    >>> bug_menu.subscription().text
    'Unsubscribe'

    >>> bug_menu.subscription().icon
    'remove'

If we subscribe one of the teams that Foo Bar is a member of, it will
still say 'Unsubscribe':

    >>> launchpad_team = getUtility(IPersonSet).getByName('launchpad')
    >>> foo_bar.inTeam(launchpad_team)
    True
    >>> bug_one.subscribe(launchpad_team)
    <BugSubscription at ...>
    >>> bug_menu = BugContextMenu(bug_one_bugtask)
    >>> bug_menu.subscription().text
    'Unsubscribe'

    >>> bug_menu.subscription().icon
    'remove'

However, if we now unsubscribe Foo Bar, but leaving the Launchpad team
subscribed, it will say 'Subscribe/Unsubscribe' since he will have the
option of either subscribe himself or unsubscribe the Launchpad team.

    >>> bug_one.unsubscribe(foo_bar)

    >>> bug_menu = BugContextMenu(bug_one_bugtask)
    >>> bug_menu.subscription().text
    'Subscribe/Unsubscribe'

    >>> bug_menu.subscription().icon
    'edit'

He will have the possibility to unsubscribe only the team that he's a
member of, so if we unsubscribe the Launchpad team and subscribe some
other team, it will say only 'Subscribe'.

    >>> shipit_team = getUtility(IPersonSet).getByName('shipit-admins')
    >>> foo_bar.inTeam(shipit_team)
    False
    >>> bug_one.unsubscribe(launchpad_team)
    >>> bug_one.subscribe(shipit_team)
    <BugSubscription at ...>

    >>> bug_menu = BugContextMenu(bug_one_bugtask)
    >>> bug_menu.subscription().text
    'Subscribe'

    >>> bug_menu.subscription().icon
    'add'

If the user is logged out, it also says 'Subscribe/Unsubscribe', since
we can't know if the user is subscribed or not.

    >>> login(ANONYMOUS)
    >>> bug_menu = BugContextMenu(bug_one_bugtask)
    >>> bug_menu.subscription().text
    'Subscribe/Unsubscribe'

    >>> bug_menu.subscription().icon
    'edit'

BugTasks and Nominations Table
------------------------------

A table is rendered at the top of the bug page which shows both bugtasks
and nominations. This table is rendered with the
+bugtasks-and-nomination-table view.

    >>> request = LaunchpadTestRequest()

    >>> bugtasks_and_nominations_view = getView(
    ...     bug_one_bugtask, "+bugtasks-and-nominations-table", request)

The getBugTasksAndNominations method returns a list of bugtasks and
nominations to render in the table, sorted by bugtargetname. Approved
nominations are not included in the returned results, because an
approved nomination will have created a task anyway.

    >>> from canonical.launchpad.interfaces import IBugTask, IBugNomination

    >>> def get_object_type(task_or_nomination):
    ...     if IBugTask.providedBy(task_or_nomination):
    ...         return "bugtask"
    ...     elif IBugNomination.providedBy(task_or_nomination):
    ...         return "nomination"
    ...     else:
    ...         return "unknown"

    >>> def print_tasks_and_nominations(tasks_and_nominations):
    ...     for task_or_nomination in tasks_and_nominations:
    ...         print "%s, %s, %s" % (
    ...             get_object_type(task_or_nomination),
    ...             task_or_nomination.status.title,
    ...             task_or_nomination.target.bugtargetname)

    >>> tasks_and_nominations = (
    ...     bugtasks_and_nominations_view.getBugTasksAndNominations())

    >>> print_tasks_and_nominations(tasks_and_nominations)
    bugtask, Unconfirmed, firefox (upstream)
    nomination, Proposed, firefox 1.0 (upstream)
    bugtask, Confirmed, mozilla-firefox (Debian)
    bugtask, Unconfirmed, mozilla-firefox (Ubuntu)
    nomination, Proposed, Ubuntu Hoary

Let's nominate the bug for upstream and an Ubuntu release and see how
the list changes.

(Login as an unprivileged user to be able to nominate.)

    >>> login("no-priv@canonical.com")

    >>> ubuntu_warty = ubuntu.getRelease("warty")
    >>> firefox_milestones = firefox.getSeries("milestones")

    >>> bug_one.addNomination(current_user, target=ubuntu_warty)
    <BugNomination ...>
    >>> bug_one.addNomination(current_user, target=firefox_milestones)
    <BugNomination ...>

    >>> tasks_and_nominations = (
    ...     bugtasks_and_nominations_view.getBugTasksAndNominations())

    >>> print_tasks_and_nominations(tasks_and_nominations)
    bugtask, Unconfirmed, firefox (upstream)
    nomination, Proposed, firefox 1.0 (upstream)
    nomination, Proposed, firefox milestones (upstream)
    bugtask, Confirmed, mozilla-firefox (Debian)
    bugtask, Unconfirmed, mozilla-firefox (Ubuntu)
    nomination, Proposed, Ubuntu Hoary
    nomination, Proposed, Ubuntu Warty

Let's add another affected package in Ubuntu to the bug.

    >>> evolution = ubuntu.getSourcePackage("evolution")

    >>> current_user = getUtility(ILaunchBag).user

    >>> bugtaskset.createTask(
    ...     owner=current_user, bug=bug_one,
    ...     distribution=evolution.distribution,
    ...     sourcepackagename=evolution.sourcepackagename)
    <BugTask ...>

A nomination row will be included for evolution now too.

    >>> tasks_and_nominations = (
    ...     bugtasks_and_nominations_view.getBugTasksAndNominations())

    >>> print_tasks_and_nominations(tasks_and_nominations)
    bugtask, Unconfirmed, firefox (upstream)
    nomination, Proposed, firefox 1.0 (upstream)
    nomination, Proposed, firefox milestones (upstream)
    bugtask, Unconfirmed, evolution (Ubuntu)
    nomination, Proposed, Ubuntu Hoary
    nomination, Proposed, Ubuntu Warty
    bugtask, Confirmed, mozilla-firefox (Debian)
    bugtask, Unconfirmed, mozilla-firefox (Ubuntu)
    nomination, Proposed, Ubuntu Hoary
    nomination, Proposed, Ubuntu Warty

When a nomination is approved, it turns into a task; the nomination is
no longer shown. Declined nominations continue to be shown.

(First, login as an admin, to ensure we have the privileges to
approve/decline nominations.)

    >>> login("foo.bar@canonical.com")
    >>> current_user = getUtility(ILaunchBag).user

    >>> ubuntu_hoary = ubuntu.getRelease("hoary")
    >>> hoary_nomination = bug_one.getNominationFor(ubuntu_hoary)
    >>> warty_nomination = bug_one.getNominationFor(ubuntu_warty)

    >>> hoary_nomination.approve(current_user)
    >>> warty_nomination.decline(current_user)

    >>> tasks_and_nominations = (
    ...     bugtasks_and_nominations_view.getBugTasksAndNominations())

    >>> print_tasks_and_nominations(tasks_and_nominations)
    bugtask, Unconfirmed, firefox (upstream)
    nomination, Proposed, firefox 1.0 (upstream)
    nomination, Proposed, firefox milestones (upstream)
    bugtask, Unconfirmed, evolution (Ubuntu)
    nomination, Declined, Ubuntu Warty
    bugtask, Unconfirmed, evolution (Ubuntu Hoary)
    bugtask, Confirmed, mozilla-firefox (Debian)
    bugtask, Unconfirmed, mozilla-firefox (Ubuntu)
    nomination, Declined, Ubuntu Warty
    bugtask, Unconfirmed, mozilla-firefox (Ubuntu Hoary)

Bug Edit Page
=============

The bug edit page is used to edit the summary, description, nick name,
and bug tags. If the user try to add a tag that hasn't been used in the
current context, we display a confirmation button, which shouldn't be
automatically rendered by the form template. In order to show how it
works, let's override the edit page, making it a bit shorter, and
initialize the test harness.

    >>> from canonical.launchpad.browser import BugEditView
    >>> class BugEditViewTest(BugEditView):
    ...     def index(self):
    ...         print 'EDIT BUG'

    >>> firefox_task = bug_one.bugtasks[0]
    >>> firefox_task.targetname
    u'firefox (upstream)'
    >>> from canonical.launchpad.ftests import LaunchpadFormHarness
    >>> bug_edit = LaunchpadFormHarness(firefox_task, BugEditViewTest)

Initially, the normal edit page is shown, with a single button.

    >>> bug_edit.view.render()
    EDIT BUG
    >>> [action.label for action in bug_edit.view.actions]
    ['Change']

If we fill in some values and submit the action, the view will redirect
and the bug will have been edited.

    >>> login('test@canonical.com')
    >>> edit_values = {
    ...     'field.title': u'New title',
    ...     'field.description': u'New description.',
    ...     'field.name': u'new-nickname',
    ...     'field.tags': u'doc'}

    >>> bug_edit.submit('change', edit_values)
    >>> bug_edit.hasErrors()
    False
    >>> bug_edit.wasRedirected()
    True

    >>> bug_one.title
    u'New title'
    >>> bug_one.description
    u'New description.'
    >>> bug_one.name
    u'new-nickname'
    >>> bug_one.tags
    [u'doc']


The tag 'doc' has already been used for other Firefox bugs, let's try
adding a tag that hasn't already been used.

    >>> edit_values['field.tags'] = u'doc new-tag'
    >>> bug_edit.submit('change', edit_values)

Now the form will have a notification, asking us to confirm that we indeed
want to use a new tag. The notification includes a button, with which
the user can confirm that he wants to add the tag.

    >>> bug_edit.hasErrors()
    False
    >>> for message in bug_edit.view.notifications:
    ...     print message
    The tag "new-tag" hasn't yet been used by firefox (upstream) before.
    Is this a new tag?...<input ...Yes, define new tag...>

    >>> bug_edit.wasRedirected()
    False

The form still contains the 'Change' button, though, so that the user
can edit the tag and submit the form again.

    >>> bug_edit.view.render()
    EDIT BUG
    >>> [action.label for action in bug_edit.view.actions]
    ['Change']

If we click on the 'Yes, define new tag' button, we'll get redirected to
the bug page, and the bug will have the new tag.

    >>> bug_edit.submit('confirm_tag', edit_values)
    >>> bug_edit.hasErrors()
    False
    >>> bug_edit.wasRedirected()
    True

    >>> bug_one.tags
    [u'doc', u'new-tag']
