OpenPGP Import
==============

The importPublicKey method is exposed by IGPGHandler but it's only used
internally by the retrieveKey method.  Ideally, we shouldn't need to
check for all error conditions that we do, but we can't assume the
keyserver is a trusted data source, so we have to do that.

    >>> from zope.component import getUtility
    >>> from canonical.launchpad.webapp.testing import verifyObject

    >>> from canonical.launchpad.interfaces import (
    ...      IGPGHandler, IPymeKey)
    >>> gpghandler = getUtility(IGPGHandler)

-------------------------------------------------------------------------
XXX: All these checks for error conditions should probably be moved to a
unit tests somewhere else at some point. -- Guilherme Salgado, 2006-08-23
-------------------------------------------------------------------------

A GPGKeyNotFoundError is raised if we try to import an empty content.

    >>> key = gpghandler.importPublicKey('')
    Traceback (most recent call last):
    ...
    GPGKeyNotFoundError...

The same happens for bogus content.

    >>> key = gpghandler.importPublicKey('XXXXXXXXX')
    Traceback (most recent call last):
    ...
    GPGKeyNotFoundError: ...

Let's recover some coherent data and verify if it works as expected:

    >>> import os
    >>> from canonical.launchpad.ftests.keys_for_tests import gpgkeysdir
    >>> filepath = os.path.join(gpgkeysdir, 'test@canonical.com.pub')
    >>> pubkey = open(filepath).read()
    >>> key = gpghandler.importPublicKey(pubkey)

    >>> verifyObject(IPymeKey, key)
    True

    >>> key.fingerprint
    'A419AE861E88BC9E04B9C26FBA2B9389DFD20543'

    >>> print key.secret
    False

    >>> print key.can_encrypt
    True

    >>> print key.can_sign
    True

    >>> print key.can_certify
    True

    >>> print key.can_authenticate
    False

    >>> print key.export()
    -----BEGIN PGP PUBLIC KEY BLOCK-----
    ...
    -----END PGP PUBLIC KEY BLOCK-----
    <BLANKLINE>

Now, try to import a secret key, which will cause a
SecretGPGKeyImportDetected exception to be raised.

    >>> filepath = os.path.join(gpgkeysdir, 'test@canonical.com.sec')
    >>> seckey = open(filepath).read()
    >>> key = gpghandler.importPublicKey(seckey)
    Traceback (most recent call last):
    ...
    SecretGPGKeyImportDetected: ...

Now, try to import two public keys, causing a MoreThanOneGPGKeyFound
exception to be raised.

    >>> filepath = os.path.join(gpgkeysdir, 'foo.bar@canonical.com.pub')
    >>> pubkey2 = open(filepath).read()
    >>> key = gpghandler.importPublicKey('\n'.join([pubkey, pubkey2]))
    Traceback (most recent call last):
    ...
    MoreThanOneGPGKeyFound: ...

Raise a GPGKeyNotFoundError if we try to import a public key with damaged
preamble.

    >>> key = gpghandler.importPublicKey(pubkey[1:])
    Traceback (most recent call last):
    ...
    GPGKeyNotFoundError: ...

Apparently GPGME is able to import an incomplete public key:

    >>> key = gpghandler.importPublicKey(pubkey[:-300])
    >>> assert key is not None
    >>> verifyObject(IPymeKey, key)
    True
    >>> key.fingerprint
    'A419AE861E88BC9E04B9C26FBA2B9389DFD20543'

But we get an error if the damage is big:
(what probably happened in bug #2547)

    >>> key = gpghandler.importPublicKey(pubkey[:-400])
    Traceback (most recent call last):
    ...
    GPGKeyNotFoundError: ...


Secret keys
============

Secret keys can be imported using IGPGHandler.importSecretKey() which
does exactly the same job performed by importPublicKey() but
supporting only ASCII-armored secret keys.

    >>> filepath = os.path.join(gpgkeysdir, 'test@canonical.com.sec')
    >>> seckey = open(filepath).read()
    >>> key = gpghandler.importSecretKey(seckey)

    >>> verifyObject(IPymeKey, key)
    True

    >>> print key.fingerprint
    A419AE861E88BC9E04B9C26FBA2B9389DFD20543

    >>> print key.secret
    True

    >>> print key.can_encrypt
    True

    >>> print key.can_sign
    True

    >>> print key.can_certify
    True

    >>> print key.can_authenticate
    False

    >>> print key.export()
    -----BEGIN PGP PRIVATE KEY BLOCK-----
    ...
    -----END PGP PRIVATE KEY BLOCK-----
    <BLANKLINE>


Keyserver URLs
==============

The gpghandler can also provide us with convenient links to the
keyserver web interface. By default the action is to display the index
page. Notice that the fingerprint must be the 40-byte fingerprint,
to avoid the retrieval of more than one key.

    >>> fingerprint = "A419AE861E88BC9E04B9C26FBA2B9389DFD20543"
    >>> gpghandler.getURLForKeyInServer(fingerprint)
    'http://localhost:11371/pks/lookup?search=0xA419AE861E88BC9E04B9C26FBA2B9389DFD20543&op=index'

But you can also specify your own action:

    >>> gpghandler.getURLForKeyInServer(fingerprint, action="get")
    'http://localhost:11371/pks/lookup?search=0xA419AE861E88BC9E04B9C26FBA2B9389DFD20543&op=get'

The method accepts a flag to retrieve a link to ubuntu's public
keyserver web interface.

    >>> gpghandler.getURLForKeyInServer(fingerprint, public=True)
    'http://keyserver.ubuntu.com:11371/pks/lookup?search=0xA419AE861E88BC9E04B9C26FBA2B9389DFD20543&op=index'


Fingerprint sanitizing
======================

The GPG handler offers a convenience method to sanitize key
fingerprints:

    >>> print gpghandler.sanitizeFingerprint("XXXXX")
    None

    >>> fingerprint = 'C858 2652 1A6E F6A6 037B  B3F7 9FF2 583E 681B 6469'
    >>> print gpghandler.sanitizeFingerprint(fingerprint)
    C85826521A6EF6A6037BB3F79FF2583E681B6469

    >>> fingerprint = 'c858 2652 1a6e f6a6 037b  b3f7 9ff2 583e 681b 6469'
    >>> print gpghandler.sanitizeFingerprint(fingerprint)
    C85826521A6EF6A6037BB3F79FF2583E681B6469

    >>> print gpghandler.sanitizeFingerprint('681B 6469')
    None

    >>> print gpghandler.sanitizeFingerprint('abnckjdiue')
    None

    >>> non_ascii_chars = u'\xe9\xe1\xed'
    >>> fingerprint = ('c858 2652 1a6e f6a6 037b  b3f7 9ff2 583e 681b 6469 %s'
    ...                % non_ascii_chars)
    >>> print gpghandler.sanitizeFingerprint(fingerprint)
    C85826521A6EF6A6037BB3F79FF2583E681B6469

    >>> fingerprint = (
    ...     '%s c858 2652 1a6e f6a6 037b  b3f7 9ff2 583e 681b 6469 %s'
    ...     % (non_ascii_chars, non_ascii_chars))
    >>> print gpghandler.sanitizeFingerprint(fingerprint)
    None

