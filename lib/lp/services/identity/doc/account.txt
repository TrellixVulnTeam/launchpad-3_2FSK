======================
Account and AccountSet
======================

An Account is used by someone to Authenticate with the Launchpad login
service.


AccountSet
==========

The AccountSet object provides methods to retrieve `IAccount`s. It
implements the IAccountSet interface.

    >>> from zope.interface.verify import verifyObject
    >>> from lp.registry.interfaces.person import IPersonSet
    >>> from lp.services.identity.interfaces.account import (
    ...     IAccount, IAccountSet)

    >>> account_set = getUtility(IAccountSet)
    >>> verifyObject(IAccountSet, account_set)
    True

    >>> account = getUtility(IPersonSet).getByEmail(
    ...     'no-priv@canonical.com').account


Looking up accounts by their database ID
----------------------------------------

If we know the ID of an account we can use the get() method.

    >>> account_set.get(account.id) == account
    True

If there's no account with the given ID, a LookupError is raised.

    >>> account_set.get(99999)
    Traceback (most recent call last):
    ...
    LookupError:...


Looking up accounts by OpenID identifier
----------------------------------------

Each Launchpad user is assigned an permanent OpenID identity URL. The
last component of this URL is specific to the user, and can be used to
look up the user.

    >>> account = account_set.getByOpenIDIdentifier(u'no-priv_oid')
    >>> IAccount.providedBy(account)
    True
    >>> print account.displayname
    No Privileges Person

A LookupError is raised if the identifier is not used by any account.

    >>> account_set.getByOpenIDIdentifier(u'no-such-identifier')
    Traceback (most recent call last):
    ...
    LookupError: no-such-identifier


The Account object
==================

The account implements the IAccount interface but not all attributes are
accessible for the owner.

    >>> login('admin@canonical.com')
    >>> verifyObject(IAccount, account)
    True
    >>> login('no-priv@canonical.com')

An account has a displayname, and a preferred email address.

    >>> print account.displayname
    No Privileges Person
    >>> print account.preferredemail.email
    no-priv@canonical.com

Account objects have a useful string representation.

    >>> account
    <Account 'No Privileges Person' (Active account)>

It also has an encrypted password.

    >>> print account.password
    K7Qmeansl6RbuPfulfcmyDQOzp70OxVh5Fcf

Ensure the password changes are sticky, as this is a property hiding the
AccountPassword table.

    >>> account.password = None
    >>> print account.password
    None

    >>> account.password = u'K7Qmeansl6RbuPfulfcmyDQOzp70OxVh5Fcf'
    >>> print account.password
    K7Qmeansl6RbuPfulfcmyDQOzp70OxVh5Fcf

The account has other metadata.

    >>> account.date_created
    datetime.datetime(...)

    >>> print account.creation_rationale.name
    OWNER_CREATED_LAUNCHPAD

    >>> print account.status.name
    ACTIVE

    >>> account.date_status_set >= account.date_created
    True

    >>> print account.status_comment
    None

    >>> print account.displayname
    No Privileges Person

When the status is changed, the date_status_set is updated in the
database. Only an admin can change the status.

    >>> from lp.services.identity.interfaces.account import AccountStatus

    >>> original_date_status_set = account.date_status_set
    >>> login('admin@canonical.com')
    >>> account.status = AccountStatus.SUSPENDED

    # Shouldn't be necessary with Storm!
    >>> from zope.security.proxy import removeSecurityProxy
    >>> removeSecurityProxy(account).sync()
    >>> account.date_status_set > original_date_status_set
    True

    >>> account.status = AccountStatus.ACTIVE
    >>> login('no-priv@canonical.com')

An Account has at least one OpenID identifier used to generate the
OpenID identity URL.

    >>> account.openid_identifiers.any().identifier
    u'no-priv_oid'


Creating new accounts
=====================

New Accounts are created using the AccountSet.new() method. The account
rationale and displayname are required.

    >>> from lp.services.identity.interfaces.account import (
    ...     AccountCreationRationale)
    >>> from storm.store import Store

    >>> login('admin@canonical.com')
    >>> passwordless_account = account_set.new(
    ...     AccountCreationRationale.USER_CREATED, 'Passwordless')
    >>> transaction.commit()
    >>> print passwordless_account.creation_rationale.name
    USER_CREATED
    >>> print passwordless_account.displayname
    Passwordless
    >>> print passwordless_account.password
    None
    >>> print passwordless_account.preferredemail
    None

The new() method accepts the optional parameters of password and
password_is_encrypted. If password_is_encrypted is False, the default,
then the method encrypts it for us.

    >>> passworded_account = account_set.new(
    ...     AccountCreationRationale.OWNER_CREATED_LAUNCHPAD , 'Passworded',
    ...     password=u'clear_password')
    >>> Store.of(passworded_account).flush()
    >>> passworded_account.password == u'clear_password'
    False

The method does not encrypt the password if told that it is already
encrypted, by setting password_is_encrypted to True.

    >>> clear_account = account_set.new(
    ...     AccountCreationRationale.OWNER_CREATED_LAUNCHPAD , 'Clear',
    ...     password=u'clear_password', password_is_encrypted=True)
    >>> Store.of(clear_account).flush()
    >>> print clear_account.password
    clear_password


Valid Accounts
--------------

Like person objects, an account is considered valid if it is in the
active state and has a preferred email address.  So a newly created
account with no email address is not valid.

    >>> account = account_set.new(
    ...     AccountCreationRationale.USER_CREATED,
    ...     "Valid Account Test")
    >>> account.status = AccountStatus.ACTIVE
    >>> account.is_valid
    False

Let's add a new email address to the account.

    >>> email = getUtility(IEmailAddressSet).new(
    ...     "valid-account-test@example.com", account=account)
    >>> account.is_valid
    False

The account is still not valid because it has no preferred email.
Setting the email to preferred fixes this.

    >>> from lp.services.identity.interfaces.emailaddress import EmailAddressStatus
    >>> email.status = EmailAddressStatus.PREFERRED
    >>> account.is_valid
    True

If the account is deactivated, it won't be considered valid any more:

    >>> account.status = AccountStatus.DEACTIVATED
    >>> account.is_valid
    False
