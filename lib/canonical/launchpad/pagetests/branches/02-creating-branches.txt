= Creating Branches =

== Finding product/+addbranch ==

We should be able to create a new branch from a product.

First, check that the +addbranch link is visible on product overview page and
the product code facet page.

  >>> print http(r"""
  ... GET /products/applets/ HTTP/1.1
  ... Host: launchpad.dev
  ... """)
  HTTP/1.1 200 Ok
  ..."http://.../products/applets/+addbranch"...

  >>> print http(r"""
  ... GET /products/applets/+branches HTTP/1.1
  ... Host: launchpad.dev
  ... """)
  HTTP/1.1 200 Ok
  ..."http://.../products/applets/+addbranch"...

Let's make sure we can load the branch creation form on a product.

  >>> print http(r"""
  ... GET /products/applets/+addbranch HTTP/1.1
  ... Host: launchpad.dev
  ... Authorization: Basic Zm9vLmJhckBjYW5vbmljYWwuY29tOnRlc3Q=
  ... """)
  HTTP/1.1 200 Ok
  ...


== Adding a branch to a product ==

Now, post the branch creation form for the product.

The specified URL has a trailing slash. In the next test, we will check that it
has been stripped.

  >>> user_browser.open('http://launchpad.dev/products/applets/+addbranch')
  >>> user_browser.getControl('Name').value = 'main'
  >>> user_browser.getControl('Title').value = 'Gnome Panel Applets Mainline'
  >>> user_browser.getControl('Branch URL').value = 'http://example.com/applets/main'
  >>> user_browser.getControl(name='field.lifecycle_status').value = ['Development']
  >>> user_browser.getControl('Summary').value = 'Main branch of development for GNOME Panel Applets.'
  >>> user_browser.getControl('Add Branch').click()

Posting the form should succeed and redirect to the page of the newly
registered branch. We check that the final slash of the URL was stripped by
matching for the angle brackets of an enclosing tag.

  >>> user_browser.url
  'http://launchpad.dev/people/name12/+branch/applets/main'
  >>> print user_browser.contents
  <!DOCTYPE...
  ...Gnome Panel Applets Mainline...
  ...>http://example.com/applets/main<...

This page includes a link to other branches associated
with that product, and a link to other branches maintained by that person.

  >>> user_browser.getLink('Other Gnome Applets branches').url
  'http://launchpad.dev/products/applets/+branches'
  >>> user_browser.getLink('Other branches registered (and not authored) by Sample Person').url
  'http://launchpad.dev/people/name12/+registeredbranches'


== Finding person/+addbranch ==

We can also create a branch from a person's page. First, check that the
+addbranch link is present in the code facet of a person.

  >>> print http(r"""
  ... GET /people/lifeless/+branches HTTP/1.1
  ... Host: launchpad.dev
  ... """)
  HTTP/1.1 200 Ok
  ..."http://.../people/lifeless/+addbranch"...


== Adding a branch to a person ==

When creating a branch from a person, we have the option not to specify an
associated product. A branch with no associated product is called a "junk"
branch.

The specified URL has a trailing slash. We will check later that it has been
stripped.

  >>> user_browser.open('http://launchpad.dev/people/lifeless/+addbranch')
  >>> user_browser.getControl('Name').value = 'pyresources'
  >>> user_browser.getControl('Title').value = 'Resource Management for Unit Tests'
  >>> user_browser.getControl('Branch URL').value = 'sftp://example.com/~lifeless/pyresources/'
  >>> user_browser.getControl('Summary').value = \
  ...     'A resource management framework for handling unit test fixtures in Python.'
  >>> user_browser.getControl('Add Branch').click()

Posting the form should succeed and redirect to the page of the newly created
junk branch. Because it has no product, it has no link to other product
branches.

  >>> user_browser.url
  'http://launchpad.dev/people/name12/+branch/+junk/pyresources'
  >>> user_browser.getLink('Other branches authored by Robert Collins').url
  'http://launchpad.dev/people/lifeless/+authoredbranches'

Also, the branch URL must appear with the trailing slash stripped.

  >>> user_browser.contents
  '...>sftp://example.com/~lifeless/pyresources<...'


== Conflict on unique name ==

Trying to register a branch with a product and that matches an existing branch
owned by the user would cause a database integrity error, because the triplet
owner-product-name is unique for all branches.

For this example, we will use ~name12/gnome-terminal/main. Check that it
already exists.

  >>> user_browser.open('http://launchpad.dev/people/name12/+branch/gnome-terminal/main')

Try a adding a conflicting branch from the product/+addbranch form.

  >>> user_browser.open('http://launchpad.dev/products/gnome-terminal/+addbranch')
  >>> user_browser.getControl('Branch URL').value = 'http://example.com/gnome-terminal/main-dup'

Trying to post the form without filling a name at all should not cause an oops!

  >>> user_browser.getControl('Add Branch').click()
  >>> user_browser.url
  'http://launchpad.dev/products/gnome-terminal/+addbranch'

Now, complete the form, but give a name that is alredy in use for that owner
and product.

  >>> user_browser.getControl('Name').value = 'main'
  >>> user_browser.getControl('Add Branch').click()

That should give us the form back with an error message.

  >>> user_browser.url
  'http://launchpad.dev/products/gnome-terminal/+addbranch'
  >>> from BeautifulSoup import BeautifulSoup
  >>> soup = BeautifulSoup(user_browser.contents)
  >>> print soup('div', {'class': 'message'})[0].renderContents()
  Name already in use. ...

Trying to add a conflicting branch from person/+addbranch should produce the
same error message.

  >>> user_browser.open('http://launchpad.dev/people/name12/+addbranch')
  >>> user_browser.getControl('Branch URL').value = 'http://example.com/gnome-terminal/main-dup'
  >>> user_browser.getControl('Add Branch').click()
  >>> user_browser.url
  'http://launchpad.dev/people/name12/+addbranch'
  >>> user_browser.getControl('Name').value = 'main'
  >>> user_browser.getControl('Product').value = 'gnome-terminal'
  >>> user_browser.getControl('Add Branch').click()
  >>> user_browser.url
  'http://launchpad.dev/people/name12/+addbranch'
  >>> from BeautifulSoup import BeautifulSoup
  >>> soup = BeautifulSoup(user_browser.contents)
  >>> print soup('div', {'class': 'message'})[0].renderContents()
  Name already in use. ...
