Buildd Slave
============

Buildd Slave is an application independent of Launchpad Database, so
it has its own configuration file and depends only of sbuild package

It consists basically of an wrapper of sbuild process through an XMLRPC
Server interface. It requires read access to the current Librarian machine
to download needed files for the build job.

See more initialization details in canonical/buildd/ftests/harness.py

  >>> from canonical.buildd.ftests import BuilddSlaveTestSetup
  >>> BuilddSlaveTestSetup().setUp()

Use simple xmlrpclib client to certify the BuildSlave is running

  >>> import xmlrpclib
  >>> slave = xmlrpclib.Server('http://localhost:8221/rpc/')
  >>> slave.echo('Hello World')
  ['Hello World']

With slave protocol v1.0new, the only way to get files to the slave is to
put them in the librarian first...

  >>> from canonical.librarian.client import LibrarianClient
  >>> from StringIO import StringIO
  >>> from canonical.launchpad.database import LibraryFileAlias
  >>> import transaction
  >>> lc = LibrarianClient()
  >>> helloworld = "Hello World"
  >>> hw_sio = StringIO(helloworld)
  >>> alias = lc.addFile("HelloWorld.txt", len(helloworld),
  ...                    hw_sio, "text/plain")
  >>> transaction.commit()
  >>> lf = LibraryFileAlias.get(alias)
  >>> present, info = slave.ensurepresent(
  ...     lf.content.sha1, lf.http_url, "", "")
  >>> present, info
  (True, 'Download')

As of slave protocol v1.0new, /filecache/SHA1SUM is *THE* way
to retrieve files from the slave. Verify it works...

  >>> from urllib2 import urlopen
  >>> f = urlopen("http://localhost:8221/filecache/" + lf.content.sha1)
  >>> hw_str = f.read()
  >>> f.close()
  >>> hw_str == helloworld
  True


== BuilddMaster class ==

    >>> import logging
    >>> from canonical.buildmaster.master import BuilddMaster

    >>> bm = BuilddMaster(logging.getLogger(), transaction)

Retrieve a known DistroArchSeries.

    >>> from canonical.launchpad.interfaces import IDistributionSet
    >>> hoary_i386 = getUtility(IDistributionSet)['ubuntu']['hoary']['i386']
    >>> warty_i386 = getUtility(IDistributionSet)['ubuntu']['warty']['i386']

Create a totally bogus CHROOT.

    >>> from canonical.launchpad.database import LibraryFileAlias
    >>> fake_chroot = LibraryFileAlias.get(1)
    >>> unused = hoary_i386.addOrUpdateChroot(fake_chroot)
    >>> unused = warty_i386.addOrUpdateChroot(fake_chroot)

Initialise the BuildMaster with all available distroarchseries.
Because the sampledata builders are busy we issue and warning stating
that.

    >>> from canonical.launchpad.interfaces import IDistroArchSeriesSet
    >>> all_architectures = sorted(
    ...     getUtility(IDistroArchSeriesSet),
    ...     key=lambda dar: (dar.distroseries.distribution.name,
    ...                      dar.distroseries.name, dar.architecturetag))
    >>> for dar in all_architectures:
    ...     bm.addDistroArchSeries(dar)
    ...     bm.setupBuilders(dar)

Scan active builders looking for information about current jobs,
collect result of finished jobs, everything is stored directly in
the Launchpad DB. (simply check if it doesn't explode)

    >>> bm.scanActiveBuilders()
    WARNING:root.builders.x86:Builder http://localhost:8221/ forgot about
    build i386 build of mozilla-firefox 0.9 in ubuntu hoary RELEASE --
    resetting buildqueue record

Tested, time to shutdown.

  >>> BuilddSlaveTestSetup().tearDown()

At this point the buildd-slave is not accessible anymore.

  >>> s = xmlrpclib.Server('http://localhost:8221/rpc/')
  >>> s.info()
  Traceback (most recent call last):
  ...
  error: (111, 'Connection refused')
