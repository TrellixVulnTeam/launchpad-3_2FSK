Introduction
============

Bugs are problems in software. When a bug gets assigned to a specific
upstream or distro/sourcepackagename, a bug /task/ is created. In
essence, a bug task is a bug that needs to be fixed in a specific
place. Where a bug has things like a title, comments and subscribers,
it's the bug task that tracks importance, assignee, etc.

Working with Bug Tasks in Launchpad
===================================

Creating Bug Tasks
------------------

All BugTask creation and retrieval is done through an IBugTaskSet utility.

    >>> from zope.component import getUtility
    >>> import transaction
    >>> from canonical.launchpad.interfaces import IBugTaskSet
    >>> bugtaskset = getUtility(IBugTaskSet)

To create a bug task, you have to be logged in:

    >>> from canonical.launchpad.ftests import login, ANONYMOUS
    >>> login('foo.bar@canonical.com')

There are three kinds of bug tasks. We need to pass the bug task creation
methods some other objects to create a task, so lets get the utilities we need
to access those other objects:

    >>> from canonical.launchpad.interfaces import (IBugSet, IPersonSet,
    ...     IProductSet, IDistributionSet, IDistroReleaseSet,
    ...     ISourcePackageNameSet)
    >>> productset = getUtility(IProductSet)
    >>> distroset = getUtility(IDistributionSet)
    >>> distoreleaseset = getUtility(IDistroReleaseSet)
    >>> sourcepackagenameset = getUtility(ISourcePackageNameSet)
    >>> bugset = getUtility(IBugSet)
    >>> personset = getUtility(IPersonSet)
    >>> bug_one = bugset.get(1)
    >>> sabdfl = personset.get(1)

Next, we need to grab some values to provide for importance and status.

    >>> from canonical.lp.dbschema import (BugTaskStatus, BugTaskImportance)
    >>> STATUS_UNCONFIRMED = BugTaskStatus.UNCONFIRMED
    >>> STATUS_CONFIRMED = BugTaskStatus.CONFIRMED
    >>> STATUS_FIXRELEASED = BugTaskStatus.FIXRELEASED
    >>> IMPORTANCE_MEDIUM = BugTaskImportance.MEDIUM

  i. Upstream -- a bug that has to be fixed in an upstream product

    >>> evolution = productset.get(5)
    >>> upstream_task = bugtaskset.createTask(
    ...     bug=bug_one, product=evolution, owner=sabdfl,
    ...     status=STATUS_UNCONFIRMED, importance=IMPORTANCE_MEDIUM)
    >>> upstream_task.product == evolution
    True

    >>> from canonical.launchpad.interfaces import IUpstreamBugTask
    >>> IUpstreamBugTask.providedBy(upstream_task)
    True

  ii. Distro -- a bug that has to be fixed in a specific distro

    >>> ubuntu = distroset.get(1)
    >>> distro_task = bugtaskset.createTask(
    ...     bug=bug_one, distribution=ubuntu, owner=sabdfl,
    ...     status=STATUS_UNCONFIRMED, importance=IMPORTANCE_MEDIUM)
    >>> distro_task.distribution == ubuntu
    True

    >>> from canonical.launchpad.interfaces import IDistroBugTask
    >>> IDistroBugTask.providedBy(distro_task)
    True

  ii. Distro Release -- a bug that has to be fixed in a specific distro
  release. This primary use case for distro release bug tasks is for backporting
  fixes (e.g. for security bugs or bugs causing critical data loss.)

    >>> warty = distoreleaseset.get(1)
    >>> distro_release_task = bugtaskset.createTask(
    ...     bug=bug_one, distrorelease=warty, owner=sabdfl,
    ...     status=STATUS_UNCONFIRMED, importance=IMPORTANCE_MEDIUM)
    >>> distro_release_task.distrorelease == warty
    True

    >>> from canonical.launchpad.interfaces import IDistroReleaseBugTask
    >>> IDistroReleaseBugTask.providedBy(distro_release_task)
    True

XXX: Brad Bollenbach, 2005-02-24: See the bottom of this file for a chunk of
test documentation that is missing from here, due to problems with resetting
the connection after a ProgrammingError is raised. ARGH.

Retrieving and Searching for Bug Tasks
--------------------------------------

To retrieve a specific BugTask, use IBugTaskSet.get. As an example,
interacting with the system as an anonymous (i.e. unauthenticated) user:

    >>> from canonical.launchpad.interfaces import IPerson
    >>> from canonical.launchpad.database import Person
    >>> login(ANONYMOUS)

let's fetch the BugTask with ID 2:

    >>> bugtask = bugtaskset.get(2)
    >>> bugtask.bug.title
    u'Firefox does not support SVG'

If you pass an ID for which no object exists, you'll get a
zope.exceptions.NotFoundError:

    >>> bugtask = bugtaskset.get(-1)
    Traceback (most recent call last):
      ...
    NotFoundError: 'BugTask with ID -1 does not exist'

To retrieve a set of bug tasks matching a set of search criteria, use
the searchTasks method of the IBugTarget interface. Here's how you'd
grab all the UNCONFIRMED and CONFIRMED tasks:

For upstream:

    >>> from canonical.launchpad.searchbuilder import any
    >>> from canonical.lp.dbschema import BugTaskStatus
    >>> from canonical.launchpad.database import Product
    >>> from canonical.launchpad.interfaces import BugTaskSearchParams
    >>> upstream_mozilla = Product.get(4)
    >>> params = BugTaskSearchParams(status=any(BugTaskStatus.UNCONFIRMED,
    ...                                         BugTaskStatus.CONFIRMED),
    ...                              orderby="id", user=None)
    >>> bugtasks = upstream_mozilla.searchTasks(params)
    >>> print bugtasks.count()
    4
    >>> bugtask_ids = [bt.id for bt in bugtasks]
    >>> print bugtask_ids
    [2, 13, 14, 15]

By project:

    >>> from canonical.launchpad.interfaces import IProjectSet
    >>> mozilla_project = getUtility(IProjectSet).getByName('mozilla')
    >>> params = BugTaskSearchParams(status=any(BugTaskStatus.UNCONFIRMED,
    ...                                         BugTaskStatus.CONFIRMED),
    ...                              orderby="id", user=None)
    >>> bugtasks = mozilla_project.searchTasks(params)
    >>> print bugtasks.count()
    4
    >>> bugtask_ids = [bt.id for bt in bugtasks]
    >>> print bugtask_ids
    [2, 13, 14, 15]

For a distribution:

    >>> debian = distroset.get(3)
    >>> sample_person = personset.get(12)
    >>> params = BugTaskSearchParams(status=any(BugTaskStatus.UNCONFIRMED,
    ...                                         BugTaskStatus.CONFIRMED),
    ...                              orderby="id", user=None,
    ...                              assignee=sample_person)
    >>> bugtasks = debian.searchTasks(params)
    >>> print bugtasks.count()
    1
    >>> bugtasks[0].id
    5

For a person:

    >>> from canonical.database.sqlbase import (
    ...     flush_database_updates, flush_database_caches)
    >>> foobar = personset.get(16)
    >>> evolution_sourcepackage = sourcepackagenameset.queryByName('evolution')
    >>> ubuntu_evolution_task = bugtaskset.createTask(
    ...     bug=bug_one, distribution=ubuntu, owner=foobar,
    ...     status=STATUS_UNCONFIRMED, importance=IMPORTANCE_MEDIUM,
    ...     sourcepackagename=evolution_sourcepackage)
    >>> flush_database_updates()
    >>> params = BugTaskSearchParams(owner=foobar, user=None,
    ...                              orderby='targetname')
    >>> [bugtask.targetname for bugtask in foobar.searchTasks(params)]
    [u'Ubuntu',
     u'evolution (Ubuntu)',
     u'evolution (upstream)',
     u'linux-source-2.6.15 (Ubuntu)',
     u'mozilla-firefox (Debian)',
     u'mozilla-firefox (Ubuntu)',
     u'thunderbird (Ubuntu)']

It's also possible to search bugs that a person is subscribed to:

    >>> params = BugTaskSearchParams(user=None, subscriber=foobar, orderby="id")
    >>> [bugtask.bug.id for bugtask in foobar.searchTasks(params)]
    [7, 7, 9, 9, 10]

To provide null-matching search criteria, use canonical.launchpad.searchbuilder.NULL:

    >>> from canonical.launchpad.searchbuilder import NULL
    >>> params = BugTaskSearchParams(assignee=NULL, user=None)
    >>> bugtasks = upstream_mozilla.searchTasks(params)
    >>> print bugtasks.count()
    2
    >>> print [bugtask.bug.id for bugtask in bugtasks]
    [4, 6]

    >>> params = BugTaskSearchParams(sourcepackagename=NULL, user=None)
    >>> bugtasks = ubuntu.searchTasks(params)
    >>> print sorted(bugtask.bug.id for bugtask in bugtasks)
    [1, 2]

For negating a search argument, use not_equals:

    >>> from canonical.launchpad.searchbuilder import not_equals

    >>> params = BugTaskSearchParams(
    ...     importance=not_equals(BugTaskImportance.LOW), user=None)
    >>> bugtasks = upstream_mozilla.searchTasks(params)

    >>> print sorted(bugtask.bug.id for bugtask in bugtasks)
    [4, 5, 6]

There's also support for searching tasks based on a string of text, e.g.:

    >>> params = BugTaskSearchParams(searchtext="instructions", user=None)
    >>> bugtasks = upstream_mozilla.searchTasks(params)
    >>> print bugtasks.count()
    1
    >>> print [bugtask.bug.id for bugtask in bugtasks]
    [5]

searchtext is also used in a substring search against the target name:

    >>> params = BugTaskSearchParams(searchtext="mozilla-firefoxX", user=None)
    >>> bugtasks = debian.searchTasks(params)
    >>> print bugtasks.count()
    0
    >>> params = BugTaskSearchParams(searchtext="mozilla-firefox", user=None)
    >>> bugtasks = debian.searchTasks(params)
    >>> print bugtasks.count()
    4
    >>> params = BugTaskSearchParams(searchtext="mozilla-fire", user=None)
    >>> bugtasks = debian.searchTasks(params)
    >>> print bugtasks.count()
    4

When the IBugTarget is an IDistribution, IDistributionSourcePackage, or
ISourcePackage, you may include a "component" argument to filter the
search. Let's file some bugs on cnews, a universe package, to
demonstrate how component filtering works.

    >>> from canonical.launchpad.interfaces import CreateBugParams

    >>> cnews = ubuntu.getSourcePackage("cnews")

    >>> login("foo.bar@canonical.com")

    >>> params = CreateBugParams(
    ...     owner=getUtility(ILaunchBag).user,
    ...     title="a bug in a universe package",
    ...     comment="test")
    >>> cnews.createBug(params)
    <Bug ...>

There are now three bugtasks open on packages in Ubuntu main.

    >>> from canonical.launchpad.interfaces import IComponentSet
    >>> componentset = getUtility(IComponentSet)
    >>> main = componentset["main"]
    >>> universe = componentset["universe"]

    >>> params = BugTaskSearchParams(component=main, user=None)
    >>> main_tasks = ubuntu.searchTasks(params)
    >>> sorted(bugtask.bug.id for bugtask in main_tasks)
    [1, 10]

And there is the one bug on a "universe" package that we just added:

    >>> params = BugTaskSearchParams(component=universe, user=None)
    >>> universe_tasks = ubuntu.searchTasks(params)
    >>> sorted(bugtask.bug.title for bugtask in universe_tasks)
    [u'a bug in a universe package']

Let's get all bugs on either main or universe:

    >>> params = BugTaskSearchParams(
    ...     component=any(main, universe), user=None)
    >>> main_or_universe_tasks = ubuntu.searchTasks(params)
    >>> sorted(bugtask.bug.id for bugtask in main_or_universe_tasks)
    [1, 10, 11L]

You can also filter your search on other bugtasks. Let's show only bugs
where a bug watch is needed. This means that we should show only bugs
where there is at least one other bugtask on the bug, on a target which
doesn't use Malone, and which lacks a bug watch.

    >>> from canonical.launchpad.ftests.test_bugtask import (
    ...     BugTaskSearchBugsElsewhereTest)
    >>> test_helper = BugTaskSearchBugsElsewhereTest(helper_only=True)

    >>> params = BugTaskSearchParams(
    ...     pending_bugwatch_elsewhere=True, user=None)
    >>> pending_bugwatch_elsewhere_tasks = ubuntu.searchTasks(params)
    >>> for bugtask in pending_bugwatch_elsewhere_tasks:
    ...     test_helper.assertBugTaskIsPendingBugWatchElsewhere(bugtask)
    ...     print bugtask.bug.id, bugtask.bug.title
    2 Blackhole Trash folder

Now let's take a look at all the bugs that are fixed elsewhere. There
are none in the sample data, so let's change the status of one. Elsewhere
means not Ubuntu context, so it has nothing to do with bug watches.

    >>> login('test@canonical.com')
    >>> test_helper.setUpBugsElsewhereTests()

    >>> from canonical.launchpad.interfaces import RESOLVED_BUGTASK_STATUSES
    >>> params = BugTaskSearchParams(
    ...     status_elsewhere=any(*RESOLVED_BUGTASK_STATUSES),
    ...     orderby='id', user=None)
    >>> closed_elsewhere_tasks = ubuntu.searchTasks(params)
    >>> for bugtask in closed_elsewhere_tasks:
    ...     test_helper.assertBugTaskIsResolvedElsewhere(bugtask)
    ...     print bugtask.bug.id, bugtask.targetname
    1 mozilla-firefox (Ubuntu)
    1 Ubuntu
    1 evolution (Ubuntu)
    9 thunderbird (Ubuntu)

We can also exclude bugtasks which have a certain status elsewhere.
This is useful for hiding all bugs that are open upstream.

    >>> from canonical.launchpad.interfaces import UNRESOLVED_BUGTASK_STATUSES
    >>> params = BugTaskSearchParams(
    ...     omit_status_elsewhere=any(*UNRESOLVED_BUGTASK_STATUSES),
    ...     orderby='id', user=None)
    >>> not_open_elsewhere_tasks = ubuntu.searchTasks(params)
    >>> for bugtask in not_open_elsewhere_tasks:
    ...     test_helper.assertShouldBeShownOnOmittedStatusSearch(
    ...         bugtask, UNRESOLVED_BUGTASK_STATUSES)
    ...     print bugtask.bug.id, bugtask.targetname
    1 mozilla-firefox (Ubuntu)
    1 Ubuntu
    1 evolution (Ubuntu)
    9 thunderbird (Ubuntu)
    10 linux-source-2.6.15 (Ubuntu)
    11 cnews (Ubuntu)

    >>> test_helper.tearDownBugsElsewhereTests()


Bug Task Targets
----------------

The "target" of an IBugTask is one of the following things:

  * an upstream product

    >>> upstream_task.target == evolution
    True

  * a product series

    >>> from canonical.launchpad.interfaces import IProductSeriesBugTask

    >>> firefox = productset['firefox']
    >>> firefox_1_0 = firefox.getSeries("1.0")

    >>> productseries_task = bugtaskset.createTask(
    ...     owner=sabdfl, bug=bug_one, productseries=firefox_1_0)
    >>> IProductSeriesBugTask.providedBy(productseries_task)
    True

    >>> productseries_task.target == firefox_1_0
    True

  * a distribution

    >>> distro_task.target == ubuntu
    True

  * a distrorelease

    >>> distro_release_task.target == warty
    True

  * a distribution sourcepackage

    >>> from canonical.launchpad.database.distributionsourcepackage import DistributionSourcePackage
    >>> from canonical.launchpad.interfaces import IDistributionSourcePackage
    >>> distro_sp_task = bugtaskset.get(4)
    >>> expected_target = DistributionSourcePackage(
    ...     distro_sp_task.distribution,
    ...     distro_sp_task.sourcepackagename)
    >>> got_target = distro_sp_task.target
    >>> IDistributionSourcePackage.providedBy(distro_sp_task.target)
    True
    >>> got_target.distribution == expected_target.distribution
    True
    >>> got_target.sourcepackagename == expected_target.sourcepackagename
    True

  * a distrorelease sourcepackage

    >>> from canonical.launchpad.database import SourcePackage
    >>> from canonical.launchpad.interfaces import ISourcePackage
    >>> distro_release_sp_task = bugtaskset.get(16)
    >>> expected_target = SourcePackage(
    ...     distrorelease=distro_release_sp_task.distrorelease,
    ...     sourcepackagename=distro_release_sp_task.sourcepackagename)
    >>> got_target = distro_release_sp_task.target
    >>> ISourcePackage.providedBy(distro_release_sp_task.target)
    True
    >>> got_target.distrorelease == expected_target.distrorelease
    True
    >>> got_target.sourcepackagename == expected_target.sourcepackagename
    True

Each task has a "targetname", a string describing the site of the
task. It concatenates the display names of the distribution,

    >>> bugtask = bugtaskset.get(17)
    >>> bugtask.targetname
    u'mozilla-firefox (Ubuntu)'

distro release, or product;

    >>> bugtask = bugtaskset.get(2)
    >>> bugtask.targetname
    u'firefox (upstream)'

the name of the source package (if any); and the name of the binary
package (but only if it's named differently from the source
package).

Editing Bug Tasks
-----------------

Upstream Bug Tasks
^^^^^^^^^^^^^^^^^^

To edit an upstream task, you must be logged in. Anonymous users
cannot edit upstream tasks.

    >>> login(ANONYMOUS)
    >>> upstream_task.transitionToStatus(STATUS_CONFIRMED)
    Traceback (most recent call last):
      ...
    Unauthorized: (..., 'transitionToStatus', 'launchpad.Edit')

Let's login and try again.

    >>> login('jeff.waugh@ubuntulinux.com')
    >>> upstream_task.transitionToStatus(STATUS_FIXRELEASED)

Distro and Distro Release Bug Tasks
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Any logged-in user can edit tasks filed on distros as long as the bug
is not marked private. So, as an anonymous user, we can edit anything:

    >>> login(ANONYMOUS)
    >>> distro_task.transitionToStatus(STATUS_FIXRELEASED)
    Traceback (most recent call last):
      ...
    Unauthorized: (..., 'transitionToStatus', 'launchpad.Edit')

    >>> distro_release_task.transitionToAssignee(sample_person)
    Traceback (most recent call last):
      ...
    Unauthorized: (..., 'transitionToAssignee', 'launchpad.Edit')

But once authenticated:

    >>> login('test@canonical.com')

We can edit the task:

    >>> distro_task.transitionToStatus(STATUS_FIXRELEASED)
    >>> distro_release_task.transitionToAssignee(sample_person)

Null Bug Tasks
--------------

Sometimes we need to be able to render a page for a bug in a context,
when the bug hasn't actually been filed yet in that context. For cases
like these, use the NullBugTask object.

    >>> from canonical.launchpad.components.bugtask import NullBugTask

    >>> netapplet = productset.get(11)
    >>> null_bugtask = NullBugTask(bug=bug_one, product=netapplet)
    >>> IUpstreamBugTask.providedBy(null_bugtask)
    True

    >>> null_bugtask.id is None
    True
    >>> null_bugtask.title == 'Bug #1 in netapplet (upstream): "Firefox does not support SVG"'
    True
    >>> null_bugtask.product is netapplet
    True
    >>> null_bugtask.bug == bug_one
    True
    >>> null_bugtask.datecreated is None
    True
    >>> null_bugtask.dateassigned is None
    True
    >>> null_bugtask.age is None
    True
    >>> null_bugtask.status is None
    True
    >>> null_bugtask.sourcepackagename is None
    True
    >>> null_bugtask.distribution is None
    True
    >>> null_bugtask.distrorelease is None
    True
    >>> null_bugtask.milestone is None
    True
    >>> null_bugtask.importance is None
    True
    >>> null_bugtask.assignee is None
    True
    >>> null_bugtask.bugwatch is None
    True
    >>> null_bugtask.owner is None
    True
    >>> null_bugtask.target == netapplet
    True
    >>> null_bugtask.targetname
    u'netapplet (upstream)'
    >>> expected_related_task_ids = [
    ...     task.id for task in null_bugtask.related_tasks]
    >>> actual_related_task_ids = [task.id for task in bug_one.bugtasks]
    >>> expected_related_task_ids.sort()
    >>> actual_related_task_ids.sort()
    >>> expected_related_task_ids == actual_related_task_ids
    True
    >>> null_bugtask.statusdisplayhtml
    u'Not reported in netapplet (upstream)'
    >>> null_bugtask.statuselsewhere
    'fixed in 2 of 8 places'

The astute reader will have noticed that NullBugTask automatically
"marked" itself as providing the correct IBugTask interface. Let's see
two more examples:

    >>> ubuntu_null_bugtask = NullBugTask(bug=bug_one, distribution=ubuntu)
    >>> IDistroBugTask.providedBy(ubuntu_null_bugtask)
    True

    >>> warty_null_bugtask = NullBugTask(bug=bug_one, distrorelease=warty)
    >>> IDistroReleaseBugTask.providedBy(warty_null_bugtask)
    True

Bug Privacy
===========

A bug is either private or public. Private bugs are only visible (e.g. in search
listings) to explicit subscribers and Launchpad admins. Public bugs are visible
to anyone.

    >>> from zope.event import notify
    >>> from zope.publisher.browser import TestRequest
    >>> from canonical.launchpad.event.sqlobjectevent import (
    ...     SQLObjectToBeModifiedEvent, SQLObjectModifiedEvent)

Privacy and Unpriviledged Users
-------------------------------

Let's log in as the user Foo Bar (to be allowed to edit bugs):

    >>> login('foo.bar@canonical.com')
    >>> foobar = getUtility(ILaunchBag).user

and mark one of the Firefox bugs private. While we do this, we're also
going to subscribe the Ubuntu team to the bug report to help demonstrate
later on the interaction between privacy and teams (see the section
entitled _Privacy and Team Awareness_):

    >>> from canonical.launchpad.interfaces import IBug
    >>> from canonical.launchpad.webapp.snapshot import Snapshot

    >>> bug_upstream_firefox_no_svg_support = bugtaskset.get(2)

    >>> ubuntu_team = personset.get(17)
    >>> subscription = bug_upstream_firefox_no_svg_support.bug.subscribe(
    ...     ubuntu_team)

    >>> notify(SQLObjectToBeModifiedEvent(
    ...     bug_upstream_firefox_no_svg_support.bug, {'private' : True}))

    >>> old_state = Snapshot(
    ...     bug_upstream_firefox_no_svg_support.bug, providing=IBug)
    >>> bug_upstream_firefox_no_svg_support.bug.private = True
    >>> bug_set_private = SQLObjectModifiedEvent(
    ...     bug_upstream_firefox_no_svg_support.bug, old_state,
    ...     ["id", "title", "private"])
    >>> notify(bug_set_private)

    >>> from canonical.database.sqlbase import flush_database_updates
    >>> flush_database_updates()

If we now login as someone who was neither implicitly nor explicitly subscribed
to this bug, e.g. No Privileges Person, they will not be able to access or set
properties of the bugtask.

    >>> login("no-priv@canonical.com")
    >>> mr_no_privs = getUtility(ILaunchBag).user

    >>> bug_upstream_firefox_no_svg_support.status
    Traceback (most recent call last):
      ...
    Unauthorized: (..., 'status', 'launchpad.View')

    >>> bug_upstream_firefox_no_svg_support.transitionToStatus(
    ...     BugTaskStatus.FIXCOMMITTED)
    Traceback (most recent call last):
      ...
    Unauthorized: (..., 'transitionToStatus', 'launchpad.Edit')

The private bugs will be invisible to No Privileges Person in the search
results:

    >>> params = BugTaskSearchParams(
    ...     status=any(STATUS_UNCONFIRMED, STATUS_CONFIRMED),
    ...     orderby="id", user=mr_no_privs)
    >>> bugtasks = upstream_mozilla.searchTasks(params)
    >>> print bugtasks.count()
    3
    >>> bug_ids = [bt.bug.id for bt in bugtasks]
    >>> print sorted(bug_ids)
    [4, 5, 6]

Likewise when the No Privileges Person tries to do a search on tasks
maintained by Foo Bar.

    >>> foobar_maintained_tasks = bugtaskset.maintainedBugTasks(
    ...     foobar, user=mr_no_privs)
    >>> [bugtask.bug.id for bugtask in foobar_maintained_tasks]
    [2]

Privacy and Priviledged Users
-----------------------------

Now, we'll log in as Mark Shuttleworth, who was assigned to this bug
when it was marked private:

    >>> login("mark@hbd.com")

And note that he can access and set the bugtask attributes:

    >>> bug_upstream_firefox_no_svg_support.status.title
    'Unconfirmed'

    >>> bug_upstream_firefox_no_svg_support.transitionToStatus(
    ...     BugTaskStatus.UNCONFIRMED)

Privacy and Team Awareness
--------------------------

No Privileges Person can't see the private bug, because he's not a subscriber:

    >>> login("no-priv@canonical.com")
    >>> no_priv = personset.getByName("no-priv")
    >>> params = BugTaskSearchParams(
    ...     status=any(STATUS_UNCONFIRMED, STATUS_CONFIRMED), user=no_priv)
    >>> firefox_bugtasks = firefox.searchTasks(params)
    >>> [bugtask.bug.id for bugtask in firefox_bugtasks]
    [4, 5, 6]


But if we add No Privileges Person to the Ubuntu Team, and because the Ubuntu
Team *is* subscribed to the bug, No Privileges Person will see the private bug.

    >>> login("mark@hbd.com")
    >>> ubuntu_team.addMember(no_priv)

    >>> login("no-priv@canonical.com")
    >>> params = BugTaskSearchParams(
    ...     status=any(STATUS_UNCONFIRMED, STATUS_CONFIRMED), user=foobar)
    >>> firefox_bugtasks = firefox.searchTasks(params)
    >>> [bugtask.bug.id for bugtask in firefox_bugtasks]
    [1, 4, 5, 6]


If we query for all bugtasks reported on all packages/products that
Sample Person maintains, we'll see that bug 1 is there (we'll not see it
if we query logged in as a user who can't see that bug).

    >>> foobar_maintained_tasks = bugtaskset.maintainedBugTasks(
    ...     sample_person, user=foobar)
    >>> sorted(bugtask.bug.id for bugtask in foobar_maintained_tasks)
    [1, 4, 5, 7]

Privacy and Launchpad Admins
----------------------------

Let's log in as Daniel Henrique Debonzi:

    >>> login("daniel.debonzi@canonical.com")
    >>> debonzi = getUtility(ILaunchBag).user

The same search as above yields the same result, because Daniel Debonzi is an
administrator.

    >>> firefox = productset.get(4)
    >>> params = BugTaskSearchParams(status=any(STATUS_UNCONFIRMED,
    ...                                         STATUS_CONFIRMED),
    ...                              user=debonzi)
    >>> firefox_bugtasks = firefox.searchTasks(params)
    >>> [bugtask.bug.id for bugtask in firefox_bugtasks]
    [1, 4, 5, 6]

If, still logged in as Daniel Debonzi, we query for all bugtasks
reported on packages/products for which Sample Person is the maintainer,
we'll also see bug 1 again in the results, even though it's private.

    >>> foobar_maintained_tasks = bugtaskset.maintainedBugTasks(
    ...     sample_person, user=debonzi)
    >>> sorted(bugtask.bug.id for bugtask in foobar_maintained_tasks)
    [1, 4, 5, 7]

Trying to retrieve the bug directly will work fine:

    >>> bug_upstream_firefox_no_svg_support = bugtaskset.get(2)

As will attribute access:

    >>> bug_upstream_firefox_no_svg_support.status.title
    'Unconfirmed'

And attribute setting:

    >>> bug_upstream_firefox_no_svg_support.transitionToStatus(
    ...     BugTaskStatus.FIXRELEASED)
    >>> bug_upstream_firefox_no_svg_support.transitionToStatus(
    ...     BugTaskStatus.UNCONFIRMED)

Sorting Bug Tasks
-----------------

Bug tasks need to sort in a very particular order. We want product tasks
first, then ubuntu tasks, then other distro-related tasks. In the
distro-related tasks we want a distribution-task first, then
distrorelease-tasks for that same distribution. The distrorelease tasks
should be sorted by distrorelease version.

Phew.

Let's just make sure that the tasks on bug_one sort correctly.

    >>> tasks = bug_one.bugtasks
    >>> for task in tasks:
    ...     print task.targetname
    evolution (upstream)
    firefox (upstream)
    firefox 1.0 (upstream)
    Ubuntu
    evolution (Ubuntu)
    mozilla-firefox (Ubuntu)
    Ubuntu Warty
    mozilla-firefox (Debian)

BugTask Adaptation
------------------

An IBugTask can be adapted to an IBug.

   >>> from canonical.launchpad.interfaces import IBug

   >>> bugtask_four = bugtaskset.get(4)
   >>> bug = IBug(bugtask_four)
   >>> bug.title
   u'Firefox does not support SVG'

The targetnamecache attribute of BugTask
----------------------------------------

The BugTask table has this targetnamecache attribute which stores a computed
value to allow us to sort and search on that value without having to do lots
of SQL joins. This cached value gets updated daily by the
update-bugtask-targetnamecaches cronscript and whenever the bugtask is changed.
Of course, it's also computed and set when a bugtask is created.

    >>> upstream_task = bugtaskset.createTask(
    ...     bug=bug_one, product=netapplet, owner=sabdfl,
    ...     status=STATUS_UNCONFIRMED, importance=IMPORTANCE_MEDIUM)
    >>> upstream_task.targetname
    u'netapplet (upstream)'

    >>> thunderbird = productset.get(8)
    >>> upstream_task_id = upstream_task.id
    >>> upstream_task.product = thunderbird
    >>> upstream_task.targetname
    u'thunderbird (upstream)'

    >>> thunderbird.name = 'thunderbird-ng'

    # XXX: This flush_database_updates() shouldn't be needed because we
    # already have the transaction.commit() here, but without it
    # (flush_database_updates), the cronscript won't see the thunderbird name
    # change. See https://launchpad.net/products/launchpad/+bug/3989 for more
    # information.
    >>> flush_database_updates()
    >>> transaction.commit()

    >>> import subprocess
    >>> process = subprocess.Popen(
    ...     'cronscripts/update-bugtask-targetnamecaches.py -q', shell=True,
    ...     stdin=subprocess.PIPE, stdout=subprocess.PIPE,
    ...     stderr=subprocess.PIPE)
    >>> (out, err) = process.communicate()
    >>> out, err
    ('', '')
    >>> process.returncode
    0

    # XXX: If we don't call flush_database_caches() here, we won't see the
    # changes made by the cronscript in objects we already have cached.
    >>> flush_database_caches()
    >>> transaction.commit()

    >>> bugtaskset.get(upstream_task_id).targetname
    u'thunderbird-ng (upstream)'

Target Uses Malone
------------------

Bug tasks have a flag, target_uses_malone, that says whether the bugtask
target uses Malone as its official bugtracker.

    >>> for bugtask in bug_one.bugtasks:
    ...     print "%-30s %s" % (bugtask.targetname, bugtask.target_uses_malone)
    evolution (upstream)           True
    firefox (upstream)             True
    firefox 1.0 (upstream)         True
    thunderbird-ng (upstream)      False
    Ubuntu                         True
    evolution (Ubuntu)             True
    mozilla-firefox (Ubuntu)       True
    Ubuntu Warty                   True
    mozilla-firefox (Debian)       False

Handling IntegrityError and ProgrammingError
--------------------------------------------

XXX: Brad Bollenbach, 2005-02-24: This bit testing the IntegrityError should be
higher up in the file (under the explanation about creating tasks), but I can't
figure out how to reset the connection properly after an IntegrityError is
raised. ARGH.

Note that a task filed on a specific distro release does *not* have its
distribution column set. In fact, a task must have exactly one of its product,
distribution or distrorelease fields set, otherwise the database integrity
constraints will be violated.

note that DatabaseError is a superclass of both IntegrityError and
ProgrammingError

    >>> from psycopg import DatabaseError
    >>> import sys
    >>> try: bad_task = bugtaskset.createTask(
    ...     bug=bug_one, distribution=ubuntu, distrorelease=warty,
    ...     owner=sabdfl, status=STATUS_UNCONFIRMED,
    ...     importance=IMPORTANCE_MEDIUM)
    ... except DatabaseError: print sys.exc_value
    ERROR:  new row for relation "bugtask" violates check constraint "bugtask_assignment_checks"
    <BLANKLINE>
    /*...*/ INSERT INTO BugTask ...

