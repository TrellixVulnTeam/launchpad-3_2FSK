== The nascent uploads ==

Import the test keys so we have them ready for verification

  >>> from canonical.launchpad.ftests import import_public_test_keys
  >>> import_public_test_keys()

We need to be logged into the security model in order to get any further

  >>> login('foo.bar@canonical.com')

For the purpose of this test, hoary needs to be an open (development)
distrorelease so that we can upload to it.

  >>> from canonical.launchpad.interfaces import IDistributionSet
  >>> ubuntu = getUtility(IDistributionSet)['ubuntu']
  >>> hoary = ubuntu['hoary']
  >>> from canonical.lp.dbschema import DistributionReleaseStatus
  >>> hoary.releasestatus = DistributionReleaseStatus.DEVELOPMENT

A nascent upload is a collection of files in a directory. They
represent what may turn out to be an acceptible upload to a launchpad
managed archive.

  >>> from canonical.archivepublisher.nascentupload import NascentUpload
  >>> from canonical.archivepublisher.uploadpolicy import findPolicyByName
  >>> from canonical.archivepublisher.tests import (
  ...    datadir, mock_options, mock_logger, mock_logger_quiet)

The policy we feed to to the nascent upload needs to have its command
line options passed in.

  >>> class MockOptions:
  ...     distro = "ubuntu"
  ...     distrorelease = "hoary"

  >>> class BuilddOptions(MockOptions):
  ...     buildid = 1


When initially constructing a NascentUpload instance, it verifies that
the changes file specified exists, raising FileNotFound if it does not.

  >>> buildd_policy = findPolicyByName('buildd')
  >>> buildd_policy.setOptions(BuilddOptions())

  >>> NascentUpload(datadir("DOES-NOT-EXIST"), buildd_policy, mock_logger)
  Traceback (most recent call last):
  ...
  FatalUploadError:...

XXX

  >>> buildd_policy = findPolicyByName('buildd')
  >>> buildd_policy.setOptions(BuilddOptions())
  >>> buildd_policy.can_upload_source = True
  >>> buildd_policy.can_upload_mixed = True

  >>> ed_source_upload = NascentUpload(
  ...     datadir("ed_0.2-20_i386.changes.source-only-unsigned"),
  ...     buildd_policy, mock_logger_quiet)

  >>> ed_source_upload.process()

  >>> ed_source_upload.sourceful
  True

  >>> ed_source_upload.binaryful
  False

XXX

  >>> buildd_policy = findPolicyByName('buildd')
  >>> buildd_policy.setOptions(BuilddOptions())

  >>> ed_binary_upload = NascentUpload(
  ...     datadir("ed_0.2-20_i386.changes.binary-only-unsigned"),
  ...     buildd_policy, mock_logger_quiet)

  >>> ed_binary_upload.process()

  >>> ed_binary_upload.sourceful
  False
  >>> ed_binary_upload.binaryful
  True
  >>> ed_binary_upload.archdep
  True
  >>> ed_binary_upload.archindep
  False

'native' and 'hasorig' status are always false for binary uploads:

  >>> ed_binary_upload.native
  False
  >>> ed_binary_upload.hasorig
  False

We can distinguish between the arch-indep and arch-dep binary uploads.

  >>> buildd_policy = findPolicyByName('buildd')
  >>> buildd_policy.setOptions(BuilddOptions())
  >>> quodlibet = NascentUpload(
  ...     datadir("quodlibet_0.13.1-1_i386.changes"),
  ...     buildd_policy, mock_logger_quiet)

  >>> quodlibet.process()

  >>> quodlibet.sourceful
  False
  >>> quodlibet.binaryful
  True
  >>> quodlibet.archdep
  True
  >>> quodlibet.archindep
  True


If the Architecture line does not match then we get an exception.

  >>> buildd_policy = findPolicyByName('buildd')
  >>> buildd_policy.setOptions(BuilddOptions())
  >>> buildd_policy.can_upload_source = True
  >>> buildd_policy.can_upload_mixed = True

  >>> ed_mismatched_upload = NascentUpload(
  ...     datadir("ed_0.2-20_i386.changes.mismatched-arch-unsigned"),
  ...     buildd_policy, mock_logger_quiet)
  >>> ed_mismatched_upload.process()

  >>> print ed_mismatched_upload.rejection_message
  ed_0.2-20_i386.deb: control file lists arch as 'i386' which isn't in the changes file.


Let's start a new upload, mixed-mode.

  >>> insecure_policy = findPolicyByName('insecure')
  >>> insecure_policy.setOptions(MockOptions())
  >>> insecure_policy.can_upload_binaries = True
  >>> insecure_policy.can_upload_mixed = True

  >>> ed_mixed_upload = NascentUpload(
  ...     datadir("ed_0.2-20_i386.changes"), insecure_policy, mock_logger)
  DEBUG: Verifying signature on ed_0.2-20_i386.changes

The upload can extract distributions and distroreleases if it tries

  >>> ed_mixed_upload.policy.distro.name
  u'ubuntu'
  >>> ed_mixed_upload.policy.distrorelease.name
  u'hoary'

Finally we can ask the upload to process itself.

  >>> ed_mixed_upload.process()
  DEBUG: Beginning processing.
  DEBUG: Performing DSC verification.
  DEBUG: Verifying signature on ed_0.2-20.dsc
  DEBUG: Verifying the changes file.
  DEBUG: Verifying files in upload.
  DEBUG: Verifying source file ed_0.2-20.dsc
  DEBUG: Verifying uploaded source package by unpacking it.
  DEBUG: Cleaning up source tree.
  DEBUG: Done
  DEBUG: Verifying source file ed_0.2-20.diff.gz
  DEBUG: Verifying binary ed_0.2-20_i386.deb
  DEBUG: Verifying timestamps in ed_0.2-20_i386.deb
  DEBUG: Finding and applying overrides.
  DEBUG: Checking for ed/0.2-20 source ancestry
  DEBUG: ed: (source) NEW
  DEBUG: Checking for ed/0.2-20/i386 binary ancestry
  DEBUG: ed: (binary) NEW
  DEBUG: Foo Bar (16) is an uploader for main, restricted, universe.
  DEBUG: Finished checking upload.

  >>> print ed_mixed_upload.rejection_message+"\nEND"
  END

  >>> ed_mixed_upload.is_rejected
  False

Going back to the upload itself, at a very basic level a NascentUpload
allows us to probe the contents of the changes file to see things like
the maintainer.

  >>> ed_mixed_upload.changes.maintainer['rfc822']
  'James Troup <james@nocrew.org>'

We can also extract the list of files from the upload. If this raises
an exception then the file list is utterly broken.

  >>> for uploaded_file in ed_mixed_upload.changes.files:
  ...     print uploaded_file.filename
  ed_0.2-20.dsc
  ed_0.2-20.diff.gz
  ed_0.2-20_i386.deb

  >>> [f.filename for f in ed_mixed_upload.changes.binary_package_files]
  ['ed_0.2-20_i386.deb']

The nascent upload can tell us if it is sourceful or not, (ditto binaryful)

  >>> ed_mixed_upload.sourceful
  True
  >>> ed_mixed_upload.binaryful
  True
  >>> ed_mixed_upload.archindep
  False
  >>> ed_mixed_upload.archdep
  True

Tweak hoary distrorelease to have the right changeslist address:

  >>> from canonical.launchpad.database import (
  ...     SourcePackageName, BinaryPackageName, DistroRelease)
  >>> hoary = DistroRelease.get(3)
  >>> saved_list = hoary.changeslist
  >>> hoary.changeslist = "dapper-announce@lists.ubuntu.com"
  >>> hoary.sync()

  >>> ed_mixed_upload.policy.distrorelease.changeslist
  u'dapper-announce@lists.ubuntu.com'


  >>> success, msgs = ed_mixed_upload.do_accept()
  DEBUG: Building recipients list.
  DEBUG: Attempting to decide if James Troup is in the keyring.
  DEBUG: Decision: False
  DEBUG: Adding recipient: 'Foo Bar <foo.bar@canonical.com>'
  DEBUG: Creating queue entry
  DEBUG: Build ... created

  >>> success
  True

  >>> for msg in msgs:
  ...     print msg, "END"
  From: Root <root@localhost>
  To: Foo Bar <foo.bar@canonical.com>
  Bcc: Root <root@localhost>
  Precedence: bulk
  Subject: ed_0.2-20_i386.changes is NEW
  <BLANKLINE>
  NEW: ed_0.2-20.dsc
   OK: ed_0.2-20.diff.gz
  NEW: ed_0.2-20_i386.deb
  <BLANKLINE>
  -----BEGIN PGP SIGNED MESSAGE-----
  Hash: SHA1
  <BLANKLINE>
  Format: 1.7
  Date: Wed,  2 Apr 2003 17:19:47 +0100
  Source: ed
  Binary: ed
  Architecture: source i386
  Version: 0.2-20
  Distribution: unstable
  Urgency: low
  Maintainer: James Troup <james@nocrew.org>
  Changed-By: James Troup <james@nocrew.org>
  Description:
   ed         - The classic unix line editor
  Closes: 122517 130327 179957
  Changes:
   ed (0.2-20) unstable; urgency=low
   .
     * Move to dpatch; existing non-debian/ changes split into
       01_buf.c-tmpfile, 02_-Wall-cleanup, 03_ed.1-cleanup and
       04_Makfile.in-no-libed.
     * debian/rules: include /usr/share/dpatch/dpatch.make.
     * debian/rules (build): depend on patch-stamp.
     * debian/rules (clean): depend on unpatch.  Remove debian/patched.
     * debian/rules (.PHONY): add 'patch' and 'unpatch'.
     * debian/control (Build-Depends): add dpatch.
   .
     * debian/rules: update copyright.
     * debian/copyright: likewise and update upstream URL.
     * debian/changelog: remove local-variables stuff.
   .
     * debian/rules: use install_foo convenience variables.
     * debian/rules (clean): remove *~ in any subdirectory.
   .
     * debian/control (Standards-Version): bump to 3.5.8.0.
     * debian/postinst, debian/prerm: no longer do /usr/doc symlinks.
   .
     * config, test/*: unused aegis cruft; removed.
     * Undo s/%/$/ change in RCS keywords.
   .
     * debian/postinst: provide editor.1.gz alternative; thanks to Ben Harris
       <bjh21@cam.ac.uk> for the suggestion.  Closes: #122517
     * 05_ed.1-warning-fix.dpatch: new patch to avoid groff warnings.  Thanks
       to Colin Watson <cjwatson@debian.org>.  Closes: #179957
     * 06_testsuite-Makefile.dpatch: new patch to ensure the test suite bombs
       out on errors.  Thanks to Joel Baker <fenton@debian.org>.
       Closes: #130327
  Files:
   e31eeb0b6b3b87e1ea79378df864be18 522 editors important ed_0.2-20.dsc
   f9e1e5f13725f581919e9bfd62272a05 8506 editors important ed_0.2-20.diff.gz
   0c466ce6a160c62fa558fbbb46a4ea45 44718 editors important ed_0.2-20_i386.deb
  <BLANKLINE>
  -----BEGIN PGP SIGNATURE-----
  ...
  -----END PGP SIGNATURE-----
  <BLANKLINE>
  <BLANKLINE>
  Your package contains new components which requires manual editing of
  the override file.  It is ok otherwise, so please be patient.  New
  packages are usually added to the overrides about once a week.
  <BLANKLINE>
  You may have gotten the distrorelease wrong.  If so, you may get warnings
  above if files already exist in other distroreleases.
  END

We can ask sourceful uploads if they are native or not. If they are
not native we can find out if they have an orig.tar.gz or not.

  >>> ed_mixed_upload.native
  False
  >>> ed_mixed_upload.hasorig
  False

We can parse addresses and look them up in launchpad.

  >>> addr = ed_mixed_upload.changes.parse_address(
  ...     "Foo Bar <foo.bar@canonical.com>")
  >>> addr['person'].displayname
  u'Foo Bar'

If the address is unparsable, we get an error.

  >>> ed_mixed_upload.changes.parse_address("Cannot Parse Me <FOOO>")
  Traceback (most recent call last):
  ...
  UploadError: Cannot Parse Me <FOOO>: no @ found in email address part.

If the email address is not yet registered and policy.create_people is True,
a new Person will be created.

  >>> orig_create_people = ed_mixed_upload.policy.create_people
  >>> ed_mixed_upload.policy.create_people = True
  >>> addr = ed_mixed_upload.changes.parse_address("Baz <baz@canonical.com>")
  >>> addr['person'].creation_rationale.name
  'SOURCEPACKAGEUPLOAD'
  >>> addr['person'].creation_comment
  u'when the ed package was uploaded to Ubuntu'
  >>> ed_mixed_upload.policy.create_people = orig_create_people

Retrive the just-inserted SourcePackageRelease correspondent to 'ed'
(it's the only one we have, the process to retrieve a non-published
SPR w/o at least and DRQ entry is quite unusual)

  >>> from canonical.launchpad.database import (
  ...     SourcePackageRelease, SourcePackageName)
  >>> ed_name = SourcePackageName.selectOneBy(name='ed')
  >>> ed_spr = SourcePackageRelease.selectBy(sourcepackagenameID=ed_name.id)[0]

Check if we have rebuid the change's author line properly (as
mentioned in bug # 30621)

  >>> print ed_spr.changelog
  ed (0.2-20) unstable; urgency=low
  ...
   -- James Troup <james@nocrew.org>  Wed,  2 Apr 2003 17:19:47 +0100

Some new fields required for NoMoreAptFtparchive implementation are
present in SourcePackageRelease. They are cached from the DSC and used
for the archive index generation:

The 'Maintainer:' identification in RFC-822 format, as it was in DSC:

  >>> ed_spr.dsc_maintainer_rfc822
  u'James Troup <james@nocrew.org>'

Version of debian policy/standards used to build this sourcepackage:

  >>> ed_spr.dsc_standards_version
  u'3.5.8.0'

Format of the included DSC (.dsc) file:

  >>> ed_spr.dsc_format
  u'1.0'

Binaries names claimed to be resulted of this source, line with names
separated by space:

  >>> ed_spr.dsc_binaries
  u'ed'


Roll back everything so that we can try again

  >>> import transaction
  >>> transaction.abort()

First up, construct an upload of just the ed source...

  >>> sync_policy = findPolicyByName('sync')
  >>> sync_policy.setOptions(MockOptions())

  >>> ed_src = NascentUpload(
  ...     datadir('split-upload-test/ed_0.2-20_source.changes'),
  ...     sync_policy, mock_logger_quiet)
  >>> ed_src.process()
  >>> ed_src.is_rejected
  False
  >>> success, msgs = ed_src.do_accept()
  >>> success
  True

The ed source would be in NEW, so punt it into accepted.

  >>> from canonical.lp.dbschema import DistroReleaseQueueStatus
  >>> from canonical.launchpad.interfaces import QueueInconsistentStateError
  >>> new_queue = hoary.getQueueItems(DistroReleaseQueueStatus.NEW)
  >>> for item in new_queue:
  ...     try:
  ...         print "%s/%s" % (item.sourcepackagerelease.name,
  ...                          item.sourcepackagerelease.version)
  ...         item.setAccepted()
  ...         item.sync()
  ...     except QueueInconsistentStateError, info:
  ...         print info
  ed/0.2-20


Check if we refuse duplicated uploads even before publishing (bug #31038)

The uploaded source will be considered okay, since it still passing
all the consistency checks.

However there is another candidate, submitted before and not yet
published in the archive, which provides the same sourcepackagename
and sourcepackageversion for the distrorelease in question.

  >>> sync_policy = findPolicyByName('sync')
  >>> sync_policy.setOptions(MockOptions())
  >>> ed_src = NascentUpload(
  ...     datadir('split-upload-test/ed_0.2-20_source.changes'),
  ...     sync_policy, mock_logger_quiet)
  >>> ed_src.process()
  >>> ed_src.is_rejected
  False

This is a special trick to make do_accept() consider this upload OLD
(publication already present in the archive), so it will try to
automatically promote the queue entry to ACCEPTED.

  >>> for upload_file in ed_src.changes.files:
  ...     upload_file.new = False

The we invoke do_accept() normally, since the upload is consistent.
but since the uniqueness check in IDRQ.setAccepted() has detected
another accepted candidate that conflicts with the proposed one.
The upload will be rejected.

  >>> success, msgs = ed_src.do_accept()
  >>> ed_src.is_rejected
  True
  >>> print ed_src.rejection_message
  Exception while accepting: This sourcepackagerelease is already accepted in hoary.

We rely on process-upload transaction rollback to not store bogus
queue entry in the database.

  >>> success
  False

  >>> hoary.getQueueItems(DistroReleaseQueueStatus.NEW).count()
  1

Next we send in the binaries, since the source should be in ACCEPTED the
binary should go straight there too.

XXX cprov 20060728: Building from ACCEPTED is special condition, not
really used in production. We should remove the support for this use
case, see further info in bug #55774.

  >>> sync_policy = findPolicyByName('sync')
  >>> sync_policy.setOptions(MockOptions())
  >>> sync_policy.can_upload_binaries = True

  >>> ed_bin = NascentUpload(
  ...      datadir('split-upload-test/ed_0.2-20_i386.changes'),
  ...      sync_policy, mock_logger)
  DEBUG: Changes file can be unsigned.

  >>> ed_bin.process()
  DEBUG: Beginning processing.
  DEBUG: Verifying the changes file.
  DEBUG: Verifying files in upload.
  DEBUG: Verifying binary ed_0.2-20_i386.deb
  DEBUG: Verifying timestamps in ed_0.2-20_i386.deb
  DEBUG: Finding and applying overrides.
  DEBUG: Checking for ed/0.2-20/i386 binary ancestry
  DEBUG: ed: (binary) NEW
  DEBUG: No signer, therefore ACL not processed
  DEBUG: Finished checking upload.

  >>> ed_bin.is_rejected
  False

  >>> print ed_bin.rejection_message

  >>> success, msgs = ed_bin.do_accept()
  DEBUG: Building recipients list.
  DEBUG: Changes file is unsigned, adding changer as recipient
  DEBUG: Creating queue entry
  DEBUG: No source published, checking the ACCEPTED queue
  DEBUG: Build 23 created

  >>> ed_bin.queue_root.status.name
  'NEW'

Chuck it all away again

  >>> transaction.abort()

And this time, try an upload to -updates, it'll have to be signed etc because
we're using the insecure policy to check everything in it end-to-end. We have
to set hoary to CURRENT in order to do this because we're not allowed
to upload to -UPDATES in a DEVELOPMENT release.

  >>> hoary.releasestatus = DistributionReleaseStatus.CURRENT

  >>> sync_policy = findPolicyByName('sync')
  >>> sync_policy.setOptions(MockOptions())
  >>> sync_policy.distrorelease = None # Override this by the changes
  >>> ed_src = NascentUpload(
  ...     datadir('updates-upload-test/ed_0.2-20_source.changes'),
  ...     sync_policy, mock_logger_quiet)
  >>> ed_src.process()
  >>> ed_src.is_rejected
  False

  >>> success, msgs = ed_src.do_accept()

  >>> print ed_src.queue_root.pocket.name
  UPDATES

Even though this went to a pocket and thus would be unapproved rather
than accepted, the ed upload ought still make it to NEW instead of
unapproved.

  >>> print ed_src.queue_root.status.name
  NEW

And pop it back to development now that we're done

  >>> hoary.releasestatus = DistributionReleaseStatus.DEVELOPMENT

Check the uploader behaviour against a missing orig.tar.gz file,
bug # 30741.

  >>> sync_policy = findPolicyByName('sync')
  >>> sync_policy.setOptions(MockOptions())
  >>> ed21_src = NascentUpload(
  ...     datadir('ed-0.2-21/ed_0.2-21_source.changes'),
  ...     sync_policy, mock_logger_quiet)
  >>> ed21_src.process()
  >>> ed21_src.is_rejected
  True
  >>> print ed21_src.rejection_message+"\nEND"
  Unable to find ed_0.2.orig.tar.gz in upload or distribution.
  Files specified in DSC are broken or missing, skipping package unpack verification.
  END

== Installer source uploads doesn't contain 'Standards-Version' ==

Check if we can accept a installer-source upload which doesn't have
'Standards-Version' field in DSC. See bug #75874 for further
information.

  >>> sync_policy = findPolicyByName('sync')
  >>> sync_policy.setOptions(MockOptions())
  >>> inst_src = NascentUpload(
  ...     datadir('test75874_0.1_source.changes'),
  ...     sync_policy, mock_logger_quiet)
  >>> inst_src.process()

  >>> inst_src.is_rejected
  False

  >>> success, msgs = inst_src.do_accept()
  >>> success
  True

Look for the respective SourcePackageRelease entry and inspect its
content, it should have all the required fields except the
'dsc_standards_version':

  >>> inst_queue = hoary.getQueueItems(DistroReleaseQueueStatus.NEW,
  ...                                  name='test75874', exact_match=True)[0]
  >>> inst_spr = inst_queue.sources[0].sourcepackagerelease

  >>> inst_spr.dsc_maintainer_rfc822
  u'Colin Watson <cjwatson@ubuntu.com>'

  >>> inst_spr.dsc_binaries
  u'test75874'

  >>> inst_spr.dsc_standards_version is None
  True

Chuck it all away again

  >>> transaction.abort()

== Insecure Policy ==

'insecure' upload policy forces NascentUpload to perform ACLs over the
DSC signature. It only allows 'source' upload where both, changesfile
and DSC, should be signed.

Import the test keys again since the transaction was aborted before.

  >>> from canonical.launchpad.ftests import import_public_test_keys
  >>> import_public_test_keys()

When using 'insecure' policy, NascentUpload instace stores the DSC
sigining key reference as an IGPGKey:

  >>> insecure_policy = findPolicyByName('insecure')
  >>> insecure_policy.setOptions(MockOptions())
  >>> bar_ok = NascentUpload(
  ...     datadir('suite/bar_1.0-1/bar_1.0-1_source.changes'),
  ...     insecure_policy, mock_logger_quiet)
  >>> bar_ok.process()
  >>> bar_ok.is_rejected
  False

  >>> from zope.interface.verify import verifyObject
  >>> from canonical.launchpad.interfaces import (
  ...    IGPGKey, IPersonSet)

  >>> verifyObject(IGPGKey, bar_ok.changes.dsc.signingkey)
  True

  >>> verifyObject(IGPGKey, bar_ok.changes.signingkey)
  True

The second key of name16 person is used to sign uploads (the first gpgkey
record is a placeholder one, we used the second key):

  >>> name16 = getUtility(IPersonSet).getByName('name16')
  >>> uploader_key = name16.gpgkeys[1]

Both, DSC and changesfile were signed:

  >>> bar_ok.changes.dsc.signingkey.fingerprint == uploader_key.fingerprint
  True

  >>> bar_ok.changes.signingkey.fingerprint == uploader_key.fingerprint
  True

Let's modify the current ACL rules for ubuntu, moving the upload
rights to all commponents from 'ubuntu-team' to 'sabdfl':

  >>> new_uploader = getUtility(IPersonSet).getByName('sabdfl')
  >>> for distro_component in ubuntu.uploaders:
  ...     distro_component.uploader = new_uploader

This time the upload should fail because the ACLs don't let
"name16", the key owner, upload a package.

  >>> insecure_policy = findPolicyByName('insecure')
  >>> insecure_policy.setOptions(MockOptions())
  >>> bar_failed = NascentUpload(
  ...     datadir('suite/bar_1.0-1/bar_1.0-1_source.changes'),
  ...     insecure_policy, mock_logger_quiet)

  >>> bar_failed.process()
  >>> bar_failed.is_rejected
  True
  >>> print bar_failed.rejection_message
  Signer has no upload rights at all to this distribution.

Even in a rejected upload using 'insecure' policy, the DSC signing key
and the changesfile sigining key are stored in NascentUpload instance
for further checks:

  >>> verifyObject(IGPGKey, bar_failed.changes.dsc.signingkey)
  True
  >>> verifyObject(IGPGKey, bar_failed.changes.signingkey)
  True

  >>> bar_failed.changes.dsc.signingkey.fingerprint == uploader_key.fingerprint
  True
  >>> bar_failed.changes.signingkey.fingerprint == uploader_key.fingerprint
  True


== DEB packages using BZIP ==

Deb packages can compress their contents in a bzip tar file. But
in these case, the control file should state that the package
Pre-depends on a newer version of dpkg. NascentUploadFile enforces
that constraint.

  >>> sync_policy = findPolicyByName('sync')
  >>> sync_policy.setOptions(MockOptions())
  >>> sync_policy.can_upload_binaries = True
  >>> sync_policy.can_upload_mixed = True
  >>> foo_failed = NascentUpload(
  ...     datadir('suite/foo_1.0-1_mixed/foo_1.0-1_i386.changes'),
  ...     sync_policy, mock_logger_quiet)
  >>> foo_failed.process()

  >>> print foo_failed.rejection_message
  foo_1.0-1_i386.deb uses bzip2 compression but pre-depends on an old version of dpkg: 1.10.20
