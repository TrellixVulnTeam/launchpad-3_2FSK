= Create a question from a bug =

Bugs can be converted into questions when a person ascertains that
that is the nature of the issue

The bug's target must be adaptable to IQuestionTarget and must use
Launchpad track bugs--see bugtarget-questiontarget.txt in
interfaces/ftests/ for more information on this issue.

    >>> from canonical.launchpad.interfaces import (
    ...     CreateBugParams, BugTaskStatus, IBugSet, IBugTaskSet,
    ...     IDistributionSet, IPersonSet, IProductSet, IQuestionTarget,
    ...     ISourcePackageNameSet)

Some parts of the IQuestionTarget interface are only accessible
to a registered user. No Privileges Person will create the bugs,
Sample Person will play the role of bug contact.

    >>> no_priv = getUtility(IPersonSet).getByName('no-priv')
    >>> sample_person = getUtility(IPersonSet).getByName('name12')
    >>> login('test@canonical.com')

The bug selects the only bugtask that can provide a QuestionTarget.
The bugtask must be in New, Incomplete, Confirmed, or Wont Fix
status, and the target's pillar must use Launchpad to track bugs.
Jokosher does use Launchpad to track bugs; its bugs can be converted
to questions.

    >>> login('no-priv@canonical.com')

    >>> target = getUtility(IProductSet)['jokosher']
    >>> bug_params = CreateBugParams(
    ...     title="Print is broken", comment="blah blah blah", owner=no_priv)
    >>> bug_params.setBugTarget(product=target)
    >>> bug = target.createBug(bug_params)
    >>> bugtask = bug.bugtasks[0]
    >>> bugtask.status.title
    'New'
    >>> target.official_malone
    True
    >>> IQuestionTarget.providedBy(target)
    True

The primary use case for converting a bug into a question is when
a bug contact recognises a bug is really a question. This happens
at the UI level. For example, Sample Person would recognise that
this bug is a question while reviewing Jokosher's bugs, and choose
to make it into a question. The UI would pass Jokosher as the
QuestionTarget and Sample Person as the Person.

    >>> login('test@canonical.com')
    >>> question = bug.createQuestionFromBug(
    ...     sample_person, "This is a question.")

    >>> question.target == target
    True
    >>> question.owner == bug.owner
    True
    >>> question.title == bug.title
    True
    >>> question.description == bug.description
    True
    >>> question.messages[-1].text_contents == bug.messages[-1].text_contents
    True

    >>> question.owner.displayname
    u'No Privileges Person'
    >>> question.title
    u'Print is broken'
    >>> question.description
    u'blah blah blah'
    >>> question.messages[-1].text_contents
    u'This is a question.'

Once converted to a question, the bugtask status is Invalid. The
statusexplanation explanation is set to an empty string.

    >>> bugtask.status.title
    'Invalid'
    >>> print bugtask.statusexplanation
    This is a question.

Subscribers to the bug are notified that the bug was made into a
question and that the bugtasks are Invalid.

    >>> from canonical.launchpad.tests.mail_helpers import pop_notifications
    >>> notifications = pop_notifications()
    >>> len(notifications)
    1

    >>> notifications[0]['To']
    'no-priv@canonical.com'

    >>> notifications[0]['Subject']
    '[Question #15]: Print is broken'

A bug can only be converted to a question once.

    >>> question = bug.createQuestionFromBug(sample_person, "Fail.")
    Traceback (most recent call last):
    ...
    AssertionError: This bug was already converted to question #...


== getQuestionCreatedFromBug() ==

The question created from the bug is automatically linked to the
original bug. A bug can also retrieve all the questions that link
to it, but QuestionBug links are a many to many relationship. The
question can also be retrieved using the getQuestionCreatedFromBug()
method.

    >>> bug.getQuestionCreatedFromBug() == question
    True

    >>> [bug_link.question.title for bug_link in question.bug_links]
    [u'Print is broken']

    >>> [question.title for question in bug.questions]
    [u'Print is broken']


== canBeAQuestion() ==

The canBeAQuestion() method can be used to check if a question can be
created from a bug (but it will not state why).


=== The bugtask's target must use Launchpad to track bugs ===

A Firefox bug in Debian cannot be converted to a question because the
Distribution does not use Launchpad to track bugs.

    >>> firefox_bug = getUtility(IBugSet).get(8)
    >>> target = firefox_bug.bugtasks[0].target
    >>> IQuestionTarget.providedBy(target)
    True
    >>> target.distribution.official_malone
    False
    >>> firefox_bug.canBeAQuestion()
    False


== Only one bugtask must be valid ==

In the rare instance where a bug has more than one bugtask, the only
one must be have a status in New, Incomplete, Confirmed or Wont Fix,
and is not a conjoined slave. All other bugtasks must be Invalid or
a conjoined slave.

    >>> login('no-priv@canonical.com')

    >>> ubuntu = getUtility(IDistributionSet)['ubuntu']
    >>> bug_params = CreateBugParams(
    ...     title="Print is borked", comment="blah blah blah", owner=no_priv)
    >>> bug_params.setBugTarget(distribution=ubuntu)
    >>> ubuntu_bug = getUtility(IBugSet).createBug(bug_params)

    >>> evo_ubuntu = getUtility(ISourcePackageNameSet)['evolution']
    >>> evo_bugtask = getUtility(IBugTaskSet).createTask(
    ...     bug=ubuntu_bug, distribution=ubuntu, sourcepackagename=evo_ubuntu,
    ...     owner=no_priv)
    >>> bugtasks = ubuntu_bug.bugtasks
    >>> len(bugtasks)
    2

    >>> ['%s: %s' % (bt.target.name, bt.status.title) for bt in bugtasks]
    [u'ubuntu: New', u'evolution: New']

    >>> login('test@canonical.com')

    >>> ubuntu_bug.canBeAQuestion()
    False

The user can choose to Invalidate one or more bugtasks so that only
one bugtask can provide the QuestionTarget.

    >>> evo_bugtask.transitionToStatus(BugTaskStatus.INVALID, sample_person)
    >>> ubuntu_bug.canBeAQuestion()
    True

    >>> question = ubuntu_bug.createQuestionFromBug(
    ...     sample_person, "Many bugtasks are one question")
    >>> question.title
    u'Print is borked'
    >>> question.target.name
    u'ubuntu'

    >>> ['%s: %s' % (bt.target.name, bt.status.title) for bt in bugtasks]
    [u'ubuntu: Invalid', u'evolution: Invalid']
    >>> [bt.statusexplanation for bt in bugtasks]
    [u'Many bugtasks are one question', None]
