Adding BugTasks
===============

If a bug occurs in more than one place, you can request a fix in some
other software. You can request a fix in either a product or a
distribution. Let's start with a product, this is done using
+upstreamtask.

    >>> login('test@canonical.com')
    >>> from zope.component import getView
    >>> from canonical.launchpad.interfaces import IBugSet
    >>> bug_four = getUtility(IBugSet).get(4)
    >>> len(bug_four.bugtasks)
    1
    >>> firefox_task = bug_four.bugtasks[0]
    >>> from canonical.launchpad.webapp.servers import LaunchpadTestRequest

Some of the setup is done just before the view is rendered. Let's
create a helper function that makes sure the view is set up properly.
We don't care about the actual rendering of the page, so we override
the index template.

    >>> def get_and_setup_view(context, name, form):
    ...     view = getView(context, name, LaunchpadTestRequest(form=form))
    ...     view.index = lambda: ''
    ...     return view
    >>> add_task_view = get_and_setup_view(
    ...     firefox_task, '+upstreamtask', form={})

We haven't posted the form, so we'll see one button. In order to set
everything up correctly, we have to call render_upstreamtask().

    >>> add_task_view.render_upstreamtask()
    ''
    >>> [action.label for action in add_task_view.actions]
    [u'Continue']

If we POST the form without entering any information, it will complain
that product is required:

    >>> form = {
    ...     'field.actions.request_fix': '', 'field.product': '',
    ...     'field.bugtracker': '2',
    ...     'field.link_to_bugwatch.used': '', 'field.remotebug': ''}
    >>> add_task_view = get_and_setup_view(firefox_task, '+upstreamtask', form)
    >>> add_task_view.render_upstreamtask()
    ''
    >>> add_task_view.getWidgetError('product')
    u'Required input is missing.'

In order to show that all the events get fired off, let's create an
event listener and register it:

    >>> from zope.interface import Interface
    >>> from canonical.launchpad.event.interfaces import ISQLObjectCreatedEvent
    >>> from canonical.launchpad.ftests.event import TestEventListener

    >>> def on_created_event(object, event):
    ...     print "SQLObjectCreatedEvent: %r" % object

    >>> on_created_listener = TestEventListener(
    ...     Interface, ISQLObjectCreatedEvent, on_created_event)


If we specify a valid product, no errors will occur, and a bugtask will
be created:

    >>> form['field.product'] = u'evolution'
    >>> add_task_view = get_and_setup_view(firefox_task, '+upstreamtask', form)
    >>> add_task_view.render_upstreamtask()
    SQLObjectCreatedEvent: <BugTask at ...>
    ''

    >>> for bugtask in bug_four.bugtasks:
    ...     print bugtask.targetname
    evolution (upstream)
    firefox (upstream)

This worked without any problems since Evolution does use Malone as its
offical bug tracker.

    >>> evolution_task = bug_four.bugtasks[0]
    >>> evolution_task.target.official_malone
    True

If we try to add a task for ALSA, which doesn't use Malone, it won't go
as smoothly as above.

    >>> form['field.product'] = u'alsa-utils'
    >>> request = LaunchpadTestRequest(
    ...     form={'FORM_SUBMIT': '', 'field.product': 'alsa-utils',
    ...           'field.bugtracker': '2'})
    >>> add_task_view = get_and_setup_view(firefox_task, '+upstreamtask', form)
    >>> add_task_view.render_upstreamtask()
    ''

    >>> for bugtask in bug_four.bugtasks:
    ...     print bugtask.targetname
    evolution (upstream)
    firefox (upstream)

As you can see no ALSA was added to the bug. In order to add such a
task, a user has to confirm that he indeed wants to add the task. A
notification is displayed asking the user for confirmation.

    >>> len(add_task_view.errors)
    0
    >>> add_task_view._confirm_new_task
    True
    >>> len(add_task_view.notifications)
    1
    >>> add_task_view.next_url is None
    True

If the user confirms, a bugtask will be added to the bug.

    >>> del form['field.actions.request_fix']
    >>> form['field.actions.confirm'] = u''
    >>> add_task_view = get_and_setup_view(firefox_task, '+upstreamtask', form)
    >>> add_task_view.render_upstreamtask()
    SQLObjectCreatedEvent: <BugTask at ...>
    ''
    >>> add_task_view._confirm_new_task
    False
    >>> add_task_view.next_url is not None
    True

    >>> for bugtask in bug_four.bugtasks:
    ...     print bugtask.targetname
    alsa-utils (upstream)
    evolution (upstream)
    firefox (upstream)

But since no bug watch was specified, the status and importance
are set to the default values.

    >>> alsa_task = bug_four.bugtasks[0]
    >>> alsa_task.target.official_malone
    False
    >>> alsa_task.status.title
    'Unconfirmed'
    >>> alsa_task.importance.title
    'Undecided'

On the same form, we can add a bug watch. If we specify a remote bug
tracker, but omit the remote bug number, an error message is given:

    >>> del form['field.actions.confirm']
    >>> form['field.actions.request_fix'] = u''
    >>> form['field.product'] = u'thunderbird'
    >>> form['field.link_to_bugwatch'] = 'on'
    >>> form['field.remotebug']
    ''
    >>> add_task_view = get_and_setup_view(firefox_task, '+upstreamtask', form)
    >>> add_task_view.render_upstreamtask()
    ''
    >>> add_task_view.form_wide_errors
    ['Please specify the remote bug number in the remote bug tracker.']

Note that this caused the transaction to be aborted, thus the bugtasks
that got added earlier are now gone:

    >>> len(bug_four.bugtasks)
    1

If we specify a remote bug number as well, both the task and the bug
watch will be added without any confirmation needee:

    >>> form['field.remotebug'] = u'84'
    >>> add_task_view = get_and_setup_view(firefox_task, '+upstreamtask', form)
    >>> add_task_view.render_upstreamtask()
    SQLObjectCreatedEvent: <BugWatch at ...>
    SQLObjectCreatedEvent: <BugTask at ...>
    ''

    >>> add_task_view._confirm_new_task
    False

    >>> for bugtask in bug_four.bugtasks:
    ...     print bugtask.targetname
    firefox (upstream)
    thunderbird (upstream)

    >>> for bugwatch in bug_four.watches:
    ...     print "%s: %s" % (bugwatch.bugtracker.title, bugwatch.remotebug)
    GnomeGBug GTracker: 84

The bug watch got linked to the create task, and all the bug task's
attribute got initialised to Unknown. The bugtask will be synced with
the bug watch's status later.

    >>> thunderbird_task = bug_four.bugtasks[1]
    >>> thunderbird_task.product.official_malone
    False
    >>> thunderbird_task.bugwatch == bug_four.watches[0]
    True

    >>> thunderbird_task.status.title
    'Unknown'
    >>> thunderbird_task.importance.title
    'Unknown'


If we try to add a bug watch together with a product which does use
Malone, an error will occur.

    >>> form['field.product'] = u'evolution'
    >>> form['field.remotebug'] = u'42'
    >>> add_task_view = get_and_setup_view(firefox_task, '+upstreamtask', form)
    >>> add_task_view.render_upstreamtask()
    ''
    >>> add_task_view.form_wide_errors
    [u"Evolution uses Malone as its bug tracker, and it can't at the
       same time be linked to a remote bug."]

There's a method for easily retrieving the target display name for use
on the confirmation page. If we request a fix in an upstream product,
its display name is returned:

    >>> del form['field.link_to_bugwatch']
    >>> form['field.product'] = u'alsa-utils'
    >>> add_task_view = get_and_setup_view(firefox_task, '+upstreamtask', form)
    >>> add_task_view.render_upstreamtask()
    ''
    >>> add_task_view.getBugTargetName()
    u'alsa-utils'

If we request a fix in a source package, the distribution's display
name is returned.

    >>> del form['field.product']
    >>> form['field.distribution'] = u'debian'
    >>> form['field.sourcepackagename'] = u'evolution'
    >>> add_task_view = get_and_setup_view(firefox_task, '+distrotask', form)
    >>> add_task_view.render_distrotask()
    ''
    >>> add_task_view.getBugTargetName()
    u'Debian'

    >>> on_created_listener.unregister()
