When an email arrives in Launchpad the user who sent it needs to be
authenticated. This is done by authenticateEmail:

    >>> from canonical.launchpad.mail.incoming import authenticateEmail

The only way of authenticating the user is by looking at the OpenPGP
signature. First we have to import the OpenPGP keys we will use in the
emails:

    >>> from canonical.launchpad.ftests import import_public_test_keys
    >>> import transaction
    >>> import_public_test_keys()
    >>> transaction.commit()

Now Sample Person and Foo Bar have one OpenPGP key each. Next, let's get
a test email that's signed and try to authenticate the user who sent it:

    >>> from canonical.launchpad.mail.ftests import read_test_message
    >>> msg = read_test_message('signed_detached.txt')
    >>> principal = authenticateEmail(msg)

If the user isn't registered in Launchpad, None is return, if it
succeeds the authenticated principal:

    >>> principal is not None
    True

We can check that the user really got authenticated by looking at the
user in the launch bag:

    >>> import email
    >>> from canonical.launchpad.interfaces import ILaunchBag, IPersonSet
    >>> from zope.component import getUtility
    >>> launchbag = getUtility(ILaunchBag)
    >>> name, addr = email.Utils.parseaddr(msg['From'])
    >>> from_user = getUtility(IPersonSet).getByEmail(addr)
    >>> launchbag.user == from_user
    True
    >>> launchbag.login
    'test@canonical.com'

In the above email the GPG signature was detached from the actual
message. Inline signatures are supported as well. 

    >>> msg = read_test_message('signed_inline.txt')
    >>> principal = authenticateEmail(msg)
    >>> principal is not None
    True
    >>> name, addr = email.Utils.parseaddr(msg['From'])
    >>> from_user = getUtility(IPersonSet).getByEmail(addr)
    >>> launchbag.user == from_user
    True
    >>> launchbag.login
    'test@canonical.com'

As well as signed multipart messages:

    >>> msg = read_test_message('signed_multipart.txt')
    >>> principal = authenticateEmail(msg)
    >>> principal is not None
    True
    >>> name, addr = email.Utils.parseaddr(msg['From'])
    >>> from_user = getUtility(IPersonSet).getByEmail(addr)
    >>> launchbag.user == from_user
    True
    >>> launchbag.login
    'foo.bar@canonical.com'

When dealing with inline signatures, lines that begin with a '-'
character in the signed content are required to be escaped, so we need
to deal with it if we receive a dash escaped message.

    >>> msg = read_test_message('signed_dash_escaped.txt')
    >>> principal = authenticateEmail(msg)
    >>> principal is not None
    True
    >>> name, addr = email.Utils.parseaddr(msg['From'])
    >>> from_user = getUtility(IPersonSet).getByEmail(addr)
    >>> launchbag.user == from_user
    True
    >>> launchbag.login
    'test@canonical.com'


Since an OpenPGP key can be associated with several addresses, the user to
authenticate is extracted from the From header. If the key used to sign
the email doesn't belong to that user, he won't be authenticated, as
shown below where the email was signed with Sample Person's key, but
the From header states it's from Foo Bar:

    >>> msg = read_test_message('signed_incorrect_from.txt')
    >>> name, addr = email.Utils.parseaddr(msg['From'])
    >>> from_user = getUtility(IPersonSet).getByEmail(addr)
    >>> principal = authenticateEmail(msg)
    Traceback (most recent call last):
      ...
    InvalidSignature:...

Also if the signature is invalid, that is it won't verify properly,
InvalidSignature will be raised:

    >>> msg = read_test_message('signed_detached_invalid_signature.txt')
    >>> name, addr = email.Utils.parseaddr(msg['From'])
    >>> from_user = getUtility(IPersonSet).getByEmail(addr)
    >>> principal = authenticateEmail(msg)
    Traceback (most recent call last):
      ...
    InvalidSignature:...

Before the signature is verified, the signed text's line endings should
be canonicalised to \r\n. In order to ensure that the line endings in
signed_canonicalised.txt are not already '\r\n', we recreate the test
message.

    >>> from canonical.launchpad.mail import SignedMessage
    >>> msg = read_test_message('signed_canonicalised.txt')
    >>> msg_lines = msg.as_string().splitlines()
    >>> msg = email.message_from_string(
    ...     '\n'.join(msg_lines), _class=SignedMessage)
    >>> msg.parsed_string = msg.as_string()

    >>> from canonical.launchpad.interfaces import IGPGHandler
    >>> getUtility(IGPGHandler).getVerifiedSignature(
    ...     msg.signedContent, msg.signature)
    Traceback (most recent call last):
    ...
    GPGVerificationError: Bad signature

    >>> getUtility(IGPGHandler).getVerifiedSignature(
    ...     msg.signedContent.replace('\n', '\r\n'), msg.signature)
    <...PymeSignature...>

authenticateEmail() doesn't have any problems verifying the signature:

    >>> from canonical.launchpad.interfaces import IPerson
    >>> for line_ending in '\n', '\r\n':
    ...     msg = email.message_from_string(
    ...         line_ending.join(msg_lines), _class=SignedMessage)
    ...     msg.parsed_string = msg.as_string()
    ...     principal = authenticateEmail(msg)
    ...     authenticated_person = IPerson(principal)
    ...     print authenticated_person.preferredemail.email
    test@canonical.com
    test@canonical.com

Python's email library unfolds the headers, which means that we have to
be careful when extracting the signed content when folded headers are
signed.

    >>> msg = read_test_message('signed_folded_header.txt')
    >>> print msg.parsed_string #doctest: -NORMALIZE_WHITESPACE
    Date:...
    ...
    Content-Type: multipart/mixed;
     boundary="--------------------EuxKj2iCbKjpUGkD"
    ...

    >>> print msg.as_string() #doctest: -NORMALIZE_WHITESPACE
    Date:...
    ...
    Content-Type: multipart/mixed; boundary="--------------------EuxKj2iCbKjpUGkD"
    ...

    >>> principal = authenticateEmail(msg)
    >>> print IPerson(principal).displayname
    Sample Person
