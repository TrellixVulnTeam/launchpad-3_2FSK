Source Package Release
======================

The SourcePackageRelease table represents a particular release of a
SourcePackageName, but isn't tied to any particular DistroSeries
as the same release can appear in many.

In a very basic explanation, this table caches the attributes of an
uploaded DSC (Debian Source Control) file.

This model allow us to have more granular control of the fields,
enabling faster searches, faster readings and model constraints.

Basic attributes
----------------

Let's get one from the database:

   >>> from canonical.launchpad.database import SourcePackageRelease
   >>> spr = SourcePackageRelease.get(14)
   >>> spr.name
   u'mozilla-firefox'
   >>> spr.version
   u'0.9'
   >>> spr.dateuploaded
   datetime.datetime(...)

'age' is a special property that performs on-the-fly:
{{{
NOW - dateuploaded
}}}
It returns a timedelta object:

   >>> spr.age
   datetime.timedelta(...)

Check if the result match the locally calculated one:

   >>> import datetime
   >>> import pytz
   >>> local_now = datetime.datetime.now(pytz.timezone('UTC'))

   >>> expected_age = local_now - spr.dateuploaded
   >>> spr.age.days == expected_age.days
   True

Modify dateuploaded to a certain number of days in the past and check
if the 'age' result looks sane:

   >>> spr.dateuploaded = (local_now - datetime.timedelta(days=10))
   >>> spr.age.days == 10
   True

We can use the magic productrelease property to map this to a ProductRelease:

   >>> pr = spr.productrelease
   >>> print pr.product.name
   firefox
   >>> print pr.productseries.name
   trunk
   >>> print pr.version
   0.9

We can use the sourcepackage and distrosourcepackage properties to
grab magical objects representing that package in the distribution to
which it was uploaded:

   >>> print spr.sourcepackage.displayname
   Hoary mozilla-firefox
   >>> print spr.distrosourcepackage.displayname
   mozilla-firefox in ubuntu

It should also work when the version has a dash and packaging revision
after it:

   >>> spr = SourcePackageRelease.get(16)
   >>> print spr.name
   netapplet
   >>> print spr.version
   1.0-1
   >>> pr = spr.productrelease
   >>> print pr.product.name
   netapplet
   >>> print pr.productseries.name
   trunk
   >>> print pr.version
   1.0

If there isn't one, that should return None.

   >>> print SourcePackageRelease.get(20).productrelease
   None


Check ISourcePackageRelease.override() behaviour:

   >>> spr.component.name, spr.section.name
   (u'main', u'editors')

   >>> from canonical.launchpad.interfaces import (
   ...     IComponentSet, ISectionSet)
   >>> new_comp = getUtility(IComponentSet)['universe']
   >>> new_sec = getUtility(ISectionSet)['mail']

Override the current sourcepackagerelease with new component/section
pair:

   >>> spr.override(component=new_comp, section=new_sec)

   >>> spr.component.name, spr.section.name
   (u'universe', u'mail')

Abort transaction to avoid error propagation of the new attributes:

   >>> import transaction
   >>> transaction.abort()


Verify the creation of a new ISourcePackageRelease based on the
IDistroSeries API:

  >>> from canonical.launchpad.interfaces import (
  ...     IDistributionSet, ISourcePackageNameSet, IGPGKeySet)
  >>> from canonical.database.constants import UTC_NOW
  >>> from canonical.lp.dbschema import SourcePackageUrgency

  >>> hoary = getUtility(IDistributionSet)['ubuntu']['hoary']

All the arguments to create an ISourcePackageRelease are obtained when
processing a source upload, see more details in nascentupload.txt.
Some of the 20 required arguments are foreign keys or DB contants:

  >>> arg_name = getUtility(ISourcePackageNameSet)['pmount']
  >>> arg_comp = getUtility(IComponentSet)['universe']
  >>> arg_sect = getUtility(ISectionSet)['web']
  >>> arg_key = getUtility(IGPGKeySet).get(1)
  >>> arg_maintainer = hoary.owner
  >>> arg_creator = hoary.owner
  >>> arg_urgency = SourcePackageUrgency.LOW

'manifest' is the only nullable FK:

  >>> arg_manifest = None

The other argurments are strings:

  >>> version = '0.0.99'
  >>> dsc = 'smashed dsc...'
  >>> changelog = 'contigous text....'
  >>> archhintlist = 'any'
  >>> builddepends = 'cdbs, debhelper (>= 4.1.0), libsysfs-dev, libhal-dev'
  >>> builddependsindep = ''
  >>> dsc_maintainer_rfc822 = 'Foo Bar <foo@bar.com>'
  >>> dsc_standards_version = '2.6.1'
  >>> dsc_format = '1.0'
  >>> dsc_binaries = 'pmount'
  >>> archive = hoary.main_archive

Having proper arguments in hand we can create a new
ISourcePackageRelease, it will automatically set the
'uploaddistroseries' to the API entry point, in this case Hoary.

  >>> new_spr = hoary.createUploadedSourcePackageRelease(
  ...     arg_name, version, arg_maintainer,
  ...     builddepends, builddependsindep, archhintlist, arg_comp, arg_creator,
  ...     arg_urgency, changelog, dsc, arg_key, arg_sect, arg_manifest,
  ...     dsc_maintainer_rfc822, dsc_standards_version, dsc_format,
  ...     dsc_binaries, archive)

  >>> new_spr.uploaddistroseries.name
  u'hoary'
  >>> new_spr.version
  u'0.0.99'
  >>> new_spr.upload_archive.id == hoary.main_archive.id
  True

Throw away the DB changes:

  >>> transaction.abort()

Let's get a sample SourcePackageRelease:

   >>> spr_test = SourcePackageRelease.get(20)
   >>> spr_test.name
   u'pmount'


== Creating Build records ==

The SourcePackageRelease has the ability to create Build records,
however it needs fully support to treat architecturehintlist and P-a-s
information, see further information in buildd-queuebuilder.txt.

The base method createBuild() is able to create build to a given
distroarchseries and pocket.

Build.buildstate, by default is set to NEEDSBUILD and build.archive is
the default distribution.main_archive.

   >>> from canonical.lp.dbschema import PackagePublishingPocket
   >>> pocket = PackagePublishingPocket.RELEASE

   >>> dar = spr_test.uploaddistroseries['i386']

   >>> test_build = spr_test.createBuild(
   ...     dar, pocket, dar.distroseries.main_archive)

   >>> test_build.buildstate.name
   'NEEDSBUILD'

   >>> test_build.distroarchseries.architecturetag
   u'i386'

   >>> test_build.archive.id == dar.distroseries.main_archive.id
   True

Optionally you can pass also status & archive:

   >>> from canonical.launchpad.interfaces import IPersonSet
   >>> cprov = getUtility(IPersonSet).getByName('cprov')

   >>> from canonical.lp.dbschema import BuildStatus
   >>> ppa_build = spr_test.createBuild(
   ...    dar, pocket, cprov.archive, status=BuildStatus.SUPERSEDED)

   >>> ppa_build.buildstate.name
   'SUPERSEDED'

   >>> ppa_build.archive.id == cprov.archive.id
   True


Counting bugs
-------------

The SourcePackageRelease offers a convenient way of checking how many
bugs are open against this package in the distribution to which it was
uploaded. Because of bug privacy, this method needs a user supplied.

   >>> spr = SourcePackageRelease.get(14)
   >>> print spr.name
   mozilla-firefox
   >>> login('no-priv@canonical.com')
   >>> no_priv = getUtility(ILaunchBag).user
   >>> print spr.countOpenBugsInUploadedDistro(no_priv)
   1

Uploading translations
----------------------

It's time to check the translation upload function.

   >>> import canonical.launchpad
   >>> import os.path
   >>> import transaction
   >>> from canonical.launchpad.interfaces import ITranslationImportQueue
   >>> from canonical.librarian.interfaces import ILibrarianClient
   >>> translation_import_queue = getUtility(ITranslationImportQueue)
   >>> client = getUtility(ILibrarianClient)

We need a test tarball uploaded into librarian to run this test.

   >>> test_file_name = os.path.join(
   ...     os.path.dirname(canonical.launchpad.__file__),
   ...     'doc/sourcepackagerelease-translations.tar.gz')
   >>> file = open(test_file_name)
   >>> size = len(file.read())
   >>> file.seek(0)
   >>> alias = client.addFile(
   ...     name='test.tar.gz',
   ...     size=size,
   ...     file=file,
   ...     contentType='application/x-gtar')

We need the commit to see the upload.

   >>> transaction.commit()

Before the upload, the queue should be empty.

   >>> translation_import_queue.getAllEntries(target='distros').count()
   0

Now we do the upload. It's necessary to retrive an ILibraryFileAlias
correspondent to the alias (long) we already have.

   >>> from canonical.launchpad.interfaces import ILibraryFileAliasSet
   >>> file_alias = getUtility(ILibraryFileAliasSet)[alias]

   >>> spr_test = SourcePackageRelease.get(20)
   >>> spr_test.name
   u'pmount'
   >>> spr_test.attachTranslationFiles(file_alias, True)

The commit is needed to see the new entries

   >>> transaction.commit()

And the queue should have a new entry.

   >>> translation_import_queue.getAllEntries(target='distros').count()
   1

Now, we need to do the final import. It's done as a two steps procedure.

The first one, approves the import.

    >>> import subprocess, sys
    >>> process = subprocess.Popen([
    ...     sys.executable, 'cronscripts/rosetta-approve-imports.py'
    ...     ], stdin=subprocess.PIPE, stdout=subprocess.PIPE,
    ...     stderr=subprocess.STDOUT
    ...     )
    >>> (output, empty) = process.communicate()
    >>> print output
    INFO    creating lockfile
    INFO    The automatic approval system approved some entries.
    INFO    Removed 2 entries from the queue.
    <BLANKLINE>

The second one, executes the import.

    >>> import subprocess, sys
    >>> process = subprocess.Popen([
    ...     sys.executable, 'cronscripts/rosetta-poimport.py'
    ...     ], stdin=subprocess.PIPE, stdout=subprocess.PIPE,
    ...     stderr=subprocess.STDOUT
    ...     )
    >>> (output, empty) = process.communicate()
    >>> print output
    INFO    creating lockfile
    INFO    Importing: Spanish (es) translation of pmount in Ubuntu Hoary package "pmount"
    ...

