= ExternalBugTracker: Trac =

This covers the implementation of the ExternalBugTracker class for Trac
bugwatches.


== Basics ==

The ExternalBugTracker descendant class which implements methods for updating
bug watches on Trac bug trackers is externalbugtracker.Trac.

    >>> from canonical.launchpad.components.externalbugtracker import Trac
    >>> Trac('http://trac.foo.com')
    <canonical.launchpad.components.externalbugtracker.Trac object at...>


== Status Conversion ==

The basic Trac ticket statuses map to Launchpad bug statuses.
Trac.convertRemoteStatus() handles the conversion.

    >>> trac = Trac('http://foo.bar')
    >>> trac.convertRemoteStatus('open').title
    'New'
    >>> trac.convertRemoteStatus('assigned').title
    'Confirmed'
    >>> trac.convertRemoteStatus('fixed').title
    'Fix Released'
    >>> trac.convertRemoteStatus('invalid').title
    'Invalid'
    >>> trac.convertRemoteStatus('wontfix').title
    "Won't Fix"
    >>> trac.convertRemoteStatus('duplicate').title # XXX: Fix this, too!
    'Confirmed'
    >>> trac.convertRemoteStatus('worksforme').title
    'Invalid'

If the status isn't one that our Trac ExternalBugTracker can understand,
Unknown will be returned and a warning logged.

    >>> trac.convertRemoteStatus('eggs').title
    WARNING:...:Unknown status 'eggs'
    'Unknown'

UNKNOWN_REMOTE_STATUS maps to Unknown without generating a
warning. This handles the case where we've tried to probe for a bug
but didn't succeed. For example, if the bug number was invalid.

    >>> from canonical.launchpad.interfaces import UNKNOWN_REMOTE_STATUS
    >>> trac.convertRemoteStatus(UNKNOWN_REMOTE_STATUS).title
    'Unknown'


== Initialization ==

Calling initializeRemoteBugDB() on our Trac instance and passing it a set of
remote bug IDs will fetch those bug IDs from the server and file them in a
local variable for later use.

We use a test-oriented implementation for the purposes of these tests, so that
we don't have to rely on a working network connection.

    >>> from canonical.launchpad.ftests.externalbugtracker import TestTrac
    >>> trac = TestTrac('http://test.trac')
    >>> trac.initializeRemoteBugDB([1])
    >>> sorted(trac.bugs.keys())
    [1]

If we initialise with a different set of keys we overwrite the first set:

    >>> trac.initializeRemoteBugDB([6,7,8,9,10,11,12])
    >>> sorted(trac.bugs.keys())
    [6, 7, 8, 9, 10, 11, 12]


== Updating Bug Watches ==

First, we create some bug watches to test with:

    >>> from canonical.launchpad.database import BugTracker
    >>> from canonical.launchpad.interfaces import IBugSet, IPersonSet
    >>> from canonical.launchpad.ftests.externalbugtracker import TestMantis
    >>> from canonical.lp.dbschema import BugTrackerType

    >>> sample_person = getUtility(IPersonSet).getByEmail('test@canonical.com')

    >>> example_bug_tracker = BugTracker(
    ...     name="example-bugs",
    ...     title="Example.com Trac",
    ...     bugtrackertype=BugTrackerType.TRAC,
    ...     baseurl="http://bugs.example.com",
    ...     summary="Contains bugs for Example.com",
    ...     contactdetails="foo.bar@example.com",
    ...     owner=sample_person)

    >>> login('foo.bar@canonical.com')

    >>> example_bug = getUtility(IBugSet).get(10)
    >>> example_bugwatch = example_bug.addWatch(
    ...     example_bug_tracker, 1, sample_person)

    >>> login('no-priv@canonical.com')

Collect the Example.com watches:

    >>> for bug_watch in example_bug_tracker.watches:
    ...     print "%s: %s" % (bug_watch.remotebug, bug_watch.remotestatus)
    1: None

And have a Trac instance process them:

    >>> trac = TestTrac(example_bug_tracker.baseurl)
    >>> trac.updateBugWatches(example_bug_tracker.watches)
    >>> for bug_watch in example_bug_tracker.watches:
    ...     print "%s: %s" % (bug_watch.remotebug, bug_watch.remotestatus)
    1: open

We'll add some more watches now.

    >>> from canonical.launchpad.interfaces import IBugSet, IBugWatchSet

    >>> bug_watch_set = getUtility(IBugWatchSet)
    >>> expected_remote_statuses = dict(
    ...     (int(bug_watch.remotebug), bug_watch.remotestatus)
    ...     for bug_watch in example_bug_tracker.watches)

    >>> expected_remote_statuses
    {1: u'open'}

    >>> remote_bugs = [
    ...     (143, 'closed'),
    ...     (144, 'assigned'),
    ...     (145, 'assigned'),
    ...     (146, 'closed'),
    ...     (147, 'closed'),
    ...     (148, 'closed'),
    ...     (149, 'assigned'),
    ...     (150, 'new'),
    ...     (151, 'new'),
    ...     (152, 'new'),
    ...     (153, 'new'),
    ... ]

    >>> for remote_bug_id, remote_status in remote_bugs:
    ...     bug_watch = bug_watch_set.createBugWatch(
    ...         bug=example_bug, owner=sample_person,
    ...         bugtracker=example_bug_tracker,
    ...         remotebug=str(remote_bug_id))
    ...     expected_remote_statuses[remote_bug_id] = remote_status

Because we're updating more than ten bugs our Trac code will ask the server
for them all at once.

    >>> trac.trace_calls = True
    >>> trac.updateBugWatches(example_bug_tracker.watches)

