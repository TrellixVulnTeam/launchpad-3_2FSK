== AssertionErrors in IBinaryPackageBuild ==

Build records inserted by gina don't provide calculated_buildstart
value, since they miss fields used in its calculation.
TODO: check and update this based on the new model.

    >>> gina_build = getUtility(IBinaryPackageBuildSet).getByBuildID(10)
    >>> gina_build.title
    u'i386 build of cnews cr.g7-37 in ubuntu warty RELEASE'

even if IBinaryPackageBuild.was_built return true:

    >>> gina_build.was_built
    True

Only builds in failed_states (FAILEDTOBUILD, MANUALDEPWAIT and
CHROOTWAIT) can be retried. We must check if Soyuz is able to accept
its result in case of success, i.e., we should not be able to retry a
build for a released pocket.

All those conditions are controlled by
IBinaryPackageBuild.can_be_retried() property (see above).

    >>> failed_build = getUtility(IBinaryPackageBuildSet).getByBuildID(6)

    >>> failed_build.title
    u'i386 build of foobar 1.0 in ubuntu warty RELEASE'

    >>> failed_build.status.name
    'FAILEDTOBUILD'

    >>> failed_build.can_be_retried
    False

Attempt to retry this build record will fail with an AssertionError:

    >>> login('foo.bar@canonical.com')
    >>> failed_build.retry()
    Traceback (most recent call last):
    ...
    AssertionError: Build 6 cannot be retried

    >>> login(ANONYMOUS)

Partner archive builds are an exception to this rule; they can be retried
in the release pocket for a released distro.  Let's turn build 9 into a
partner archive build:

    >>> partner_archive = ubuntu.getArchiveByComponent('partner')
    >>> removeSecurityProxy(failed_build).archive = partner_archive

The build can now be re-tried:

    >>> failed_build.can_be_retried
    True

Similarly to PPA builds, they can be retried for release pockets since
they will happen in another archive.

    >>> removeSecurityProxy(failed_build).archive = cprov.archive

    >>> failed_build.can_be_retried
    True

storeUploadLog() refuses to override any previously stored
'upload_log'.

    >>> failedtoupload_build = getUtility(IBinaryPackageBuildSet).getByBuildID(22)
    >>> print failedtoupload_build.title
    i386 build of cdrkit 1.0 in ubuntu breezy-autotest RELEASE

    >>> print failedtoupload_build.upload_log.filename
    upload_22_log.txt

    >>> failedtoupload_build.storeUploadLog('something')
    Traceback (most recent call last):
    ...
    AssertionError: Upload log information already exists and cannot be
    overridden.

It's only possible to store another 'upload_log' content once the
build is retried.

    >>> login('foo.bar@canonical.com')
    >>> failedtoupload_build.retry()
    >>> login(ANONYMOUS)
    >>> print failedtoupload_build.upload_log
    None

    >>> failedtoupload_build.storeUploadLog('something')

    >>> print failedtoupload_build.upload_log.filename
    upload_22_log.txt


== Updating build-dependencies line ==

The IBinaryPackageBuild.dependencies field is only filled when a build
job is collected as MANUALDEPWAIT, its content is informed by the
buildd-slave in the apt-dependencies format.

    >>> depwait_build = getUtility(IBinaryPackageBuildSet).getByBuildID(12)
    >>> print depwait_build.dependencies
    cpp (>= 4:4.0.1-3), gcc-4.0 (>= 4.0.1-2)

IBinaryPackageBuild.updateDependencies is designed to process this field
and eliminate dependencies that can be satisfied. It is used as part of
the auto-depwait processing where all builds marked as MANUALDEPWAIT are
re-processed and the ones with empty dependencies are re-queued.

If nothing has changed, which is the case of the current
depwait_build, the 'dependencies' field remains the same.

    >>> old_dep = depwait_build.dependencies
    >>> depwait_build.updateDependencies()
    >>> depwait_build.dependencies == old_dep
    True

A dependency can only be used if it is an a component allowed in our
context (see above on 'Ogre' components). If we do a build using a
dependency available in the sample data but published in an unreachable
component, we will see that the dependency is considered to be unsatisfied.
See also bug 177827.

    >>> login('foo.bar@canonical.com')
    >>> depwait_build.dependencies = u'pmount'
    >>> flush_database_updates()

'pmount' in hoary/i386 is published in the 'universe' component:

    >>> hoary_i386 = depwait_build.distro_arch_series
    >>> pmount_pub = hoary_i386[
    ...     'pmount'].currentrelease.current_publishing_record
    >>> print pmount_pub.component.name
    universe

The build is only allowed to depend on packages published in 'main':

    >>> print depwait_build.current_component.name
    main

    >>> from lp.soyuz.adapters.archivedependencies import (
    ...     get_components_for_context)
    >>> print get_components_for_context(
    ...     depwait_build.current_component, depwait_build.pocket)
    ['main']

Thus the 'pmount' dependency remains unsatisfied.

    >>> depwait_build.updateDependencies()
    >>> print depwait_build.dependencies
    pmount

If we make pmount in hoary/i386 reachable, by moving it to the 'main'
component, we can see that it will be excluded from the dependencies
list.

    >>> login('foo.bar@canonical.com')
    >>> from lp.soyuz.interfaces.component import IComponentSet
    >>> main_component = getUtility(IComponentSet)['main']
    >>> pmount_pub = hoary_i386[
    ...     'pmount'].currentrelease.current_publishing_record
    >>> pmount_pub.component = main_component
    >>> depwait_build.dependencies = u'mozilla-firefox, pmount'
    >>> from canonical.database.sqlbase import flush_database_caches
    >>> flush_database_caches()
    >>> transaction.commit()
    >>> login(ANONYMOUS)

    >>> flush_database_updates()

Note that only the satisfied dependencies are removed the build
dependency list.

    >>> depwait_build.updateDependencies()
    >>> print depwait_build.dependencies
    mozilla-firefox

'pmount' dependency is also satisfied in the Celso's PPA context,
even when it is published in a component not allowed in its current
component domain ('ogre_components'). That's because PPAs implicitly
depend on all components of its distribution PRIMARY archive.


    >>> login('foo.bar@canonical.com')
    >>> depwait_build.dependencies = u'biscuit, pmount'
    >>> universe_component = getUtility(IComponentSet)['universe']
    >>> pmount_pub.component = universe_component
    >>> removeSecurityProxy(depwait_build).archive = cprov.archive
    >>> flush_database_caches()
    >>> login(ANONYMOUS)

    >>> print get_components_for_context(
    ...     depwait_build.current_component, depwait_build.pocket)
    ['main']

    >>> print pmount_pub.component.name
    universe

    >>> depwait_build.updateDependencies()
    >>> print depwait_build.dependencies
    biscuit

Restore depwait_build previous state.

    >>> login('foo.bar@canonical.com')
    >>> pmount_pub.component = main_component
    >>> removeSecurityProxy(depwait_build).archive = ubuntu.main_archive
    >>> flush_database_caches()
    >>> login(ANONYMOUS)

=== Retrying DEPWAIT builds ===

It depends on the callsite to decide whether or not to 'retry' a
build after calling updateDependencies, to encapsulate such decision
for performing the mentioned  auto-depwait procedure we have a utility
in IBinaryPackageBuildSet called retryDepWaiting().

    >>> print depwait_build.status.name
    MANUALDEPWAIT
    >>> print depwait_build.distro_arch_series.title
    The Hoary Hedgehog Release for i386 (x86)

In order to allow depwait_build to be retried we will forge a
'fully-satisfiable' dependencies field.

    >>> login('foo.bar@canonical.com')
    >>> depwait_build.dependencies = u'pmount'
    >>> login(ANONYMOUS)
    >>> flush_database_updates()

Then we can run the utility method for the target distroarchseries and
expect depwait_build to be 'retried' and scored.

    >>> getUtility(IBinaryPackageBuildSet).retryDepWaiting(hoaryi386)

    >>> print depwait_build.status.name
    NEEDSBUILD

    >>> depwait_build.buildqueue_record.lastscore
    2505

The 'retryDepWaiting' task is performed periodically via cronjob by
cronscript/buildd-retry-depwait.py. It can be run in parallel with
other buildd tasks because the procedure is 'atomic' enough, i.e.,
after the commit the retried jobs are ready to be dispatched.


== Build rescoring ==

Some builds can be rescored, to determine if it's possible check the
can_be_rescored property:

    >>> depwait_build.can_be_rescored
    True

We need to be at least a buildd-admin to rescore:

    >>> depwait_build.rescore(1000)
    Traceback (most recent call last):
    ...
    Unauthorized:...

    >>> login('celso.providelo@canonical.com')
    >>> depwait_build.rescore(1000)
    >>> print depwait_build.buildqueue_record.lastscore
    1000

If a callsite tries to rescore a build that is not in the NEEDSBUILD state,
a CannotBeRescored exception is raised.

    >>> depwait_build.status = BuildStatus.FAILEDTOUPLOAD
    >>> depwait_build.rescore(1000)
    Traceback (most recent call last):
    ...
    CannotBeRescored: Build cannot be rescored.

    >>> login(ANONYMOUS)


== Build record security ==

IBinaryPackageBuild's content class is wrapped in a Zope security
wrapper that prevents access to private builds for unauthorised users.

Accessing the cprov builds when logged in as admin will see the records:

    >>> login('admin@canonical.com')
    >>> bob_builds = bob.getBuildRecords(user=admin)
    >>> print_build_details(bob_builds)
    cprov: i386 build of privacycheck 666 in ubuntutest breezy-autotest...
    ubuntu-team: hppa build of mozilla-firefox 0.9 in ubuntu warty RELEASE
    cprov: hppa build of mozilla-firefox 0.9 in ubuntu warty RELEASE
    cprov: i386 build of pmount 0.1-1 in ubuntu warty RELEASE
    cprov: i386 build of cdrkit 1.0 in ubuntu breezy-autotest RELEASE
    ...

Likewise when logged in as cprov:

    >>> login('celso.providelo@canonical.com')
    >>> bob_builds = bob.getBuildRecords(user=admin)
    >>> print_build_details(bob_builds)
    cprov: i386 build of privacycheck 666 in ubuntutest breezy-autotest...
    ubuntu-team: hppa build of mozilla-firefox 0.9 in ubuntu warty RELEASE
    cprov: hppa build of mozilla-firefox 0.9 in ubuntu warty RELEASE
    cprov: i386 build of pmount 0.1-1 in ubuntu warty RELEASE
    cprov: i386 build of cdrkit 1.0 in ubuntu breezy-autotest RELEASE
    ...

A user who is a buildd admin is not allowed to see the build records for
private builds. Even though they are admin, privacy must be maintained.

    >>> login(buildd_admin.preferredemail.email)
    >>> bob_builds = bob.getBuildRecords(user=admin)

Define a helper function to catch the security exception:

    >>> from zope.security.interfaces import Unauthorized
    >>> def print_builds_with_exception(builds):
    ...     try:
    ...         print_build_details(bob_builds)
    ...     except Unauthorized:
    ...         print "Generated Unauthorized exception as expected"
    ...     else:
    ...         print "FAIL: should raise Unauthorized exception"

And try to access the builds:

    >>> print_builds_with_exception(bob_builds)
    Generated Unauthorized exception as expected

When logged in as anonymous this will generate a securtity exception
when accessing the builds:

    >>> login(ANONYMOUS)
    >>> bob_builds = bob.getBuildRecords(user=admin)
    >>> print_builds_with_exception(bob_builds)
    Generated Unauthorized exception as expected

There are other settable attributes declared in the zcml that require
launchpad.Edit.

    >>> def check_setting_property(build_rec, property, value, should_fail):
    ...     try:
    ...         setattr(build_rec, property, value)
    ...         if should_fail:
    ...             print "Should have failed setting %s" % property
    ...     except Unauthorized:
    ...         if not should_fail:
    ...             print "Did not fail when expected setting %s" % property
    >>> from canonical.database.constants import UTC_NOW
    >>> properties = {
    ...     'log': 1,
    ...     'date_finished': UTC_NOW,
    ...     'date_started': UTC_NOW,
    ...     'builder': bob,
    ...     'status': BuildStatus.FAILEDTOUPLOAD,
    ...     'dependencies': u'whatever',
    ...     'upload_log': 1,
    ...     }

Login as a non-privileged user and set the properties.  It will fail.

    >>> login('no-priv@canonical.com')
    >>> for property in properties:
    ...     check_setting_property(
    ...         depwait_build, property, properties[property],
    ...         should_fail=True)

As a buildd-admin it will work:

    >>> login('celso.providelo@canonical.com')
    >>> for property in properties:
    ...     check_setting_property(
    ...         depwait_build, property, properties[property],
    ...         should_fail=False)

== Estimated Build Duration ==

Build records will have an 'estimated_duration' time in the associated
BuildQueue record. The latter is set from a previous builds' 'buildduration'
value.

We will use SoyuzTestPublisher to generate coherent publications to
test this behaviour.

    >>> login('foo.bar@canonical.com')

Create oldest SourcePackageRelease instance.

    >>> oldest_spr = test_publisher.getPubSource(
    ...     status=PackagePublishingStatus.PUBLISHED,
    ...     sourcename='ebdtest')

Create oldest build instance.

    >>> oldest_build = oldest_spr.sourcepackagerelease.createBuild(
    ...         test_publisher.breezy_autotest_hppa,
    ...         PackagePublishingPocket.UPDATES,
    ...         test_publisher.breezy_autotest.main_archive,
    ...         status=BuildStatus.FULLYBUILT)
    >>> oldest_build.date_finished = datetime(2008, 4, 1, 10, 45, 39, tzinfo=UTC)
    >>> oldest_build.date_started = oldest_build.date_finished - timedelta(minutes=72)

Check that the oldest build instance's 'estimated_duration'
is initialized based on its package size. Since the latter is very
small (less than a KB) the 'estimated_duration' will be a
minute.

    >>> bq = oldest_build.queueBuild()
    >>> bq.estimated_duration
    datetime.timedelta(0, 60)

Create intermediate SourcePackageRelease instance.

    >>> medium_spr = test_publisher.getPubSource(
    ...     status=PackagePublishingStatus.PUBLISHED,
    ...     sourcename='ebdtest')

Create intermediate build instance.

    >>> medium_build = medium_spr.sourcepackagerelease.createBuild(
    ...         test_publisher.breezy_autotest_hppa,
    ...         PackagePublishingPocket.UPDATES,
    ...         test_publisher.breezy_autotest.main_archive,
    ...         status=BuildStatus.FULLYBUILT)
    >>> medium_build.date_finished = datetime(2008, 4, 2, 11, 56, 33, tzinfo=UTC)
    >>> medium_build.date_started = medium_build.date_finished - timedelta(minutes=60)

Check whether the intermediate build instance's 'estimated_duration'
value equals the oldest instance's 'buildduration' (72 minutes equals 4320
seconds).

    >>> bq = medium_build.queueBuild()
    >>> bq.estimated_duration
    datetime.timedelta(0, 4320)

Create most recent SourcePackageRelease instance.

    >>> recent_spr = test_publisher.getPubSource(
    ...     status=PackagePublishingStatus.PUBLISHED,
    ...     sourcename='ebdtest')

Create most recent build instance. Please note: this one is in state
NEEDSBUILD.

    >>> recent_build = recent_spr.sourcepackagerelease.createBuild(
    ...         test_publisher.breezy_autotest_hppa,
    ...         PackagePublishingPocket.UPDATES,
    ...         test_publisher.breezy_autotest.main_archive,
    ...         status=BuildStatus.NEEDSBUILD)

Check whether the most recent build instance's 'estimated_duration'
value equals the intermediate instance's 'buildduration'.

    >>> bq = recent_build.queueBuild()
    >>> bq.estimated_duration
    datetime.timedelta(0, 3600)

Create a SourcePackageRelease instance in a PPA.

    >>> ppa_spr = test_publisher.getPubSource(
    ...     status=PackagePublishingStatus.PUBLISHED,
    ...     sourcename='ebdtest')

Create most recent build instance.

    >>> ppa_build = ppa_spr.sourcepackagerelease.createBuild(
    ...         test_publisher.breezy_autotest_hppa,
    ...         PackagePublishingPocket.UPDATES,
    ...         cprov.archive,
    ...         status=BuildStatus.NEEDSBUILD)

Check whether the PPA build instance's 'estimated_duration'
value was set from the intermediate instance's 'buildduration' in
the main archive.

    >>> bq = ppa_build.queueBuild()
    >>> bq.estimated_duration
    datetime.timedelta(0, 3600)


== IBinaryPackageBuildSet.getBuildsBySourcePackageRelease() ==

getBuildsBySourcePackageRelease() will return all the Build records for
all the SourcePackageRelease IDs passed.

Create some sources with builds:

    >>> source_one = test_publisher.getPubSource(
    ...     status=PackagePublishingStatus.PUBLISHED,
    ...     sourcename='sourceone')
    >>> source_two = test_publisher.getPubSource(
    ...     status=PackagePublishingStatus.PUBLISHED,
    ...     sourcename='sourcetwo')
    >>> build_one = source_one.sourcepackagerelease.createBuild(
    ...         test_publisher.breezy_autotest_hppa,
    ...         PackagePublishingPocket.RELEASE,
    ...         test_publisher.breezy_autotest.main_archive,
    ...         status=BuildStatus.FULLYBUILT)
    >>> build_two = source_two.sourcepackagerelease.createBuild(
    ...         test_publisher.breezy_autotest_hppa,
    ...         PackagePublishingPocket.RELEASE,
    ...         test_publisher.breezy_autotest.main_archive,
    ...         status=BuildStatus.NEEDSBUILD)

    >>> source_ids = (
    ...     source_one.sourcepackagerelease.id,
    ...     source_two.sourcepackagerelease.id,
    ...     )
    >>> builds = removeSecurityProxy(bs).getBuildsBySourcePackageRelease(
    ...     source_ids)
    >>> import operator
    >>> for build in sorted(builds, key=operator.attrgetter("id")):
    ...     print build.title, build.status.name
    hppa build of sourceone 666 in ubuntutest breezy-autotest RELEASE
        FULLYBUILT
    hppa build of sourcetwo 666 in ubuntutest breezy-autotest RELEASE
        NEEDSBUILD

The results can also be filtered on build state:

    >>> builds = removeSecurityProxy(bs).getBuildsBySourcePackageRelease(
    ...     source_ids, buildstate=BuildStatus.FULLYBUILT)
    >>> for build in sorted(builds, key=operator.attrgetter("id")):
    ...     print build.title, build.status.name
    hppa build of sourceone 666 in ubuntutest breezy-autotest RELEASE
        FULLYBUILT

If there are no matching results then it returns an empty SelectResults.

    >>> builds = removeSecurityProxy(bs).getBuildsBySourcePackageRelease(
    ...     source_ids, buildstate=BuildStatus.CHROOTWAIT)
    >>> print builds.count()
    0

Supplying an empty list or None for the IDs results in an empty list
being returned.

    >>> removeSecurityProxy(bs).getBuildsBySourcePackageRelease(None)
    []

    >>> removeSecurityProxy(bs).getBuildsBySourcePackageRelease([])
    []


== Getting the build records for a particular builder ==

The getBuildsForBuilder method returns all the builds for the
specified builder ID, ordered from most-recently built.

    Create some source packages with which to test the
    getBuildsForBuilder method:

    >>> src_pkg_earlier = test_publisher.getPubSource(
    ...     status=PackagePublishingStatus.PUBLISHED,
    ...     sourcename='earlierbuildsrc', architecturehintlist='hppa i386')
    >>> src_pkg_later = test_publisher.getPubSource(
    ...     status=PackagePublishingStatus.PUBLISHED,
    ...     sourcename='laterbuildsrc',
    ...     architecturehintlist='hppa i386')

    Create the builds based on the source packages, with the builds
    for 'earlierbuildsrc' built one day before the 'laterbuildsrc':

    >>> frog_builder = getUtility(IBuilderSet)['frog']
    >>> bob_builder = getUtility(IBuilderSet)['bob']

    >>> earlier_builds = src_pkg_earlier.createMissingBuilds()
    >>> eg_build_date = earlier_builds[0].date_created
    >>> for build in earlier_builds:
    ...     build.date_started = eg_build_date - timedelta(1)
    ...     build.date_finished = eg_build_date - timedelta(1)

    >>> later_builds = src_pkg_later.createMissingBuilds()
    >>> for build in later_builds:
    ...     build.date_started = eg_build_date
    ...     build.date_finished = eg_build_date

    Ensure that the i386 builds are created by the 'frog' builder,
    while the hppa builds are created by 'bob' the builder:

    >>> builds = earlier_builds + later_builds
    >>> for build in builds:
    ...     if build.processor.name == u'386':
    ...         build.builder = frog_builder
    ...     else:
    ...         build.builder = bob_builder

    A call to getBuildsForBuilder returns only those builds that were
    built by the specified builder, ordered by datebuilt DESC:

    >>> frog_builds = getUtility(IBinaryPackageBuildSet).getBuildsForBuilder(
    ...     frog_builder.id)
    >>> print_build_details(frog_builds)
    ubuntu-team: i386 build of laterbuildsrc 666 in ubuntutest
        breezy-autotest RELEASE
    ubuntu-team: i386 build of earlierbuildsrc 666 in ubuntutest
        breezy-autotest RELEASE


== Source publication for builds ==

The current source publication for a given build is available via
its 'current_source_publication' property.

We will create a new publication and its corresponding build.

    >>> original_pub = test_publisher.getPubSource()
    >>> [build] = original_pub.createMissingBuilds()

The publication returned by 'current_source_publication' is the one
that originated the build.

    >>> build.current_source_publication == original_pub
    True

We will override the source publication, moving it from 'main'
component (default) to 'universe'.

    >>> universe_component = getUtility(IComponentSet)['universe']
    >>> secure_overridden_pub = original_pub.changeOverride(
    ...     new_component=universe_component)

Fetching the corresponding `SourcePackagePublishingHistory` for the
comparisons.

    >>> from lp.soyuz.model.publishing import (
    ...     SourcePackagePublishingHistory)
    >>> overridden_pub = SourcePackagePublishingHistory.get(
    ...     secure_overridden_pub.id)

An we can see that the build 'current_source_publication' now points
to the most recent publication, the overridden one.

    >>> original_pub == build.current_source_publication
    False

    >>> overridden_pub == build.current_source_publication
    True
