= Facets and menus =

An object has a facetmenu if it can be adapted to IFacetMenu.

=== Construct an example url hierarchy ===

    >>> from canonical.launchpad.webapp import (
    ...     nearest_adapter, nearest_context_with_adapter, canonical_url)
    >>> from canonical.launchpad.webapp.interfaces import (
    ...     ICanonicalUrlData, IFacetMenu, IApplicationMenu, IContextMenu,
    ...     ILink, ILinkData, IFacetLink
    ...     )
    >>> from zope.interface import implements, directlyProvides, Interface
    >>> from zope.component import queryAdapter

    >>> class ObjectThatHasUrl:
    ...     implements(ICanonicalUrlData)
    ...     def __init__(self, name, parent):
    ...         self.name = name  # Used in examples later.
    ...         self.path = name  # See ICanonicalUrlData.
    ...         self.inside = parent  # See ICanonicalUrlData.
    ...         self.rootsite = None  # See ICanonicalUrlData.

Here's a useful class that we can use to effectively register adapters for
an object, without actually using adapter registries.  This comes from
PEP-246.

    >>> class Conformable:
    ...     adapt_to = None
    ...     def setAdapter(self, interface, object):
    ...         self.adapt_to = (interface, object)
    ...     def __conform__(self, protocol):
    ...         if self.adapt_to is not None:
    ...             interface, object = self.adapt_to
    ...             if interface.extends(protocol, strict=False):
    ...                 return object(self)
    ...         return None

    >>> class ExampleContentObject(ObjectThatHasUrl, Conformable):
    ...     pass

Let's make three objects that together make a url hierarchy:

  (the root)/sesamestreet/number73

    >>> root = ExampleContentObject('', None)
    >>> street = ExampleContentObject('sesamestreet', root)
    >>> house = ExampleContentObject('number73', street)
    >>> canonical_url(house)
    u'http://launchpad.dev/sesamestreet/number73'
    >>> canonical_url(street)
    u'http://launchpad.dev/sesamestreet'


=== Test nearest_adapter ===

Right now, none of our example objects have a facet menu.

    >>> nearest_adapter(root, IFacetMenu) is None
    True
    >>> nearest_adapter(street, IFacetMenu) is None
    True
    >>> nearest_adapter(house, IFacetMenu) is None
    True

We can see that this is true for nearest_context_with_adapter too.

    >>> nearest_context_with_adapter(root, IFacetMenu)
    (None, None)

We'll make the 'street' object be conformable to IFacetMenu.  Making an object
be conformable to IFacetMenu is one way of making the object adaptable to
IFacetMenu.  Another way would be to provide an adapter.

    >>> class ExampleFacetMenu(list):
    ...     implements(IFacetMenu)
    ...     def __init__(self, context):
    ...         list.__init__(self, ['foo', 'bar', 'baz'])
    ...         self.context = context

    >>> street.setAdapter(IFacetMenu, ExampleFacetMenu)
    >>> IFacetMenu(street).__class__ is ExampleFacetMenu
    True
    >>> nearest_adapter(root, IFacetMenu) is None
    True
    >>> nearest_adapter(street, IFacetMenu).__class__ is ExampleFacetMenu
    True
    >>> nearest_adapter(house, IFacetMenu).__class__ is ExampleFacetMenu
    True

We can also see this work with nearest_context_with_adapter.

    >>> context, adapter = nearest_context_with_adapter(house, IFacetMenu)
    >>> adapter.__class__ is ExampleFacetMenu
    True
    >>> context is street
    True

== The Link class ==

When you define a menu using class based on FacetMenu, you return Link
objects from its methods.  The Link class is very simple.  You provide
it with a target and some text for the link.  Other optional arguments
are some summary text, the name of an icon, and a boolean saying whether
the link is enabled.  Defaults are to have no summary, no icon, and
to be enabled.

Exactly how a disabled link appears on a page is up to the page template
code that renders links.  Typically, disabled links will be hidden, or
may be shown "greyed out" and not clickable.

These are the attributes that Link instances provide for setting by the
software developer who defines menus.  When you define a Link, you are
defining an object that provides ILinkData.

There are other attributes that are set by the menu infrastructure, and
are used when a Link is rendered in a page.  These attributes are defined
in ILink and IFacetLink.

    >>> from canonical.launchpad.webapp import Link
    >>> no_summary_link = Link('target', 'text -->')
    >>> ILinkData.providedBy(no_summary_link)
    True
    >>> no_summary_link.target
    'target'
    >>> no_summary_link.text
    'text -->'
    >>> print no_summary_link.summary
    None
    >>> print no_summary_link.icon
    None
    >>> no_summary_link.enabled
    True

If we want to include text with markup in the text of a link, we need to
mark is as being "structured".

    >>> from canonical.launchpad.webapp import structured
    >>> text = structured('some <b>%s</b> text', ' --> ')

    >>> full_link = Link('target', text, 'summary', icon='icon', enabled=False)
    >>> ILinkData.providedBy(full_link)
    True
    >>> full_link.target
    'target'
    >>> full_link.text
    <structured-string 'some <b>%s</b> text'>
    >>> full_link.summary
    'summary'
    >>> full_link.icon
    'icon'
    >>> full_link.enabled
    False


The menu infrastructure adapts a Link instance to ILink (for context and
application menus) and IFacetLink (for facet menus).  This (morally speaking)
allows the menu infrastructure to set the 'name', 'url', 'linked' and
(in the case of IFacetLink) 'selected' attributes of the link.

By using separate interfaces, and by adapting, we keep the different
responsibilities of links clearly separated, and leave room for making
clean changes and optimisations later.

Let's make a couple of Link instances, adapt them to ILink and IFacetLink,
and show that getting and setting the appropriate attributes works.

We use two separate links because setting attributes on the adapted link
will change the data in the underlying link instance.  We may change this
later, to allow some links to be precomputed or shared, but right now,
link instances are meant to be created freshly on each request, and not
shared or reused.

    >>> link1 = Link('target', 'text', 'summary', icon='icon', enabled=False)
    >>> link2 = Link('target', 'text', 'summary', icon='icon', enabled=False)

    >>> for menu_link in ILink(link1), IFacetLink(link2):
    ...     print menu_link.name, menu_link.url, menu_link.linked
    ...     menu_link.name = 'name'
    ...     menu_link.url = 'url'
    ...     menu_link.linked = False
    ...     print menu_link.name, menu_link.url, menu_link.linked
    None None True
    name url False
    None None True
    name url False

    >>> facet_menu_link = IFacetLink(link2)
    >>> facet_menu_link.selected
    False
    >>> facet_menu_link.selected = True
    >>> facet_menu_link.selected
    True


== The FacetMenu class ==

    >>> from canonical.launchpad.webapp import FacetMenu

FacetMenu is meant to be used as a base-class for writing your own IFacetMenu
classes.  Here's what happens when you use it on its own.

    >>> bad_idea_menu = FacetMenu(object())
    >>> for link in bad_idea_menu.iterlinks():
    ...     pass
    Traceback (most recent call last):
    ...
    AssertionError: Subclasses of FacetMenu must provide self.links

So, we must test FacetMenu by making our own menu subclass.  We'll just call
our menu 'Facets'.  One thing missing from this class is the 'usedfor'
declaration.  We need to use this in practice because we need to know how to
register our menu as an adapter.  For this part of the test, we won't worry
about that.

The FacetMenu class also allows you to specify the 'defaultlink' attribute,
which is None by default (for no default link), but can be the name of the
default link for this menu.

    >>> class Facets(FacetMenu):
    ...
    ...     links = ['foo', 'bar']
    ...
    ...     def foo(self):
    ...         target = '+foo'
    ...         text = 'Foo'
    ...         return Link(target, text)
    ...
    ...     def bar(self):
    ...         target = '+bar'
    ...         text = 'Bar'
    ...         summary = (
    ...             'More explanation about Bar of %s' % self.context.name)
    ...         return Link(target, text, summary)

Now, we can make an instance of this Facets class, with a contextobject to
show that its methods can access `self.context`.

    >>> facetmenu = Facets(street)

We can go through each attribute of each of the links, checking that they
are as we expect.

    >>> for link in facetmenu.iterlinks():
    ...     print '--- link %s ---' % link.name
    ...     for attrname in sorted(IFacetLink.names(all=True)):
    ...         print '%s: %s' % (attrname, getattr(link, attrname))
    --- link foo ---
    enabled: True
    escapedtext: Foo
    icon: None
    linked: True
    name: foo
    selected: False
    site: None
    summary: None
    target: +foo
    text: Foo
    url: http://launchpad.dev/sesamestreet/+foo
    --- link bar ---
    enabled: True
    escapedtext: Bar
    icon: None
    linked: True
    name: bar
    selected: False
    site: None
    summary: More explanation about Bar of sesamestreet
    target: +bar
    text: Bar
    url: http://launchpad.dev/sesamestreet/+bar


== Enabled links and disabled links ==

Often, we want to make a facet menu that uses the standard facet menu links,
but with only some of them enabled.

To do this, we make a new menu class that extends an existing one.  We need
to provide a set of link names that are to be enabled.  All other links will
be disabled.

    >>> class OnlySomeEnabledFacets(Facets):
    ...
    ...     enable_only = ['foo']

Now, we can make an instance of this class.

    >>> onlysomeenabledfacetmenu = OnlySomeEnabledFacets(street)

We look at the links, to make sure they are as we expect.

    >>> for link in onlysomeenabledfacetmenu.iterlinks():
    ...     print '--- link %s ---' % link.name
    ...     print 'enabled:', link.enabled
    --- link foo ---
    enabled: True
    --- link bar ---
    enabled: False

If 'enable_only' contains a link name that does not appear in 'links', we
should get a warning.

    >>> class UnknownEnableOnlyFacets(Facets):
    ...
    ...     enable_only = ['bar', 'quux']

Now, we can make an instance of this class.

    >>> unknownenableonlyfacets = UnknownEnableOnlyFacets(street)

    >>> for link in unknownenableonlyfacets.iterlinks():
    ...     print '--- link %s ---' % link.name
    ...     print 'enabled:', link.enabled
    Traceback (most recent call last):
    ...
    AssertionError: Links in 'enable_only' not found in 'links': quux


== The MenuLink and FacetLink adapter classes ==

The menus system needs to be able to adapt ILinkData objects to objects
that provide ILink or IFacetLink.  The menus system needs to be able to
set the 'enabled', 'name', 'url', 'linked, and for IFacetLink, 'selected'
attributes, but without altering the underlying ILinkData object.  Also,
an ILink object provides an HTML escaped version of the text in the
attribute 'escapedtext'.

    >>> somelink = Link('target', 'text', 'summary', icon='icon')
    >>> ILinkData.providedBy(somelink)
    True
    >>> ILink.providedBy(somelink)
    False
    >>> adaptedtolink = ILink(somelink)
    >>> ILink.providedBy(adaptedtolink)
    True

It is important we don't get a facetlink here, so that we can do views on links
if we want to, and have distinct views on facet and other links.

    >>> IFacetLink.providedBy(adaptedtolink)
    False

    >>> adaptedtolink.target
    'target'
    >>> adaptedtolink.text
    'text'
    >>> adaptedtolink.summary
    'summary'
    >>> adaptedtolink.icon
    'icon'
    >>> adaptedtolink.enabled
    True
    >>> adaptedtolink.enabled = False
    >>> adaptedtolink.enabled
    False
    >>> somelink.enabled
    True


Checking out the escapedtext attribute.

    >>> link = Link('+target', 'text -->')

    >>> ILink(link).escapedtext
    'text --&gt;'
    >>> IFacetLink(link).escapedtext
    'text --&gt;'

    >>> text = structured('some <b> %s </b> text', '-->')
    >>> link = Link('+target', text)

    >>> ILink(link).escapedtext
    'some <b> --&gt; </b> text'
    >>> IFacetLink(link).escapedtext
    'some <b> --&gt; </b> text'


We can test the 'structured' helper directly.

    >>> structured('foo').escapedtext
    'foo'
    >>> structured('%s', 'a < b > c & d " e').escapedtext
    'a &lt; b &gt; c &amp; d " e'
    >>> structured('a < b > c & d " e').escapedtext
    'a < b > c & d " e'
    >>> structured(
    ...     'replacement %(foo)s, %(bar)s', foo='<foo>', bar='bar').escapedtext
    'replacement &lt;foo&gt;, bar'
    >>> structured('whatever', 'foo', 'bar', baz='baz')
    Traceback (most recent call last):
    ...
    TypeError:...


== How do we tell which link from a facetmenu is the selected one? ==

A link will be selected if its name is passed to the facet menu's
iterlinks method, or otherwise, if its name is the defaultlink.

    >>> for link in facetmenu.iterlinks(selectedfacetname='bar'):
    ...     print '--- link %s ---' % link.name
    ...     print 'selected:', link.selected
    --- link foo ---
    selected: False
    --- link bar ---
    selected: True

When a link name is passed in, but no link of that name is in the menu, it
is not an error.  No link is selected.

    >>> for link in facetmenu.iterlinks(selectedfacetname='nosuchname'):
    ...     print '--- link %s ---' % link.name
    ...     print 'selected:', link.selected
    --- link foo ---
    selected: False
    --- link bar ---
    selected: False

No selected link is given, but the default is 'foo', so 'foo' will be selected.

    >>> facetmenu.defaultlink = 'foo'
    >>> for link in facetmenu.iterlinks():
    ...     print '--- link %s ---' % link.name
    ...     print 'selected:', link.selected
    --- link foo ---
    selected: True
    --- link bar ---
    selected: False

Now, 'foo' is still the default, but 'bar' has been selected.  So only 'bar'
will be selected.

    >>> for link in facetmenu.iterlinks(selectedfacetname='bar'):
    ...     print '--- link %s ---' % link.name
    ...     print 'selected:', link.selected
    --- link foo ---
    selected: False
    --- link bar ---
    selected: True

We still have 'foo' as the default.  This time, 'nosuchlink' has been selected.
As there is no such link, nothing will be selected.

    >>> for link in facetmenu.iterlinks(selectedfacetname='nosuchlink'):
    ...     print '--- link %s ---' % link.name
    ...     print 'selected:', link.selected
    --- link foo ---
    selected: False
    --- link bar ---
    selected: False


== How do we tell whether a link from a facetmenu is linked? ==

A link is linked if its link's target differs from the current URL.

To test this, we need a dummy request object that provides `getURL()`.

    >>> # Needed for getApplicationURL()
    >>> from zope.publisher.interfaces.http import IHTTPApplicationRequest
    >>> # Needed for registering a default view name.
    >>> from zope.publisher.interfaces.browser import IBrowserRequest
    >>> class DummyRequest:
    ...     implements(IHTTPApplicationRequest, IBrowserRequest)
    ...
    ...     def __init__(self, url, query=None, url1=None):
    ...         self.url = url
    ...         self.query = query
    ...         self.url1 = url1  # returned from getURL(1)
    ...         self.method = 'GET'
    ...
    ...     def getURL(self, level=0):
    ...         assert 0 <= level <=1, 'level must be 0 or 1'
    ...         if level == 0:
    ...             return self.url
    ...         else:
    ...             assert self.url1 is not None, (
    ...                 'Must set url1 in DummyRequest')
    ...             return self.url1
    ...
    ...     def getApplicationURL(self):
    ...         # Just the http://place:port part, so stop at the 3rd slash.
    ...         return '/'.join(self.url.split('/', 3)[:3])
    ...
    ...     def get(self, key, default=None):
    ...         assert key == 'QUERY_STRING', 'we handle only QUERY_STRING'
    ...         if self.query is None:
    ...             return default
    ...         else:
    ...             return self.query

    >>> from canonical.launchpad.webapp.uri import URI

The following request is for a url that is different from all of the facet
menu links for 'sesamestreet'.  So, all links will be linked.

    >>> request = URI('http://launchpad.dev/sesamestreet/+xxx')
    >>> facets = Facets(street)
    >>> for link in facets.iterlinks(request):
    ...     print link.url, link.linked
    http://launchpad.dev/sesamestreet/+foo True
    http://launchpad.dev/sesamestreet/+bar True

This next request is for +foo, but with a query string.  So, both links will
still be linked.

    >>> request = DummyRequest(
    ...     'http://launchpad.dev/sesamestreet/+foo', query="123")
    >>> facets = Facets(street)
    >>> for link in facets.iterlinks():
    ...     print link.url, link.linked
    http://launchpad.dev/sesamestreet/+foo True
    http://launchpad.dev/sesamestreet/+bar True

Next, we'll use the link +bar.  The +bar link will not be linked.

    >>> request = URI('http://launchpad.dev/sesamestreet/+bar')
    >>> facets = Facets(street)
    >>> for link in facets.iterlinks(request):
    ...     print link.url, link.linked
    http://launchpad.dev/sesamestreet/+foo True
    http://launchpad.dev/sesamestreet/+bar False

Now, we use +bar with a trailing slash.  The +bar link will still be not
linked.

    >>> request = URI('http://launchpad.dev/sesamestreet/+bar/')
    >>> facets = Facets(street)
    >>> for link in facets.iterlinks(request):
    ...     print link.url, link.linked
    http://launchpad.dev/sesamestreet/+foo True
    http://launchpad.dev/sesamestreet/+bar False


We need to test the case when we have a link with a blank target.
This will be the common case for default links.

    >>> class BlankTargetTestFacets(Facets):
    ...
    ...     links = Facets.links + ['baz']
    ...     defaultlink = 'foo'
    ...
    ...     def foo(self):
    ...         target = ''
    ...         text = 'Foo'
    ...         return Link(target, text)
    ...
    ...     def baz(self):
    ...         target = '+baz'
    ...         text = 'Baz'
    ...         summary = (
    ...             'More explanation about Baz of %s' % self.context.name)
    ...         return Link(target, text, summary)

    >>> request = URI('http://launchpad.dev/sesamestreet/+bar')
    >>> facets = BlankTargetTestFacets(street)
    >>> for link in facets.iterlinks(request):
    ...     print link.url, link.linked
    http://launchpad.dev/sesamestreet/ True
    http://launchpad.dev/sesamestreet/+bar False
    http://launchpad.dev/sesamestreet/+baz True



=== Absolute url targets ===

We will want to make links with absolute urls as targets.

Absolute urls can be made with a full url, including the host part, or as
a url path beginning with '/'.

Sometimes the target will be within Launchpad.  Other times, the link will be
to an external site.

When the link is to an external site, we'll want to note that as an attribute
of the Link.  That will come as a future enhancement.  External links will
always be linked.

When the link is to a page in Launchpad, we need to treat it the same as
a normal relative link.  That is, we need to compute 'linked' and 'selected'
as for relative links.  The usual use-case is computing an absolute link
to a page inside launchpad using canonical_url.  In this case, the host and
protocol part of the url will be the same for the canonical_url as for the
current request.  This is what we will use to see if we have a link to a
page within Launchpad.

    >>> class AbsoluteUrlTargetTestFacets(FacetMenu):
    ...
    ...     links = ['foo', 'bar', 'baz', 'spoo']
    ...
    ...     def foo(self):
    ...         target = ''
    ...         text = 'Foo'
    ...         return Link(target, text)
    ...
    ...     def bar(self):
    ...         target = 'ftp://barlink.example.com/barbarbar'
    ...         text = 'External bar'
    ...         return Link(target, text)
    ...
    ...     def baz(self):
    ...         target = 'http://launchpad.dev/sesamestreet/+baz'
    ...         text = 'Baz'
    ...         return Link(target, text)
    ...
    ...     def spoo(self):
    ...         target = '/sesamestreet/+spoo'
    ...         text = 'Spoo'
    ...         return Link(target, text)

The url1 is needed because we still have the defaultViewName registered from
earlier in this doctest.

    >>> canonical_url(street)
    u'http://launchpad.dev/sesamestreet'

    >>> request = URI('http://launchpad.dev/sesamestreet')

    >>> facets = AbsoluteUrlTargetTestFacets(street)
    >>> for link in facets.iterlinks(request):
    ...     print link.url, link.linked
    http://launchpad.dev/sesamestreet/ False
    ftp://barlink.example.com/barbarbar True
    http://launchpad.dev/sesamestreet/+baz True
    http://launchpad.dev/sesamestreet/+spoo True


== Application Menus ==

Application menus are defined for a context object for a particular named
Facet menu item.  The name of the facet menu item used is whichever facet
is selected from the nearest context object that has an IFacetMenu adapter.

Defining an ApplicationMenu works like defining a FacetMenu, except we
also need to say what facet menu item it is for.

    >>> from canonical.launchpad.webapp import ApplicationMenu

ApplicationMenu is meant to be used as a base-class for writing your own
IApplicationMenu classes.  Here's what happens when you use it on its own.

    >>> bad_idea_menu = ApplicationMenu(object())
    >>> for link in bad_idea_menu.iterlinks():
    ...     pass
    Traceback (most recent call last):
    ...
    AssertionError: Subclasses of ApplicationMenu must provide self.links

So, we must test ApplicationMenu by making our own menu subclass.  We'll
just call our menu 'FooApplicationMenu' as we intend it to be used when the
'foo' facet is selected.  Two things missing from this class are the 'usedfor'
declaration and the 'facet' declaration.  We need to use these in practice
because we need to know how to register our menu as an adapter.  For this
part of the test, we won't worry about that.

    >>> class FooApplicationMenu(ApplicationMenu):
    ...
    ...     links = ['first']
    ...     facet = 'foo'
    ...
    ...     def first(self):
    ...         target = '+first'
    ...         text = 'First menu'
    ...         return Link(target, text)

Now, we can make an instance of this FooApplicationMenu class.  We should
really be using some link text that shows that its methods can access
`self.context`. That's a minor TODO item.

    >>> housefooappmenu = FooApplicationMenu(house)

We can go through each attribute of each of the links, checking that they
are as we expect.

    >>> for link in housefooappmenu.iterlinks():
    ...     print '--- link %s ---' % link.name
    ...     for attrname in sorted(ILink.names(all=True)):
    ...         print '%s: %s' % (attrname, getattr(link, attrname))
    --- link first ---
    enabled: True
    escapedtext: First menu
    icon: None
    linked: True
    name: first
    site: None
    summary: None
    target: +first
    text: First menu
    url: http://launchpad.dev/sesamestreet/number73/+first


== Context Menus ==

Context menus are defined for a context object.  Each context object has
just one context menu, and it is available at all times.

Defining a ContextMenu works like defining a FacetMenu.

    >>> from canonical.launchpad.webapp import ContextMenu

ContextMenu is meant to be used as a base-class for writing your own
IContextMenu classes.  Here's what happens when you use it on its own.

    >>> bad_idea_menu = ContextMenu(object())
    >>> for link in bad_idea_menu.iterlinks():
    ...     pass
    Traceback (most recent call last):
    ...
    AssertionError: Subclasses of ContextMenu must provide self.links

So, we must test ContextMenu by making our own menu subclass.  We'll
just call our menu 'MyContextMenu'.

One thing missing from this class is the 'usedfor' declaration, which tells
the registration machinery how to render this menu as an adapter.  For this
part of the test, we won't worry about that.

    >>> class MyContextMenu(ContextMenu):
    ...
    ...     links = ['firstcontext']
    ...
    ...     def firstcontext(self):
    ...         target = '+firstcontext'
    ...         text = 'First context menu item'
    ...         return Link(target, text)

Now, we can make an instance of this MyContextMenu class.  We should
really be using some link text that shows that its methods can access
`self.context`. That's a minor TODO item.

    >>> housefoocontextmenu = MyContextMenu(house)

We can go through each attribute of each of the links, checking that they
are as we expect.

    >>> for link in housefoocontextmenu.iterlinks():
    ...     print '--- link %s ---' % link.name
    ...     for attrname in sorted(ILink.names(all=True)):
    ...         print '%s: %s' % (attrname, getattr(link, attrname))
    --- link firstcontext ---
    enabled: True
    escapedtext: First context menu item
    icon: None
    linked: True
    name: firstcontext
    site: None
    summary: None
    target: +firstcontext
    text: First context menu item
    url: http://launchpad.dev/sesamestreet/number73/+firstcontext


== Registering menus in ZCML ==

First, we define a couple of interfaces, and put them in the
canonical.launchpad.ftests module.

    >>> class IThingHavingFacets(Interface):
    ...     pass
    >>> import canonical.launchpad.ftests
    >>> getattr(canonical.launchpad.ftests, 'IThingHavingFacets', None) is None
    True
    >>> canonical.launchpad.ftests.IThingHavingFacets = IThingHavingFacets
    >>> IThingHavingFacets.__module__ = 'canonical.launchpad.ftests'

    >>> class IThingHavingMenus(Interface):
    ...     pass
    >>> import canonical.launchpad.ftests
    >>> getattr(canonical.launchpad.ftests, 'IThingHavingMenus', None) is None
    True
    >>> canonical.launchpad.ftests.IThingHavingMenus = IThingHavingMenus
    >>> IThingHavingMenus.__module__ = 'canonical.launchpad.ftests'

Next, we define a FacetMenu subclass to be used for IThingHavingFacets, using a
usedfor class attribute to say what interface it is to be registered for, and
put it too in the canonical.launchpad.ftests module.

    >>> class FacetsForThing(Facets):
    ...     usedfor = IThingHavingFacets
    ...
    ...     links = ['foo', 'bar', 'baz']
    ...
    ...     def baz(self):
    ...         target = ''
    ...         text = 'baz'
    ...         if self.request is None:
    ...             summary = "No request available"
    ...         else:
    ...             summary = self.request.method
    ...         return Link(target, text, summary=summary)

    >>> getattr(canonical.launchpad.ftests, 'FacetsForThing', None) is None
    True
    >>> canonical.launchpad.ftests.FacetsForThing = FacetsForThing


And likewise for an application menu registered for IThingHavingMenus.

    >>> class FooMenuForThing(FooApplicationMenu):
    ...     usedfor = IThingHavingMenus
    ...     facet = 'foo'

    >>> getattr(canonical.launchpad.ftests, 'FooMenuForThing', None) is None
    True
    >>> canonical.launchpad.ftests.FooMenuForThing = FooMenuForThing

We do the same for a context menu.

    >>> class ContextMenuForThing(MyContextMenu):
    ...     usedfor = IThingHavingMenus

    >>> print getattr(canonical.launchpad.ftests, 'ContextMenuForThing', None)
    None
    >>> canonical.launchpad.ftests.ContextMenuForThing = ContextMenuForThing


Now, check that we have no IFacetMenu adapter for an IThingHavingFacets object.

    >>> class SomeThing:
    ...     implements(IThingHavingFacets)
    >>> something_with_facets = SomeThing()
    >>> IFacetMenu(something_with_facets, None) is None
    True

We also need to check that we have no IApplicationMenu adapter named 'foo' for
an IThingHavingMenus object.

    >>> class SomeOtherThing:
    ...     implements(IThingHavingMenus)
    >>> something_with_menus = SomeOtherThing()
    >>> print queryAdapter(something_with_menus, IApplicationMenu, 'foo')
    None

Same for an IContextMenu adapter.

    >>> print queryAdapter(something_with_menus, IContextMenu, 'foo')
    None

    >>> from zope.configuration import xmlconfig
    >>> zcmlcontext = xmlconfig.string("""
    ... <configure xmlns:browser="http://namespaces.zope.org/browser">
    ...   <include file="lib/canonical/launchpad/webapp/meta.zcml" />
    ...   <browser:menus
    ...       module="canonical.launchpad.ftests"
    ...       classes="FacetsForThing FooMenuForThing ContextMenuForThing"
    ...       />
    ... </configure>
    ... """)

    >>> menu1 = IFacetMenu(something_with_facets)
    >>> menu1.context = something_with_facets
    >>> menu1.__class__ is FacetsForThing
    True
    >>> menu2 = queryAdapter(something_with_menus, IApplicationMenu, 'foo')
    >>> menu2.context = something_with_menus
    >>> menu2.__class__ is FooMenuForThing
    True
    >>> menu3 = IContextMenu(something_with_menus)
    >>> menu3.context = something_with_menus
    >>> menu3.__class__ is ContextMenuForThing
    True

The browser:menus directive also makes security declarations for the adapters.


== Using menus in page templates ==

We use menus in page templates by using the `thing/menu:typeofmenu`
TALES namespace.

First, let's look at `thing/menu:facet`.  What this does is to look up
nearest_adapter(thing, IFacetMenu), getting an IFacetMenu adapter from it.
Then, it gets the request from either the TALES CONTEXTS or the current
interaction, and calculates a request Url object to pass into IMenu.iterlinks,
so that it can properly decide whether a particular link should appear linked.
The request is also set as the menu's 'request' attribute.


    >>> from canonical.launchpad.ftests import test_tales

    >>> class View:
    ...     __launchpad_facetname__ = 'bar'
    ...
    >>> view = View()

    >>> street.adapt_to = None
    >>> directlyProvides(street, IThingHavingFacets)
    >>> house.adapt_to = None
    >>> directlyProvides(house, IThingHavingMenus)

    >>> request = DummyRequest('http://launchpad.dev/sesamestreet/+bar')

    >>> links = test_tales(
    ...     'CONTEXTS/menu:facet', context=house, view=view, request=request, debug=True)

    >>> for link in links:
    ...     print link.url, link.selected, link.linked, link.summary
    http://launchpad.dev/sesamestreet/+foo False True None
    http://launchpad.dev/sesamestreet/+bar True False More explanation about Bar of sesamestreet
    http://launchpad.dev/sesamestreet/ False True GET

So, the first link '+foo' is linked, but the second '+bar' is not.  This
is because the URL of '+bar' is the same as the request in the CONTEXTS.

Let's try again, this time with a request from the participation.

    >>> participation = DummyRequest(
    ...     'http://launchpad.dev/sesamestreet/+bar')
    >>> participation.interaction = None
    >>> login(ANONYMOUS, participation)

    >>> links = test_tales(
    ...     'context/menu:facet', context=house)
    >>> for link in links:
    ...     print link.url, link.selected, link.linked
    http://launchpad.dev/sesamestreet/+foo False True
    http://launchpad.dev/sesamestreet/+bar False False
    http://launchpad.dev/sesamestreet/ False True

Note that '+bar' is not selected.  This is because we're adapting 'context'
and not 'CONTEXTS', so the menus system has no way of knowing what the
selected facet is for the current page.


Sometimes, we need to take into account the default view name for an object.
Let's say that the default view name for an IStreet is '+baz'.  This is
the common case where the overview link is the default view name.

    >>> class IStreet(Interface):
    ...     """A street."""
    >>> directlyProvides(street, IStreet, IThingHavingFacets)
    >>> from zope.app.tests import ztapi
    >>> ztapi.setDefaultViewName(IStreet, '+baz', None)

    >>> request = DummyRequest(
    ...     'http://launchpad.dev/sesamestreet/+baz',
    ...     url1='http://launchpad.dev/sesamestreet/')

    >>> from zope.app.zapi import getDefaultViewName
    >>> getDefaultViewName(street, request)
    '+baz'

So, in this example, the last link should not be 'linked' because it is
equivalent to the default view name for a street.  The TALES infrastructure
actually calculates a shortened URL for this case.

    >>> links = test_tales(
    ...     'CONTEXTS/menu:facet', context=street, view=view, request=request)
    >>> for link in links:
    ...     print link.url, link.linked
    http://launchpad.dev/sesamestreet/+foo True
    http://launchpad.dev/sesamestreet/+bar True
    http://launchpad.dev/sesamestreet/ False


The result of `house/menu:application` will be empty at the moment, because
we registered only one application menu for a house, against 'foo'.  The
'bar' facet is the one selected, so we don't get any application menu.

    >>> menu = test_tales('CONTEXTS/menu:application',
    ...     context=house, view=view, request=request)
    >>> list(menu)
    []

Now, if we change the view's __launchpad_facetname__ so that the 'foo' facet
is selected, we get a couple of menus.

    >>> view.__launchpad_facetname__ = 'foo'
    >>> links = test_tales('CONTEXTS/menu:application',
    ...     context=house, view=view, request=request)
    >>> for link in links:
    ...     print link.url
    http://launchpad.dev/sesamestreet/number73/+first

You can traverse to an individual menu item from the facet menu:

    >>> link = test_tales(
    ...     'CONTEXTS/menu:foo/first', context=house, view=view,
    ...     request=request)
    >>> print link.url
    http://launchpad.dev/sesamestreet/number73/+first

But if a non-existing entry is requested, a KeyError is raised:

    >>> test_tales(
    ...     'CONTEXTS/menu:foo/broken', context=house, view=view,
    ...     request=request)
    Traceback (most recent call last):
    ...
    KeyError: 'broken'

Also, we report also when the selected facet does not exist with
a TraversalError exception:

    >>> test_tales(
    ...     'CONTEXTS/menu:broken/bar', context=house, view=view,
    ...     request=request)
    Traceback (most recent call last):
    ...
    TraversalError: ..., 'broken')

We get also the list of menu entries available for a given context
and facet, one is for the application menu (first) and the other is
for the context menu (firstcontext):

    >>> test_tales(
    ...     'CONTEXTS/menu:foo', context=house, view=view, request=request)
    {'firstcontext': ...MenuLink..., 'first': ...MenuLink...}

We can also get a context menu as menu:context.  It makes no difference
whether the TALES code is CONTEXTS/menu:context or context/menu:context,
because the menus system doesn't need to know anything about the view object.

    >>> links = test_tales('context/menu:context', context=house)
    >>> for link in links:
    ...     print link.url
    http://launchpad.dev/sesamestreet/number73/+firstcontext

When there is no menu for a thing, we get an empty iterator.

    >>> menu = test_tales(
    ...     'CONTEXTS/menu:facet', context=root, view=view, request=request)
    >>> list(menu)
    []
    >>> menu = test_tales('CONTEXTS/menu:application',
    ...     context=root, view=view, request=request)
    >>> list(menu)
    []
    >>> menu = test_tales('CONTEXTS/menu:context',
    ...     context=root, view=view, request=request)
    >>> list(menu)
    []

And thus, we don't have a facet to navigate to:

    >>> test_tales(
    ...     'CONTEXTS/menu:foo/+first', context=root, view=view,
    ...     request=request)
    Traceback (most recent call last):
    ...
    TraversalError: ..., 'foo')


== Cleaning up ==

We're done testing the zcml, so we can clean up the canonical.launchpad.ftests
module.

    >>> del canonical.launchpad.ftests.FacetsForThing
    >>> del canonical.launchpad.ftests.FooMenuForThing
    >>> del canonical.launchpad.ftests.ContextMenuForThing
    >>> del canonical.launchpad.ftests.IThingHavingFacets
    >>> del canonical.launchpad.ftests.IThingHavingMenus


== The enabled_with_permission function decorator ==

If you have a menu item that should be enabled only when the current logged-in
user has a particular permission, then you can write the link as usual, and use
the enabled_with_permission function decorator.

It works like this:

    >>> from canonical.launchpad.webapp import enabled_with_permission

    >>> class SomeMenu(ContextMenu):
    ...
    ...     @enabled_with_permission('launchpad.Admin')
    ...     def foo(self):
    ...         return Link('+admin', 'Admin the foo')

    >>> somemenu = SomeMenu(street)

If we're logged in as an anonymous user, then the link will be disabled.

    >>> login(ANONYMOUS)

    >>> foolink = somemenu.foo()
    >>> foolink.text
    'Admin the foo'
    >>> foolink.enabled
    False

Now, we log in as foo.bar@canonical.com, an admin.

    >>> login('foo.bar@canonical.com')
    >>> foolink = somemenu.foo()
    >>> foolink.enabled
    True

