= Badges =

Badges are nifty user interface elements that are used to indicate to
the user that there are interesting features about the thing that the
badges are attached to.

Badges are shown in two main places:
  * Object listings
  * Main object pages

In the listing views, badges are used to show links between objects,
such as bug-branch links or bug-spec links, and object attribute values
such as privacy or mentoring availability.

Listings use small icon sized images, and object details pages use
larger logo sized images.

In order to maintain a level of standardisation across the badge uses in
Launchpad, there is a central list of standard badges along with there
alternate text and titles.

    >>> from canonical.launchpad.webapp.badge import STANDARD_BADGES

Iterating over this collection gives:

    >>> for name in sorted(STANDARD_BADGES.keys()):
    ...     print name
    blueprint
    branch
    bug
    private


== The Badge class ==

The badge class has two methods of interest:
  * small - the HTML for the icon sized image
  * large - the HTML for the logo sized image

A badge is constructed with the locations of the images, the default alternate
text and the default title.

    >>> from canonical.launchpad.webapp.badge import Badge
    >>> bug = Badge(
    ...     small_image='/@@/bug', large_image='/@@/bug-logo',
    ...     alt='bug', title='Linked to a bug')

Both `alt` and `title` default to the empty string.

Calling the small or large method will produce the default image HTML.

    >>> print bug.small()
    <img alt="bug" width="14" height="14" src="/@@/bug" title="Linked to a bug"/>
    >>> print bug.large()
    <img alt="bug" width="32" height="32" src="/@@/bug-logo" title="Linked to a bug"/>


== IHasBadges ==

Badge determination is handled by the IHasBadges interface.

There is a simplistic class that implements the basic functionality of
IHasBranches in order to provide a simple mixin.  The derived class just
needs to implement `isBadgeVisible` and provide a list of badges to
check.

In order to provide a badge that is not one of the standard ones, the
badger class needs to implement the method `getBadge`.

    >>> from canonical.launchpad.webapp.badge import HasBadgeBase
    >>> class SimpleBadger(HasBadgeBase):
    ...     badges = "bug", "fish"
    ...     def isBadgeVisible(self, badge_name):
    ...         print "SimpleBadger.isBadgeVisible(%r)" % badge_name
    ...         return True
    ...     def getBadge(self, badge_name):
    ...         if badge_name == "fish":
    ...             return Badge('small-fish', 'large-fish', 'fish')
    ...         else:
    ...             return HasBadgeBase.getBadge(self, badge_name)

    >>> for badge in SimpleBadger().getVisibleBadges():
    ...     print badge.alt
    SimpleBadger.isBadgeVisible('bug')
    SimpleBadger.isBadgeVisible('fish')
    bug
    fish


== BadgeMethodDelegator ==

Determining badge visibility when passed a string is somewhat annoying.
The BadgeMethodDelegator provides an implementation for `isBadgeVisible`
and translates that to a method call based on the name of the badge, so
checking for a 'bug' badge becomes `isBugBadgeVisible`.

    >>> from canonical.launchpad.webapp.badge import BadgeMethodDelegator
    >>> class NotSoSimpleBadger(BadgeMethodDelegator):
    ...     badges = ["bug"]
    ...     def isBugBadgeVisible(self):
    ...         return True

    >>> for badge in NotSoSimpleBadger().getVisibleBadges():
    ...     print badge.alt
    bug

If the class does not implement the approprate method you get a
NotImplementedError.

    >>> NotSoSimpleBadger.badges.append("blueprint")
    >>> for badge in NotSoSimpleBadger().getVisibleBadges():
    ...     print badge.alt
    Traceback (most recent call last):
    ...
    NotImplementedError: isBlueprintBadgeVisible


== Preferred badging methodology ==

Under normal circumstances the badges for a given content object require
the accessing or counting of attributes that almost always require
database queries.  While this is fine for a single object, we do not
want to have that occurring for listings of objects.  For example, if
there were 5 possible badges for a branch and 3 of those counted links
to other tables, and we had a listing of 75 branches, then that is 225
database queries just for the badges.

In order to allow efficient database queries for listings, the suggested
way to implement badging is to provide an adapter for the content class.
This way there can be a simple way to define badges for a single content
class, and an alternative way to define the badges for a listing of the
content classes.

    >>> from zope.interface import Interface, Attribute
    >>> class IFoo(Interface):
    ...     bugs = Attribute('Some linked bugs')
    ...     blueprints = Attribute('Some linked blueprints')

    >>> from zope.interface import implements
    >>> class Foo(object):
    ...     implements(IFoo)
    ...     @property
    ...     def bugs(self):
    ...         print "Foo.bugs"
    ...         return ['a']
    ...     @property
    ...     def blueprints(self):
    ...         print "Foo.blueprints"
    ...         return []

Now define the adapter for the Foo content class.

    >>> class FooBadges(BadgeMethodDelegator):
    ...     badges = "bug", "blueprint"
    ...     def __init__(self, context):
    ...         self.context = context
    ...     def isBugBadgeVisible(self):
    ...         return len(self.context.bugs) > 0
    ...     def isBlueprintBadgeVisible(self):
    ...         return len(self.context.blueprints) > 0

Register an aptapter in ZCML from the content type to IHasBadges.  Here
is the sample from the branch.zcml to illustrate.

  <adapter
      for="canonical.launchpad.interfaces.IBranch"
      provides="canonical.launchpad.webapp.badge.IHasBadges"
      factory="canonical.launchpad.browser.BranchBadges"
      />

Luckily zope provides a way to do this in doctests:

    >>> from canonical.launchpad.webapp.badge import IHasBadges
    >>> from zope.app.testing import ztapi
    >>> ztapi.provideAdapter(Foo, IHasBadges, FooBadges)

Now adapting a Foo to IHasBadges should provide an instance of FooBadges.

    >>> foo = Foo()
    >>> foo
    <Foo object at ...>

    >>> badger = IHasBadges(foo)
    >>> badger
    <FooBadges object at ...>

Getting the visible badges for foo calls the underlying methods on foo,
as illustrated by the printed method calls.

    >>> for badge in badger.getVisibleBadges():
    ...     print badge.small()
    Foo.bugs
    Foo.blueprints
    <img alt="bug" width="14" height="14" src="/@@/bug" title="Linked to a bug"/>

When showing listings of Foos, you often want to decorate them with
`decorates`.  By having the DecoratedFoo inherit from the FooBadges
class, we provide two things: a default implementation for each of the
badge methods; and direct implementation of IHasBadges.  This allows
the decorated class to provide an alternative method to decide on
badge visibility.  For example, with branches the visibility of the
bug badge is determined by the users ability to see the bugs for any
bug branch links, but on listings we don't want to do 100 queries just
to check bug badges, so the batch handler for branches executes a single
query for the BugBranch links for the branches in the batch and that is
used to contruct the DecoratedBranch.

    >>> from canonical.lp import decorates
    >>> class DecoratedFoo(FooBadges):
    ...     decorates(IFoo, 'foo')
    ...     def __init__(self, foo):
    ...         FooBadges.__init__(self, foo)
    ...         self.foo = foo
    ...     def isBugBadgeVisible(self):
    ...         return True
    ...     def isBlueprintBadgeVisible(self):
    ...         return False

    >>> decorated_foo = DecoratedFoo(foo)
    >>> decorated_foo
    <DecoratedFoo object at ...>

Since the DecoratedFoo implements IHasBadges through the class hierarchy
FooBadges and then BadgeMethodDelegator, getting an IHasBadges for the
DecoratedFoo returns the same object.

    >>> badger = IHasBadges(decorated_foo)
    >>> badger is decorated_foo
    True

Getting the visible badges for the decorated_foo bypasses the underlying
method calls, and thus avoiding unnecessary database hits (for normal
content classes).

    >>> for badge in badger.getVisibleBadges():
    ...     print badge.small()
    <img alt="bug" width="14" height="14" src="/@@/bug" title="Linked to a bug"/>


== Tales expressions ==

There is a tales formatter defined for badges.  These can be shown
as either small or large.

Using the tales formatter on the context object itself ends up using the
adapter that is defined for the content class, and as shown below
(through the printed attribute accessors), uses
the attributes of the content class.

    >>> from canonical.launchpad.ftests import test_tales
    >>> print test_tales('context/badges:small', context=foo)
    Foo.bugs
    Foo.blueprints
    <img alt="bug" width="14" height="14" src="/@@/bug" title="Linked to a bug"/>

    >>> print test_tales('context/badges:large', context=foo)
    Foo.bugs
    Foo.blueprints
    <img alt="bug" width="32" height="32" src="/@@/bug-large" title="Linked to a bug"/>

Using the decorated foo, we get the decorated methods called and avoid
the content class method calls.

    >>> print test_tales('context/badges:small', context=decorated_foo)
    <img alt="bug" width="14" height="14" src="/@@/bug" title="Linked to a bug"/>
    >>> print test_tales('context/badges:large', context=decorated_foo)
    <img alt="bug" width="32" height="32" src="/@@/bug-large" title="Linked to a bug"/>
