= Doing lookups in a tree =

  >>> from canonical.launchpad.components.treelookup import (
  ...     Lookup, Node)

`Lookup` encapsulated a simple tree structure that can be used to do
lookups using one or more keys. This was originally created to support
mapping statuses from remote bug trackers into Launchpad
statuses.

Another main criteria was documentation. We want to be able to
automatically generate documentation from the lookup trees that are
specified.

Originally a simple dictionary lookup was attempted, but it proved
difficult to create some of the moderately complex mapping rules we
needed. Supporting defaults and such required additional logic, and
ordering was lost, which may be useful to document.

Secondly, a structure of tuples was attempted, and this proved easier
to construct. However, it proved difficult to see what was going on,
with brackets everywhere!

The final design is a compromise. The `Lookup` class and helper class
`Node` both inherit from `tuple`, but also encapsulate the searching
algorithm and a few other conveniences. This makes the generation of
lookup trees quite pleasant on the eye, makes debugging easier, and
means they can be customised.


== Creation ==

  >>> tree = Lookup(
  ...     ('Snack', Lookup(
  ...             ('Mars Bar', 'Snickers', 'Bad'),
  ...             ('Apple', 'Banana', 'Good'))),
  ...     Node('Lunch', 'Dinner', Lookup(
  ...             ('Fish and chips', "Penne all'arrabbiata", 'Nice'),
  ...             ('Raw liver', 'Not so nice'))),
  ...     ('Make up your mind!',),
  ...     )

Behind the scenes, `Lookup` promotes plain tuples (or any iterable)
into `Node` instances. This means that the last member of the tuple is
the result (or next step) of the node. All the other members are keys.

Tuples/nodes without keys are default choices. They must come last.

  >>> broken_tree = Lookup(
  ...     ('Free agents',),
  ...     ('Alice', 'Bob', 'Allies of Schneier'))
  Traceback (most recent call last):
  ...
  TypeError: Default node must be last

To help when constructing more complex trees, an existing `Lookup`
instance can be passed in when constructing a new one. Its nodes are
copied into the new `Lookup` at that point.

  >>> breakfast_tree = Lookup(
  ...     ('Breakfast', 'Corn flakes'),
  ...     tree,
  ...     )

  >>> len(tree)
  3
  >>> len(breakfast_tree)
  4


== Searching ==

Just call the tree.

  >>> tree('Snack', 'Banana')
  'Good'

If you specify more keys than you need to reach a leaf node, you still
get the result.

  >>> tree('Snack', 'Banana', 'Big', 'Yellow', 'Taxi')
  'Good'

But an exception is raised if it does not reach a leaf node.

  >>> tree('Snack')
  Traceback (most recent call last):
  ...
  KeyError: 'Snack'


== Development ==

`Lookup` makes development easy, because __repr__ gives a complete
description of the tree you've created.

  >>> print repr(tree)
  lookup(
      node(Snack => lookup(
          node('Mars Bar', Snickers => 'Bad')
          node(Apple, Banana => 'Good')
          ))
      node(Lunch, Dinner => lookup(
          node('Fish and chips', "Penne all'arrabbiata" => 'Nice')
          node('Raw liver' => 'Not so nice')
          ))
      node(* => 'Make up your mind!')
      )

We can also see that the result of constructing a new lookup using an
existing one is the as if we had constructed it independently.

  >>> print repr(breakfast_tree)
  lookup(
      node(Breakfast => 'Corn flakes')
      node(Snack => lookup(
          node('Mars Bar', Snickers => 'Bad')
          node(Apple, Banana => 'Good')
          ))
      node(Lunch, Dinner => lookup(
          node('Fish and chips', "Penne all'arrabbiata" => 'Nice')
          node('Raw liver' => 'Not so nice')
          ))
      node(* => 'Make up your mind!')
      )

Simple keys are shown without quotes, to aid readability, and default
nodes are shown with '*' as the key.


== Documentation ==

You can discover the minimum and maximum depth of a tree.

  >>> tree.min_depth
  1
  >>> tree.max_depth
  2

`Lookup` has a `flattened` property that may be useful when generating
documentation. It yields tuples of nodes that represent paths to
leaves.

  >>> for elems in tree.flattened:
  ...     path, result = elems[:-1], elems[-1]
  ...     print ' => '.join(
  ...         [repr(tuple(node)) for node in path] + [repr(result)])
  ('Snack',) => ('Mars Bar', 'Snickers') => 'Bad'
  ('Snack',) => ('Apple', 'Banana') => 'Good'
  ('Lunch', 'Dinner') => ('Fish and chips', "Penne all'arrabbiata") => 'Nice'
  ('Lunch', 'Dinner') => ('Raw liver',) => 'Not so nice'
  () => 'Make up your mind!'
