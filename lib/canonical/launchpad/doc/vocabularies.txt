Introduction
============

Vocabularies are lists of terms. In Launchpad's Component Architecture
(CA), a vocabulary is a list of terms that a widget (normally a selection
style widget) "speaks", i.e., its allowed values.

    >>> from zope.component import getUtility
    >>> from canonical.launchpad.ftests import login
    >>> from canonical.launchpad.interfaces import (
    ...     IPersonSet, IOpenLaunchBag, IProductSet, IProjectSet)
    >>> from canonical.database.sqlbase import flush_database_updates
    >>> login('foo.bar@canonical.com')
    >>> launchbag = getUtility(IOpenLaunchBag)
    >>> launchbag.clear()


Values, Tokens, and Titles
==========================

In Launchpad, we generally use "tokenized vocabularies." Each term in
a vocabulary has a value, token and title. A term is rendered in a
select widget like this:

<option value="$token">$title</option>

The $token is probably the data you would store in your DB. The Token is
used to uniquely identify a Term, and the Title is the thing you display
to the user.


Launchpad Vocabularies
======================

There are two kinds of vocabularies in Launchpad: enumerable and
non-enumerable. Enumerable vocabularies are short enough to render in a
select widget. Non-enumerable vocabularies require a query interface to make
it easy to choose just one or a couple of options from several hundred,
several thousand, or more.

Vocabularies should not be imported - they can be retrieved from the
vocabulary registry.

    >>> from zope.schema.vocabulary import getVocabularyRegistry
    >>> vocabulary_registry = getVocabularyRegistry()
    >>> product_vocabulary = vocabulary_registry.get(None, "Product")
    >>> product_vocabulary.displayname
    'Select a project'


Enumerable Vocabularies
=======================

Creating a new Enumeratable Vocabulary based on an existent dbschema
constant:

    >>> from canonical.lp import dbschema
    >>> from canonical.launchpad.webapp.vocabulary import vocab_factory
    >>> PackagingVocabulary = vocab_factory(dbschema.PackagingType)

The right place to do it is in the file vocabularies/dbschema.py.
Note: don't forget to registry your brand new instance for zope lookup
in configure.zcml.

PackagingVocabulary
-------------------
Reflects the available constants for Packaging.packaging field.

In cases where we won't have many rows, some of the database
vocabularies can be enumerated over.

DistroSeriesVocabulary
-----------------------
Reflects the available distribution serieses.  Results are ordered by
`name`

    >>> distroseries_vocabulary = vocabulary_registry.get(
    ...     None,"DistroSeries")
    >>> for term in distroseries_vocabulary:
    ...     print "%30s %s" % (term.token, term.title)
            ubuntu/breezy-autotest Ubuntu: Breezy Badger Autotest
                     ubuntu/grumpy Ubuntu: The Grumpy Groundhog Release
                      ubuntu/hoary Ubuntu: The Hoary Hedgehog Release
                      ubuntu/warty Ubuntu: The Warty Warthog Release
                      debian/sarge Debian: Sarge
                        debian/sid Debian: Sid
                      debian/woody Debian: WOODY
                    guadalinex/2k5 GuadaLinex: Guada 2005
                    kubuntu/krunch Kubuntu: The Krunchy Kangaroo
                        redhat/7.0 Red Hat: Seven
                        redhat/six Red Hat: Six Six Six
        ubuntutest/breezy-autotest ubuntutest: Breezy Badger Autotest
             ubuntutest/hoary-test ubuntutest: Mock Hoary

    >>> distroseries_vocabulary.getTermByToken('ubuntu/hoary').value.title
    u'The Hoary Hedgehog Release'

    >>> def getTerms(vocab, search_text):
    ...     [vocab.toTerm(item) for item in vocab.search(search_text)]

    >>> getTerms(distroseries_vocabulary, 'woody')
    >>> getTerms(distroseries_vocabulary, 'debian')
    >>> getTerms(distroseries_vocabulary, 'invalid')
    >>> getTerms(distroseries_vocabulary, '')

    >> [term.token for term in distroseries_vocabulary.search('woody')]
    ['debian/woody']
    >> [term.token for term in distroseries_vocabulary.search('debian')]
    ['debian/sarge', 'debian/sid', 'debian/woody']
    >> [term.token for term in distroseries_vocabulary.search('invalid')]
    []
    >> [term.token for term in distroseries_vocabulary.search('')]
    []

DistributionUsingMaloneVocabulary
---------------------------------
All the distributions that use Malone as their main bug tracker.

    >>> using_malone_vocabulary = vocabulary_registry.get(
    ...     None, 'DistributionUsingMalone')
    >>> len(using_malone_vocabulary)
    2
    >>> for term in using_malone_vocabulary:
    ...     print term.token, term.value.displayname, term.title
    gentoo Gentoo Gentoo
    ubuntu Ubuntu Ubuntu

    >>> from canonical.launchpad.interfaces import ILaunchpadCelebrities
    >>> ubuntu = getUtility(ILaunchpadCelebrities).ubuntu
    >>> ubuntu in using_malone_vocabulary
    True
    >>> debian = getUtility(ILaunchpadCelebrities).debian
    >>> debian in using_malone_vocabulary
    False

    >>> using_malone_vocabulary.getQuery() is None
    True

    >>> term = using_malone_vocabulary.getTerm(ubuntu)
    >>> print term.token, term.value.displayname, term.title
    ubuntu Ubuntu Ubuntu

    >>> term = using_malone_vocabulary.getTerm(debian)
    Traceback (most recent call last):
    ...
    LookupError:...

    >>> term = using_malone_vocabulary.getTermByToken('ubuntu')
    >>> print term.token, term.value.displayname, term.title
    ubuntu Ubuntu Ubuntu

    >>> term = using_malone_vocabulary.getTermByToken('debian')
    Traceback (most recent call last):
    ...
    LookupError:...

PersonActiveMembership
----------------------
All the teams the person is an active member of.

    >>> foo_bar = getUtility(IPersonSet).getByEmail('foo.bar@canonical.com')
    >>> person_active_membership = vocabulary_registry.get(
    ...     foo_bar, 'PersonActiveMembership')
    >>> len(person_active_membership)
    8
    >>> for term in person_active_membership:
    ...     print term.token, term.value.displayname, term.title
    guadamen GuadaMen GuadaMen
    admins Launchpad Administrators Launchpad Administrators
    launchpad-buildd-admins Launchpad Buildd Admins Launchpad Buildd Admins
    launchpad Launchpad Developers Launchpad Developers
    testing-spanish-team testing Spanish team testing Spanish team
    name18 Ubuntu Gnome Team Ubuntu Gnome Team
    ubuntu-team Ubuntu Team Ubuntu Team
    vcs-imports VCS imports VCS imports

    >>> launchpad_team = getUtility(IPersonSet).getByName('launchpad')
    >>> launchpad_team in person_active_membership
    True
    >>> mirrors_admins = getUtility(IPersonSet).getByName('mirrors-admins')
    >>> mirrors_admins in person_active_membership
    False

    >>> person_active_membership.getQuery() is None
    True

    >>> term = person_active_membership.getTerm(launchpad_team)
    >>> print term.token, term.value.displayname, term.title
    launchpad Launchpad Developers Launchpad Developers

    >>> term = person_active_membership.getTerm(mirrors_admins)
    Traceback (most recent call last):
    ...
    LookupError:...

    >>> term = person_active_membership.getTermByToken('launchpad')
    >>> print term.token, term.value.displayname, term.title
    launchpad Launchpad Developers Launchpad Developers

    >>> term = person_active_membership.getTermByToken('mirrors-admins')
    Traceback (most recent call last):
    ...
    LookupError:...

== PersonTeamParticipations ==

This vocabulary contains all the teams a person participates in. Either
through direct or indirect participations.

    >>> sample_person = getUtility(IPersonSet).getByName('name12')
    >>> [membership.team.name
    ...  for membership in sample_person.myactivememberships]
    [u'landscape-developers', u'name20']
    >>> [team.name for team in sample_person.teams_participated_in]
    [u'landscape-developers', u'name18', u'name20']

    >>> sample_person_teams_vocabulary = vocabulary_registry.get(
    ...     sample_person, 'PersonTeamParticipations')

    >>> for term in sample_person_teams_vocabulary:
    ...     print "%s: %s (%s)" % (term.token, term.title, term.value.name)
    landscape-developers: Landscape Developers (landscape-developers)
    name18: Ubuntu Gnome Team (name18)
    name20: Warty  Security Team (name20)

Milestone
---------
All the milestone in a context.

If no context is given, all milestones in the database are in the
vocabulary.

    >>> all_milestones = vocabulary_registry.get(None, 'Milestone')
    >>> len(all_milestones)
    3
    >>> for term in all_milestones:
    ...     print "%s: %s" % (term.value.target.name, term.value.name)
    debian: 3.1
    debian: 3.1-rc1
    firefox: 1.0

If the context is a product, only the product's milestones are in the
vocabulary.

    >>> from canonical.launchpad.interfaces import IProductSet
    >>> firefox = getUtility(IProductSet).getByName('firefox')
    >>> firefox_milestones = vocabulary_registry.get(firefox, 'Milestone')
    >>> for term in firefox_milestones:
    ...     print "%s: %s" % (term.value.target.name, term.value.name)
    firefox: 1.0

If the context is a bugtask, only the bugtask's target's milestones are
in the vocabulary.

    >>> from canonical.launchpad.interfaces import IBugSet
    >>> bug_one = getUtility(IBugSet).get(1)
    >>> firefox_task = bug_one.bugtasks[0]
    >>> firefox_task.targetname
    u'firefox (upstream)'
    >>> firefox_task_milestones = vocabulary_registry.get(
    ...     firefox_task, 'Milestone')
    >>> for term in firefox_task_milestones:
    ...     print "%s: %s" % (term.value.target.name, term.value.name)
    firefox: 1.0

    >>> bug_two = getUtility(IBugSet).get(2)
    >>> debian_woody_task = bug_two.bugtasks[-1]
    >>> debian_woody_task.targetname
    u'mozilla-firefox (Debian Woody)'
    >>> debian_woody_milestones = vocabulary_registry.get(
    ...     debian_woody_task, 'Milestone')
    >>> debian_woody = debian_woody_task.distroseries
    >>> len(debian_woody_milestones)
    2

If one of the milestones is disabled, it won't be included in the vocabulary
anymore.

    >>> milestone = debian_woody.milestones[0]
    >>> milestone.visible = False
    >>> flush_database_updates()
    >>> len(vocabulary_registry.get(debian_woody_task, 'Milestone'))
    1

If the milestone was used in a bugtask before it was marked invisible, though,
it'll still show up on the vocabulary so that users can change it.

    >>> debian_woody_task.milestone = milestone
    >>> flush_database_updates()
    >>> len(vocabulary_registry.get(debian_woody_task, 'Milestone'))
    2

If the context is a specification, only milestones from that specification
target are in the vocabulary.

    >>> from canonical.launchpad.interfaces import ISpecificationSet
    >>> canvas_spec = firefox.getSpecification('canvas')
    >>> spec_target_milestones = vocabulary_registry.get(
    ...     canvas_spec, 'Milestone')
    >>> for term in spec_target_milestones:
    ...     print "%s: %s" % (term.value.target.name, term.value.name)
    firefox: 1.0


The vocabulary contains only visible milestones.

    >>> one_dot_o = firefox.milestones[0]
    >>> one_dot_o.name
    u'1.0'
    >>> one_dot_o.visible = False

    >>> for term in all_milestones:
    ...     print "%s: %s" % (term.value.target.name, term.value.name)
    debian: 3.1
    >>> len(firefox_milestones)
    0
    >>> len(firefox_task_milestones)
    0

There's one exception, though; if a bugtask is assigned to a
non-visible milestone, that milestone will be in the vocabulary.

    >>> firefox_task.milestone = one_dot_o
    >>> for term in firefox_task_milestones:
    ...     print "%s: %s" % (term.value.target.name, term.value.name)
    firefox: 1.0


BugNominatableSeriesVocabulary
-------------------------------
All the serieses that can be nominated for fixing.

This vocabulary needs either a product or distribution in the launchbag
to get the available series. It also needs a bug, since it list only
series that haven't already been nominated.

Let's start with putting a product in the launchbag.

    >>> getUtility(IOpenLaunchBag).clear()
    >>> getUtility(IOpenLaunchBag).add(firefox)

Firefox has the following series:

    >>> for series in firefox.serieses:
    ...     print series.name
    1.0
    trunk

Now, if we look at bug one, we can see that it hasn't been targeted
for any Firefox series yet:

    >>> bug_one = getUtility(IBugSet).get(1)
    >>> for bugtask in bug_one.bugtasks:
    ...     print bugtask.targetname
    firefox (upstream)
    mozilla-firefox (Ubuntu)
    mozilla-firefox (Debian)

It has however been nominated for 1.0:

    >>> for nomination in bug_one.getNominations(firefox):
    ...     print nomination.target.name
    1.0

This means that if we iterate through the vocabulary with bug one, only
the trunk will be nominatable:

    >>> firefox_bug_one = bug_one.bugtasks[0]
    >>> firefox_bug_one.target.name
    u'firefox'
    >>> series_vocabulary = vocabulary_registry.get(
    ...     firefox_bug_one, 'BugNominatableSerieses')
    >>> for term in series_vocabulary:
    ...     print "%s: %s" % (term.token, term.title)
    trunk: Trunk

No series is targeted or nominated on bug 4:

    >>> bug_four = getUtility(IBugSet).get(4)
    >>> for bugtask in bug_four.bugtasks:
    ...     print bugtask.targetname
    firefox (upstream)

    >>> for nomination in bug_four.getNominations(firefox):
    ...     print nomination.target.name

So if we give bug four to the vocabulary, all serieses will be returned:

    >>> firefox_bug_four = bug_four.bugtasks[0]
    >>> firefox_bug_four.target.name
    u'firefox'
    >>> series_vocabulary = vocabulary_registry.get(
    ...     firefox_bug_four, 'BugNominatableSerieses')
    >>> for term in series_vocabulary:
    ...     print "%s: %s" % (term.token, term.title)
    1.0: 1.0
    trunk: Trunk

The same works for distributions:

    >>> getUtility(IOpenLaunchBag).clear()
    >>> getUtility(IOpenLaunchBag).add(ubuntu)

Bug one is nominated for Ubuntu Hoary:

    >>> bug_one = getUtility(IBugSet).get(1)
    >>> for bugtask in bug_one.bugtasks:
    ...     print bugtask.targetname
    firefox (upstream)
    mozilla-firefox (Ubuntu)
    mozilla-firefox (Debian)

    >>> for nomination in bug_one.getNominations(ubuntu):
    ...     print nomination.target.name
    hoary

So Hoary isn't included in the vocabulary:

    >>> ubuntu_bug_one = bug_one.bugtasks[1]
    >>> ubuntu_bug_one.distribution.name
    u'ubuntu'
    >>> serieses_vocabulary = vocabulary_registry.get(
    ...     ubuntu_bug_one, 'BugNominatableSerieses')
    >>> for term in serieses_vocabulary:
    ...     print "%s: %s" % (term.token, term.title)
    breezy-autotest: Breezy-autotest
    grumpy: Grumpy
    warty: Warty

The same is true for bug two, where the bug is targeted to Hoary.

    >>> bug_two = getUtility(IBugSet).get(2)
    >>> for bugtask in bug_two.bugtasks:
    ...     print bugtask.targetname
    ubuntu (upstream)
    Ubuntu
    Ubuntu Hoary
    mozilla-firefox (Debian)
    mozilla-firefox (Debian Woody)

    >>> for nomination in bug_two.getNominations(ubuntu):
    ...     print nomination.target.name
    hoary

    >>> ubuntu_bug_two = bug_two.bugtasks[1]
    >>> ubuntu_bug_two.distribution.name
    u'ubuntu'
    >>> serieses_vocabulary = vocabulary_registry.get(
    ...     ubuntu_bug_two, 'BugNominatableSerieses')
    >>> for term in serieses_vocabulary:
    ...     print "%s: %s" % (term.token, term.title)
    breezy-autotest: Breezy-autotest
    grumpy: Grumpy
    warty: Warty

We can get a specific term by using the release name:

    >>> term = serieses_vocabulary.getTermByToken('warty')
    >>> term.value == ubuntu.getSeries('warty')
    True

Trying to get a non-existant release will result in a LookupError:

    >>> series_vocabulary.getTermByToken('non-such-release')
    Traceback (most recent call last):
    ...
    LookupError...

ProjectProductsVocabulary
-------------------------
All the products in a project.

    >>> mozilla_project = getUtility(IProjectSet).getByName('mozilla')
    >>> mozilla_products_vocabulary = vocabulary_registry.get(
    ...     mozilla_project,'ProjectProducts')

    >>> for term in mozilla_products_vocabulary:
    ...     print "%s: %s" %(term.token, term.title)
    firefox: Mozilla Firefox
    thunderbird: Mozilla Thunderbird

ProjectProductsVocabularyUsingMalone
-----------------------------------
All the products in a project using Malone.


    >>> mozilla_project = getUtility(IProjectSet).getByName('mozilla')
    >>> for product in mozilla_project.products:
    ...     print "%s: %s" % (product.name, product.official_malone)
    firefox: True
    thunderbird: False

    >>> mozilla_products_vocabulary = vocabulary_registry.get(
    ...     mozilla_project,'ProjectProductsUsingMalone')
    >>> for term in mozilla_products_vocabulary:
    ...     print "%s: %s" %(term.token, term.title)
    firefox: Mozilla Firefox

Non-Enumerable Vocabularies
===========================

Iterating over non-enumerable vocabularies, while possible, will
probably kill the database. Instead, these vocabularies are
search-driven.

BinaryAndSourcePackageNameVocabulary
------------------------------------
The list of binary and source package names, ordered by name.

    >>> package_name_vocabulary = vocabulary_registry.get(
    ...     None, "BinaryAndSourcePackageName")
    >>> package_name_vocabulary.displayname
    'Select a Package'

When a package name matches both a binary package name and a source
package of the exact same name, the binary package name is
returned. This allows us, in bug reporting for example, to collect the
most specific information possible.

Let's demonstrate by searching for "mozilla-firefox", for which there is
both a source and binary package of that name.

    >>> from canonical.launchpad.interfaces import (
    ...     ISourcePackageName, IBinaryPackageName)

    >>> package_name_terms = package_name_vocabulary.searchForTerms("mozilla-firefox")
    >>> package_name_terms.count()
    1
    >>> [(term.token, term.title) for term in package_name_terms]
    [('mozilla-firefox', u'iceweasel huh ?')]

Searching for "mozilla" should return the binary package name above, and
the source package named "mozilla".

    >>> package_name_terms = package_name_vocabulary.searchForTerms("mozilla")
    >>> package_name_terms.count()
    2
    >>> [(term.token, term.title) for term in package_name_terms]
    [('mozilla', 'Not uploaded'), ('mozilla-firefox', u'iceweasel huh ?')]

The search does a case-insensitive, substring match.

    >>> package_name_terms = package_name_vocabulary.searchForTerms("lInuX")
    >>> package_name_terms.count()
    2
    >>> [(term.token, term.title) for term in package_name_terms]
    [('linux-2.6.12', u'this kernel is like the crystal method: a temple o...'),
     ('linux-source-2.6.15', u'Source of: linux-2.6.12')]

BinaryPackageNameVocabulary
---------------------------
All the binary packages in Launchpad.

    >>> bpn_vocabulary = vocabulary_registry.get(None, 'BinaryPackageName')
    >>> len(bpn_vocabulary)
    6

    >>> bpn_terms = bpn_vocabulary.searchForTerms("mozilla")
    >>> len(bpn_terms)
    1
    >>> [(term.token, term.title) for term in bpn_terms]
    [('mozilla-firefox', u'iceweasel huh ?')]

SourcePackageNameVocabulary
---------------------------
All the source packages in Launchpad.

    >>> spn_vocabulary = vocabulary_registry.get(None, 'SourcePackageName')
    >>> len(spn_vocabulary)
    16

    >>> spn_terms = spn_vocabulary.searchForTerms("mozilla")
    >>> len(spn_terms)
    2
    >>> [(term.token, term.title) for term in spn_terms]
    [('mozilla', 'Not yet built'), ('mozilla-firefox', u'Source of: mozilla-firefox')]

    >>> spn_terms = spn_vocabulary.searchForTerms("pmount")
    >>> len(spn_terms)
    1
    >>> [(term.token, term.title) for term in spn_terms]
    [('pmount', u'Source of: pmount')]

LanguageVocabulary
------------------
All the languages know by Launchpad

    >>> from canonical.launchpad.interfaces import ILanguageSet
    >>> language_set = getUtility(ILanguageSet)

    >>> language_vocabulary = vocabulary_registry.get(
    ...     None, 'Language')
    >>> len(language_vocabulary)
    559

    >>> es = language_set['es']
    >>> term = language_vocabulary.getTerm(es)
    >>> print term.token, term.value.displayname, term.title
    es Spanish (es) Spanish (es)

    >>> pt_BR = language_set['pt_BR']
    >>> term = language_vocabulary.getTerm(pt_BR)
    >>> print term.token, term.value.displayname, term.title
    pt_BR Portuguese (Brazil) (pt_BR) Portuguese (Brazil) (pt_BR)

    >>> term = language_vocabulary.getTermByToken('es')
    >>> print term.token, term.value.displayname, term.title
    es Spanish (es) Spanish (es)

    >>> term = language_vocabulary.getTermByToken('pt_BR')
    >>> print term.token, term.value.displayname, term.title
    pt_BR Portuguese (Brazil) (pt_BR) Portuguese (Brazil) (pt_BR)

    >>> language_vocabulary.getTermByToken('foo')
    Traceback (most recent call last):
    ...
    LookupError:...

BranchVocabulary
----------------
The list of bzr branches registered in Launchpad.

Searchable by branch name or URL, and searched within the context of a
product.

    >>> from canonical.launchpad.interfaces import IBranchSet

    >>> firefox = getUtility(IProductSet)["firefox"]
    >>> gnome_terminal = getUtility(IProductSet)["gnome-terminal"]

    >>> branch_vocabulary = vocabulary_registry.get(firefox, "Branch")

    >>> branches = branch_vocabulary.search(
    ...     "http://bazaar.example.com/mozilla@arch.ubuntu.com/"
    ...     "mozilla--release--0.9.2")

    >>> [branch.unique_name for branch in branches]
    [u'~sabdfl/firefox/release-0.9.2']

    >>> branches = branch_vocabulary.search(
    ...     "release-0.9.2")

    >>> [branch.unique_name for branch in branches]
    [u'~sabdfl/firefox/release-0.9.2']

The search will not match branches in another product:

    >>> branches = branch_vocabulary.search("slowness")
    >>> [branch for branch in branches]
    []

Now, when we search in gnome-terminal, we'll find the "slowness"
branch:

    >>> branch_vocabulary = vocabulary_registry.get(
    ...     gnome_terminal, "Branch")
    >>> branches = branch_vocabulary.search("slowness")
    >>> [branch.name for branch in branches]
    [u'slowness']

If the context is None or not a product, then the LaunchBag is checked
for a product.

    >>> launchbag.add(firefox)
    >>> branch_vocabulary = vocabulary_registry.get(None, "Branch")
    >>> branches = branch_vocabulary.search("slowness")
    >>> [branch for branch in branches]
    []

If the context is not a product and the launchbag has no product, the
search covers all branches:

    >>> launchbag.clear()
    >>> branches = branch_vocabulary.search("slowness")
    >>> [branch.name for branch in branches]
    [u'slowness']

    >>> from canonical.launchpad.interfaces import IBugTaskSet
    >>> bugtask = getUtility(IBugTaskSet).get(2)
    >>> branch_vocabulary = vocabulary_registry.get(bugtask, "Branch")
    >>> branches = branch_vocabulary.search("slowness")
    >>> [branch.name for branch in branches]
    [u'slowness']

The tokens used by terms retrieved from BranchVocabulary use the
branch unique name as an ID:

    >>> branch = getUtility(IBranchSet).get(15)
    >>> print branch.unique_name
    ~name12/gnome-terminal/main
    >>> term = branch_vocabulary.toTerm(branch)
    >>> print term.token
    ~name12/gnome-terminal/main

The BranchVocabulary recognises both unique names and URLs as tokens:

    >>> term = branch_vocabulary.getTermByToken('~name12/gnome-terminal/main')
    >>> term.value == branch
    True
    >>> term = branch_vocabulary.getTermByToken(
    ...     'http://bazaar.launchpad.net/~name12/gnome-terminal/main/')
    >>> term.value == branch
    True
    >>> term = branch_vocabulary.getTermByToken(
    ...     'http://example.com/gnome-terminal/main')
    >>> term.value == branch
    True

The searches that the BranchVocabulary does are private branch aware.
The results are effectively filtered on what the logged in user is
able to see.

    >>> branches = branch_vocabulary.search("trunk")
    >>> for name in sorted([branch.unique_name for branch in branches]):
    ...     print name
    ~landscape-developers/landscape/trunk
    ~limi/+junk/trunk
    ~spiv/+junk/trunk

    >>> login('no-priv@canonical.com')
    >>> branches = branch_vocabulary.search("trunk")
    >>> for name in sorted([branch.unique_name for branch in branches]):
    ...     print name
    ~limi/+junk/trunk
    ~spiv/+junk/trunk

    >>> login('foo.bar@canonical.com')


ProjectVocabulary
-----------------
The list of selectable projects. The results are ordered by displayname.

    >>> project_vocabulary = vocabulary_registry.get(None, "Project")
    >>> project_vocabulary.displayname
    'Select a project group'

    >>> [p.title for p in project_vocabulary.search('mozilla')]
    [u'The Mozilla Project']
    >>> mozilla = project_vocabulary.getTermByToken('mozilla')
    >>> mozilla.title
    u'The Mozilla Project'

  The ProjectVocabulary does not list inactive projects.

    >>> from canonical.launchpad.interfaces import IProjectSet
    >>> moz_project = getUtility(IProjectSet)['mozilla']
    >>> moz_project in project_vocabulary
    True

    >>> [p.title for p in project_vocabulary.search('mozilla')]
    [u'The Mozilla Project']
    >>> moz_project.active = False
    >>> flush_database_updates()
    >>> moz_project in project_vocabulary
    False

    >>> [p.title for p in project_vocabulary.search('mozilla')]
    []
    >>> moz_project.active = True
    >>> flush_database_updates()

ProductVocabulary
-----------------
The list of selectable products. Results are ordered by displayname.

    >>> product_vocabulary = vocabulary_registry.get(None, "Product")
    >>> product_vocabulary.displayname
    'Select a project'

    >>> list(product_vocabulary.search(None))
    []
    >>> gnome_products = product_vocabulary.search("gnome")
    >>> l = [product_term.title for product_term in gnome_products]
    >>> l[:2]
    [u'The Evolution Groupware Application', u'The GNOME Terminal Emulator']
    >>> l[2:]
    [u'The Gnome Panel Applets', u'Ubuntu', u'Gnome Baker']
    >>> arch = product_vocabulary.getTermByToken("arch-mirrors")
    >>> arch.title
    u'Arch archive mirrors'

The ProductVocabulary does not list inactive products.

    >>> arch.value in product_vocabulary
    True

    >>> arch_product = getUtility(IProductSet)['arch-mirrors']
    >>> arch_product in product_vocabulary
    True

    >>> [t.title for t in product_vocabulary.search('arch and archive')]
    [u'Arch archive mirrors']
    >>> arch_product.active = False
    >>> flush_database_updates()
    >>> arch_product in product_vocabulary
    False
    >>> [t.title for t in product_vocabulary.search('arch and archive')]
    []
    >>> arch_product.active = True
    >>> flush_database_updates()

ProductReleaseVocabulary
------------------------
The list of selectable products releases.

    >>> productrelease_vocabulary = vocabulary_registry.get(None,
    ...                                                     "ProductRelease")
    >>> productrelease_vocabulary.displayname
    'Select a Product Release'

    >>> list(productrelease_vocabulary.search(None))
    []
    >>> evolution_releases = productrelease_vocabulary.search("evolution")
    >>> l = [release_term.title for release_term in evolution_releases]
    >>> release = productrelease_vocabulary.getTermByToken(
    ...     "evolution/trunk/2.1.6")
    >>> release.title
    u'evolution trunk 2.1.6'

PersonAccountToMergeVocabulary
------------------------------
All non-merged people. This vocabulary is meant to be used only in the
people merge form.

    >>> vocab = vocabulary_registry.get(None, "PersonAccountToMerge")
    >>> vocab.displayname
    'Select a Person to Merge'

Searching for None returns an empty list.

    >>> list(vocab.search(None))
    []

Searching for 'Launchpad Administrators' will return an empty list, because
teams are not part of this vocabulary.

    >>> [item.name for item in list(vocab.search('Launchpad Administrators'))]
    []

A search using part of the email address of a team will also return an
empty list.

    >>> list(vocab.search('rosetta'))
    []

Searching for a person without a preferred email will return that
person's name.

    >>> [person.name for person in vocab.search('salgado')]
    [u'salgado']

A search using the beginning of a person's preferred email will return
that person that owns that email.

    >>> [(person.name, person.preferredemail.email)
    ...  for person in vocab.search('foo.bar')]
    [(u'name16', u'foo.bar@canonical.com')]

A search using part of the host of an email address will not return
anything, as we only match against the beginning of an email address.

    >>> list(vocab.search('canonical'))
    []

A person with a single and unvalidated email address can be merged.

    >>> from canonical.lp.dbschema import PersonCreationRationale
    >>> fooperson, email = getUtility(IPersonSet).createPersonAndEmail(
    ...     'foobaz@bar.com', PersonCreationRationale.UNKNOWN,
    ...     name='foobaz', displayname='foo baz')
    >>> fooperson in vocab
    True

But any person without a single email address can't.

    >>> email.destroySelf()
    >>> fooperson in vocab
    False

Any person that's already merged is not part of this vocabulary:
# XXX: Here we cheat because IPerson.merged is a readonly attribute.

    >>> from zope.security.proxy import removeSecurityProxy
    >>> removeSecurityProxy(fooperson).merged = 1
    >>> flush_database_updates()
    >>> fooperson in vocab
    False

NonMergedPeopleAndTeams
-----------------------
All non-merged people and teams.

    >>> vocab = vocabulary_registry.get(None, "NonMergedPeopleAndTeams")
    >>> vocab.displayname
    'Select a Person or Team'

    >>> list(vocab.search(None))
    []

This vocabulary includes both validated and unvalidated profiles, as well
as teams:

    >>> [(p.name, p.is_valid_person) for p in vocab.search('limi@plone.org')]
    [(u'limi', False)]

    >>> [(p.name, p.is_valid_person) for p in vocab.search('mark@hbd.com')]
    [(u'sabdfl', True)]

    >>> [(p.name, p.teamowner.name) for p in vocab.search('ubuntu-team')]
    [(u'name18', u'sabdfl'), (u'ubuntu-team', u'sabdfl')]

But it doesn't include merged accounts:

    >>> fooperson in vocab
    False

ValidPersonOrTeam
-----------------
All 'valid' persons or teams. This is currently defined as people with a
password, a preferred email address and not merged (Person.merged is
None) or any team.

    >>> vocab = vocabulary_registry.get(None, "ValidPersonOrTeam")
    >>> vocab.displayname
    'Select a Person or Team'

    >>> list(vocab.search(None))
    []

We can do token lookups using either a person's name or a person's email
address.

    >>> vocab.getTermByToken('name16').value.displayname
    u'Foo Bar'
    >>> vocab.getTermByToken('foo.bar@canonical.com').value.displayname
    u'Foo Bar'

Almost all teams have the word 'team' as part of their names, so a search
for 'team' should give us some of them.

    >>> sorted(person.name for person in vocab.search('team'))
    [u'name18', u'name19', u'name20', u'name21', u'no-team-memberships', u'simple-team', u'testing-spanish-team', u'ubuntu-team']

A search for 'support' will give us only the persons which have support
as part of their name or displayname, or the beginning of
one of its email addresses.

    >>> sorted(person.name for person in vocab.search('support'))
    [u'ubuntu-team']

Dave hasn't validated his email address; he's not a valid Person.

    >>> sorted(person.name for person in vocab.search('dave.miller'))
    []

'foo.bar@canonical.com' is a valid Person.

    >>> [person.name for person in vocab.search('foo.bar')]
    [u'name16']

The vocabulary also allows us to search by IRC nickname.

    >>> [cjwatson] = vocab.search('cjwatson')
    >>> cjwatson.name, cjwatson.preferredemail.email
    (u'kamion', u'colin.watson@ubuntulinux.com')
    >>> [ircid.nickname for ircid in cjwatson.ircnicknames]
    [u'cjwatson']

ValidOwner
----------
All valid persons and teams are also valid owners.

    >>> vocab = vocabulary_registry.get(None, "ValidOwner")
    >>> vocab.displayname
    'Select a Person or Team'

    >>> list(vocab.search(None))
    []

Almost all teams have the word 'team' as part of their names, so a
search for 'team' should give us some of them:

    >>> sorted(person.name for person in vocab.search('team'))
    [u'name18', u'name19', u'name20', u'name21', u'no-team-memberships', u'simple-team', u'testing-spanish-team', u'ubuntu-team']

ValidTeamMember
---------------
With the exception of all teams that have this team as a member and the
team itself, all valid persons and teams are valid members.

    >>> team = getUtility(IPersonSet).getByName('ubuntu-team')
    >>> team2 = getUtility(IPersonSet).getByName('guadamen')
    >>> person = getUtility(IPersonSet).getByName('name16')

ValidTeamMember needs a context:

    >>> vocab = vocabulary_registry.get(None, "ValidTeamMember")
    Traceback (most recent call last):
    ...
    AssertionError: ...

ValidTeamMember's context must implement ITeam:

    >>> vocab = vocabulary_registry.get(person, "ValidTeamMember")
    Traceback (most recent call last):
    ...
    AssertionError: ...

'name16' is a valid member for 'ubuntu-team':

    >>> vocab = vocabulary_registry.get(team, "ValidTeamMember")
    >>> vocab.displayname
    'Select a Person or Team'

    >>> person in vocab
    True
    >>> [person.name for person in vocab.search('foo.bar')]
    [u'name16']

'ubuntu-team' is not a valid member for itself:

    >>> team in vocab
    False
    >>> [person.name for person in vocab.search('ubuntu-team')]
    [u'name18']

'ubuntu-team' is a member of 'guadamen', so 'guadamen' can't be a member
of 'ubuntu-team'.

    >>> team2 in vocab
    False
    >>> [person.name for person in vocab.search('guadamen')]
    []

ValidTeamOwner
--------------
With the exception of the team itself and all teams owned by that team,
all valid persons and teams are valid owners for the team in context.

ValidTeamOwner needs a context.

    >>> vocab = vocabulary_registry.get(None, "ValidTeamOwner")
    Traceback (most recent call last):
    ...
    AssertionError: ...

ValidTeamOwner's context must be a team.

    >>> person = getUtility(IPersonSet).getByName('name16')
    >>> vocab = vocabulary_registry.get(person, "ValidTeamOwner")
    Traceback (most recent call last):
    ...
    AssertionError: ...

'ubuntu-team' is not a valid owner for itself.

    >>> vocab = vocabulary_registry.get(team, "ValidTeamOwner")
    >>> vocab.displayname
    'Select a Person or Team'

    >>> team in vocab
    False
    >>> [person.name for person in vocab.search('ubuntu-team')]
    [u'name18']

'name16' is a valid owner for 'ubuntu-team'.

    >>> person in vocab
    True
    >>> [person.name for person in vocab.search('foo.bar')]
    [u'name16']

Processor
---------
All processors type available in Launchpad.

    >>> vocab = vocabulary_registry.get(None, "Processor")
    >>> vocab.displayname
    'Select a Processor'

    >>> [term.token for term in vocab.searchForTerms('386')]
    ['386']

BugWatchVocabulary
------------------
All bug watches associated with a bugtask's bug

    >>> bug_one = getUtility(IBugSet).get(1)
    >>> bugtask = bug_one.bugtasks[0]
    >>> vocab = vocabulary_registry.get(bugtask, "BugWatch")
    >>> for term in vocab:
    ...     print term.title
    The Mozilla.org Bug Tracker <a...>#123543</a>
    The Mozilla.org Bug Tracker <a...>#2000</a>
    The Mozilla.org Bug Tracker <a...>#42</a>
    Debian Bug tracker <a...>#304014</a>

DistributionOrProductVocabulary
-------------------------------
All products and distributions. Note that the value type is
heterogeneous.

    >>> vocab = vocabulary_registry.get(None, "DistributionOrProduct")
    >>> for term in vocab:
    ...     if 'Ubuntu' in term.title:
    ...         print term.title, '- class', term.value.__class__.__name__
    Ubuntu Linux (Distribution) - class Distribution
    Ubuntu (Product) - class Product
    Ubuntu Test (Distribution) - class Distribution

Inactive products and projects are not available

    >>> ubuntu_product = getUtility(IProductSet).getByName('ubuntu-product')
    >>> ubuntu_product in vocab
    True
    >>> ubuntu_product.active = False
    >>> flush_database_updates()
    >>> vocab = vocabulary_registry.get(None, "DistributionOrProduct")
    >>> for term in vocab:
    ...     if 'Ubuntu' in term.title:
    ...         print term.title, '- class', term.value.__class__.__name__
    Ubuntu Linux (Distribution) - class Distribution
    Ubuntu Test (Distribution) - class Distribution
    >>> ubuntu_product in vocab
    False

    >>> ubuntu_product.active = True
    >>> flush_database_updates()
    >>> vocab = vocabulary_registry.get(None, "DistributionOrProduct")
    >>> for term in vocab:
    ...     if 'Ubuntu' in term.title:
    ...         print term.title, '- class', term.value.__class__.__name__
    Ubuntu Linux (Distribution) - class Distribution
    Ubuntu (Product) - class Product
    Ubuntu Test (Distribution) - class Distribution
    >>> ubuntu_product in vocab
    True

Projects are not contained in this vocabulary:

    >>> ubuntu_project = getUtility(IProjectSet).getByName('ubuntu-project')
    >>> ubuntu_project in vocab
    False

DistributionOrProductOrProjectVocabulary
----------------------------------------
All products, projects and distributions. Note that the value type is
heterogeneous.

    >>> vocab = vocabulary_registry.get(None, "DistributionOrProductOrProject")
    >>> for term in vocab:
    ...     if 'Ubuntu' in term.title:
    ...         print term.title, '- class', term.value.__class__.__name__
    Ubuntu Linux (Distribution) - class Distribution
    Ubuntu (Product) - class Product
    The Ubuntu Project (Project) - class Project
    Ubuntu Test (Distribution) - class Distribution

Inactive products and projects are not available

    >>> from canonical.launchpad.ftests import syncUpdate
    >>> ubuntu_product = getUtility(IProductSet).getByName('ubuntu-product')
    >>> ubuntu_product in vocab
    True
    >>> ubuntu_product.active = False
    >>> syncUpdate(ubuntu_product)
    >>> ubuntu_product in vocab
    False

    >>> ubuntu_project = getUtility(IProjectSet).getByName('ubuntu-project')
    >>> ubuntu_project in vocab
    True
    >>> ubuntu_project.active = False
    >>> syncUpdate(ubuntu_project)
    >>> ubuntu_project in vocab
    False

    >>> vocab = vocabulary_registry.get(None, "DistributionOrProductOrProject")
    >>> for term in vocab:
    ...     if 'Ubuntu' in term.title:
    ...         print term.title, '- class', term.value.__class__.__name__
    Ubuntu Linux (Distribution) - class Distribution
    Ubuntu Test (Distribution) - class Distribution
    >>> getUtility(IProductSet).getByName('ubuntu-product').active = True
    >>> getUtility(IProjectSet).getByName('ubuntu-project').active = True
    >>> flush_database_updates()
    >>> vocab = vocabulary_registry.get(None, "DistributionOrProductOrProject")
    >>> for term in vocab:
    ...     if 'Ubuntu' in term.title:
    ...         print term.title, '- class', term.value.__class__.__name__
    Ubuntu Linux (Distribution) - class Distribution
    Ubuntu (Product) - class Product
    The Ubuntu Project (Project) - class Project
    Ubuntu Test (Distribution) - class Distribution

SpecificationDepCandidatesVocabulary
------------------------------------

    All blueprints that can be added as a dependency of the
    context blueprint.

    Dependency candidate come only from the same product of the
    blueprint they depend on.

    >>> from canonical.launchpad.interfaces import IProduct
    >>> firefox = getUtility(IProductSet).getByName('firefox')
    >>> canvas_spec = firefox.getSpecification('canvas')
    >>> vocab = vocabulary_registry.get(canvas_spec,
    ...                                 "SpecificationDepCandidates")
    >>> [term.value.product for term in vocab
    ...  if term.value.product != firefox]
    []

    No circular dependencies - blueprint A is not a dependency candidate
    of blueprint B if blueprint B depends on blueprint A.

    >>> from canonical.launchpad.interfaces import IProduct
    >>> firefox = getUtility(IProductSet).getByName('firefox')
    >>> e4x_spec = firefox.getSpecification('e4x')
    >>> canvas_spec = firefox.getSpecification('canvas')
    >>> canvas_spec in e4x_spec.all_blocked
    True
    >>> vocab = vocabulary_registry.get(e4x_spec,
    ...                                 "SpecificationDepCandidates")
    >>> canvas_spec in [term.value for term in vocab]
    False

XXX: document more vocabularies here, particularly when they break!
