= Bazaar Branches =

The Branch table holds information about a Bazaar branch.  It contains
the metadata associated with the branch -- the owner, the whiteboard
and so on.  Where the actual branch data lives depends on the branch.

It has a N-N association to the Revision table through the
BranchRevision table. An associated table is required because the
sequence of revisions listed by "bzr log" is defined by a
"revision-history" file which has some freedom with respect to the
ancestry of revisions, at least in Branch5 and older branches.

  * Distinct revision histories may point to same revision.

  * Revision histories including the same revision may have different
    starting points, they need not trace history back to the initial
    import. Therefore a given revision may have a different order
    number in different branches.

  * A revision history is required to follow the ancestry DAG, but two
    different branches may have histories tracing a different path between two
    shared revisions. This is exercised by the "convergence" feature of "bzr
    pull".


== Interfaces ==

    >>> from canonical.launchpad.webapp.testing import verifyObject
    >>> from canonical.launchpad.interfaces import (
    ...     BranchType, IBranch, IBranchSet, IBranchSubscription)
    >>> from canonical.launchpad.database import (
    ...     Branch, BranchSet, BranchSubscription,)
    >>> verifyObject(IBranchSet, BranchSet())
    True
    >>> verifyObject(IBranch, Branch.get(1))
    True
    >>> verifyObject(IBranchSubscription, BranchSubscription.get(1))
    True


== Branch types ==

There are four different types of branches:

 * Hosted
 * Mirrored
 * Imported
 * Remote

Hosted branches use the Launchpad codehosting as a primary location for
the branch.  The branch (as far as Launchpad is concerned) can be pushed
to and pulled from.

Mirrored branches have a main location outside of Launchpad, and Launchpad
pulls the branch into the codehosting area.  Mirrored branches can be
pulled from but not pushed to.  Launchpad keeps the branch up to date
using the `branch_puller` script.

Imported branches are those where a bazaar branch is built from a CVS or
Subversion repository.  Imported branches have to be requested and go
through a testing and verification process.

Remote branches are registered in Launchpad, but the branch is not stored in
the Launchpad codehosting service, and as such are not accessible using the
anonymous http access, nor through the Launchpad SFTP or smart server.  The
remote branches can still be linked to bugs and blueprints.


== Fetching branches by ID ==

The collection of all branches is represented by IBranchSet, which is
registered as an utility.

    >>> from zope.component import getUtility
    >>> from canonical.launchpad.interfaces import IBranchSet
    >>> from canonical.launchpad.ftests import syncUpdate
    >>> branchset = getUtility(IBranchSet)

The 'get' method on the branch set fetches branches by ID.

    >>> branch = factory.makeAnyBranch(name='foobar')
    >>> print branchset.get(branch.id).name
    foobar

It returns None if there is no branch with the specified ID.

    >>> print branchset.get(-1)
    None

BranchSet's __getitem__ also fetches branches by ID.

    >>> branchset[branch.id].name
    u'foobar'

It differs from .get() by the fact that it raises NotFoundError if
there is no branch with the specified ID.

    >>> branchset[-1]
    Traceback (most recent call last):
      ...
    NotFoundError: ...


== Creating branches ==

Branches can be created with IBranchSet.new, which takes details like
the type of the branch -- whether it is mirrored, hosted, imported or
remote, name, owner, and so on.

    >>> from canonical.launchpad.interfaces.person import IPersonSet
    >>> registrant = factory.makePerson(name='registrant')
    >>> new_branch = branchset.new(
    ...     branch_type=BranchType.MIRRORED, name='dev',
    ...     owner=registrant, registrant=registrant,
    ...     product=factory.makeProduct(),
    ...     url=factory.getUniqueURL())

    >>> new_branch.name
    u'dev'

The registrant of the branch is the user that originally registered
the branch, whereas the owner is the current owner of the branch.

    >>> print new_branch.registrant.name
    registrant
    >>> print new_branch.owner.name
    registrant

A user can create a branch where the owner is either themselves,
or a team that they are a member of.  The registrant is not writable,
whereas the owner is.

    >>> login('admin@canonical.com')
    >>> new_branch.registrant = factory.makePerson()
    Traceback (most recent call last):
      ...
    ForbiddenAttribute: ('registrant', <Branch ...>)

    >>> new_branch.owner = factory.makePerson(name='new-owner')
    >>> print new_branch.registrant.name
    registrant
    >>> print new_branch.owner.name
    new-owner

A Branch may or may not be associated to a product, may have no title,
no summary, and, depending on the branch type, no URL.

Most branches with no URL are hosted on the supermirror (it is also
possible for a remote branch to have no URL, but this is rare).

    >>> junkowner = factory.makePerson(name='junkowner')
    >>> junkcode = branchset.new(
    ...     branch_type=BranchType.HOSTED, name='junkcode', url=None,
    ...     owner=junkowner, registrant=junkowner, product=None)

    >>> junkcode.name
    u'junkcode'
    >>> print repr(junkcode.product)
    None
    >>> print repr(junkcode.title)
    None
    >>> print repr(junkcode.summary)
    None
    >>> print repr(junkcode.url)
    None

A branch that is not associated with a product may not be owned by a
team, however.

    >>> team = factory.makeTeam(owner=junkcode.owner)
    >>> teamjunkcode = branchset.new(
    ...     branch_type=BranchType.HOSTED, name='teamjunkcode', product=None,
    ...     owner=factory.makeTeam(owner=junkowner), registrant=junkowner,
    ...     url=None)
    Traceback (most recent call last):
      ...
    BranchCreationNoTeamOwnedJunkBranches: ...

The ~vcs-imports celebrity team is exempt from this restriction to
allow the creation of code import branches without an associated
product.

    >>> from canonical.launchpad.interfaces import ILaunchpadCelebrities
    >>> vcs_imports = getUtility(ILaunchpadCelebrities).vcs_imports
    >>> vcs_imports_junkcode = branchset.new(
    ...     branch_type=BranchType.HOSTED, name='junkcode', owner=vcs_imports,
    ...     registrant=vcs_imports.teamowner, url=None, product=None)
    >>> print repr(vcs_imports_junkcode.product)
    None
    >>> print vcs_imports_junkcode.owner.name
    vcs-imports

Branch names must start with a number or a letter (upper or lower
case) and -, +, _ and @ are allowed after that.

    >>> owner = factory.makePerson()
    >>> branchset.new(
    ...     branch_type=BranchType.HOSTED, name='invalid name!',
    ...     owner=owner, registrant=owner, product=factory.makeProduct(),
    ...     url=None)
    Traceback (most recent call last):
      ...
    LaunchpadValidationError: Invalid branch name 'invalid name!'.  Branch ...


== Determining the number of branches ==

The IBranchSet can tell us how many public branches there are
registered.  As this, and several other methods documented below,
queries the global state of the system, we just test the difference
creating a branch makes to avoid gratuitous fragility in the test.

    >>> before_count = branchset.count()
    >>> new_branch = factory.makeAnyBranch()
    >>> branchset.count() - before_count
    1
    >>> new_branch = factory.makeAnyBranch(private=True)
    >>> branchset.count() - before_count
    1


== Determing the number of branches with bugs ==

The count of branches that have bugs associated with them is another
useful piece of summary information that is supplied on one of the initial
pages to show that there can be a relationship created between
branches and bugs.

    >>> branchset.countBranchesWithAssociatedBugs()
    2


== Determining the recently changed, registered and imported branches ==

The IBranchSet methods getRecentlyChangedBranches, getRecentlyImportedBranches,
and getRecentlyRegisteredBranches are used to give summary information that
is to be displayed on the code.launchpad.net page to entice the
user to click through.

Changed branches are branches that are owned by real people or groups (as
opposed to vcs-imports), and have recently had new revisions detected by
the branch scanner, either through the branch being pushed to the supermirror
or the branch puller script mirroring a remote branch.

Imported branches are those branches owned by vcs-imports, and are "imported"
from other VCS hosted code bases.  Again recently imported branches are
identified by new revisions detected by the branch scanner.

Branches that have been recently registered have either been created by a user
using the web UI, or by pushing a new branch directly to the supermirror.

In order to determine changes in the branches the last_scanned
timestamp is used.  This is set by the branch scanner when it has
finished scanning the branches and recording the branch data in the
launchpad database.  We don't want any of the branches in the sample
data to mess up our tests, so we clear the last_scanned data in all
existing branches.

    >>> from canonical.launchpad.webapp.interfaces import (
    ...     IStoreSelector, MAIN_STORE, DEFAULT_FLAVOR)
    >>> store = getUtility(IStoreSelector).get(MAIN_STORE, DEFAULT_FLAVOR)
    >>> store.find(Branch).set(last_scanned=None)

    >>> list(branchset.getRecentlyChangedBranches(5))
    []

Now we create a few branches that we pretend were updated in a
definite order.

    >>> from datetime import datetime
    >>> from canonical.launchpad.testing import time_counter
    >>> import pytz
    >>> today = datetime.now(pytz.timezone('UTC'))
    >>> product = factory.makeProduct(name='product')
    >>> user = factory.makePerson(name='user')
    >>> time_generator = time_counter()

    >>> def make_new_scanned_branch(name, owner=user, branch_type=None):
    ...     """Create """
    ...     new_branch = factory.makeProductBranch(
    ...         branch_type=branch_type, owner=owner, product=product,
    ...         name=name, date_created=time_generator.next())
    ...     new_branch.last_scanned = new_branch.date_created

    >>> make_new_scanned_branch('oldest')
    >>> make_new_scanned_branch('middling')
    >>> make_new_scanned_branch('young')
    >>> make_new_scanned_branch(
    ...     'imported', owner=vcs_imports, branch_type=BranchType.IMPORTED)

    >>> for branch in branchset.getRecentlyChangedBranches(5):
    ...   print branch.unique_name
    ~user/product/young
    ~user/product/middling
    ~user/product/oldest

    >>> for branch in branchset.getRecentlyImportedBranches(5):
    ...   print branch.unique_name
    ~vcs-imports/product/imported

    >>> for branch in branchset.getRecentlyRegisteredBranches(3):
    ...   print branch.unique_name
    ~vcs-imports/product/imported
    ~user/product/young
    ~user/product/middling


== Finding a branch by URL ==

It is possible to find a branch by URL. Either using the pull URL:

    >>> new_url = factory.getUniqueURL()
    >>> new_mirrored_branch = factory.makeAnyBranch(
    ...     branch_type=BranchType.MIRRORED, url=new_url)
    >>> branchset.getByUrl(new_url) == new_mirrored_branch
    True

Or using the Supermirror URL of the same branch:

    >>> new_branch_supermirror = (
    ...     u'http://bazaar.launchpad.dev/' +
    ...     new_mirrored_branch.unique_name)
    >>> branchset.getByUrl(new_branch_supermirror) == new_mirrored_branch
    True
    >>> new_junk_branch = factory.makePersonalBranch()
    >>> junkcode_supermirror = (
    ...     u'http://bazaar.launchpad.dev/' +
    ...     new_junk_branch.unique_name)
    >>> branchset.getByUrl(junkcode_supermirror) == new_junk_branch
    True

The provided URL must not have any trailing slash:

    >>> try: branchset.getByUrl(new_url + '/')
    ... except AssertionError: print 'trailing slash not allowed'
    trailing slash not allowed

If no branch is found for the specified URL, the specified default value is
returned.

    >>> not_there_url = factory.getUniqueURL()
    >>> print branchset.getByUrl(not_there_url)
    None
    >>> print branchset.getByUrl(not_there_url, 123)
    123


== Branch names ==

Branches have a display name that is the Branch.title if it's provided, and the
unique_name otherwise.

    >>> titled_branch = factory.makeAnyBranch(
    ...     title=factory.getUniqueString())
    >>> titled_branch.displayname == titled_branch.title
    True
    >>> untitled_branch = factory.makeAnyBranch(title=None)
    >>> untitled_branch.displayname == untitled_branch.unique_name
    True


== Branch subscriptions ==

Branches can be subscribed to and unsubscribed from by a Person.  An
implicit subscription to the branch is created when the branch is created
so that the branch owner can be informed of merge proposals or code review
messages relating to their branches.

    >>> owner = factory.makePerson()
    >>> branch = factory.makeAnyBranch(owner=owner)
    >>> subscriptions = list(branch.subscriptions)
    >>> print len(subscriptions)
    1
    >>> subscriptions[0].person == owner
    True

Branch subscriptions have attributes associated with them.
The notification_level is used to control what email is sent to the
subscribed user, and max_diff_lines is used to control the size of
any generated diffs between revisions that are emailed out.  The review_level
controls the amount of notification caused by code review activities.

Both of these attributes are contolled through the UI through the use
of the enumerated types: BranchSubscriptionDiffSize, and
BranchSubscriptionNotificationLevel.

    >>> from canonical.launchpad.interfaces import (
    ...     BranchSubscriptionDiffSize, BranchSubscriptionNotificationLevel,
    ...     CodeReviewNotificationLevel, IBranchSubscription)
    >>> subscriber = factory.makePerson(name='subscriber')
    >>> branch = factory.makeProductBranch(
    ...     owner=user, product=product, name='subscribed')
    >>> subscription = branch.subscribe(
    ...     subscriber,
    ...     BranchSubscriptionNotificationLevel.FULL,
    ...     BranchSubscriptionDiffSize.FIVEKLINES,
    ...     CodeReviewNotificationLevel.FULL)
    >>> verifyObject(IBranchSubscription, subscription)
    True
    >>> subscription.branch == branch and subscription.person == subscriber
    True
    >>> subscription.notification_level == BranchSubscriptionNotificationLevel.FULL
    True
    >>> subscription.max_diff_lines == BranchSubscriptionDiffSize.FIVEKLINES
    True
    >>> subscription.review_level == CodeReviewNotificationLevel.FULL
    True
    >>> branch.subscriptions[1] == subscription
    True
    >>> set(branch.subscribers) == set([branch.owner, subscriber])
    True
    >>> from canonical.launchpad.webapp import canonical_url
    >>> print canonical_url(subscription)
    http://code.launchpad.dev/~user/product/subscribed/+subscription/subscriber

The settings for a subscription can be changed by re-subscribing.

    >>> subscription1 = branch.getSubscription(subscriber)
    >>> subscription1.review_level == CodeReviewNotificationLevel.FULL
    True
    >>> subscription2 = branch.subscribe(
    ...     subscriber,
    ...     BranchSubscriptionNotificationLevel.FULL,
    ...     BranchSubscriptionDiffSize.FIVEKLINES,
    ...     CodeReviewNotificationLevel.NOEMAIL)
    >>> subscription == subscription2
    True
    >>> subscription2.review_level == CodeReviewNotificationLevel.NOEMAIL
    True

    Unsubscribing is also supported.

    >>> branch.unsubscribe(subscriber)
    >>> branch.subscribers.count()
    1

We can get the subscribers for a branch based on their level of
subscription.

    >>> branch2 = factory.makeProductBranch(
    ...     owner=user, product=product, name='subscribed2')

    >>> def print_names(persons):
    ...     """Print the name of each person on a new line."""
    ...     for person in persons:
    ...         print person.person.name

    >>> subscription = branch2.subscribe(
    ...     subscriber,
    ...     BranchSubscriptionNotificationLevel.FULL,
    ...     BranchSubscriptionDiffSize.FIVEKLINES,
    ...     CodeReviewNotificationLevel.NOEMAIL)

    >>> print_names(branch2.getSubscriptionsByLevel([
    ...     BranchSubscriptionNotificationLevel.FULL]))
    subscriber

    >>> print_names(branch2.getSubscriptionsByLevel([
    ...     BranchSubscriptionNotificationLevel.DIFFSONLY]))

    >>> print_names(branch2.getSubscriptionsByLevel([
    ...     BranchSubscriptionNotificationLevel.DIFFSONLY,
    ...     BranchSubscriptionNotificationLevel.FULL]))
    subscriber


== Branches and revisions ==

See revision.txt for a doctest covering the creation of revisions and related
objects. Revision data is loaded in the database by a batch job using a
different user, Launchpad code is only concened with using this data.

Let's get a branch with some revisions in it.

    >>> personset = getUtility(IPersonSet)
    >>> sample_person = personset.getByName('name12')
    >>> junk = sample_person.getBranch('+junk', 'junk.dev')
    >>> print junk.unique_name
    ~name12/+junk/junk.dev


== Revision history of Branch ==

Branch.revision_history gives the sequence of revisions in this branch's
history, latest revisions first. All revision history items must implement the
IBranchRevision interface. The Branch.revision_count attribute gives the length
of the revision_history attribute but without building the list.

    >>> from canonical.launchpad.interfaces import IBranchRevision
    >>> junk.revision_count
    6
    >>> [verifyObject(IBranchRevision, a) for a in junk.revision_history]
    [True, True, True, True, True, True]
    >>> for branch_revision in junk.revision_history:
    ...     print branch_revision.sequence, branch_revision.revision.id
    6 9
    5 8
    4 7
    3 6
    2 5
    1 4

There are two methods for getting only the the latest items of the revision
history.

Branch.latest_revisions give a specific count of BranchRevisions at the end of
the history.

    >>> three_latest = list(junk.revision_history)[:3]
    >>> list(junk.latest_revisions(3)) == three_latest
    True

Branch.revisions_since gives all the BranchRevisions for revisions comitted
since a given timestamp. It may give suprising results if some committers had a
skewed clock.

    >>> from datetime import datetime
    >>> timestamp = datetime(2005, 10, 31, 12, 00, 00)
    >>> two_latest = list(junk.revision_history)[:2]
    >>> list(junk.revisions_since(timestamp)) == two_latest
    True


== Ancestry of Revision ==

The revision-history of a given branch, is only one possible ancestry path in
the ancestry graph. It is also possible to examine the ancestry graph directly.

A Bazaar branch may contains references (by revision_id) to revisions for which
no data is available. Such revisions are called "ghosts".

Initial commits (after a "bzr init") revisions have no parent.

    >>> history = list(junk.revision_history)
    >>> initial = history[-1].revision
    >>> initial.parent_ids
    []

Normal commits (as opposed to merges) have exactly one parent. The first parent
of a revision is always the revision that was current when committing.

    >>> commit = history[-2].revision
    >>> [type(a) for a in commit.parent_ids] == [unicode]
    True

Merges usually have two parents, but they may have more. Though the bzr user
interface discourage such complex merges.

    >>> merge = history[-4].revision
    >>> len(merge.parent_ids)
    2

Parent revisions are identified by their globally unique id, and not by a
foreign key, so existing parents and ghosts can be modelled in the same way.

To try and retrieve a Revision given its globally unique id, you can use the
RevisionSet utility.

    >>> from canonical.launchpad.interfaces import IRevisionSet
    >>> revisionset = getUtility(IRevisionSet)
    >>> [parent_id] = commit.parent_ids
    >>> parent = revisionset.getByRevisionId(parent_id)
    >>> parent == initial
    True

If the parent was a ghost at import time and is not currently available in the
database. getByRevisionId returns None.

    >>> revisionset.getByRevisionId('missing-revision-id') is None
    True


== Getting the tip revision for a Branch ==

The last revision that we have stored in the database for any given branch
is identified by the branch attribute "last_scanned_id".  This is the textual
revision_id for the bzr revision.  The reason that it is a text id rather than
an integer foreign key is so it can easily be compared to the
"last_mirrored_id".  The "last_mirrored_id" is set by the branch puller, and is
used to identify when a scan is needed for a branch.

    >>> branch = branchset.get(1)
    >>> branch.last_scanned_id
    >>> branch.getTipRevision() is None
    True

    >>> branch.last_scanned_id = 'null:'
    >>> branch.getTipRevision() is None
    True

    >>> branch.last_scanned_id = 'test@canonical.com-20051031165248-6f1bb97973c2b4f4'
    >>> rev = branch.getTipRevision()
    >>> print rev.date_created
    2005-10-31 17:21:47.381770+00:00
    >>> print rev.log_body
    initial import (empty)


== Codebrowse and branches ==

Most branches are able to be browsed using the loggerhead codebrowse
instance at http://bazaar.launchpad.net.  Branches that have no
revisions or private branches are not able to be viewed using code
browse.

The link to codebrowse is shown on the action context menu for branches.
The enabling of this link is controlled using the branch property
`code_is_browseable`.

For a public branch with revisions, the link is enabled.

    >>> branch = branchset.getByUniqueName('~name12/+junk/junk.dev')
    >>> print branch.private
    False
    >>> print branch.revision_count
    6
    >>> print branch.code_is_browseable
    True

For a public branch without revisions, the link is disabled.

    >>> branch = branchset.getByUniqueName('~name12/gnome-terminal/main')
    >>> print branch.private
    False
    >>> print branch.revision_count
    0
    >>> print branch.code_is_browseable
    False

Private branches are not browseable at all.

    >>> branch = branchset.getByUniqueName(
    ...     '~landscape-developers/landscape/trunk')
    >>> print branch.private
    True
    >>> print branch.code_is_browseable
    False


== Branch push and branch URLs ==

URLs are shown for a branch to show a user where they can push to and
pull or branch from.  These methods don't check any visibility constraints
for the person passed into the methods, that job is left to the views.
The branch location is shown using the lp: Bazaar lookup names.

    >>> print branch.unique_name
    ~landscape-developers/landscape/trunk
    >>> branch.private
    True
    >>> print branch.bzr_identity
    lp://dev/~landscape-developers/landscape/trunk

Branches associated with product series have shorter identities.  To
show this the landscape trunk branch will be associated as the primary
development focus branch.

    >>> landscape = branch.product
    >>> landscape.development_focus.user_branch = branch
    >>> syncUpdate(landscape.development_focus)

Private branches still show the full branch name.

    >>> print branch.bzr_identity
    lp://dev/~landscape-developers/landscape/trunk

    >>> branch.private = False
    >>> print branch.bzr_identity
    lp://dev/landscape

If the series is not the main development focus, then the series
name is appended.  The branch will always use the shorter of the
names if possible.

    >>> series = landscape.newSeries(branch.owner, 'experimental', '', branch)
    >>> len(list(branch.associatedProductSeries()))
    2
    >>> print branch.bzr_identity
    lp://dev/landscape
    >>> landscape.development_focus.user_branch = None
    >>> syncUpdate(landscape.development_focus)
    >>> print branch.bzr_identity
    lp://dev/landscape/experimental

Junk branches associated with a series do not get the short form of
bzr_identity.

    >>> print junkcode.product
    None
    >>> series.user_branch = junkcode
    >>> syncUpdate(series)
    >>> print junkcode.bzr_identity
    lp://dev/~junkowner/+junk/junkcode


== Branch Scan List ==

To speed up the branch scanning process, we only want to scan those
branches that have new information available to be scanned.

This accomplished by making the branch puller and branch scanner
record the last revision IDs in the branch that they saw.

If the last mirrored and last scanned revision IDs differ for a
branch, then they will be included in the scan list:

    >>> branch = branchset.get(1)
    >>> branch.last_mirrored_id = 'rev-2'
    >>> branch.last_scanned_id = 'rev-1'
    >>> syncUpdate(branch)
    >>> branch in branchset.getBranchesToScan()
    True

When the branch is scanned, the scanned ID will be updated, and the
branch will no longer appear in the list:

    >>> branch.last_scanned_id = 'rev-2'
    >>> syncUpdate(branch)
    >>> branch in branchset.getBranchesToScan()
    False

If a branch has not been scanned yet, it will have a null scanned ID,
so is included in the branch pull list:

    >>> branch.last_scanned_id = None
    >>> syncUpdate(branch)
    >>> branch in branchset.getBranchesToScan()
    True

Remote branches are not scanned.

    >>> old_type = branch.branch_type
    >>> branch.branch_type = BranchType.REMOTE
    >>> syncUpdate(branch)
    >>> branch in branchset.getBranchesToScan()
    False
    >>> branch.branch_type = old_type
    >>> syncUpdate(branch)

If a branch has not been mirrored, it will have a null mirrored ID.
There is no point in mirroring such branches, whatever the last
scanned ID is.

    >>> branch.last_mirrored_id = None
    >>> branch.last_scanned_id = None
    >>> syncUpdate(branch)
    >>> branch in branchset.getBranchesToScan()
    False

    >>> branch.last_scanned_id = 'rev-1'
    >>> syncUpdate(branch)
    >>> branch in branchset.getBranchesToScan()
    False


== Getting the branch count and last commit for products ==

    >>> from canonical.launchpad.interfaces.product import IProductSet
    >>> productset = getUtility(IProductSet)
    >>> products = [
    ...     productset.getByName('evolution'),
    ...     productset.getByName('firefox'),
    ...     productset.getByName('gnome-terminal'),
    ...     ]

    >>> summary = branchset.getActiveUserBranchSummaryForProducts(products)
    >>> for product in products:
    ...     print "%s %s %s" % (
    ...         product.name,
    ...         summary[product]['branch_count'],
    ...         summary[product]['last_commit'])
    evolution      1 None
    firefox        5 2005-03-09 15:50:00
    gnome-terminal 7 None


== Getting all branches for a person ==

Batching of the branch pages relies (ideally) on a quick simple query
that can have the result set limited in order to only return a partial
result set.  The getBranchesForContext method on IBranchSet where the
context is a Person (or team) will return all branches associated with
that person.  "Associated" means one of:

  - person is subscribed to the branch
  - person is owner of the branch
  - person registered the branch

The default sort order is by product name, lifecycle, owner name and
finally branch name (with NULL names sorting at the end, as is usual
for SQL), but any value from the BranchListingSort enumeration can be
used (when a sort order is specified, it only affects the initial
ordering -- so when BranchListingSort.LIFECYCLE is specified as the
sort order, the sort is by lifecycle, product name, owner name, and
finally name).

    >>> from canonical.launchpad.interfaces.branch import (
    ...     BranchLifecycleStatus, BranchListingSort,
    ...     DEFAULT_BRANCH_STATUS_IN_LISTING)
    >>> person = factory.makePerson(name="person")
    >>> product_a = factory.makeProduct(name='a')
    >>> product_b = factory.makeProduct(name='b')
    >>> branch_for_a_called_b = factory.makeProductBranch(
    ...     owner=person, product=product_a, name='b')
    >>> mature_branch_for_b_called_a = factory.makeProductBranch(
    ...     owner=person, product=product_b, name='a',
    ...     lifecycle_status=BranchLifecycleStatus.MATURE)
    >>> branch_for_b_called_b = factory.makeProductBranch(
    ...     owner=person, product=product_b, name='b')
    >>> branch_for_b_called_c = factory.makeProductBranch(
    ...     owner=person, product=product_b, name='c')
    >>> junk_branch = factory.makePersonalBranch(
    ...     owner=person, product=None, name='junk')
    >>> other = factory.makePerson(name='other')
    >>> other_branch_for_b_called_a = factory.makeProductBranch(
    ...     owner=other, product=product_b, name='a',
    ...     lifecycle_status=BranchLifecycleStatus.MATURE)
    >>> subscription = other_branch_for_b_called_a.subscribe(
    ...     person,
    ...     BranchSubscriptionNotificationLevel.FULL,
    ...     BranchSubscriptionDiffSize.FIVEKLINES,
    ...     CodeReviewNotificationLevel.FULL)
    >>> branches = branchset.getBranchesForContext(
    ...     person, DEFAULT_BRANCH_STATUS_IN_LISTING)
    >>> for branch in branches:
    ...     print branch.lifecycle_status.title, branch.unique_name
    New ~person/a/b
    Mature ~other/b/a
    Mature ~person/b/a
    New ~person/b/b
    New ~person/b/c
    New ~person/+junk/junk

    >>> branches = branchset.getBranchesForContext(
    ...     person, DEFAULT_BRANCH_STATUS_IN_LISTING,
    ...     sort_by=BranchListingSort.LIFECYCLE)
    >>> for branch in branches:
    ...     print branch.lifecycle_status.title, branch.unique_name
    Mature ~other/b/a
    Mature ~person/b/a
    New ~person/a/b
    New ~person/b/b
    New ~person/b/c
    New ~person/+junk/junk

In order to further restrict the branches that are returned for a person
there is the BranchPersonSearchContext, which has a restriction from
BranchPersonSearchRestriction.

    >>> from canonical.launchpad.interfaces import (
    ...     BranchPersonSearchContext, BranchPersonSearchRestriction)
    >>> for item in BranchPersonSearchRestriction.items:
    ...     print repr(item)
    <Item ...ALL, All related branches>
    <Item ...REGISTERED, Registered branches>
    <Item ...OWNED, Owned branches>
    <Item ...SUBSCRIBED, Subscribed branches>

A BranchPersonSearchContext takes a person and a restriction.

    >>> search_context = BranchPersonSearchContext(
    ...     sample_person, BranchPersonSearchRestriction.REGISTERED)
    >>> for branch in branchset.getBranchesForContext(
    ...     search_context, sort_by=BranchListingSort.PRODUCT):
    ...     print branch.unique_name
    ~name12/firefox/main
    ~name12/gnome-terminal/2.4
    ~name12/gnome-terminal/slowness
    ~name12/gnome-terminal/2.6
    ~name12/gnome-terminal/main
    ~name12/gnome-terminal/klingon
    ~name12/gnome-terminal/mirrored
    ~name12/gnome-terminal/pushed
    ~name12/gnome-terminal/scanned
    ~landscape-developers/landscape/trunk
    ~name12/+junk/junk.dev
    ~name12/+junk/junk.contrib

    >>> search_context = BranchPersonSearchContext(
    ...     sample_person, BranchPersonSearchRestriction.SUBSCRIBED)
    >>> for branch in branchset.getBranchesForContext(search_context):
    ...     print branch.unique_name
    ~launchpad/gnome-terminal/launchpad
    ~name12/+junk/junk.dev


== Getting branches for a product ==

In order to have batched branch listings the database needs to do as much
of the work as possible.  This way there are optimal database queries for
extra display information.

    >>> gnome_terminal = productset.getByName('gnome-terminal')
    >>> branches = branchset.getBranchesForContext(
    ...     gnome_terminal, DEFAULT_BRANCH_STATUS_IN_LISTING,
    ...     sort_by=BranchListingSort.REGISTRANT)
    >>> for branch in branches:
    ...     print branch.lifecycle_status.title, branch.owner.displayname,
    ...     print branch.unique_name
    New Launchpad Developers ~launchpad/gnome-terminal/launchpad
    Mature Sample Person ~name12/gnome-terminal/2.6
    Development Sample Person ~name12/gnome-terminal/main
    Experimental Sample Person ~name12/gnome-terminal/klingon
    New Sample Person ~name12/gnome-terminal/mirrored
    New Sample Person ~name12/gnome-terminal/pushed
    New Sample Person ~name12/gnome-terminal/scanned
    New VCS imports ~vcs-imports/gnome-terminal/import

    >>> branches = branchset.getBranchesForContext(
    ...     gnome_terminal, [BranchLifecycleStatus.DEVELOPMENT])
    >>> for branch in branches:
    ...     print branch.lifecycle_status.title, branch.unique_name
    Development ~name12/gnome-terminal/main


== Getting branches for a project ==

Similarly as for a product, we can retrieve the branches associated to all the
products that belong to a given project.

    >>> from canonical.launchpad.interfaces import IProjectSet
    >>> def printMozillaBranches(lifecycle_statuses=None):
    ...     mozilla = getUtility(IProjectSet).getByName('mozilla')
    ...     branches = branchset.getBranchesForContext(
    ...         mozilla, lifecycle_statuses)
    ...     for branch in branches:
    ...         print branch.lifecycle_status.title, branch.unique_name

    >>> printMozillaBranches()
    New ~name12/firefox/main
    New ~sabdfl/firefox/release--0.9.1
    New ~sabdfl/firefox/release-0.8
    New ~sabdfl/firefox/release-0.9
    New ~sabdfl/firefox/release-0.9.2
    New ~stevea/thunderbird/main

Filtering by status must work here too.

We update the branches for the Mozilla project in the sample data to use a
variety of different statuses, so that we can demonstrate filtering by status.

    >>> from canonical.database.sqlbase import flush_database_caches
    >>> def setMultipleStatus(branch_status_pairs):
    ...     for unique_name, new_status_name in branch_status_pairs:
    ...         branch = branchset.getByUniqueName(unique_name)
    ...         new_status = getattr(BranchLifecycleStatus, new_status_name)
    ...         branch.lifecycle_status = new_status
    ...         syncUpdate(branch)
    ...     # getBranchesForContext queries BranchWithSortKeys but we've just
    ...     # updated Branch.  SQLObject doesn't know that these are related
    ...     # so we have to drop the cached BranchWithSortKeys objects.
    ...     flush_database_caches()
    >>> login('foo.bar@canonical.com')
    >>> setMultipleStatus([
    ...     ('~name12/firefox/main', 'DEVELOPMENT'),
    ...     ('~sabdfl/firefox/release-0.8', 'ABANDONED'),
    ...     ('~sabdfl/firefox/release-0.9', 'ABANDONED'),
    ...     ('~sabdfl/firefox/release--0.9.1', 'ABANDONED'),
    ...     ('~sabdfl/firefox/release-0.9.2', 'MATURE'),
    ...     ('~stevea/thunderbird/main', 'DEVELOPMENT')])

    >>> printMozillaBranches()
    Abandoned ~sabdfl/firefox/release--0.9.1
    Abandoned ~sabdfl/firefox/release-0.8
    Abandoned ~sabdfl/firefox/release-0.9
    Mature ~sabdfl/firefox/release-0.9.2
    Development ~name12/firefox/main
    Development ~stevea/thunderbird/main

    >>> printMozillaBranches(DEFAULT_BRANCH_STATUS_IN_LISTING)
    Mature ~sabdfl/firefox/release-0.9.2
    Development ~name12/firefox/main
    Development ~stevea/thunderbird/main

    >>> printMozillaBranches([BranchLifecycleStatus.DEVELOPMENT])
    Development ~name12/firefox/main
    Development ~stevea/thunderbird/main

== Associated product series ==

A branch is able to return a list of product series that the branch is
associated with through either ProductSeries.user_branch or
ProductSeries.import_branch.

    >>> branch = branchset.getByUniqueName('~vcs-imports/evolution/main')
    >>> series = list(branch.associatedProductSeries())
    >>> len(series)
    1
    >>> series = series[0]
    >>> print series.product.name, series.name
    evolution trunk


== Deleting branches ==

If a user creates a branch in error, they should be able to remove that branch.

A branch can be deleted trivially if it is not associated with any bugs or
blueprints, has no subscribers, and hasn't been associated with any product
series.

Deleting the branch is done through Branch.destroySelf.  If the branch is not
deletable then an exception is raised.

More details can be found in the file
canonical/launchpad/database/tests/test_branch.py.

    >>> branch = branchset.new(
    ...     BranchType.MIRRORED, 'to-delete', person, person, product_a,
    ...     'http://example.com/branches/to-delete', 'A branch to delete')
    >>> print branch.unique_name
    ~person/a/to-delete

Since the branch has ddaa as an implicit subscriber, the branch is not
deletable.

    >>> branch.canBeDeleted()
    False
    >>> branch.destroySelf()
    Traceback (most recent call last):
      ...
    CannotDeleteBranch: Cannot delete branch: ~person/a/to-delete

The process can be rectified though by removing the offending links.

    >>> branch.unsubscribe(person)
    >>> branch.canBeDeleted()
    True
    >>> branch.destroySelf()
    >>> print branchset.getByUniqueName('~person/a/to-delete')
    None

The requirements for deleting the branch can be discovered:

    >>> branch = branchset.new(
    ...     BranchType.MIRRORED, 'to-delete', person, person, product_a,
    ...     'http://example.com/branches/to-delete', 'A branch to delete')
    >>> requirements = branch.deletionRequirements()

The keys in the requirements are the objects that are associated with the
branch.

    >>> [subscription] = list(branch.subscriptions)
    >>> [subscription] == requirements.keys()
    True
    >>> action, reason = requirements[subscription]
    >>> print action
    delete
    >>> print reason
    This is a subscription to this branch.

Deletion can be forced by supplying break_references=True.  This will delete
items that have mandantory references to this branch, and alter items with
optional references to this branch.  (Of course, this will fail if
the user does not have appropriate permissions.)

    >>> branch.destroySelf(break_references=True)
    >>> print branchset.getByUniqueName(
    ...     '~person/a/to-delete')
    None

Branches with revisions are deletable.

    >>> branch = branchset.getByUniqueName('~sabdfl/firefox/release--0.9.1')
    >>> branch.revision_count
    1
    >>> branch.canBeDeleted()
    True
    >>> branch.destroySelf()
    >>> print branchset.getByUniqueName('~sabdfl/firefox/release--0.9.1')
    None
    >>> logout()

A user without launchpad.Edit cannot delete a branch.

    >>> login('no-priv@canonical.com')
    >>> message = factory.makeCodeReviewComment()
    >>> branch = message.branch_merge_proposal.target_branch
    >>> branch.destroySelf(break_references=True)
    Traceback (most recent call last):
    Unauthorized: (<Branch ...>, 'destroySelf', 'launchpad.Edit')

Even if users with no delete rights on the branch could somehow access
the page, they still wouldn't be able to delete the message.  The message
is listed as not "allowed":

    >>> from zope.component import getMultiAdapter
    >>> from canonical.launchpad.webapp.servers import LaunchpadTestRequest
    >>> branch_delete_view = getMultiAdapter(
    ...   (branch, LaunchpadTestRequest()), name="+delete")
    >>> deletion_requirements = [
    ...     "%s allowed: %s" % (req[0].__class__.__name__, req[3])
    ...     for req in branch_delete_view.display_deletion_requirements]
    >>> for req in sorted(deletion_requirements):
    ...     print req
    BranchMergeProposal allowed: False
    BranchSubscription allowed: False


The "allowed: False" status is mirrored in the display.

    >>> request = LaunchpadTestRequest(
    ...   method='POST',
    ...   form={'field.actions.delete_branch': 'Delete'})
    >>> branch_delete_view = getMultiAdapter(
    ...   (branch, request), name="+delete")
    >>> branch_delete_view.delete_branch_action.success({})
    >>> for notice in request.response.notifications:
    ...     print notice.message
    This branch cannot be deleted.
    >>> logout()


== Branch references ==

When new references to the branch table are added, these need to be
taken into consideration with branch deletion.

The current references to the branch table are shown here.

    >>> from canonical.database import postgresql
    >>> from canonical.database.sqlbase import cursor
    >>> cur = cursor()
    >>> references = list(postgresql.listReferences(cur, 'branch', 'id'))

    >>> for name in sorted([
    ...     '%s.%s' % (src_tab, src_col) for
    ...     src_tab, src_col, ref_tab, ref_col, updact, delact in references]):
    ...     print name
    branch.stacked_on
    branchjob.branch
    branchmergeproposal.dependent_branch
    branchmergeproposal.source_branch
    branchmergeproposal.target_branch
    branchrevision.branch
    branchsubscription.branch
    bugbranch.branch
    codeimport.branch
    productseries.import_branch
    productseries.user_branch
    seriessourcepackagebranch.branch
    specificationbranch.branch

(Unfortunately, references can form a graph-- note that codereviewcomments
 aren't shown.)
