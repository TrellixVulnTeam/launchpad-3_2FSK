= Archives =

Representations for IArchive can be fetch via the API for PPAs and
distribution archives.

    >>> cprov_archive = webservice.get("/~cprov/+archive/ppa").jsonBody()
    >>> print cprov_archive['self_link']
    http://.../~cprov/+archive/ppa

    >>> main = webservice.get("/ubuntu/+archive/primary").jsonBody()
    >>> print main['self_link']
    http://.../ubuntu/+archive/primary

We publish a subset of their attributes.

    >>> from lazr.restful.testing.webservice import pprint_entry
    >>> pprint_entry(cprov_archive)
    description: u'packages to help my friends.'
    displayname: u'PPA for Celso Providelo'
    distribution_link: u'http://.../ubuntu'
    name: u'ppa'
    owner_link: u'http://.../~cprov'
    private: False
    resource_type_link: u'http://.../#archive'
    self_link: u'http://.../~cprov/+archive/ppa'
    signing_key_fingerprint: None

While the Archive signing key is being generated its
'signing_key_fingerprint' attribute is None.

We can quickly assign a random OpenPGP key to Celso's PPA.

    >>> from zope.component import getUtility
    >>> from lp.registry.interfaces.person import IPersonSet

    >>> login('foo.bar@canonical.com')
    >>> foo_bar = getUtility(IPersonSet).getByName('name16')
    >>> [a_key] = foo_bar.gpgkeys
    >>> print a_key.fingerprint
    ABCDEF0123456789ABCDDCBA0000111112345678

    >>> cprov = getUtility(IPersonSet).getByName('cprov')
    >>> cprov.archive.signing_key = a_key
    >>> print cprov.archive.signing_key_fingerprint
    ABCDEF0123456789ABCDDCBA0000111112345678

    >>> logout()

And then the new attribute value is exported as a string.

    >>> cprov_archive = webservice.get("/~cprov/+archive/ppa").jsonBody()
    >>> print cprov_archive['signing_key_fingerprint']
    ABCDEF0123456789ABCDDCBA0000111112345678

Distributions can provide information about their archives.  Looking
at "ubuntutest":

    >>> distros = webservice.get("/distros").jsonBody()
    >>> for entry in distros['entries']:
    ...    print entry['self_link']
    http://.../ubuntu
    http://.../kubuntu
    http://.../ubuntutest
    http://.../debian
    http://.../gentoo

    >>> ubuntutest = distros['entries'][2]
    >>> ubuntu = distros['entries'][0]

"ubuntutest" has a "main_archive" which is always present:

    >>> print ubuntutest['main_archive_link']
    http://.../ubuntutest/+archive/primary

The archive has the following attributes:

    >>> main_archive = webservice.get(
    ...     ubuntutest['main_archive_link']).jsonBody()
    >>> pprint_entry(main_archive)
    description: None
    displayname: u'Primary Archive for Ubuntu Test'
    distribution_link: u'http://.../ubuntutest'
    name: u'primary'
    owner_link: u'http://.../~ubuntu-team'
    private: False
    resource_type_link: u'http://.../#archive'
    self_link: u'http://.../ubuntutest/+archive/primary'
    signing_key_fingerprint: None

A distribution can also provide a list of all its archives:

    >>> print ubuntutest['archives_collection_link']
    http://.../ubuntutest/archives
    >>> archives = webservice.get(
    ...     ubuntutest['archives_collection_link']).jsonBody()
    >>> print_self_link_of_entries(archives)
    http://api.launchpad.dev/beta/ubuntutest/+archive/partner
    http://api.launchpad.dev/beta/ubuntutest/+archive/primary

Attempting to grab a non-existent archive will result in a 404 error:

    >>> bogus_archive = "ubuntutest/+archive/bogus"
    >>> webservice.get(bogus_archive).jsonBody()
    Traceback (most recent call last):
    ...
    ValueError: HTTP/1.1 404 Not Found
    ...


= Archive Permissions =

Archives have associated permissions.  These are currently either upload
rights or queue administration rights.  The URL to the permissions
takes two forms:
 * <archive>/+upload/username.item
 * <archive>/+queue-admin/username.item
where `item` is a component or a source package name.

This is a permission that allows a team to upload to a component:

    >>> url = '/ubuntu/+archive/primary/+upload/ubuntu-team?type=component&item=main'
    >>> ubuntu_main_permission = webservice.get(url).jsonBody()
    >>> pprint_entry(ubuntu_main_permission)
    archive_link: u'http://.../ubuntu/+archive/primary'
    component_name: u'main'
    date_created: ...
    permission: u'Archive Upload Rights'
    person_link: u'http://.../~ubuntu-team'
    resource_type_link: ...
    self_link: u'http://.../ubuntu/+archive/primary/+upload/ubuntu-team?type=component&item=main'
    source_package_name: None

This is a permission that allows an individual to upload a source package.

    >>> url = '/ubuntu/+archive/primary/+upload/carlos?type=packagename&item=mozilla-firefox'
    >>> carlos_mozilla_permission = webservice.get(url).jsonBody()
    >>> pprint_entry(carlos_mozilla_permission)
    archive_link: u'http://.../ubuntu/+archive/primary'
    component_name: None
    date_created: ...
    permission: u'Archive Upload Rights'
    person_link: u'http://.../~carlos'
    resource_type_link: ...
    self_link:
        u'http://.../ubuntu/+archive/primary/+upload/carlos?type=packagename&item=mozilla-firefox'
    source_package_name: u'mozilla-firefox'

This is a queue admin right for ubuntu-team:

    >>> url = '/ubuntu/+archive/primary/+queue-admin/ubuntu-team?type=component&item=main'
    >>> ubuntu_main_permission = webservice.get(url).jsonBody()
    >>> pprint_entry(ubuntu_main_permission)
    archive_link: u'http://.../ubuntu/+archive/primary'
    component_name: u'main'
    date_created: ...
    permission: u'Queue Administration Rights'
    person_link: u'http://.../~ubuntu-team'
    resource_type_link: ...
    self_link:
        u'http://.../ubuntu/+archive/primary/+queue-admin/ubuntu-team?type=component&item=main'
    source_package_name: None

And one for an individual:

    >>> url = '/ubuntu/+archive/primary/+queue-admin/name12?type=component&item=universe'
    >>> name16_admin_permission = webservice.get(url).jsonBody()
    >>> pprint_entry(name16_admin_permission)
    archive_link: u'http://.../ubuntu/+archive/primary'
    component_name: u'universe'
    date_created: ...
    permission: u'Queue Administration Rights'
    person_link: u'http://.../~name12'
    resource_type_link: ...
    self_link:
        u'http://.../ubuntu/+archive/primary/+queue-admin/name12?type=component&item=universe'
    source_package_name: None


== Archive Permission Custom Operations ==

Permission collections can be retrieved with custom operations on the
archive.

getPermissionsForPerson returns all the permissions that a user has.

    >>> ubuntu_team = webservice.get("/~ubuntu-team").jsonBody()
    >>> permissions = webservice.named_get(
    ...     ubuntutest['main_archive_link'], 'getPermissionsForPerson',
    ...     person=ubuntu_team['self_link']).jsonBody()

    >>> def permission_entry_sort_key(entry):
    ...      return (entry['permission'],
    ...              entry['person_link'],
    ...              entry['component_name'],
    ...              entry['source_package_name']),

    >>> def show_permission_entries(permissions):
    ...     for entry in sorted(permissions['entries'],
    ...                         key=permission_entry_sort_key):
    ...         print entry['permission']
    ...         print entry['person_link']
    ...         print entry['component_name']
    ...         print entry['source_package_name']

    >>> show_permission_entries(permissions)
    Archive Upload Rights ...~ubuntu-team main None
    Archive Upload Rights ...~ubuntu-team universe None

getUploadersForPackage returns all the permissions where someone can
upload a particular package.

    >>> def show_mozilla_permissions():
    ...     permissions = webservice.named_get(
    ...         ubuntu['main_archive_link'], 'getUploadersForPackage',
    ...         source_package_name='mozilla-firefox').jsonBody()
    ...     show_permission_entries(permissions)

    >>> show_mozilla_permissions()
    Archive Upload Rights ...~carlos None mozilla-firefox

Passing a bad package name results in an error:

    >>> print webservice.named_get(
    ...     ubuntu['main_archive_link'], 'getUploadersForPackage',
    ...     source_package_name="badpackage").getOutput()
    HTTP/1.1 400 Bad Request
    ...

newPackageUploader() is a factory function that adds a new permission for
a person to upload a package.

    >>> name12 = webservice.get("/~name12").jsonBody()
    >>> response = webservice.named_post(
    ...     ubuntu['main_archive_link'], 'newPackageUploader', {},
    ...     person=name12['self_link'],
    ...     source_package_name='mozilla-firefox')
    >>> print response.getOutput()
    HTTP/1.1 201 Created
    ...

    >>> new_permission = webservice.get(
    ...     response.getHeader('Location')).jsonBody()
    >>> print new_permission['self_link']
    http://.../ubuntu/+archive/primary/+upload/name12?type=packagename&item=mozilla-firefox

    >>> show_mozilla_permissions()
    Archive Upload Rights ...~carlos None mozilla-firefox
    Archive Upload Rights ...~name12 None mozilla-firefox

deletePackageUploader() removes that permission:

    >>> print webservice.named_post(
    ...     ubuntu['main_archive_link'], 'deletePackageUploader', {},
    ...     person=name12['self_link'],
    ...     source_package_name='mozilla-firefox')
    HTTP/1.1 200 Ok
    ...

And we can see that it's gone:

    >>> show_mozilla_permissions()
    Archive Upload Rights ...~carlos None mozilla-firefox

getUploadersForComponent returns all the permissions where someone can
upload to a particular component:

    >>> def show_component_permissions(component=None):
    ...     permissions = webservice.named_get(
    ...         ubuntu['main_archive_link'], 'getUploadersForComponent',
    ...         component_name=component).jsonBody()
    ...     show_permission_entries(permissions)

    >>> show_component_permissions("main")
    Archive Upload Rights ...~ubuntu-team main None

Passing a bad component name results in an error:

    >>> print webservice.named_get(
    ...     ubuntu['main_archive_link'], 'getUploadersForComponent',
    ...     component_name="badcomponent").getOutput()
    HTTP/1.1 400 Bad Request
    ...

If you don't specify the component, you get all the uploaders for
all components.

    >>> show_component_permissions()
    Archive Upload Rights ...~ubuntu-team main None
    Archive Upload Rights ...~ubuntu-team universe None

newComponentUploader adds a new permission for a person to upload to a
component.

    >>> response = webservice.named_post(
    ...     ubuntu['main_archive_link'], 'newComponentUploader', {},
    ...     person=name12['self_link'],
    ...     component_name='restricted')
    >>> print response.getOutput()
    HTTP/1.1 201 Created
    ...

    >>> new_permission = webservice.get(
    ...     response.getHeader('Location')).jsonBody()
    >>> print new_permission['self_link']
    http://.../ubuntu/+archive/primary/+upload/name12?type=component&item=restricted

    >>> show_component_permissions()
    Archive Upload Rights ...~name12 restricted None
    Archive Upload Rights ...~ubuntu-team main None
    Archive Upload Rights ...~ubuntu-team restricted None
    Archive Upload Rights ...~ubuntu-team universe None

If you add a new permission for someone to upload to a PPA, you must specify
the 'main' component, or an error is returned:

    >>> response = webservice.named_post(
    ...     cprov_archive['self_link'], 'newComponentUploader', {},
    ...     person=name12['self_link'], component_name='restricted')
    >>> print response.getOutput()
    HTTP/1.1 400 Bad Request
    ...
    InvalidComponent: Component for PPAs should be 'main'
    <BLANKLINE>

    >>> response = webservice.named_post(
    ...     cprov_archive['self_link'], 'newComponentUploader', {},
    ...     person=name12['self_link'], component_name='main')
    >>> print response.getOutput()
    HTTP/1.1 201 Created
    ...

deleteComponentUploader() removes that permission:

    >>> print webservice.named_post(
    ...     ubuntu['main_archive_link'], 'deleteComponentUploader', {},
    ...     person=name12['self_link'],
    ...     component_name='restricted')
    HTTP/1.1 200 Ok
    ...

And we can see that it's gone:

    >>> show_component_permissions()
    Archive Upload Rights ...~ubuntu-team main None
    Archive Upload Rights ...~ubuntu-team restricted None
    Archive Upload Rights ...~ubuntu-team universe None

getQueueAdminsForComponent returns all the permissions where someone
can administer distroseries queues in a particular component.

    >>> def show_admins_for_component(component):
    ...     permissions = webservice.named_get(
    ...         ubuntu['main_archive_link'], 'getQueueAdminsForComponent',
    ...         component_name=component).jsonBody()
    ...     show_permission_entries(permissions)

    >>> show_admins_for_component("main")
    Queue Administration Rights ...~name12 main None
    Queue Administration Rights ...~ubuntu-team main None

getComponentsForQueueAdmin returns all the permissions relating to components
where the user is able to administer distroseries queues.

    >>> def show_components_for_admin(person):
    ...     permissions = webservice.named_get(
    ...         ubuntu['main_archive_link'], 'getComponentsForQueueAdmin',
    ...         person=person['self_link']).jsonBody()
    ...     show_permission_entries(permissions)

    >>> show_components_for_admin(name12)
    Queue Administration Rights ...~name12 main None
    Queue Administration Rights ...~name12 multiverse None
    Queue Administration Rights ...~name12 restricted None
    Queue Administration Rights ...~name12 universe None

newQueueAdmin adds a new permission for a person to administer distroseries
queues in a particular component.

    >>> response = webservice.named_post(
    ...     ubuntu['main_archive_link'], 'newQueueAdmin', {},
    ...     person=name12['self_link'],
    ...     component_name='partner')
    >>> print response.getOutput()
    HTTP/1.1 201 Created
    ...

    >>> new_permission = webservice.get(
    ...     response.getHeader('Location')).jsonBody()
    >>> print new_permission['self_link']
    http://.../ubuntu/+archive/primary/+queue-admin/name12?type=component&item=partner

    >>> show_components_for_admin(name12)
    Queue Administration Rights ...~name12 main None
    Queue Administration Rights ...~name12 multiverse None
    Queue Administration Rights ...~name12 partner None
    Queue Administration Rights ...~name12 restricted None
    Queue Administration Rights ...~name12 universe None

deleteQueueAdmin removes that permission.

    >>> print webservice.named_post(
    ...     ubuntu['main_archive_link'], 'deleteQueueAdmin', {},
    ...     person=name12['self_link'],
    ...     component_name='partner')
    HTTP/1.1 200 Ok
    ...

And we can see that it's gone:

    >>> show_components_for_admin(name12)
    Queue Administration Rights ...~name12 main None
    Queue Administration Rights ...~name12 multiverse None
    Queue Administration Rights ...~name12 restricted None
    Queue Administration Rights ...~name12 universe None


== Malformed archive permission URLs ==

Malformed URLs are handled reasonably well.

The type of item for which we seek the archive permission is missing. The
latter can thus not be found.

    >>> missing_type_url = '/ubuntu/+archive/primary/+upload/name12?item=firefox'
    >>> this_will_fail = webservice.get(missing_type_url)
    >>> print this_will_fail.getOutput()
    HTTP/1.1 404 Not Found
    ...

The ultimate item type ('Integer') is wrong. The archive permission is hence
not found.

    >>> wrong_type_url = '/ubuntu/+archive/primary/+upload/name12?type=packageset&item=firefox&type=Integer'
    >>> this_will_fail = webservice.get(missing_type_url)
    >>> print this_will_fail.getOutput()
    HTTP/1.1 404 Not Found
    ...

The item name is missing. The archive permission is hence not found.

    >>> missing_item_url = '/ubuntu/+archive/primary/+upload/name12?type=packageset'
    >>> this_will_fail = webservice.get(missing_type_url)
    >>> print this_will_fail.getOutput()
    HTTP/1.1 404 Not Found
    ...

The ultimate item name ('vapourware') is wrong. The archive permission is hence
not found.

    >>> wrong_type_url = '/ubuntu/+archive/primary/+upload/name12?type=packageset&item=firefox&item=vapourware'
    >>> this_will_fail = webservice.get(missing_type_url)
    >>> print this_will_fail.getOutput()
    HTTP/1.1 404 Not Found
    ...


= Getting Build counts for an IArchive =

IArchive exposes the getBuildCounters() method, enabling this data to be
used and displayed via XHR.

    >>> build_counters = webservice.named_get(
    ...     ubuntu['main_archive_link'], 'getBuildCounters').jsonBody()
    >>> for key, val in build_counters.items():
    ...     print "%s: %s" % (key, val)
    failed: 5
    superseded: 3
    total: 18
    pending: 2
    succeeded: 8

The optional param exclude_needsbuild is also provided:

    >>> build_counters = webservice.named_get(
    ...     ubuntu['main_archive_link'], 'getBuildCounters',
    ...     include_needsbuild=False).jsonBody()
    >>> for key, val in build_counters.items():
    ...     print "%s: %s" % (key, val)
    failed: 5
    superseded: 3
    total: 17
    pending: 1
    succeeded: 8

== Package copying/synchronisation ==

IArchive contains 2 custom operations to copy packages from another archive.
These are syncSource() and syncSources(). Both are wrappers of the
`PackageCopier` infrastructure, see more information in
scripts/packagecopier.py.

For testing purpose we will create some publications.

    >>> login('foo.bar@canonical.com')

    >>> from lp.registry.interfaces.distribution import (
    ...     IDistributionSet)

    >>> ubuntu_distro = getUtility(IDistributionSet).getByName('ubuntu')

    >>> main_archive = ubuntu_distro.main_archive

    >>> from lp.soyuz.tests.test_publishing import (
    ...     SoyuzTestPublisher)
    >>> test_publisher = SoyuzTestPublisher()
    >>> hoary = ubuntu_distro.getSeries('hoary')
    >>> test_publisher.addFakeChroots(hoary)
    >>> ignore = test_publisher.setUpDefaultDistroSeries(hoary)

'package1' (with two versions) and 'package2' publications in the
ubuntu primary archive.

    >>> ignore = test_publisher.getPubSource(
    ...     sourcename="package1", version="1.0", archive=main_archive)

    >>> ignore = test_publisher.getPubSource(
    ...     sourcename="package1", version="1.1", archive=main_archive)

    >>> ignore = test_publisher.getPubSource(
    ...     sourcename="package2", version="1.0", archive=main_archive)

A test publication in Celso's PPA.

    >>> cprov = getUtility(IPersonSet).getByName('cprov')

    >>> ignore = test_publisher.getPubSource(
    ...     sourcename="package3", version="1.0", archive=cprov.archive)

Colin is a valid member of the team who owns the ubuntu primary archive.

    >>> cjwatson = getUtility(IPersonSet).getByName('kamion')
    >>> cjwatson.inTeam(main_archive.owner)
    True

Setup done, let's log out and continue with the tests.

    >>> logout()

syncSource() copies a single package with a specific version from another
archive.  It will prevent unauthorised changes to an archive.  Here we are
using user_webservice, which has no privileges, and trying to copy to
the Ubuntu main archive:

    >>> print user_webservice.named_post(
    ...     ubuntu['main_archive_link'], 'syncSource', {},
    ...     source_name='package3', version='1.0',
    ...     from_archive=cprov_archive['self_link'], to_pocket='release',
    ...     to_series="hoary")
    HTTP/1.1 401 Unauthorized
    ...

When accessed via Colin's key that can perform writes, the API will
respond positively.

    >>> from canonical.launchpad.testing.pages import webservice_for_person
    >>> from canonical.launchpad.webapp.interfaces import OAuthPermission

    >>> admin_webservice = webservice_for_person(
    ...     cjwatson, permission=OAuthPermission.WRITE_PUBLIC)

    >>> print admin_webservice.named_post(
    ...     ubuntu['main_archive_link'], 'syncSource', {},
    ...     source_name='package3', version='1.0',
    ...     from_archive=cprov_archive['self_link'], to_pocket='release',
    ...     to_series="hoary")
    HTTP/1.1 200 Ok
    ...

Now copy "package1" version 1.0 from the main archive into cprov's
PPA. The 'admin_write' key created for Colin isn't allowed to modify
Celso's PPA.

    >>> print admin_webservice.named_post(
    ...     cprov_archive['self_link'], 'syncSource', {},
    ...     source_name='package1', version='1.0',
    ...     from_archive=ubuntu['main_archive_link'], to_pocket='release',
    ...     to_series="hoary")
    HTTP/1.1 401 Unauthorized
    ...

Only a key created by Celso with write permissions will allow this
operation.

    >>> cprov_webservice = webservice_for_person(
    ...     cprov, permission=OAuthPermission.WRITE_PUBLIC)

    >>> print cprov_webservice.named_post(
    ...     cprov_archive['self_link'], 'syncSource', {},
    ...     source_name='package1', version='1.0',
    ...     from_archive=ubuntu['main_archive_link'], to_pocket='release',
    ...     to_series="hoary")
    HTTP/1.1 200 Ok
    ...

syncSources() allows the caller to specify a list of sources to copy all at
once.  The latest versions that are found in the from_archive are
"synchronised" to the context archive.  If a particular version already
exists then nothing is copied.

    >>> print cprov_webservice.named_post(
    ...     cprov_archive['self_link'], 'syncSources', {},
    ...     source_names=['package1', 'package2'],
    ...     from_archive=ubuntu['main_archive_link'], to_pocket='release',
    ...     to_series="warty")
    HTTP/1.1 200 Ok
    ...

The operation is still successful if there is nothing to copy, as you
would expect from a 'sync-like' method.

    >>> already_copied = cprov_webservice.named_post(
    ...     cprov_archive['self_link'], 'syncSources', {},
    ...     source_names=['package1', 'package2'],
    ...     from_archive=ubuntu['main_archive_link'], to_pocket='release',
    ...     to_series="warty")
    >>> print already_copied
    HTTP/1.1 200 Ok
    ...

Within the web application, the CannotCopy exception means that there
was an oversight in the code that called syncSources()--that method
shouldn't have been called in the first place. The CannotCopy
exception therefore results in an OOPS. But within the web service,
syncSources is invoked directly by the client, and any problems are
the client's fault. Therefore, there's no need to record an OOPS.

    >>> 'X-Lazr-Oopsid' in already_copied.getOutput()
    False

'syncSources' behaves trasactionally, i.e. it will only synchronise
all packages or none of them if there was a problem.

    # Create an 'allowed' source publication with binaries in main_archive.
    # It can be successfully synchronised to Celso's PPA.
    >>> login('foo.bar@canonical.com')
    >>> allowed_source = test_publisher.getPubSource(
    ...     sourcename="allowed", version="1.0", archive=main_archive)
    >>> ignore = test_publisher.getPubBinaries(pub_source=allowed_source)
    >>> logout()

'package1' has no binaries to be copied, so when we attempt to copy
'allowed' and 'package1' with binaries an error is returned.

    >>> print cprov_webservice.named_post(
    ...     cprov_archive['self_link'], 'syncSources', {},
    ...     source_names=['allowed', 'package1'],
    ...     from_archive=ubuntu['main_archive_link'], to_pocket='release',
    ...     to_series="warty", include_binaries=True)
    HTTP/1.1 400 Bad Request
    ...
    CannotCopy: package1 1.1 in hoary (source has no binaries to be copied)
    <BLANKLINE>

Even if the error was only when processing 'package1', the 'allowed'
source was not synchronised to Celso's PPA.

    >>> cprov_webservice.named_get(
    ...     cprov_archive['self_link'], 'getPublishedSources',
    ...     source_name="allowed").jsonBody()['total_size']
    0

Keys with not enough permissions in Celso's PPA context are not
allowed to call the method at all.

    >>> print user_webservice.named_post(
    ...     cprov_archive['self_link'], 'syncSources', {},
    ...     source_names=['package1', 'package2'],
    ...     from_archive=ubuntu['main_archive_link'], to_pocket='release',
    ...     to_series="warty")
    HTTP/1.1 401 Unauthorized
    ...

    >>> print admin_webservice.named_post(
    ...     cprov_archive['self_link'], 'syncSources', {},
    ...     source_names=['package1', 'package2'],
    ...     from_archive=ubuntu['main_archive_link'], to_pocket='release',
    ...     to_series="warty")
    HTTP/1.1 401 Unauthorized
    ...


== Private archives ==

Make Celso's PPA private and create a private source publication.

    >>> login('foo.bar@canonical.com')

    >>> cprov.archive.buildd_secret = 'boing'
    >>> cprov.archive.private = True

    >>> private_publication = test_publisher.getPubSource(
    ...     sourcename="private", version="1.0", archive=cprov.archive)

    >>> logout()

Now we need a webservice with rights to read private data in order to
be able to access Celso's private PPA.

    >>> cprov_webservice = webservice_for_person(
    ...     cprov, permission=OAuthPermission.WRITE_PRIVATE)

Note that the 'description' and the 'signing_key_fingerprint'
attributes are only exposed when the requestor has View permission in
the IArchive context, in this case only Celso has it.

    >>> pprint_entry(user_webservice.get("/~cprov/+archive/ppa").jsonBody())
    description: u'tag:launchpad.net:2008:redacted'
    displayname: u'PPA for Celso Providelo'
    distribution_link: u'http://.../ubuntu'
    name: u'ppa'
    owner_link: u'http://.../~cprov'
    private: True
    resource_type_link: u'http://.../#archive'
    self_link: u'http://.../~cprov/+archive/ppa'
    signing_key_fingerprint: u'tag:launchpad.net:2008:redacted'

    >>> pprint_entry(cprov_webservice.get("/~cprov/+archive/ppa").jsonBody())
    description: u'packages to help my friends.'
    displayname: u'PPA for Celso Providelo'
    distribution_link: u'http://.../ubuntu'
    name: u'ppa'
    owner_link: u'http://.../~cprov'
    private: True
    resource_type_link: u'http://.../#archive'
    self_link: u'http://.../~cprov/+archive/ppa'
    signing_key_fingerprint: u'ABCDEF0123456789ABCDDCBA0000111112345678'

== Creating subscriptions to a (private) archive ==

IArchive exposes the newSubscription() method, enabling new subscriptions
to be created via AJAX.

Archive subscriptions can only be created for private archives. If we
try creating a subscription for sabdfl's archive (which is public), a
bad request will result:

    >>> login('foo.bar@canonical.com')
    >>> sabdfl_db = getUtility(IPersonSet).getByName('sabdfl')
    >>> sabdfl_webservice = webservice_for_person(
    ...     sabdfl_db, permission=OAuthPermission.WRITE_PUBLIC)
    >>> logout()
    >>> sabdfl = sabdfl_webservice.get("/~sabdfl").jsonBody()
    >>> sabdfl_archive = sabdfl_webservice.get(
    ...     "/~sabdfl/+archive/ppa").jsonBody()
    >>> response = sabdfl_webservice.named_post(
    ...     sabdfl_archive['self_link'], 'newSubscription',
    ...     subscriber=cprov_archive['owner_link'])
    >>> print response.getOutput()
    HTTP/1.1 400 Bad Request
    ...
    ArchiveNotPrivate: Only private archives can have subscriptions.
    <BLANKLINE>

First we'll subscribe sabdfl to cprov's archive:

    >>> sabdfl = webservice.get("/~sabdfl").jsonBody()
    >>> cprov_archive = cprov_webservice.get("/~cprov/+archive/ppa").jsonBody()
    >>> response = cprov_webservice.named_post(
    ...     cprov_archive['self_link'], 'newSubscription',
    ...     subscriber=sabdfl['self_link'])

    >>> print response.getOutput()
    HTTP/1.1 201 Created
    ...

    >>> print response.getHeader('Location')
    http://.../~cprov/+archive/ppa/+subscriptions/sabdfl

We publish a subset of the IArchiveSubscriber attributes.

    >>> new_subscription = cprov_webservice.get(
    ...     response.getHeader('Location')).jsonBody()
    >>> pprint_entry(new_subscription)
    archive_link: u'http://api.launchpad.dev/beta/~cprov/+archive/ppa'
    date_created: ...
    date_expires: None
    description: None
    registrant_link: u'http://api.launchpad.dev/beta/~cprov'
    resource_type_link: u'http://api.launchpad.dev/beta/#archive_subscriber'
    self_link: u'http://api.launchpad.dev/beta/~cprov/+archive/ppa/+subscriptions/sabdfl'
    status: u'Active'
    subscriber_link: u'http://api.launchpad.dev/beta/~sabdfl'

Other webservice users cannot view the subscription.

    >>> response = user_webservice.get(
    ...     response.getHeader('Location'))
    >>> print response.getOutput()
    HTTP/1.1 401 Unauthorized
    ...

Similarly, other webservice users cannot create a new subscription
as the calling user must have append privileges on the archive
to use this method.

    >>> response = user_webservice.named_post(
    ...     cprov_archive['self_link'], 'newSubscription',
    ...     subscriber=cprov_archive['owner_link'])
    >>> print response.getOutput()
    HTTP/1.1 401 Unauthorized
    ...

A second subscription cannot be created for the same user/team when there
is already a current subscription:

    >>> response = cprov_webservice.named_post(
    ...     cprov_archive['self_link'], 'newSubscription',
    ...     subscriber=sabdfl['self_link'])
    >>> print response.getOutput()
    HTTP/1.1 400 Bad Request
    ...
    AlreadySubscribed: Mark Shuttleworth already has a current subscription
    for 'PPA for Celso Providelo'.


== Modifying privacy ==

Modifying the privacy flag through the API is not allowed except for
admins and commercial admins.

    >>> import simplejson
    >>> def modify_archive(service, archive):
    ...     headers = {'Content-type': 'application/json'}
    ...     return service(
    ...         archive['self_link'], 'PUT', simplejson.dumps(archive),
    ...         headers)

    >>> sabdfl_archive = webservice.get("/~sabdfl/+archive/ppa").jsonBody()
    >>> sabdfl_archive['private'] = True
    >>> print modify_archive(user_webservice, sabdfl_archive)
    HTTP/1.1 401 Unauthorized
    ...
    Unauthorized: (<Archive at ...>, 'private', 'launchpad.Commercial')
    <BLANKLINE>


=== Copy privacy mismatch ===

A CannotCopy error, giving the reason "Cannot copy private source into
public archives." is raised if such operation is requested.

When we try to copy the private source to the primary archive, which
is public, the 'privacy mismatch' error is raised. The behaviour is
the same for `syncSource` or `syncSources` operations.

    >>> print cprov_webservice.named_post(
    ...     ubuntu['main_archive_link'], 'syncSource', {},
    ...     source_name='private', version="1.0", to_pocket='release',
    ...     from_archive=cprov_archive['self_link'],
    ...     to_series="hoary")
    HTTP/1.1 400 Bad Request
    ...
    CannotCopy: private 1.0 in hoary
    (cannot copy private files into public archives)
    <BLANKLINE>

    >>> print cprov_webservice.named_post(
    ...     ubuntu['main_archive_link'], 'syncSources', {},
    ...     source_names=['private'], to_pocket='release',
    ...     from_archive=cprov_archive['self_link'],
    ...     to_series="hoary")
    HTTP/1.1 400 Bad Request
    ...
    CannotCopy: private 1.0 in hoary
    (cannot copy private files into public archives)
    <BLANKLINE>
