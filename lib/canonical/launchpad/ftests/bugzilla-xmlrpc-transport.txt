= TestBugzillaXMLRPCTransport =

The TestBugzillaXMLRPCTransport is an XML-RPC transport which simulates
a remote Bugzilla instance that implements both the Bugzilla XMLRPC API
and the additional Launchpad plugin API.

    >>> import xmlrpclib
    >>> from canonical.launchpad.ftests.externalbugtracker import (
    ...     TestBugzillaXMLRPCTransport)
    >>> bugzilla_transport = TestBugzillaXMLRPCTransport()
    >>> server = xmlrpclib.ServerProxy(
    ...     'http://example.com/', transport=bugzilla_transport)

The transport will only allow calls to methods in a predefined set of
namespaces.

    >>> server.spam.eggs()
    Traceback (most recent call last):
      ...
    AssertionError: All methods should be in one of the following
    namespaces: ...

Adding a new namespace to the transport's methods dict will make methods
in that namespace callable. Of course, if the method doesn't exist, an
error will be raised.

    >>> bugzilla_transport.methods['spam'] = ['eggs']
    >>> server.spam.eggs()
    Traceback (most recent call last):
      ...
    AttributeError: 'TestBugzillaXMLRPCTransport' object has no
    attribute 'eggs'

    >>> del bugzilla_transport.methods['spam']

If a namespace exists but there is no method registered under that
namespace with a given method name, an AssertionError will be raised.

    >>> 'unregistered_method' in bugzilla_transport.methods['Bug']
    False

    >>> server.Bug.unregistered_method()
    Traceback (most recent call last):
      ...
    AssertionError: No method 'unregistered_method' in namespace 'Bug'.


== Launchpad.time() ==

Launchpad.time() returns the current time on the remote server, the
remote server's timezone and what the remote server believes to be the
current UTC time.

    >>> time_dict = server.Launchpad.time()
    >>> for key in sorted(time_dict):
    ...     print "%s: %s" % (key, time_dict[key])
    local_time: 20080501T01:01:01
    tz_name: UTC
    utc_time: 20080501T01:01:01

We can set the local time value on the remote server to make testing
more useful.

    >>> import time
    >>> from datetime import datetime

    >>> remote_datetime = datetime(2008, 5, 15, 16, 19, 53)
    >>> bugzilla_transport.seconds_since_epoch = time.mktime(
    ...     remote_datetime.timetuple())
    >>> bugzilla_transport.timezone = "US/Central"
    >>> bugzilla_transport.utc_offset = -6*60*60

    >>> time_dict = server.Launchpad.time()
    >>> for key in sorted(time_dict):
    ...     print "%s: %s" % (key, time_dict[key])
    local_time: 20080515T16:19:53
    tz_name: US/Central
    utc_time: 20080515T22:19:53


== Bug.get_bugs() ==

The common Bugzilla bug API offers a get_bugs() method which can be used
to retrieve bugs from a remote Bugzilla instance. It takes a list of bug
IDs to retrieve and returns a list of dicts containing those bugs' data.
As is standard with the Bugzilla XMLRPC API, arguments are enclosed in a
dict so that they are treated as key: value pairs.

    >>> [bug_dict] = server.Bug.get_bugs({'ids': [1]})
    >>> for key in sorted(bug_dict.keys()):
    ...     print "%s: %s" % (key, bug_dict[key])
    alias:
    assigned_to: test@canonical.com
    component: GPPSystems
    creation_time: 20080610T16:19:53
    id: 1
    internals:...
    is_open: True
    last_change_time: 20080610T16:19:53
    priority: P1
    product: HeartOfGold
    resolution: FIXED
    severity: normal
    status: RESOLVED
    summary: That bloody robot still exists

If more than one ID is specified when get_bugs() is called, more than
one bug will be returned (assuming they all exist and are accessible).

    >>> bug_dicts = server.Bug.get_bugs({'ids': [1, 2]})
    >>> for bug_dict in bug_dicts:
    ...     for key in sorted(bug_dict.keys()):
    ...         print "%s: %s" % (key, bug_dict[key])
    ...     print
    alias:
    assigned_to: test@canonical.com
    component: GPPSystems
    creation_time: 20080610T16:19:53
    id: 1
    internals:...
    is_open: True
    last_change_time: 20080610T16:19:53
    priority: P1
    product: HeartOfGold
    resolution: FIXED
    severity: normal
    status: RESOLVED
    summary: That bloody robot still exists

    alias: bug-two
    assigned_to: marvin@heartofgold.ship
    component: Crew
    creation_time: 20080611T09:23:12
    id: 2
    internals:...
    is_open: True
    last_change_time: 20080611T09:24:29
    priority: P1
    product: HeartOfGold
    resolution:
    severity: high
    status: NEW
    summary: Collect unknown persons in docking bay 2.

Bug aliases can also be used to request remote bugs.

    >>> bug_dicts = server.Bug.get_bugs({'ids': ['bug-two']})
    >>> for key in sorted(bug_dict.keys()):
    ...     print "%s: %s" % (key, bug_dict[key])
    alias: bug-two
    assigned_to: marvin@heartofgold.ship
    component: Crew
    creation_time: 20080611T09:23:12
    id: 2
    internals:...
    is_open: True
    last_change_time: 20080611T09:24:29
    priority: P1
    product: HeartOfGold
    resolution:
    severity: high
    status: NEW
    summary: Collect unknown persons in docking bay 2.

XXX 2008-06-13 gmb:
We don't yet know how the Bugzilla Launchpad API will handle invalid bug
IDs (the current method of handling them is extremely sub-optimal). We
need to implement such error handling here once we know its details.
