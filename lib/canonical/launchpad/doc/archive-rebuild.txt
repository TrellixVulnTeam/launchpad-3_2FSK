== Archive rebuild ==

We model archive rebuild attempt as distinct `IArchives` targeted to
a `IDistroSeries`. This way we can have several rebuilds all with
similar purposes for different distroseries individually published in
the same location. See the example:

 1. rebuilds.ubuntu.com/warty-gcc-toolchain
 2. rebuilds.ubuntu.com/warty-gtk2.0
 3. rebuilds.ubuntu.com/hoary-gcc-toolchain
 4. rebuilds.ubuntu.com/hoary-glibc


== IArchiveRebuildSet utility ==

This utility implements methods for creating and looking up
ArchiveRebuilds.

    >>> from canonical.launchpad.interfaces.archiverebuild import (
    ...     IArchiveRebuildSet)
    >>> archiverebuild_set = getUtility(IArchiveRebuildSet)

We can iterate over existent `ArchiveRebuild`s using the
IArchvieRebuildSet utility, even when we have none in sampledata.

    >>> [rebuild.id for rebuild in archiverebuild_set]
    []

We will create some rebuilds also using the utility. For doing that we
need a target IDistroSeries and an IPerson to be the registrant.

    >>> from canonical.launchpad.interfaces.distribution import (
    ...     IDistributionSet)
    >>> from canonical.launchpad.interfaces.person import (
    ...     IPersonSet)

    >>> ubuntu = getUtility(IDistributionSet).getByName('ubuntu')
    >>> warty = ubuntu.getSeries('warty')
    >>> hoary = ubuntu.getSeries('hoary')

    >>> cprov = getUtility(IPersonSet).getByName('cprov')

`ArchiveRebuild`s get created with distinct names.

    >>> rebuild_warty = archiverebuild_set.new(
    ...     name='gcc4.0-toolchain', distroseries=warty,
    ...     registrant=cprov, reason="Because I can.")
    >>> print rebuild_warty.id, rebuild_warty.archive.name
    1 warty-gcc4.0-toolchain

    >>> rebuild_hoary = archiverebuild_set.new(
    ...     name='gcc4.0-toolchain', distroseries=hoary,
    ...     registrant=cprov, reason="Because I want.")
    >>> print rebuild_hoary.id, rebuild_hoary.archive.name
    2 hoary-gcc4.0-toolchain

Once created the ArchiveRebuild records can be seen during the
IArchiveRebuildSet iteration, which is ordered by descending database
ID, i.e. newest first.

    >>> for rebuild in archiverebuild_set:
    ...     print rebuild.archive.name
    hoary-gcc4.0-toolchain
    warty-gcc4.0-toolchain

ArchiveRebuilds are created with INPROGRESS status.

    >>> print rebuild_warty.status.name
    INPROGRESS

Archive.name collisions are detected during creation and an error is
raised.

    >>> archiverebuild_set.new(
    ...     name='gcc4.0-toolchain', distroseries=hoary,
    ...     registrant=cprov, reason="Because I want.")
    Traceback (most recent call last):
    ...
    ArchiveRebuildAlreadyExists: An archive rebuild named
    'gcc4.0-toolchain' for 'hoary' in 'ubuntu' already exists.

An ArchiveRebuild can be retrieved by database ID.

    >>> candidate = archiverebuild_set.get(rebuild_hoary.id)
    >>> print candidate.id, candidate.archive.name
    2 hoary-gcc4.0-toolchain

and also by targeted distribution and archive name.

    >>> candidate = archiverebuild_set.getByDistributionAndArchiveName(
    ...     ubuntu, 'hoary-gcc4.0-toolchain')
    >>> print candidate.id, candidate.archive.name
    2 hoary-gcc4.0-toolchain

When a corresponding rebuild cannot be found, None is returned.

    >>> print archiverebuild_set.getByDistributionAndArchiveName(
    ...     ubuntu, 'boing')
    None

Before verifying the results of getByDistroSeries() we will create
other rebuilds for hoary.

    >>> rebuild_hoary_gtk = archiverebuild_set.new(
    ...     name='gtk3', distroseries=hoary,
    ...     registrant=cprov, reason="Because we need.")

    >>> rebuild_hoary_qt = archiverebuild_set.new(
    ...     name='qt4', distroseries=hoary,
    ...     registrant=cprov, reason="Because we were forced.")

The results of getByDistroSeries() are ordered by ascending 'status'
and then descending database ID. This way, rebuilds in early
status/stages will be presented first.

    >>> for rebuild in archiverebuild_set.getByDistroSeries(hoary):
    ...     print rebuild.archive.name, rebuild.status.name
    hoary-qt4               INPROGRESS
    hoary-gtk3              INPROGRESS
    hoary-gcc4.0-toolchain  INPROGRESS

Setting 'hoary-qt4' rebuild as OBSOLETE will move it to the end of the
list, since it is a higher 'status' (see further details about rebuild
state-handling below).

    >>> login('celso.providelo@canonical.com')
    >>> rebuild_hoary_qt.setObsolete()
    >>> login(ANONYMOUS)

    >>> for rebuild in archiverebuild_set.getByDistroSeries(hoary):
    ...     print rebuild.archive.name, rebuild.status.name
    hoary-gtk3              INPROGRESS
    hoary-gcc4.0-toolchain  INPROGRESS
    hoary-qt4               OBSOLETE


== IArchiveRebuild ==

`IArchiveRebuild` objects represents a join between an `IArchive` with
REBUILD purpose and an `IDistroSeries`. It also aggregates extra
information to this relationship as 'registrant', 'status' and 'reason'.

    >>> from canonical.launchpad.interfaces.archiverebuild import (
    ...     IArchiveRebuild)
    >>> from canonical.launchpad.webapp.testing import verifyObject

    >>> verifyObject(IArchiveRebuild, rebuild_hoary_qt)
    True

Let's see what is stored for the just-created 'rebuild_hoary_qt'.

It stores the 'date_created' as the current transaction time.

    >>> from canonical.database.sqlbase import get_transaction_timestamp
    >>> rebuild_hoary_qt.date_created == get_transaction_timestamp()
    True

It correctly attaches a REBUILD archive to a hoary distroseries.

    >>> print rebuild_hoary_qt.archive.name
    hoary-qt4

    >>> print rebuild_hoary_qt.archive.purpose.name
    REBUILD

    >>> print rebuild_hoary_qt.distroseries.displayname
    Hoary

The rebuild 'registrant', the IPerson who created the rebuild.

    >>> print rebuild_hoary_qt.registrant.displayname
    Celso Providelo

Lifecyle information, the rebuild 'status' and a 'reason' text field
with further comments.

    >>> print rebuild_hoary_qt.status.name
    OBSOLETE

    >>> print rebuild_hoary_qt.reason
    Because we were forced.

A 'title' attribute is also implemented for convenience.

    >>> print rebuild_hoary_qt.title
    hoary-qt4 for Hoary


== Editing ArchiveRebuild ==

Once created, only 'status' and 'reason' can be changed in an
ArchiveRebuild record.

    >>> login('foo.bar@canonical.com')

    >>> rebuild_hoary_qt.distroseries = warty
    Traceback (most recent call last):
    ...
    ForbiddenAttribute: ('distroseries', <ArchiveRebuild at ...>)

    >>> rebuild_hoary_qt.archive = rebuild_warty.archive
    Traceback (most recent call last):
    ...
    ForbiddenAttribute: ('archive', <ArchiveRebuild at ...>)

    >>> rebuild_hoary_qt.date_created = rebuild_warty.date_created
    Traceback (most recent call last):
    ...
    ForbiddenAttribute: ('date_created', <ArchiveRebuild at ...>)

    >>> from canonical.launchpad.interfaces.person import IPersonSet
    >>> jdub = getUtility(IPersonSet).getByName('jdub')
    >>> rebuild_hoary_qt.registrant = jdub
    Traceback (most recent call last):
    ...
    ForbiddenAttribute: ('registrant', <ArchiveRebuild at ...>)

The 'status' field can't be changed directly. It is protected by a
state-machine that forces users to use special method that may trigger
further actions required to keep the rebuild workflow sane. They are:

 * setInProgress();
 * setCancelled();
 * setComplete();
 * setObsolete();

'status' attribute write is forbidden on IArchiveRebuild.

    >>> from canonical.launchpad.interfaces.archiverebuild import (
    ...      ArchiveRebuildStatus)

    >>> rebuild_hoary_qt.status = ArchiveRebuildStatus.INPROGRESS
    Traceback (most recent call last):
    ...
    ForbiddenAttribute: ('status', <ArchiveRebuild at ...>)

The same operation also results in an error if we remove the zope
security proxy.

    >>> from zope.security.proxy import removeSecurityProxy
    >>> naked_rebuild = removeSecurityProxy(rebuild_hoary_qt)
    >>> naked_rebuild.status = ArchiveRebuildStatus.INPROGRESS
    Traceback (most recent call last):
    ...
    ArchiveRebuildStatusWriteProtectedError: Directly write on archive
    rebuild status is forbidden use the provided methods to set it.

Changing the 'status' is only possible via the mentioned methods.

    >>> rebuild_hoary_qt.setComplete()
    >>> print rebuild_hoary_qt.status.name
    COMPLETE

An error is also raised if a callsite attempts to set a rebuild to the
same status is already is.

    >>> rebuild_hoary_qt.setComplete()
    Traceback (most recent call last):
    ...
    ArchiveRebuildInconsistentStateError: Archive rebuild is already in
    COMPLETE status

These fields can only be changed by users in the following teams:

 1. 'registrant';
 2. Distribution owner;
 3. Launchpad administrator.

An anonymous user cannot modify an ArchiveRebuild.

    >>> login(ANONYMOUS)
    >>> rebuild_hoary_qt.setCancelled()
    Traceback (most recent call last):
    ...
    Unauthorized: (..., 'setCancelled', 'launchpad.Edit')

    >>> rebuild_hoary_qt.reason = 'Who does need QT4 ?'
    Traceback (most recent call last):
    ...
    Unauthorized: (..., 'reason', 'launchpad.Edit')

The same goes for No Privileged user.

    >>> login('no-priv@canonical.com')

    >>> rebuild_hoary_qt.setCancelled()
    Traceback (most recent call last):
    ...
    Unauthorized: (..., 'setCancelled', 'launchpad.Edit')

    >>> rebuild_hoary_qt.reason = 'Who does need QT4 ?'
    Traceback (most recent call last):
    ...
    Unauthorized: (..., 'reason', 'launchpad.Edit')

Celso Providelo, as the rebuild registrant, can modify it.

    >>> login('celso.providelo@canonical.com')
    >>> rebuild_hoary_qt.setCancelled()
    >>> rebuild_hoary_qt.reason = 'Who does need QT4 ?'

Jeff Waugh as member of the team owning the ubuntu distribution can also
edit it.

    >>> jdub.inTeam(ubuntu.owner)
    True

    >>> login('jeff.waugh@ubuntulinux.com')
    >>> rebuild_hoary_qt.setComplete()
    >>> rebuild_hoary_qt.reason = 'I do not.'

Finally, a Launchpad administrator can also edit it, because he can do
pretty much everything he wants.

    >>> login('foo.bar@canonical.com')
    >>> rebuild_hoary_qt.setObsolete()
    >>> rebuild_hoary_qt.reason = 'I do :)'

