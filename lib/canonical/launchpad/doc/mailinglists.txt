= Team Mailing Lists =

Teams may have at most one team mailing list.  Creating a team mailing list
requires several steps, starting with registration of the list by the owner of
an existing team.  This is done through an IMailingListSet utility.

    >>> from canonical.launchpad.webapp.testing import verifyObject
    >>> from canonical.launchpad.interfaces import (
    ...     IMailingList, IMailingListSet)
    >>> list_set = getUtility(IMailingListSet)
    >>> verifyObject(IMailingListSet, list_set)
    True

In the following description of how to use team mailing lists, we will need
several teams.

    >>> from canonical.launchpad.ftests.mailinglists_helper import new_team
    >>> team_one = new_team('team-one')
    >>> team_two = new_team('team-two')
    >>> team_three = new_team('team-three')
    >>> team_four = new_team('team-four')

    # Define a helper function that sorts mailing lists alphabetically based
    # on their team's name.  We can't use operator.attrgetter() because that
    # traverses only one level of attribute.
    >>> def sorted_lists(lists):
    ...     return sorted(lists, key=lambda L: L.team.name)

None of these teams have mailing lists yet.

    >>> sorted_lists(list_set.registered_lists)
    []
    >>> sorted_lists(list_set.approved_lists)
    []
    >>> sorted_lists(list_set.active_lists)
    []
    >>> print list_set.get(team_one.name)
    None
    >>> print list_set.get(team_two.name)
    None
    >>> print list_set.get(team_three.name)
    None
    >>> print list_set.get(team_four.name)
    None


== Registering a team mailing list ==

Any team owner or administrator may start the process of creating a team
mailing list by registering the list.  By registering the mailing list, the
team administrator makes a request to have the list created, but it is not
created right away.

    >>> from datetime import datetime
    >>> import pytz
    >>> registration_date = datetime.now(pytz.timezone('UTC'))
    >>> list_one = list_set.new(team_one)
    >>> verifyObject(IMailingList, list_one)
    True
    >>> from canonical.database.sqlbase import flush_database_updates
    >>> flush_database_updates()
    >>> list_one
    <MailingList for team "team-one"; status=REGISTERED at 0x...>

You can always access the mailing list through its team, if the team has a
mailing list.

    >>> team_one.mailing_list
    <MailingList for team "team-one"; status=REGISTERED at 0x...>
    >>> print team_two.mailing_list
    None

You may not register a mailing list for a person.

    >>> from canonical.launchpad.ftests.mailinglists_helper import new_person
    >>> login('foo.bar@canonical.com')
    >>> anne = new_person('Anne')
    >>> login(ANONYMOUS)
    >>> list_set.new(anne, anne)
    Traceback (most recent call last):
    ...
    AssertionError: Cannot register a list for a person who is not a team

The mailing list registrant must be a team owner or administrator.  salgado is
neither and thus may not create a list for team_two.

    >>> list_set.new(team_two, anne)
    Traceback (most recent call last):
    ...
    AssertionError: registrant is not a team owner or administrator

However, if we make Anne a team administrator, she can then register the
mailing list.

    >>> from canonical.launchpad.interfaces import TeamMembershipStatus
    >>> login('foo.bar@canonical.com')
    >>> bart = new_person('Bart')
    >>> team_two.addMember(anne, bart, status=TeamMembershipStatus.ADMIN)
    >>> login(ANONYMOUS)
    >>> flush_database_updates()
    >>> list_two = list_set.new(team_two, anne)
    >>> list_two
    <MailingList for team "team-two"; status=REGISTERED at ...>
    >>> list_two.address
    u'team-two@lists.launchpad.dev'

The newly registered mailing list is linked to its team, and the list's
registrant is the team owner at the time the list was registered.  The list's
registration date is set, and its status is set to REGISTERED.

    >>> list_one.team.displayname
    u'Team One'
    >>> list_one.registrant.name
    u'no-priv'
    >>> # We have to compare dates this way because of minor clock skew
    >>> # between the Python process and the database (which is where
    >>> # date_registered comes from).  Also, Python's date objects don't
    >>> # support timezones.
    >>> list_one.date_registered.date() == registration_date.date()
    True
    >>> list_one.status.name
    'REGISTERED'

The mailing list has no reviewer or review date, nor an activation date or
welcome message text.

    >>> print list_one.reviewer
    None
    >>> print list_one.date_reviewed
    None
    >>> print list_one.date_activated
    None
    >>> print list_one.welcome_message
    None

The mailing list's registrant does not change even if the team's owner
changes.

    >>> login('foo.bar@canonical.com')
    >>> cris = new_person('Cris')
    >>> team_one.teamowner = cris
    >>> flush_database_updates()
    >>> login(ANONYMOUS)
    >>> # new_team() uses No Privileges Person as the registrant.
    >>> list_one.registrant.name
    u'no-priv'

A mailing list cannot be registered more than once.

    >>> list_set.new(team_one)
    Traceback (most recent call last):
    ...
    AssertionError: Mailing list for team "team-one" already exists


== Reviewing a registered mailing list ==

A registered mailing list must then be reviewed by a member of
the Mailing List Experts team before the request to create it can be
made.  Use the list set to find all currently registered mailing lists.

    >>> list_three = list_set.new(team_three)
    >>> list_three
    <MailingList for team "team-three"; status=REGISTERED at ...>
    >>> list_four = list_set.new(team_four)
    >>> list_four
    <MailingList for team "team-four"; status=REGISTERED at ...>
    >>> flush_database_updates()
    >>> sorted_lists(list_set.registered_lists)
    [<MailingList for team "team-four"; status=REGISTERED at ...>,
     <MailingList for team "team-one"; status=REGISTERED at ...>,
     <MailingList for team "team-three"; status=REGISTERED at ...>,
     <MailingList for team "team-two"; status=REGISTERED at ...>]

A mailing list's registration cannot be reviewed by somebody who doesn't
participate in the Mailing List Experts team.

    >>> from canonical.launchpad.ftests import syncUpdate
    >>> from canonical.launchpad.interfaces import (
    ...     ILaunchpadCelebrities, MailingListStatus)
    >>> mailing_list_experts = getUtility(
    ...     ILaunchpadCelebrities).mailing_list_experts
    >>> login('foo.bar@canonical.com')
    >>> dirk = new_person('Dirk')
    >>> login(ANONYMOUS)
    >>> dirk.hasParticipationEntryFor(mailing_list_experts)
    False
    >>> list_one.review(dirk, MailingListStatus.APPROVED)
    Traceback (most recent call last):
    ...
    AssertionError: Reviewer must be a member of the Mailing List Experts team

A mailing list expert is required to approve the registration.

    >>> lpadmin = list(mailing_list_experts.allmembers)[0]
    >>> list_one.review(lpadmin, MailingListStatus.APPROVED)
    >>> syncUpdate(list_one)
    >>> list_one.status.name
    'APPROVED'
    >>> list_one.date_reviewed
    CURRENT_TIMESTAMP AT TIME ZONE 'UTC'


If Dirk becomes a member of the Mailing List Experts, he'll be able to approve
a list.

    >>> login('foo.bar@canonical.com')
    >>> mailing_list_experts.addMember(dirk, lpadmin)
    >>> login(ANONYMOUS)
    >>> list_four.review(dirk, MailingListStatus.APPROVED)
    >>> syncUpdate(list_four)
    >>> list_four.status.name
    'APPROVED'

A mailing list that has already been reviewed, may not be re-reviewed.

    >>> list_one.review(dirk, MailingListStatus.APPROVED)
    Traceback (most recent call last):
    ...
    AssertionError: Only unreviewed mailing lists may be reviewed
    >>> list_one.review(dirk, MailingListStatus.DECLINED)
    Traceback (most recent call last):
    ...
    AssertionError: Only unreviewed mailing lists may be reviewed

A reviewer may also decline a mailing list registration.

    >>> list_two.review(dirk, MailingListStatus.DECLINED)
    >>> syncUpdate(list_two)
    >>> list_two.status.name
    'DECLINED'

A reviewer may not review a mailing list to a state other than approved or
declined.

    >>> list_three.review(dirk, MailingListStatus.ACTIVE)
    Traceback (most recent call last):
    ...
    AssertionError: Reviewed lists may only be approved or declined

Once approved or declined the lists won't be re-considered for review.

    >>> sorted_lists(list_set.registered_lists)
    [<MailingList for team "team-three"; status=REGISTERED at ...>]

Approve the other list to illustrate some additional outcomes later
on.

    >>> list_three.review(dirk, MailingListStatus.APPROVED)
    >>> syncUpdate(list_three)
    >>> list(list_set.registered_lists)
    []


== Constructing mailing lists ==

Once a team mailing list has been approved, it can be constructed by Mailman.
This happens by returning the set of approved mailing lists through the XMLRPC
interface used by Mailman (not shown here).  When Mailman retrieves the set of
mailing lists to construct, the list's statuses are set to the CONSTRUCTING
state.

    >>> sorted_lists(list_set.approved_lists)
    [<MailingList for team "team-four"; status=APPROVED at ...>,
     <MailingList for team "team-one"; status=APPROVED at ...>,
     <MailingList for team "team-three"; status=APPROVED at ...>]

    >>> list_one.startConstructing()
    >>> flush_database_updates()
    >>> list_one.status.name
    'CONSTRUCTING'

A mailing list that has been declined may not be constructed.

    >>> list_two.startConstructing()
    Traceback (most recent call last):
    ...
    AssertionError: Only approved mailing lists may be constructed

Once in the construction phase, a list is no longer in the approval state.

    >>> sorted_lists(list_set.approved_lists)
    [<MailingList for team "team-four"; status=APPROVED at ...>,
     <MailingList for team "team-three"; status=APPROVED at ...>]

Lists should never be constructed more than once.

    >>> list_one.startConstructing()
    Traceback (most recent call last):
    ...
    AssertionError: Only approved mailing lists may be constructed

Construct a couple of other lists to illustration some additional outcomes
later.

    >>> list_three.startConstructing()
    >>> list_four.startConstructing()
    >>> flush_database_updates()


== Reporting the results of construction ==

After Mailman has worked at constructing lists for a while, it reports (again
through XMLRPC not shown here) on the status of each list construction.  Most,
if not all will succeed, thus activating the team's mailing list. Also, once
a mailing list is made active, its email address is registered in Launchpad
and associated with the team's mailing list, so that it can be used as the
team's contact address.

    >>> from canonical.launchpad.interfaces import IEmailAddressSet
    >>> email_set = getUtility(IEmailAddressSet)
    >>> print email_set.getByEmail(list_one.address)
    None
    >>> print list_one.date_activated
    None

    >>> list_one.transitionToStatus(MailingListStatus.ACTIVE)
    >>> list_three.transitionToStatus(MailingListStatus.ACTIVE)
    >>> flush_database_updates()
    >>> list_one.status.name
    'ACTIVE'
    >>> list_three.status.name
    'ACTIVE'
    >>> email_set.getByEmail(list_one.address).status.name
    'VALIDATED'
    >>> list_one.date_activated
    CURRENT_TIMESTAMP AT TIME ZONE 'UTC'


Some list constructions may fail.

    >>> list_four.transitionToStatus(MailingListStatus.FAILED)
    >>> flush_database_updates()
    >>> list_four.status.name
    'FAILED'

You can then get the mailing list for a team, given the team name.

    >>> list_set.get(team_one.name)
    <MailingList for team "team-one"; status=ACTIVE at ...>
    >>> list_set.get(team_two.name)
    <MailingList for team "team-two"; status=DECLINED at ...>
    >>> list_set.get(team_three.name)
    <MailingList for team "team-three"; status=ACTIVE at ...>
    >>> list_set.get(team_four.name)
    <MailingList for team "team-four"; status=FAILED at ...>

This method will return None for missing teams or non-team people.

    >>> print list_set.get('not an existing team')
    None
    >>> print list_set.get(dirk.name)
    None


== Deactivating lists ==

A list which is active may be deactivated.

    >>> login(list_three.team.teamowner.preferredemail.email)
    >>> list_three.deactivate()
    >>> flush_database_updates()
    >>> list_three.status.name
    'DEACTIVATING'

This doesn't immediately deactivate the mailing list though.  Mailman still
needs to query for the requested deactivations, take the necessary actions,
and report the deactivation results.

    >>> sorted_lists(list_set.deactivated_lists)
    [<MailingList for team "team-three"; status=DEACTIVATING at ...>]
    >>> list_three.transitionToStatus(MailingListStatus.INACTIVE)
    >>> list_three.status.name
    'INACTIVE'

Once a list's deactivation is complete, its email address' status is set to
NEW.

    >>> email_set.getByEmail(list_three.address).status.name
    'NEW'

But lists which are not active may not be deactivated.

    >>> list_two.deactivate()
    Traceback (most recent call last):
    ...
    AssertionError: Only active mailing lists may be deactivated
    >>> list_four.deactivate()
    Traceback (most recent call last):
    ...
    AssertionError: Only active mailing lists may be deactivated


== Reactivating lists ==

A list which is inactive may be reactivated.

    >>> list_three.status.name
    'INACTIVE'
    >>> list_three.reactivate()

This doesn't immediately reactivate the mailing list though.  Mailman still
needs to query for the requested reactivations, take the necessary actions,
and report the reactivation results.

    >>> list_three.status.name
    'APPROVED'

But lists which are not inactive may not be reactivated.

    >>> list_three.reactivate()
    Traceback (most recent call last):
    ...
    AssertionError: Only inactive mailing lists may be reactivated


== Cancelling registrations ==

Any mailing list in the REGISTERED state can be cancelled.  Mailing lists in
any other state can't though.

    >>> guitarists = new_team('guitarists')
    >>> guitarists_list = list_set.new(guitarists)
    >>> guitarists_list
    <MailingList for team "guitarists"; status=REGISTERED...
    >>> guitarists_list.cancelRegistration()
    >>> print list_set.get('guitarists')
    None

    >>> list_three.cancelRegistration()
    Traceback (most recent call last):
    ...
    AssertionError: Only mailing lists in the REGISTERED state...


== Mailing list permissions ===

Permissions on a team's mailing list are not tracked separately from
permissions on the team.


== Welcome messages ==

Mailing lists have a welcome message text which is sent to new members when
they subscribe to a list.  The welcome message can contain any text.

    >>> print list_one.welcome_message
    None
    >>> login('foo.bar@canonical.com')
    >>> list_one.welcome_message = """\
    ... Welcome to the Team One mailing list."""
    >>> login(ANONYMOUS)
    >>> flush_database_updates()
    >>> list_one.welcome_message
    u'Welcome to the Team One mailing list.'

After changing the welcome message, the list's status should be MODIFIED.

    >>> list_one.status.name
    'MODIFIED'
    >>> sorted_lists(list_set.modified_lists)
    [<MailingList for team "team-one"; status=MODIFIED at ...>]

Eventually, Mailman will get around to acting on this modification.  When it
does so, the list's state transitions first to UPDATING so as to avoid
multiple modifications.  Transitioning to the ACTIVE state while still
MODIFIED is not allowed.

    >>> list_one.transitionToStatus(MailingListStatus.ACTIVE)
    Traceback (most recent call last):
    ...
    AssertionError: Not a valid state transition: Modified -> Active

What really happens is that the list's state is first transitioned to
UPDATING, and then to ACTIVE or FAILED.

    >>> list_one.startUpdating()
    >>> flush_database_updates()
    >>> list_one.status.name
    'UPDATING'
    >>> list_one.transitionToStatus(MailingListStatus.ACTIVE)
    >>> flush_database_updates()
    >>> list_one.status.name
    'ACTIVE'

A mailing list's welcome message can also be changed while it is in REGISTERED
status.  This is essentially equivalent to initializing the mailing list with
a particular welcome message.

    >>> team_five = new_team('team-five')
    >>> list_five = list_set.new(team_five)
    >>> login('foo.bar@canonical.com')
    >>> list_five.welcome_message = u'Welcome to Team Five'
    >>> login(ANONYMOUS)
    >>> flush_database_updates()
    >>> list_five.status.name
    'REGISTERED'

You cannot change the welcome message text for a mailing list in anything but
ACTIVE or REGISTERED status.

    >>> login('foo.bar@canonical.com')
    >>> list_two.welcome_message = """\
    ... This list has been declined."""
    Traceback (most recent call last):
    ...
    AssertionError: Only registered or usable mailing lists may be modified

    >>> list_four.welcome_message = """\
    ... This list has been deactivated."""
    Traceback (most recent call last):
    ...
    AssertionError: Only registered or usable mailing lists may be modified


== Renaming teams with mailing lists ==

A team that has a mailing list may not be renamed.

    >>> login('no-priv@canonical.com')
    >>> team_one.name = 'team-canonical'
    Traceback (most recent call last):
    ...
    AssertionError: Cannot rename teams with mailing lists

But a team with no mailing list (yet) can still be renamed.

    >>> team_six = new_team('team-six')
    >>> team_six.name = 'team-canonical'
    >>> team_six.name
    u'team-canonical'


== Team archive links ==

Mailing lists have archives, accessible through a list-specific url.  However,
if a mailing list has never be activated, it won't have an archive url.

    >>> print list_two.archive_url
    None

An active mailing list has an archive url.

    >>> list_one.status.name
    'ACTIVE'
    >>> list_one.archive_url
    u'http://lists.launchpad.dev/team-one'

Inactive mailing lists also have an archive url, because once activated, a
mailing list could have an archive and archives are never deleted.

    >>> list_one.deactivate()
    >>> list_one.transitionToStatus(MailingListStatus.INACTIVE)
    >>> list_one.status.name
    'INACTIVE'
    >>> list_one.archive_url
    u'http://lists.launchpad.dev/team-one'


== Events ==

Activating the mailing list (changing it's status to 'available for
subscription') will fire an instance of the SQLObjectModifiedEvent.

    # Register an event listener that will print event it receives.
    >>> from canonical.launchpad.event.interfaces import (
    ...     ISQLObjectModifiedEvent)
    >>> from canonical.launchpad.interfaces import IMailingList
    >>> from canonical.launchpad.ftests.event import TestEventListener
    >>> def print_event(object, event):
    ...     print "Received %s on %s" % (
    ...         event.__class__.__name__.split('.')[-1],
    ...         object.__class__.__name__.split('.')[-1])
    >>> mailinglist_event_listener = TestEventListener(
    ...     IMailingList, ISQLObjectModifiedEvent, print_event)


    # We need to build a new mailing list to use in our tests
    >>> list_six = list_set.new(team_six)
    >>> list_six.review(dirk, MailingListStatus.APPROVED)
    >>> syncUpdate(list_six)
    >>> list_six.startConstructing()
    >>> list_six.status.name
    'CONSTRUCTING'

    >>> list_six.transitionToStatus(MailingListStatus.ACTIVE)
    Received SQLObjectModifiedEvent on MailingList
    >>> syncUpdate(list_six)
    >>> list_six.status.name
    'ACTIVE'

    # Cleanup
    >>> mailinglist_event_listener.unregister()
