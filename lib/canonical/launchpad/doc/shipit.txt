ShipIt
======

ShipIt is our application to ship Ubuntu CDs to our users. Any user can
make an request with any number of CDs, and as soon as the request is approved,
these CDs are sent to the user.

  >>> from datetime import date
  >>> from zope.component import getUtility
  >>> from zope.interface.verify import verifyObject
  >>> from canonical.lp.dbschema import ShipItFlavour, ShipItArchitecture
  >>> from canonical.database.sqlbase import flush_database_updates
  >>> from canonical.launchpad.ftests import login
  >>> from canonical.launchpad.interfaces import (
  ...    IStandardShipItRequestSet, IShippingRequestSet, IPersonSet,
  ...    IShippingRequest, ILaunchBag, ShippingRequestStatus, IShipmentSet,
  ...    ShippingRequestPriority)
  >>> requestset = getUtility(IShippingRequestSet)
  >>> foobar = getUtility(IPersonSet).getByEmail('foo.bar@canonical.com')

Let's create a new request for foo.bar@canonical.com.

  >>> UBUNTU = ShipItFlavour.UBUNTU
  >>> X86 = ShipItArchitecture.X86
  >>> AMD64 = ShipItArchitecture.AMD64
  >>> PPC = ShipItArchitecture.PPC
  >>> recipient = foobar
  >>> country = 31 # Brazil
  >>> city = 'some city'
  >>> addressline1 = 'address1'
  >>> name = 'the name'
  >>> phone = '+551635015218'
  >>> reason = ("I'm going to give away some CDs in the next meeting of my "
  ...           "city's LUG.")
  >>> request = requestset.new(recipient, name, country, city,
  ...                          addressline1, phone, reason=reason)
  >>> quantities = {UBUNTU: {X86: 30, AMD64: 5, PPC: 2}}
  >>> request.setQuantities(quantities)

We're not allowed to add a second request for the same recipient, while the
existing one is not yet exported.

  >>> request = requestset.new(recipient, name, country, city,
  ...                          addressline1, phone, reason=reason)
  Traceback (most recent call last):
  ...
  AssertionError

XXX: This check depends on the implementation of the remaining database
classes, which are linked from the request table.
  >>> #verifyObject(IShippingRequest, request)
  True

  >>> request.totalCDs
  37
  >>> recipient.currentShipItRequest() == request
  True
  
If a request is not approved yet, it'll have approved == None. If it was
approved, then approved will be True.

  >>> request.approved is None
  True

The number of CDs can be altered by the user, if he wants.

  >>> login('foo.bar@canonical.com')
  >>> quantities = {UBUNTU: {X86: 10, AMD64: 3, PPC: 1}}
  >>> request.setQuantities(quantities)
  >>> request.totalCDs
  14

When a request is approved, you must specify the approved quantities.

  >>> login('marilize@hbd.com')
  >>> request.approve(whoapproved=getUtility(ILaunchBag).user)
  >>> request.approved
  True
  >>> request.whoapproved.displayname
  u'Marilize Coetzee'
  >>> quantities = request.getRequestedCDsGroupedByFlavourAndArch()
  >>> quantities[UBUNTU][X86].quantityapproved
  10
  >>> quantities[UBUNTU][AMD64].quantityapproved
  3
  >>> quantities[UBUNTU][PPC].quantityapproved
  1

The approved quantities can be changed only if the request is approved.

  >>> quantities = {UBUNTU: {X86: 5, AMD64: 3, PPC: 2}}
  >>> request.setApprovedQuantities(quantities)
  >>> quantities = request.getRequestedCDsGroupedByFlavourAndArch()
  >>> quantities[UBUNTU][X86].quantityapproved
  5
  >>> quantities[UBUNTU][AMD64].quantityapproved
  3
  >>> quantities[UBUNTU][PPC].quantityapproved
  2

If a request is approved but hasn't been exported yet, it can still be denied.

  >>> request.deny()
  >>> request.approved
  False

A request can also be cancelled, and this means the approved and
quantity*approved will be set back to None.

  >>> request.cancel(getUtility(ILaunchBag).user)
  >>> request.cancelled
  True
  >>> request.whocancelled.displayname
  u'Marilize Coetzee'
  >>> flush_database_updates()

When a request is cancelled it'll not show up as the recipient's current
request.

  >>> recipient.currentShipItRequest() is None
  True

Instead, it'll be part of the past requests of that recipient.

  >>> request in recipient.pastShipItRequests()
  True


Searching for requests
----------------------

We have 12 custom requests. Two of them are cancelled.

  >>> [r.recipient.name 
  ...  for r in requestset.search(request_type='custom', omit_cancelled=False)]
  [u'cprov', u'ddaa', u'debonzi', u'kurem', u'ddaa', u'carlos', u'daf', 
   u'tsukimi', u'jdub', u'marilize', u'jblack', u'name16']

  >>> [r.recipient.name for r in requestset.search(request_type='custom')]
  [u'ddaa', u'debonzi', u'kurem', u'ddaa', u'carlos', u'daf', u'tsukimi',
   u'jdub', u'marilize', u'jblack']

From the ten non-cancelled, two are approved.

  >>> approved = ShippingRequestStatus.APPROVED
  >>> [r.recipient.name 
  ...  for r in requestset.search(request_type='custom', status=approved)]
  [u'ddaa', u'jblack']

We have also four non-cancelled standard requests:

  >>> [r.recipient.name for r in
  ...  requestset.search(request_type='standard', omit_cancelled=False)]
  [u'lifeless', u'kreutzm', u'no-priv', u'stub']

And all standard requests are approved automatically.

  >>> [r.recipient.name for r in
  ...       requestset.search(request_type='standard', status=approved)]
  [u'lifeless', u'kreutzm', u'no-priv', u'stub']


It's also possible to search for standard requests of a specific type.

  >>> standardrequest = getUtility(IStandardShipItRequestSet).get(3)
  >>> requests = requestset.search(request_type='standard',
  ...                              standard_type=standardrequest)
  >>> requests.count()
  1
  >>> quantities = requests[0].getRequestedCDsGroupedByFlavourAndArch()
  >>> quantities[UBUNTU][X86].quantity == standardrequest.quantityx86
  True
  >>> quantities[UBUNTU][AMD64].quantity == standardrequest.quantityamd64
  True
  >>> quantities[UBUNTU][PPC].quantity == standardrequest.quantityppc
  True

Another way of searching is by using any part of the recipient's name or the
beginning of his email address.

  >>> [r.recipient.displayname 
  ...  for r in requestset.search(recipient_text='Kreutzmann')]
  [u'Helge Kreutzmann']

  >>> [r.recipient.preferredemail.email
  ...  for r in requestset.search(recipient_text='Stuart.Bishop')]
  [u'stuart.bishop@canonical.com']

  >>> [r.recipient.preferredemail.email
  ...  for r in requestset.search(status=ShippingRequestStatus.PENDING,
  ...                             recipient_text='david.allouche')]
  [u'david.allouche@canonical.com']


Exporting requests
------------------

When exporting requests, we'll want to get all approved requests that weren't
approved yet, with a given priority. This is done using the
getUnshippedRequests method of ShippingRequestSet.

  >>> requestset.getUnshippedRequests(ShippingRequestPriority.NORMAL).count()
  4

Now we do an export of all normal priority orders that are ready to be
shipped.

  >>> from canonical.librarian.ftests.harness import LibrarianTestSetup
  >>> LibrarianTestSetup().setUp()

  >>> import subprocess
  >>> process = subprocess.Popen(
  ...     'cronscripts/shipit-exports.py -q --priority=normal', shell=True,
  ...     stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
  >>> (out, err) = process.communicate()
  >>> out, err
  ('', '')
  >>> process.returncode
  0

  >>> import transaction
  >>> transaction.commit()
  >>> requestset.getUnshippedRequests(ShippingRequestPriority.NORMAL).count()
  0

  >>> LibrarianTestSetup().tearDown()


Generating reports
------------------

To help Jane with marketing decisions, we need to generate periodic reports
based on shipit data.

One of the reports we can generate gives us information about orders shipped
to each country.

    >>> csv_file = requestset.generateCountryBasedReport()
    >>> for line in csv_file.readlines():
    ...     line
    'Country,Shipped Ubuntu x86 CDs,Shipped Ubuntu AMD64 CDs,Shipped Ubuntu PPC CDs,Shipped KUbuntu x86 CDs,Shipped KUbuntu AMD64 CDs,Shipped KUbuntu PPC CDs,Shipped EdUbuntu x86 CDs,Shipped EdUbuntu AMD64 CDs,Shipped EdUbuntu PPC CDs,Normal-prio shipments,High-prio shipments,Average request size,Percentage of requested CDs that were approved,Percentage of total shipped CDs,Continent\r\n'
    'Bermuda,5,3,2,0,0,0,0,0,0,1,0,10,100.00%,12.35%,North America\r\n'
    'British Indian Ocean Territory,9,6,9,0,0,0,0,0,0,1,0,24,100.00%,29.63%,Asia\r\n'
    'Burkina Faso,10,3,2,0,0,0,0,0,0,1,0,15,100.00%,18.52%,Africa\r\n'
    'China,0,3,0,0,0,0,0,0,0,1,0,3,100.00%,3.70%,Asia\r\n'
    'Heard Island and McDonald Islands,5,0,0,0,0,0,0,0,0,1,0,5,100.00%,6.17%,Antarctica\r\n'
    '\xc3\x85land Islands,9,6,9,0,0,0,0,0,0,0,1,24,100.00%,29.63%,Europe\r\n'

There's another report which gives us the number of shipments of all shipment
sizes we had.

    >>> csv_file = requestset.generateShipmentSizeBasedReport()
    >>> for line in csv_file.readlines():
    ...     line
    'Number of CDs,Number of Shipments\r\n'
    '3,1\r\n'
    '5,1\r\n'
    '10,1\r\n'
    '15,1\r\n'
    '24,2\r\n'

There's also a report of requests by week.

    >>> start_date = date(2005, 4, 1)
    >>> end_date = date(2005, 7, 1)
    >>> csv_file = requestset.generateWeekBasedReport(start_date, end_date)
    >>> for line in csv_file.readlines():
    ...     line
    'Year,Week number,Requests,Ubuntu Requested X86 CDs,Ubuntu Requested AMD64 CDs,Ubuntu Requested PPC CDs,KUbuntu Requested X86 CDs,KUbuntu Requested AMD64 CDs,KUbuntu Requested PPC CDs,EdUbuntu Requested X86 CDs,EdUbuntu Requested AMD64 CDs,EdUbuntu Requested PPC CDs\r\n'
    '2005,14,0,,,,,,,,,\r\n'
    '2005,15,0,,,,,,,,,\r\n'
    '2005,16,0,,,,,,,,,\r\n'
    '2005,17,4,36,23,31,0,0,0,0,0,0\r\n'
    '2005,18,4,36,18,46,0,0,0,0,0,0\r\n'
    '2005,19,1,9,6,9,0,0,0,0,0,0\r\n'
    '2005,20,1,9,6,9,0,0,0,0,0,0\r\n'
    '2005,21,0,,,,,,,,,\r\n'
    '2005,22,0,,,,,,,,,\r\n'
    '2005,23,0,,,,,,,,,\r\n'
    '2005,24,0,,,,,,,,,\r\n'
    '2005,25,0,,,,,,,,,\r\n'
    '2005,26,1,10,3,2,0,0,0,0,0,0\r\n'

All these reports are generated periodically and stored in the Librarian by
the shipit-reports cronscript.

  >>> LibrarianTestSetup().setUp()

  >>> process = subprocess.Popen(
  ...     'cronscripts/shipit-reports.py -q', shell=True,
  ...     stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
  >>> (out, err) = process.communicate()
  >>> out, err
  ('', '')
  >>> process.returncode
  0

  >>> LibrarianTestSetup().tearDown()
