= Package Cache =

  >>> import transaction

  >>> from canonical.launchpad.database import (
  ...    DistributionSourcePackageCache,
  ...    DistroReleasePackageCache)

  >>> from canonical.launchpad.interfaces import IDistributionSet
  >>> ubuntu = getUtility(IDistributionSet)['ubuntu']
  >>> warty = ubuntu['warty']

Launchpad caches published packages (sources and binaries) details in
order to get better performance on searches.

Cached information for sources is stored in
DistributionSourcePackageCache table, including:

 * distribution, IDistribution where the source was published
 * sourcepackagename, respective ISourcePackageName
 * name, source name in text format.
 * binpkgnames, text containing all the binary package names generated
   by th source.
 * binpkgsummary, text containing all summaries of the binaries
   generated by this source.
 * binpkgdescription, text containing all descriptions of the binaries
   generated by this source.
 * fti, a tsvector generated on insert or update with the text indexes
   for name, binpkgnames, binpkgsummaries and binpkgdescriptions.


  >>> ubuntu_caches = DistributionSourcePackageCache.selectBy(
  ...     distribution=ubuntu)

  >>> ubuntu_caches.count()
  9

  >>> for cache in ubuntu_caches.orderBy('name'):
  ...     print cache.name
  alsa-utils
  cnews
  evolution
  foobar
  libstdc++
  linux-source-2.6.15
  mozilla-firefox
  netapplet
  pmount


Cached information for binaries is stored in DistroReleasePackageCache
table, including:

 * distrorelease, IDistroRelease where the binary is published.
 * binarypackagename, respective IBinaryPackageName.
 * name, binary name in text format.
 * summary, binary summary in text format.
 * description, binary description in text format.
 * summaries, binary summaries  in text format
 * descriptions, binary description in text format.
 * fti, a tsvector generated on insert or update with the text indexes
   for name, summary, description, summaries and descriptions.


  >>> warty_caches = DistroReleasePackageCache.selectBy(distrorelease=warty)
  >>> warty_caches.count()
  4
  >>> for cache in warty_caches.orderBy('name'):
  ...     print cache.name
  at
  linux-2.6.12
  mozilla-firefox
  pmount

Different than sources, where multiple generated binaries are very
common, multiple binaries of with the same name are only possible when
versions are not the same across architectures.

Building these caches we can reach good performance on full and
partial term searching.

  >>> len(ubuntu.searchSourcePackages('mozilla'))
  1

  >>> len(ubuntu.searchSourcePackages('moz'))
  1

  >>> len(ubuntu.searchSourcePackages('biscoito'))
  0

The cache update procedure is done by cronscripts/update-pkgcache.py,
which removes obsolete records, update existing ones and add new
records during the scanning of all the publishing records. This
scripts runs periodically in our infrastructure.

A SourcePackage is present in the sampledata as REVOVED and still part
of the caches:

  >>> foobar_in_ubuntu = ubuntu.getSourcePackage('foobar')
  >>> foobar_rel = foobar_in_ubuntu.releases[0]
  >>> foobar_pub = foobar_rel.publishing_history[0]
  >>> foobar_pub.status.name
  'REMOVED'

  >>> len(ubuntu.searchSourcePackages('foobar'))
  1

  >>> foobar_cache = DistributionSourcePackageCache.selectOneBy(
  ...     distribution=ubuntu, name='foobar')

  >>> foobar_cache.id
  10

Sources cache updates are driven by distribution, IDistribution
instance offers a method for removing obsolete records in cache:

Let's use a fake logger object:

  >>> class TestLog:
  ...     def debug(self, msg):
  ...         print 'DEBUG: %s' % msg

  >>> ubuntu.removeOldCacheItems(log=TestLog())
  DEBUG: Removing cache for 'foobar' (10)

  >>> transaction.commit()

  >>> len(ubuntu.searchSourcePackages('foobar'))
  0

  >>> foobar_cache = DistributionSourcePackageCache.selectOneBy(
  ...     distribution=ubuntu, name='foobar')

  >>> foobar_cache is None
  True

Also, the sampledata provides a published cache which is not present
in the caches:

  >>> cdrkit_in_ubuntu = ubuntu.getSourcePackage('cdrkit')
  >>> cdrkit_rel = cdrkit_in_ubuntu.releases[0]
  >>> cdrkit_pub = cdrkit_rel.publishing_history[0]
  >>> cdrkit_pub.status.name
  'PUBLISHED'

  >>> len(ubuntu.searchSourcePackages('cdrkit'))
  0

  >>> cdrkit_cache = DistributionSourcePackageCache.selectOneBy(
  ...     distribution=ubuntu, name='cdrkit')

  >>> cdrkit_cache is None
  True

We can invoke the cache updater directly on IDistrorelease:

  >>> ubuntu.updateCompleteSourcePackageCache(
  ...    ztm=transaction, log=TestLog())
  DEBUG: Considering 'mozilla-firefox'
  ...
  DEBUG: Considering 'cdrkit'
  DEBUG: Creating new cache entry.
  DEBUG: Considering version 1.0


The current transaction should be committed again, to catch the
partial batches (less than 50 sources considered) and also updates
should be flushed since the 'name' (among other texts) are set after
the row creation:

XXX cprov 20061201: it can be considered a bug.

  >>> transaction.commit()

  >>> from canonical.database.sqlbase import flush_database_updates
  >>> flush_database_updates()

Now we the 'cdrkit' source is part of the caches and can be reached
via searches:

  >>> len(ubuntu.searchSourcePackages('cdrkit'))
  1

  >>> cdrkit_cache = DistributionSourcePackageCache.selectOneBy(
  ...     distribution=ubuntu, name='cdrkit')

  >>> cdrkit_cache.id
  11L

