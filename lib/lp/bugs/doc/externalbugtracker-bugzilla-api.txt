Bugzilla bugtrackers with an XML-RPC API
========================================

Instances of Bugzilla version 3.4+ offer an XML-RPC API for working with
bugs. This is very similar in some regards to that offered by the
Launchpad plugin for versions 3.0 and 3.2, however the differences
between them necessitate Launchpad's support for Bugzilla 3.4+ being
implemented as a separate ExternalBugTracker.

As with the BugzillaLPPlugin ExternalBugTracker, we use a special XML-RPC
transport for the purposes of testing.

    >>> from lp.bugs.externalbugtracker.bugzilla import (
    ...     BugzillaAPI)
    >>> from lp.bugs.tests.externalbugtracker import (
    ...     TestBugzillaAPIXMLRPCTransport)
    >>> test_transport = TestBugzillaAPIXMLRPCTransport(
    ...     'http://bugzilla-3.4.example.com/')
    >>> bugzilla = BugzillaAPI(
    ...     'http://bugzilla-3.4.example.com/',
    ...     xmlrpc_transport=test_transport)
    >>> bugzilla.xmlrpc_transport == test_transport
    True


Authentication
--------------

Any XML-RPC method that modifies data on the remote server requires the
user to be logged in. The Bugzilla 3.4 API provides a method to do this
using a username and password.

The BugzillaAPI._authenticate() method is responsible for attempting to
log in to the remote server.

    >>> test_transport.print_method_calls = True
    >>> bugzilla._authenticate()
    CALLED User.login({'login': 'foo.bar@canonical.com'...})

The authorisation cookie will be stored in the auth_cookie property of
the XML-RPC transport.

    >>> test_transport.cookie_processor.cookiejar
    <cookielib.CookieJar[Cookie(version=0, name='Bugzilla_login'...),
                         Cookie(version=0, name='Bugzilla_logincookie'...)]>

Trying to log in to a Bugzilla instance for which we have no credentials
will raise an error:

    >>> transport = TestBugzillaAPIXMLRPCTransport(
    ...     'http://thiswillfail.example.com/')
    >>> non_auth_bugzilla = BugzillaAPI(
    ...     'http://thiswillfail.example.com/',
    ...     xmlrpc_transport=transport)

    >>> non_auth_bugzilla._authenticate()
    Traceback (most recent call last):
      ...
    BugTrackerAuthenticationError: http://thiswillfail.example.com:
    No credentials found.

Trying to log in to a Bugzilla with incorrect credentials will also
raise an error.

    >>> class BadCredentialsBugzillaAPI(BugzillaAPI):
    ...
    ...     credentials = {'login': 'fail', 'password': 'fail'}

    >>> non_auth_bugzilla = BadCredentialsBugzillaAPI(
    ...     'http://thiswillfail.example.com/',
    ...     xmlrpc_transport=transport)

    >>> non_auth_bugzilla._authenticate()
    Traceback (most recent call last):
        ...
    BugTrackerAuthenticationError: http://thiswillfail.example.com:
    Fault 300: The username or password you entered is not valid.


Getting the server time
-----------------------

To be able to accurately sync with a bug tracker, we need to be able to
check the time on the remote server. We use BugzillaAPI.getCurrentDBTime()
to get the current time on the remote server.

    # There's no way to create a UTC timestamp without monkey-patching
    # the TZ environment variable. Rather than do that, we create our
    # own datetime and work with that.
    >>> from datetime import datetime
    >>> remote_time = datetime(2009, 8, 19, 17, 2, 2)

    >>> test_transport.local_datetime = remote_time
    >>> bugzilla.getCurrentDBTime()
    CALLED Bugzilla.time()
    datetime.datetime(2009, 8, 19, 17, 2, 2, tzinfo=<UTC>)

If the remote system is in a different timezone, getCurrentDBTime() will
convert its time to UTC before returning it.

    >>> test_transport.utc_offset = 60**2
    >>> test_transport.timezone = 'CET'
    >>> bugzilla.getCurrentDBTime()
    CALLED Bugzilla.time()
    datetime.datetime(2009, 8, 19, 16, 2, 2, tzinfo=<UTC>)

This works whether the UTC offset is positive or negative.

    >>> test_transport.utc_offset = -5 * 60**2
    >>> test_transport.timezone = 'US/Eastern'
    >>> bugzilla.getCurrentDBTime()
    CALLED Bugzilla.time()
    datetime.datetime(2009, 8, 19, 22, 2, 2, tzinfo=<UTC>)


Initializing the bug database
-----------------------------

BugzillaAPI implements IExternalBugTracker.initializeRemoteBugDB(),
which takes a list of bug IDs to fetch from the remote server and stores
those bugs locally for future use.

    >>> bugzilla.initializeRemoteBugDB([1, 2])
    CALLED Bug.get({'ids': [1, 2], 'permissive': True})

The bug data is stored as a list of dicts:

    >>> def print_bugs(bugs):
    ...     for bug in sorted(bugs):
    ...         print "Bug %s:" % bug
    ...         for key in sorted(bugzilla._bugs[bug]):
    ...             print "    %s: %s" % (key, bugzilla._bugs[bug][key])
    ...         print "\n"

    >>> print_bugs(bugzilla._bugs)
    Bug 1:
        alias:
        assigned_to: test@canonical.com
        component: GPPSystems
        creation_time: 20080610T16:19:53
        id: 1
        internals:...
        is_open: True
        last_change_time: 20080610T16:19:53
        priority: P1
        product: Marvin
        resolution: FIXED
        severity: normal
        status: RESOLVED
        summary: That bloody robot still exists.
    <BLANKLINE>
    Bug 2:
        alias: bug-two
        assigned_to: marvin@heartofgold.ship
        component: Crew
        creation_time: 20080611T09:23:12
        id: 2
        internals:...
        is_open: True
        last_change_time: 20080611T09:24:29
        priority: P1
        product: HeartOfGold
        resolution:
        severity: high
        status: NEW
        summary: Collect unknown persons in docking bay 2.
    <BLANKLINE>
    <BLANKLINE>


Storing bugs
------------

initializeRemoteBugDB() uses the _storeBugs() method to store bug data.
_storeBugs() will only store a bug once, even if it is requested both by
alias and ID. We'll reset the test BugzillaAPI's _bugs and _bug_aliases
dicts to demonstrate this.

    >>> bugzilla._bugs = {}
    >>> bugzilla._bug_aliases = {}
    >>> bugzilla.initializeRemoteBugDB([2, 'bug-two'])
    CALLED Bug.get({'ids': [2, 'bug-two'], 'permissive': True})

    >>> for bug in sorted(bugzilla._bugs):
    ...     print "Bug %r:" % bug
    ...     for key in sorted(bugzilla._bugs[bug]):
    ...         print "    %s: %s" % (key, bugzilla._bugs[bug][key])
    ...     print "\n"
    Bug 2:
        alias: bug-two
        assigned_to: marvin@heartofgold.ship
        component: Crew
        creation_time: 20080611T09:23:12
        id: 2
        internals:...
        is_open: True
        last_change_time: 20080611T09:24:29
        priority: P1
        product: HeartOfGold
        resolution:
        severity: high
        status: NEW
        summary: Collect unknown persons in docking bay 2.
    <BLANKLINE>
    <BLANKLINE>

Aliases are stored in a separate dict, which contains a mapping between
the alias and the bug's actual ID.

    >>> for alias, bug_id in bugzilla._bug_aliases.items():
    ...     print "%s: %s" % (alias, bug_id)
    bug-two: 2

The method _getActualBugId() returns the correct bug ID for a passed bug
ID or alias.

    >>> bugzilla._getActualBugId('bug-two')
    2

    >>> bugzilla._getActualBugId(2)
    2
