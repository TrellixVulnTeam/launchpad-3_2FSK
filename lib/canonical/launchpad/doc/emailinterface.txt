Malone's Email Interface
========================

Malone has an email interface, with which you may submit new bugs, add
comments, and editing bugs. The email interface has a number of
different command. Commands can be interleaved within a comment, so in
order to distinguish them from the comment, the commands have to be
indented with at least one space or tab character. The available
commands are described later on.

Submit a new bug
----------------

In order to submit a new bug you send a GPG signed email to
new@malone-domain. Note that you have to have registered your key in
Launchpad as well. The subject of the email will be used as the summary
of the bug, and the body will be used as the description. In the body of
the email you have tell on what you file a bug, either a product or a
distribution. You do so by issuing an 'affects' command. The simplest
case is either:

    affects /products/$product_name

to file a bug on a product, or:

    affects /distros/$distribution_name

to file a bug on a distribution. And if you want to file a bug on a
specific source package in a distribution:

    affects /distros/$distribution_name/$sourcepackage_name

But if you want you can use any of the available commands as well.

Let's take an example where we file a bug on Firefox:

    >>> submit_mail = """From: Sample Person <test@canonical.com>
    ... To: new@bugs.launchpad.ubuntu.com
    ... Date: Fri Jun 17 10:20:23 BST 2005
    ... Subject: A bug in Firefox
    ... 
    ... There is a bug in Firefox.
    ...
    ...  affects /products/firefox"""

Now, in order to really submit the bug, this email would have to be PGP
signed, so that the system can verify the sender. But to avoid having
to sign each email, we'll create a class which fakes a signed email:

    >>> import email
    >>> import email.Utils
    >>> class SignedMessage(email.Message.Message):
    ...     def signedMessage(self):
    ...         return self
    ...     signedMessage = property(signedMessage) 

And since we'll pass the email directly to the correct handler,
we'll have to authenticate the user manually:

    >>> from canonical.launchpad.ftests import login
    >>> login('test@canonical.com')

Now if we pass the message to the Malone handler, we can see that the
bug got submitted correctly:

    >>> from canonical.librarian.ftests.harness import LibrarianTestSetup
    >>> from canonical.launchpad.mail.handlers import MaloneHandler
    >>> handler = MaloneHandler()
    >>> def process_email(raw_mail): 
    ...     msg = email.message_from_string(raw_mail, _class=SignedMessage)
    ...     if not msg.has_key('Message-Id'):
    ...         msg['Message-Id'] = email.Utils.make_msgid()
    ...     handler.process(msg, msg['To'])
    >>> LibrarianTestSetup().setUp()

    >>> process_email(submit_mail)

    >>> import transaction
    >>> from canonical.launchpad.interfaces import IBugSet
    >>> from canonical.launchpad.mail import stub
    >>> bugset = getUtility(IBugSet)
    >>> def get_latest_added_bug():
    ...     transaction.commit() # Need to commit for the email to be sent.
    ...     from_addr, to_addrs, raw_message = stub.test_emails[-1]
    ...     msg = email.message_from_string(raw_message)
    ...     bug_nr = int(msg['Subject'].split()[1][:-1])
    ...     return bugset.get(bug_nr)
    >>> bug = get_latest_added_bug() 

    >>> print bug.title
    A bug in Firefox
    >>> print bug.description
    There is a bug in Firefox.
    <BLANKLINE>
     affects /products/firefox

Also, an upstream bug task was added to it:

    >>> len(bug.bugtasks)
    1
    >>> upstream_task = bug.bugtasks[0]
    >>> print upstream_task.product.name
    firefox

And the entire body of the email was added as a comment:

    >>> len(bug.messages)
    1
    >>> comment = bug.messages[0]
    >>> print comment.title
    A bug in Firefox
    >>> print comment.contents
    There is a bug in Firefox.
    <BLANKLINE>
     affects /products/firefox

The owner of the bug was set to the submitter:

    >>> print bug.owner.displayname
    Sample Person

If we would file a bug on Debian instead, we would submit a mail like
this:

    >>> submit_mail = """From: Sample Person <test@canonical.com>
    ... To: new@bugs.canonical.com
    ... Date: Fri Jun 17 10:20:23 BST 2005
    ... Subject: A bug in Debian's Evolution package
    ... 
    ... There's a bug in Debian.
    ...  affects /distros/debian/evolution
    ... """
    >>> process_email(submit_mail)
    >>> bug = get_latest_added_bug() 

    >>> print bug.title
    A bug in Debian's Evolution package

    >>> distrotask = bug.bugtasks[0]
    >>> print distrotask.distribution.name
    debian
    >>> print distrotask.sourcepackagename.name
    evolution


Add a comment
-------------

After a bug has been submitted a notification is sent out. The reply-to
address is set to the bug address, $bugid@malone-domain. We can send
emails to this address in order to add new comments to the bug. Note
that we can interleave commands in the comment as well. If the comment
includes commands, the email has to be GPG signed.

    >>> comment_mail = """From: test@canonical.com
    ... To: 1@malone-domain
    ... Date: Fri Jun 17 10:20:23 BST 2005
    ... Message-Id: <yada-yada-test1>
    ... Subject: New comment to bug 1
    ...
    ... Adding a comment via the email system. Let's change the summary
    ... as well:
    ...     summary "Better summary"
    ...
    ... /Sample Person
    ... """

    >>> process_email(comment_mail)
    >>> transaction.commit()

    >>> from canonical.launchpad.interfaces import IMessageSet
    >>> bug_one = bugset.get(1)
    >>> added_message = getUtility(IMessageSet).get('<yada-yada-test1>')[0]
    >>> added_message in bug_one.messages
    True
    >>> print bug_one.title
    Better summary

If the message doesn't have a Reference or In-Reply-To header, the
parent will be set to the bug's initial message.

    >>> added_message.parent == bug_one.initial_message
    True


Edit bugs
---------

Sometimes you may want to simply edit a bug, without adding a comment.
For that you can send mails to edit@malone-domain.

    >>> bug_four = bugset.get(4)
    >>> bug_five = bugset.get(5)
    >>> bug_four_comments = len(bug_four.messages)
    >>> bug_five_comments = len(bug_five.messages)
    >>> edit_mail = """From: test@canonical.com
    ... To: edit@malone-domain
    ... Date: Fri Jun 17 10:10:23 BST 2005
    ... Subject: Not important
    ...
    ...     bug 4
    ...     summary "Changed summary"
    ...
    ... It won't break if we write some stuff here.
    ...
    ...     bug 5
    ...     summary "Nicer summary"
    ... """

    >>> process_email(edit_mail)
    >>> transaction.commit()

No comments were added to the bugs:

    >>> len(bug_four.messages) == bug_four_comments
    True
    >>> len(bug_five.messages) == bug_five_comments
    True

And the summaries were changed:

    >>> print bug_four.title
    Changed summary
    >>> print bug_five.title
    Nicer summary


Commands
--------

Now let's take a closer look at all the commands that are available for
us to play with. First we define a function to easily submit commands
to edit bug 4:

    >>> def submit_commands(bug, *commands):
    ...     edit_mail = ("From: test@canonical.com\n"
    ...                  "To: edit@malone-domain\n"
    ...                  "Date: Fri Jun 17 10:10:23 BST 2005\n"
    ...                  "Subject: Not important\n"
    ...                  "\n"
    ...                  " bug %d\n" % bug.id)
    ...     edit_mail += ' ' + '\n '.join(commands)
    ...     process_email(edit_mail)
    ...     transaction.commit()


bug $bugid
^^^^^^^^^^
Switches what bug you want to edit. Example:

    bug 42

summary "$summary"
^^^^^^^^^^^^^^^^^^
Changes the summary of the bug. The title has to be enclosed in
quotes. Example:

    >>> submit_commands(bug_four, 'summary "New summary"')
    >>> print bug_four.title
    New summary

Just a quick check that the whitespace will be preserved in the summary:

    >>> submit_commands(bug_four, 'summary "New             summary"')
    >>> print bug_four.title #doctest: -NORMALIZE_WHITESPACE
    New             summary

private yes|no
^^^^^^^^^^^^^^
Changes the secrecy of the bug. Example:

    >>> submit_commands(bug_four, 'private yes')
    >>> bug_four.private
    True

    >>> submit_commands(bug_four, 'private no')
    >>> bug_four.private
    False

subscribe [$name|$email] [cc|watch|ignore]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Subscribes yourself or someone else to the bug. All arguments are
optional. If you don't specify a name, the sender of the email will
be subscribed. Examples:

    >>> subscriptions = [subscription.person.name
    ...                  for subscription in bug_four.subscriptions]
    >>> subscriptions.sort()
    >>> subscriptions
    [u'name12']


    >>> submit_commands(bug_four, 'subscribe')
    >>> 'Sample Person' in [subscription.person.displayname
    ...                     for subscription in bug_four.subscriptions]
    True
    >>> submit_commands(bug_four, 'subscribe foo.bar@canonical.com')
    >>> 'Foo Bar' in [subscription.person.displayname
    ...               for subscription in bug_four.subscriptions]
    True
    >>> submit_commands(bug_four, 'subscribe sabdfl')
    >>> 'Mark Shuttleworth' in [subscription.person.displayname
    ...                         for subscription in bug_four.subscriptions]
    True

unsubscribe [$name|$email]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Unsubscribes yourself or someone else from the bug. 
If you don't specify a name or email, the sender of the email will be
unsubscribed. Examples:

    >>> submit_commands(bug_four, 'unsubscribe sabdfl')
    >>> 'Mark Shuttleworth' in [subscription.person.displayname
    ...                         for subscription in bug_four.subscriptions]
    False
    >>> submit_commands(bug_four, 'unsubscribe foo.bar@canonical.com')
    >>> 'Foo Bar' in [subscription.person.displayname
    ...               for subscription in bug_four.subscriptions]
    False
    >>> submit_commands(bug_four, 'unsubscribe')
    >>> 'Sample Person' in [subscription.person.displayname
    ...                     for subscription in bug_four.subscriptions]
    False

affects $path [assignee $name|$email]
              [status $status]
              [severity $severity]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Change the state of a bug in a specific context. $path can be of
the following form:

    /products/$productname
    /distros/$distroname
    /distros/$distroname/$sourcepackagename

If there is no task with the specified $path target, a new task is
created:

    >>> len(bug_four.bugtasks)
    1
    >>> 'debian' in [bugtask.target.name for bugtask in bug_four.bugtasks]
    False
    >>> submit_commands(bug_four, 'affects /distros/debian')
    >>> len(bug_four.bugtasks)
    2
    >>> 'debian' in [bugtask.target.name for bugtask in bug_four.bugtasks]
    True

Submitting the same thing again doesn't do anything, since the task
already exists:

    >>> submit_commands(bug_four, 'affects /distros/debian')
    >>> len(bug_four.bugtasks)
    2

We can change the assignee, status, and severity using the sub
commands. It's possible to have these sub commands on separate lines:

    >>> submit_commands(bug_four, 'affects /distros/debian severity critical',
    ...                 'status accepted', 'assignee test@canonical.com')

    >>> len(bug_four.bugtasks)
    2
    >>> debian_task = bug_four.bugtasks[-1]
    >>> print debian_task.severity.name
    CRITICAL
    >>> print debian_task.status.name
    ACCEPTED
    >>> print debian_task.assignee.displayname
    Sample Person

To set which source package the bug affects, we use:

    >>> submit_commands(bug_four, 'affects /distros/debian/mozilla-firefox')
    >>> len(bug_four.bugtasks)
    3
    >>> debian_task = bug_four.bugtasks[-1]
    >>> print debian_task.sourcepackagename.name
    mozilla-firefox

Let's take on the upstream task as well:

    >>> submit_commands(
    ...     bug_four,
    ...     'affects /products/firefox severity critical',
    ...     'status accepted',
    ...     'assignee test@canonical.com')

    >>> len(bug_four.bugtasks)
    3
    >>> upstream_task = bug_four.bugtasks[0]
    >>> print upstream_task.severity.name
    CRITICAL
    >>> print upstream_task.status.name
    ACCEPTED
    >>> print upstream_task.assignee.displayname
    Sample Person

    >>> stub.test_emails = []

Default 'affects' target
------------------------

Most of the time it's not necessary to give the 'affects' command,
though. It tries to guess which bug task the user wanted to edit.

If there's only one task, that task will be edited. So if we simply send
a 'status' command to bug seven, the single upstream task will be
edited:

    >>> login('foo.bar@canonical.com')
    >>> bug_seven = getUtility(IBugSet).get(7)
    >>> len(bug_seven.bugtasks)
    1
    >>> submit_commands(bug_seven, 'status accepted')
    >>> evolution_task = bug_seven.bugtasks[0]
    >>> print evolution_task.status.name
    ACCEPTED

    >>> from_addr, to_addrs, raw_message = stub.test_emails.pop()
    >>> msg = email.message_from_string(raw_message)
    >>> print msg['Subject']
    [Bug 7]...
    >>> print msg.get_payload(decode=True)
    Public bug report changed:
    ...
        Status: New => Accepted
    ...

If the bug has more than one bug task, we try to guess which bug task
the user wanted to edit. We apply the following heuristics for choosing
which bug task to edit:

The user is a bug contact of the upstream product
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    >>> login('test@canonical.com')
    >>> bug_one = getUtility(IBugSet).get(1)
    >>> len(bug_one.bugtasks)
    4
    >>> submit_commands(
    ...     bug_one, 'status accepted', 'assignee test@canonical.com')
    >>> for bugtask in bug_one.bugtasks:
    ...   if bugtask.product and bugtask.product.name == 'firefox':
    ...       firefox_task = bugtask
    >>> print firefox_task.status.name
    ACCEPTED
    >>> print firefox_task.assignee.preferredemail.email
    test@canonical.com

    >>> from_addr, to_addrs, raw_message = stub.test_emails.pop()
    >>> msg = email.message_from_string(raw_message)
    >>> print msg['Subject']
    [Bug 1]...
    >>> print msg.get_payload(decode=True)
    Public bug report changed:
    ...
        Status: New => Accepted
    ...


Error Handling
--------------

If an error is encountered, an email is sent to the sender informing
him about the error. Let's start by trying to submit a bug without
including an 'affects' command:

    >>> submit_mail_no_bugtask = """From: test@canonical.com
    ... To: new@malone
    ... Date: Fri Jun 17 10:20:23 BST 2005
    ... Subject: A bug without a product or distribution
    ...
    ... There's a nasty bug in Evolution."""
    >>> process_email(submit_mail_no_bugtask)

No bug was created, instead an error mail was sent to the submitter:

    >>> transaction.commit()
    >>> from_addr, to_addrs, raw_message = stub.test_emails[-1]
    >>> error_mail = email.message_from_string(raw_message)
    >>> print error_mail['Subject']
    Submit Request Failure

    >>> print to_addrs
    ['test@canonical.com']

    >>> print error_mail.get_payload() #doctest: -NORMALIZE_WHITESPACE
    An error...
    ...
    Error message:
    ...
    The bug has to affect at least one product or distribution.
    ...

Now we try to submit a bug on a distribution that doesn't exist:

    >>> submit_mail_distro_not_found = """From: test@canonical.com
    ... To: new@malone
    ... Date: Fri Jun 17 10:20:23 BST 2005
    ... Subject: A bug with a non existing distribution
    ...
    ... There's a nasty bug in Foo.
    ...  affects /distros/foo"""
    >>> process_email(submit_mail_distro_not_found)

Again no bug was filed, and an error mail was sent:

    >>> transaction.commit()
    >>> from_addr, to_addrs, raw_message = stub.test_emails[-1]
    >>> error_mail = email.message_from_string(raw_message)

    >>> print error_mail.get_payload() #doctest: -NORMALIZE_WHITESPACE
    An error...
    ...
    Error message:
    ...
    'foo' couldn't be found in command 'affects /distros/foo'
    ...


Let's send an empty unsigned mail to new@malone:

    >>> submit_empty = """From: test@canonical.com
    ... To: new@malone
    ... Date: Fri Jun 17 10:20:27 BST 2005
    ... Subject: An empty mail
    ...
    ... """
    >>> process_email(submit_empty)

This causes an error message to be sent to the submitter:

    >>> transaction.commit()
    >>> from_addr, to_addrs, raw_message = stub.test_emails[-1]
    >>> error_mail = email.message_from_string(raw_message)

    >>> print error_mail.get_payload() #doctest: -NORMALIZE_WHITESPACE
    An error...
    ...
    Error message:
    ...
    An error occurred while processing your mail to create a new bug. You
    didn't specify on what you want to file a bug on. A new bug has to
    affect either a product or a distribution. Please use the 'affects'
    command in order to specify on what you want to file a bug on. For
    example, in order to file a bug on Malone itself, use:
    ...


    >>> LibrarianTestSetup().tearDown()


XXX: Add tests for non-ascii mails.
     -- Bjorn Tillenius, 2005-05-20

