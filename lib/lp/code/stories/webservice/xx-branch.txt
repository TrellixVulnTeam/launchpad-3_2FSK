= Introduction =

Launchpad provides two ways to programmatically interact with your
branches. You can either interact with the branches themselves using
`bzrlib`, or you can use Launchpad's webservice APIs to explore
information about the branches and how they relate to the rest of
the things on Launchpad.

    >>> from datetime import datetime
    >>> import pytz
    >>> from zope.security.proxy import removeSecurityProxy
    >>> from lp.code.enums import BranchLifecycleStatus, BranchType
    >>> from lp.code.interfaces.branch import IBranch
    >>> from lazr.restful.marshallers import DateTimeFieldMarshaller

To make this document a little more readable, we'll have to define some
helpers. This one turns a JSON date/time response into a Python
`datetime` object.

    >>> def get_as_datetime(response):
    ...     """Return a datetime object from a JSON response."""
    ...     returned_time = response.jsonBody()
    ...     marshaller = DateTimeFieldMarshaller(
    ...         IBranch['next_mirror_time'], response)
    ...     return marshaller.marshall_from_json_data(returned_time)


== Requesting a mirror ==

Many of the branches on Launchpad are mirrored branches: branches that
are hosted on other servers and then mirrored regularly by Launchpad's
branch puller.

Normally, the puller fetches branches every six hours or so. However,
it also provides a way for you to request that a mirror be done
immediately.

Let's make a mirrored branch to play with:

    >>> login(ANONYMOUS)
    >>> branch = removeSecurityProxy(
    ...     factory.makeAnyBranch(branch_type=BranchType.MIRRORED))
    >>> logout()

At the moment, it's not scheduled to be mirrored.

    >>> print branch.next_mirror_time
    None

But we can ask for it to be mirrored using the webservice:

    >>> branch_url = '/' + branch.unique_name
    >>> start_time = datetime.now(pytz.UTC)
    >>> response = webservice.named_post(branch_url, 'requestMirror')
    >>> end_time = datetime.now(pytz.UTC)
    >>> new_mirror_time = get_as_datetime(response)
    >>> branch.next_mirror_time == new_mirror_time
    True

The new "next mirror time" is the time when we actually submitted the
request for a mirror:

    >>> print start_time < branch.next_mirror_time < end_time
    True


== Basic branch attributes ==

Not everything about a branch is exposed.  Hopefully most of what users
really care about is exposed, and we will undoubtedly expand this as
time goes on.

    >>> login('admin@canonical.com')
    >>> eric = factory.makePerson(name='eric')
    >>> marley = factory.makePerson(name='marley')
    >>> fooix = factory.makeProduct(name='fooix')
    >>> branch = factory.makeProductBranch(
    ...     branch_type=BranchType.HOSTED, owner=eric, product=fooix,
    ...     name='trunk', title='The Fooix Trunk')
    >>> feature_branch = factory.makeAnyBranch(
    ...     owner=eric, product=fooix, name='feature-branch',
    ...     lifecycle_status=BranchLifecycleStatus.EXPERIMENTAL)
    >>> feature_branch_bug = factory.makeBug(product=fooix,
    ...     title='Stuff needs features')
    >>> feature_branch_spec = factory.makeSpecification(product=fooix,
    ...     title='Super Feature X')
    >>> merge_proposal = factory.makeBranchMergeProposal(
    ...     target_branch=branch, source_branch=feature_branch,
    ...     registrant=eric)
    >>> branch_url = '/' + branch.unique_name
    >>> feature_branch_url = '/' + feature_branch.unique_name
    >>> feature_branch_bug_url = '/bugs/' + str(feature_branch_bug.id)
    >>> feature_branch_spec_url = '/' + '/'.join([
    ...     feature_branch_spec.product.name,
    ...     '+spec',
    ...     feature_branch_spec.name])
    >>> logout()

    >>> from canonical.launchpad.testing.pages import webservice_for_person
    >>> service = webservice_for_person(eric)
    >>> fooix_trunk = webservice.get(branch_url).jsonBody()
    >>> from lazr.restful.testing.webservice import pprint_entry
    >>> pprint_entry(fooix_trunk)
    branch_format: None
    branch_type: u'Hosted'
    bug_branches_collection_link: u'.../~eric/fooix/trunk/bug_branches'
    bzr_identity: u'lp://dev/~eric/fooix/trunk'
    control_format: None
    date_created: ...
    date_last_modified: ...
    dependent_branches_collection_link: u'.../~eric/fooix/trunk/dependent_branches'
    display_name: u'lp://dev/~eric/fooix/trunk'
    landing_candidates_collection_link: u'.../~eric/fooix/trunk/landing_candidates'
    landing_targets_collection_link: u'.../~eric/fooix/trunk/landing_targets'
    last_mirror_attempt: None
    last_mirrored: None
    last_scanned: None
    last_scanned_id: None
    lifecycle_status: u'Development'
    mirror_status_message: None
    name: u'trunk'
    owner_link: u'.../~eric'
    private: False
    project_link: u'.../fooix'
    registrant_link: u'.../~eric'
    repository_format: None
    resource_type_link: u'.../#branch'
    reviewer_link: None
    revision_count: 0
    self_link: u'.../~eric/fooix/trunk'
    spec_links_collection_link: u'.../~eric/fooix/trunk/spec_links'
    subscribers_collection_link: u'http://.../~eric/fooix/trunk/subscribers'
    subscriptions_collection_link: u'http://.../~eric/fooix/trunk/subscriptions'
    unique_name: u'~eric/fooix/trunk'
    url: None
    whiteboard: None


A branch can also be linked to a bug through the API.

    >>> erics_feature_branch = webservice.get(feature_branch_url).jsonBody()
    >>> more_features_bug = webservice.get(feature_branch_bug_url).jsonBody()
    >>> bug_branch = webservice.named_post(
    ...     more_features_bug['self_link'], 'linkBranch',
    ...     branch=erics_feature_branch['self_link']).jsonBody()
    >>> pprint_entry(bug_branch)
    branch_link: u'http://.../~eric/fooix/feature-branch'
    bug_link: u'http://.../bugs/...'
    resource_type_link: u'http://.../#bug_branch'
    self_link: u'http://.../~eric/fooix/feature-branch/+bug/...'


Since the branch is linked to a bug, it's possible to get that bug through the
branch.

    >>> bug_branches = webservice.get(
    ...     erics_feature_branch['bug_branches_collection_link']).jsonBody()
    >>> bug_branch = bug_branches['entries'][0]
    >>> pprint_entry(bug_branch)
    branch_link: u'http://.../~eric/fooix/feature-branch'
    bug_link: u'http://.../bugs/...'
    resource_type_link: u'http://.../#bug_branch'
    self_link: u'http://.../~eric/fooix/feature-branch/+bug/...'


SpecBranch linkages can be deleted through the API as well.

    >>> _unused = webservice.named_post(
    ...     more_features_bug['self_link'], 'unlinkBranch',
    ...     branch=erics_feature_branch['self_link']).jsonBody()
    >>> bug_branches = webservice.get(
    ...     erics_feature_branch['bug_branches_collection_link']).jsonBody()
    >>> print len(bug_branches['entries'])
    0


A branch can also be linked to a spec through the API.

    >>> erics_feature_branch = webservice.get(feature_branch_url).jsonBody()
    >>> more_features_spec = webservice.get(feature_branch_spec_url).jsonBody()
    >>> spec_branch = webservice.named_post(
    ...     more_features_spec['self_link'], 'linkBranch',
    ...     branch=erics_feature_branch['self_link']).jsonBody()
    >>> pprint_entry(spec_branch)
    branch_link: u'http://api.launchpad.dev/beta/~eric/fooix/feature-branch'
    registrant_link: u'http://api.launchpad.dev/beta/~salgado'
    resource_type_link: u'http://api.launchpad.dev/beta/#specification_branch'
    self_link: u'http://api.launchpad.dev/beta/fooix/+spec/name28/+branch/eric/fooix/feature-branch'
    specification_link: u'http://api.launchpad.dev/beta/fooix/+spec/name28'


If the branch is linked to a spec, it's possible to look up that spec through
the spec branch link.

    >>> spec_branches = webservice.get(
    ...     erics_feature_branch['spec_links_collection_link']).jsonBody()
    >>> spec_branch = spec_branches['entries'][0]
    >>> pprint_entry(spec_branch)
    branch_link: u'http://api.launchpad.dev/beta/~eric/fooix/feature-branch'
    registrant_link: u'http://api.launchpad.dev/beta/~salgado'
    resource_type_link: u'http://api.launchpad.dev/beta/#specification_branch'
    self_link: u'http://api.launchpad.dev/beta/fooix/+spec/name28/+branch/eric/fooix/feature-branch'
    specification_link: u'http://api.launchpad.dev/beta/fooix/+spec/name28'


SpecBranch linkages can be deleted through the API as well.

    >>> _unused = webservice.named_post(spec_branch['self_link'],
    ...     'delete').jsonBody()
    >>> spec_branches = webservice.get(
    ...     erics_feature_branch['spec_links_collection_link']).jsonBody()
    >>> print len(spec_branches['entries'])
    0


There is a branch merge proposal with Fooix trunk as the target branch, so it
should have a branch at the endpoint of landing_candidates.

    >>> landing_candidates = webservice.get(
    ...     fooix_trunk['landing_candidates_collection_link']).jsonBody()
    >>> for candidate in landing_candidates['entries']:
    ...     print candidate['source_branch_link']
    http://.../~eric/fooix/feature-branch


The source_branch of the landing candidate should have this same merge proposal
in its landing_targets.

    >>> feature_branch_link = \
    ...     '/~eric/fooix/feature-branch'
    >>> feature_branch = webservice.get(feature_branch_link).jsonBody()
    >>> print feature_branch['unique_name']
    ~eric/fooix/feature-branch

    >>> landing_targets = webservice.get(
    ...     feature_branch['landing_targets_collection_link']).jsonBody()
    >>> for target in landing_targets['entries']:
    ...     print target['target_branch_link']
    http://.../~eric/fooix/trunk


== Branch subscriptions ==

A user can subscribe to a branch through the API.

    >>> marley = webservice.get('/~marley').jsonBody()
    >>> subscription = webservice.named_post(
    ...     fooix_trunk['self_link'], 'subscribe', person=marley['self_link'],
    ...     notification_level=u'Branch attribute notifications only',
    ...     max_diff_lines=u'Don\'t send diffs',
    ...     code_review_level=u'No email')

    >>> pprint_entry(subscription.jsonBody())
    branch_link: u'http://.../~eric/fooix/trunk'
    max_diff_lines: u"Don't send diffs"
    notification_level: u'Branch attribute notifications only'
    person_link: u'http://.../~marley'
    resource_type_link: u'http://.../#branch_subscription'
    review_level: u'No email'
    self_link: u'http://.../~eric/fooix/trunk/+subscription/marley'


    >>> subscribers = webservice.get(
    ...     fooix_trunk['subscribers_collection_link']).jsonBody()
    >>> print len(subscribers['entries'])
    2
    >>> for subscriber in subscribers['entries']:
    ...     print subscriber['display_name']
    Eric
    Marley


== Project branches ==

The branches of a project are also available.

    >>> def print_branch(branch):
    ...     print branch['unique_name'] + ' - ' + branch['lifecycle_status']
    >>> def print_branches(webservice, url, status=None):
    ...     branches = webservice.named_get(
    ...         url, 'getBranches',
    ...         status=status).jsonBody()
    ...     for branch in branches['entries']:
    ...         print_branch(branch)

    >>> print_branches(webservice, '/fooix')
    ~eric/fooix/trunk - Development
    ~eric/fooix/feature-branch - Experimental

A list of lifecycle statuses can be provided for filtering.

    >>> print_branches(webservice, '/fooix', ('Experimental'))
    ~eric/fooix/feature-branch - Experimental

== Branches for people ==

The branches owned by a person are available from the person object.

    >>> print_branches(webservice, '/~eric')
    ~eric/fooix/trunk - Development
    ~eric/fooix/feature-branch - Experimental

As with projects, these can be filtered by the branch status.

    >>> print_branches(webservice, '/~eric', ('Experimental'))
    ~eric/fooix/feature-branch - Experimental

== Project group branches ==

Branches are also accessible for a project group.

    >>> login('admin@canonical.com')
    >>> project = factory.makeProject(name='widgets')
    >>> fooix.project = project
    >>> blob = factory.makeProduct(name='blob', project=project)
    >>> branch = factory.makeProductBranch(product=blob, name='bar')
    >>> branch.owner.name = 'mary'
    >>> logout()

    >>> print_branches(webservice, '/~eric')
    ~eric/fooix/trunk - Development
    ~eric/fooix/feature-branch - Experimental

As with projects, these can be filtered by the branch status.

    >>> print_branches(webservice, '/~eric', ('Experimental'))
    ~eric/fooix/feature-branch - Experimental
