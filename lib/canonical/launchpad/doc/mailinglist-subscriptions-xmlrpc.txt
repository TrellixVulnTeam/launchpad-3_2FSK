= XMLRPC access to mailing list memberships =

Just like the creation and deactivation of mailing lists, membership changes
to mailing lists must be communicated to Mailman over XMLRPC.  Because the
bandwidth involved is not expected to be overwhelming, a simplified interface
was chosen.

The communication pattern is initiated by Mailman in all cases; in other
words, Mailman polls Launchpad to see if there is any work for Mailman to do.

    >>> # Note that this test is run multiple times, with the harness
    >>> # providing `mailinglist_api` and `commit` for impedance matching.


== Requesting membership information ==

Mailman requests membership information for specific list of teams.  Let's
create and populate some teams to demonstrate.

    >>> from canonical.launchpad.ftests.mailinglists_helper import (
    ...     new_team, new_person)
    >>> team_one, list_one = new_team('team-one', with_list=True)
    >>> anne = new_person('Anne')
    >>> bart = new_person('Bart')
    >>> cris = new_person('Cris')
    >>> dirk = new_person('Dirk')
    >>> elle = new_person('Elle')
    >>> fred = new_person('Fred')
    >>> gwen = new_person('Gwen')
    >>> hank = new_person('Hank')
    >>> people = [anne, bart, cris, dirk, elle, fred, gwen, hank]

    # login() as an admin so that we can call join() on all the people above.
    >>> login('foo.bar@canonical.com')
    >>> for person in people:
    ...     person.join(team_one)
    ...     list_one.subscribe(person)
    >>> flush_database_updates()

Asking for the membership information for team-one's list returns all the
above people.  We want to see all the email addresses for all the people
subscribed to the mailing list, along with their full name. We'll also print
the address's flags (which will currently always be zero), and the address's
status.  A status of 0 means the address is ENABLED, while a status of 2 means
it is DISABLED (by the user).  For the purposes of delivery, ENABLED addresses
will receive list postings, but DISABLED addresses will not.  The important
point is that all addresses regardless of status, will be able to post to the
mailing list.

    >>> info = mailinglist_api.getMembershipInformation(('team-one',))
    >>> from canonical.launchpad.ftests.mailinglists_helper import print_info
    >>> print_info(info)
    team-one
        anne.person@example.com Anne Person 0 0
        aperson@example.org     Anne Person 0 2
        bart.person@example.com Bart Person 0 0
        bperson@example.org     Bart Person 0 2
        cperson@example.org     Cris Person 0 2
        cris.person@example.com Cris Person 0 0
        dirk.person@example.com Dirk Person 0 0
        dperson@example.org     Dirk Person 0 2
        elle.person@example.com Elle Person 0 0
        eperson@example.org     Elle Person 0 2
        fperson@example.org     Fred Person 0 2
        fred.person@example.com Fred Person 0 0
        gperson@example.org     Gwen Person 0 2
        gwen.person@example.com Gwen Person 0 0
        hank.person@example.com Hank Person 0 0
        hperson@example.org     Hank Person 0 2

We can also ask for the membership information for more than one mailing list
at a time.  Mix things up for the fun of it.

    >>> team_two, list_two = new_team('team-two', with_list=True)
    >>> fred.leave(team_one)
    >>> gwen.leave(team_one)
    >>> for person in people:
    ...     if person is bart:
    ...         continue
    ...     person.join(team_two)
    ...     list_two.subscribe(person)
    >>> info = mailinglist_api.getMembershipInformation(
    ...     ('team-one', 'team-two'))
    >>> print_info(info)
    team-one
        anne.person@example.com Anne Person 0 0
        aperson@example.org     Anne Person 0 2
        bart.person@example.com Bart Person 0 0
        bperson@example.org     Bart Person 0 2
        cperson@example.org     Cris Person 0 2
        cris.person@example.com Cris Person 0 0
        dirk.person@example.com Dirk Person 0 0
        dperson@example.org     Dirk Person 0 2
        elle.person@example.com Elle Person 0 0
        eperson@example.org     Elle Person 0 2
        hank.person@example.com Hank Person 0 0
        hperson@example.org     Hank Person 0 2
    team-two
        anne.person@example.com Anne Person 0 0
        aperson@example.org     Anne Person 0 2
        cperson@example.org     Cris Person 0 2
        cris.person@example.com Cris Person 0 0
        dirk.person@example.com Dirk Person 0 0
        dperson@example.org     Dirk Person 0 2
        elle.person@example.com Elle Person 0 0
        eperson@example.org     Elle Person 0 2
        fperson@example.org     Fred Person 0 2
        fred.person@example.com Fred Person 0 0
        gperson@example.org     Gwen Person 0 2
        gwen.person@example.com Gwen Person 0 0
        hank.person@example.com Hank Person 0 0
        hperson@example.org     Hank Person 0 2


== Membership tests ==

Mailman may also occasionally ask whether a specific email address is
registered with Launchpad.  It does this as a simple line-of-defense against
spam.  Email from addresses not registered with Launchpad are summarily
discarded.

    >>> mailinglist_api.isRegisteredInLaunchpad('dirk.person@example.com')
    True
    >>> mailinglist_api.isRegisteredInLaunchpad('dperson@example.org')
    True
    >>> mailinglist_api.isRegisteredInLaunchpad('geddy.lee@canonical.com')
    False

Similarly, email addresses with an unvalidated status are not considered
registered either.

    >>> from canonical.launchpad.interfaces import IEmailAddressSet
    >>> emailset = getUtility(IEmailAddressSet)
    >>> new_address = emailset.new('frederick@example.com', fred)
    >>> new_address.email, new_address.statusname
    (u'frederick@example.com', 'New Email Address')
    >>> sorted((email_address.email, email_address.statusname)
    ...        for email_address in emailset.getByPerson(fred))
    [(u'fperson@example.org', 'Validated Email Address'),
     (u'fred.person@example.com', 'Preferred Email Address'),
     (u'frederick@example.com', 'New Email Address')]
    >>> mailinglist_api.isRegisteredInLaunchpad('frederick@example.com')
    False


== Standing tests ==

Mailman may also occasionally ask whether a specific email address is a
Launchpad member in good (or better) standing.  It does this when a non-member
of a mailing list tries to post to the mailing list.  By default, an address
not registered in Launchpad is not in good standing (even though the previous
membership test should always take precedence).

    >>> mailinglist_api.inGoodStanding('frederick@example.com')
    False

Since standing makes no sense for teams, an email address assigned to a team
is also not in good standing.

    >>> team_address = list(emailset.getByPerson(team_one))[0]
    >>> mailinglist_api.inGoodStanding(team_address.email)
    False

By default, Launchpad members have an unknown, and thus not good, standing.

    >>> anne.personal_standing
    <DBItem PersonalStanding.UNKNOWN...
    >>> mailinglist_api.inGoodStanding('anne.person@example.com')
    False

Anne is a bad person and the Launchpad administrator assigns her a poor
standing.

    >>> from canonical.launchpad.interfaces import PersonalStanding
    >>> anne.personal_standing = PersonalStanding.POOR
    >>> flush_database_updates()
    >>> mailinglist_api.inGoodStanding('anne.person@example.com')
    False

Anne makes amends and the Launchpad administrator improves her standing.

    >>> anne.personal_standing = PersonalStanding.GOOD
    >>> flush_database_updates()
    >>> mailinglist_api.inGoodStanding('anne.person@example.com')
    True

It turns out that Anne is a wonderful person!  Her standing is really
excellent.

    >>> anne.personal_standing = PersonalStanding.EXCELLENT
    >>> flush_database_updates()
    >>> mailinglist_api.inGoodStanding('anne.person@example.com')
    True


== The archive address ==

We archive messages by sending them to The Mail Archive
<http://www.mail-archive.com>.  They automatically determine which list a
message is posted to so all we need to do is include them in the recipients
list and the rest is taken care of.

    >>> from canonical.config import config
    >>> config.mailman.archive_address
    'archive@mail-archive.dev'

Every team should have this address as an enabled recipient.  There is no real
name for this member.

    # Don't use print_info() since that explicitly suppresses the archive
    # address in order to make the above tests more succinct.
    >>> info = mailinglist_api.getMembershipInformation(
    ...     ('team-one', 'team-two'))
    >>> for team in sorted(info):
    ...     subscribees = info[team]
    ...     for address, realname, flags, status in subscribees:
    ...         if address == config.mailman.archive_address:
    ...             # Print the repr so we'll see the empty string better.
    ...             print team, address, repr(realname), flags, status
    ...             break
    ...     else:
    ...         raise AssertionError('No archive address in subscribees')
    team-one archive@mail-archive.dev '' 0 0
    team-two archive@mail-archive.dev '' 0 0

However, in order to prevent this address from being used to forge spam onto
the lists, the archive address is hard-coded to not be registered in
Launchpad.

    >>> mailinglist_api.isRegisteredInLaunchpad(config.mailman.archive_address)
    False    

This is true even if by dumb luck the address actually gets registered in
Launchpad.

    >>> from canonical.launchpad.interfaces import EmailAddressStatus
    >>> new_address = emailset.new(
    ...     config.mailman.archive_address, fred,
    ...     EmailAddressStatus.VALIDATED)
    >>> flush_database_updates()
    >>> mailinglist_api.isRegisteredInLaunchpad(config.mailman.archive_address)
    False    


== Error cases ==

If Mailman requests the membership information for a team that doesn't exist,
the method will raise a fault.

    >>> mailinglist_api.getMembershipInformation(('no-such-team',))
    Traceback (most recent call last):
    ...
    Fault: <Fault 140: 'No such team mailing list: no-such-team'>
