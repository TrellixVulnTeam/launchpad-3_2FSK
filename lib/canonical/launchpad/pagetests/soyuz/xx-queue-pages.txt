= Upload Queue Pages =


Upload queue pages are designed to offer the ability to perform
control and visualisation over the current uploads queue.

Currently the queue page is only available for DistroSeries context.


== The upload-admin role ==

In our sample data, Ubuntu's upload manager is "name12", who has the
rights to administer the queue for the four main components.  This
permissioning data has no web UI to administer it yet, so we'll create
a Zope interaction to show it:

  >>> from canonical.launchpad.ftests import login, logout
  >>> login('foo.bar@canonical.com')
  >>> from canonical.launchpad.interfaces import (
  ...     IArchivePermissionSet, IDistributionSet, IPersonSet)
  >>> from zope.component import getUtility
  >>> permission_set = getUtility(IArchivePermissionSet)
  >>> main_archive = getUtility(IDistributionSet)['ubuntu'].main_archive
  >>> name12 = getUtility(IPersonSet).getByName('name12')
  >>> permissions = permission_set.componentsForQueueAdmin(
  ...     main_archive, name12)
  >>> from operator import attrgetter
  >>> for permission in sorted(permissions, key=attrgetter("id")):
  ...     print permission.component.name
  main
  restricted
  universe
  multiverse

  >>> logout()

Let's setup a browser with the defined upload-admin for future use.
(name12 is test@canonical.com)

  >>> upload_manager_browser = setupBrowser(
  ...       auth="Basic test@canonical.com:test")


== Accessing the queues ==

The link "View Uploads" is presented in Distrorelease page.

Viewing the current queue, by default the NEW queue.

  >>> anon_browser.open(
  ...     "http://launchpad.dev/ubuntu/breezy-autotest/")
  >>> anon_browser.getLink("Show uploads").click()

  >>> anon_browser.getControl(
  ...     name="queue_state", index=0).displayValue
  ['New']

  >>> def print_queue(contents):
  ...     queue_rows = find_tags_by_class(contents, "queue-row")
  ...     for row in queue_rows:
  ...         print extract_text(row)

  >>> print_queue(anon_browser.contents)
  Package             Version     Component Section Priority Pocket  When
  netapplet...ddtp... -                                      Release 2005-...
  netapplet...dist... -                                      Release 2005-...
  alsa-utils (source) 1.0.9a-4... main      base    low      Release 2005-...
  netapplet (source)  0.99.6-1    main      web     low      Release 2005-...
  pmount (i386)       0.1-1                                  Release 2005-...
  moz...irefox (i386) 0.9                                    Release 2006-...

The package name in the results list is a clickable link to the changes
file for that upload.

  >>> print anon_browser.getLink("netapplet-1.0.0.tar.gz")
  <Link text='netapplet-1.0.0.tar.gz'
        url='http://.../1/netapplet-1.0.0.tar.gz'>

  >>> print anon_browser.getLink("alsa-utils")
  <Link text='alsa-utils'
        url='http://.../1/netapplet-1.0.0.tar.gz'>

(This link for alsa-utils is pointing at the librarian URL for
netapplet, because we have used its changes file for all the
PackageUpload records for the purposes of this doctest.)

We grant public access to all available queues, including the
UNAPPROVED one.

  >>> anon_browser.getControl(
  ...     name="queue_state", index=0).displayValue = ['Unapproved']
  >>> anon_browser.getControl("Update").click()
  >>> print_queue(anon_browser.contents)
  Package             Version   Component Section  Priority Pocket   When
  lang...-de (source) 1.0       main      trans... low      Proposed 2005-...
  netapplet...ddtp... -                                     Backp... 2005-...
  cnews (source)      1.0       main      base     low      Release  2005-...
  cnews (source)      1.0       main      base     low      Release  2005-...
  netapplet...(raw-translations) -                          Updates  2005-...

The results can be filtered matching source name, binary name or
custom-upload filename.

  >>> anon_browser.getControl(name="queue_text").value = 'language'
  >>> anon_browser.getControl("Update").click()
  >>> print_queue(anon_browser.contents)
  Package             Version   Component Section  Priority Pocket   When
  lang...-de (source) 1.0       main      trans... low      Proposed 2005-...

  >>> anon_browser.getControl(name="queue_text").value = 'netapplet'
  >>> anon_browser.getControl("Update").click()
  >>> print_queue(anon_browser.contents)
  Package             Version   Component Section  Priority Pocket   When
  netapplet...(raw-translations) -                          Updates  2005-...
  netapplet...ddtp... -                                     Backp... 2005-...

  >>> anon_browser.getControl(
  ...     name="queue_state", index=0).displayValue = ['New']
  >>> anon_browser.getControl(name="queue_text").value = 'pmount'
  >>> anon_browser.getControl("Update").click()
  >>> print_queue(anon_browser.contents)
  Package             Version   Component Section  Priority Pocket   When
  pmount (i386)       0.1-1                                 Release  2005-...


== Queue item filelist ==

Each queue item has a hidden 'filelist' section which is
toggled via javascript by clicking in the 'expand' arrow
image:

  >>> anon_browser.getControl(
  ...     name="queue_state", index=0).displayValue = ['New']
  >>> anon_browser.getControl(name="queue_text").value = ''
  >>> anon_browser.getControl("Update").click()

  >>> print find_tag_by_id(anon_browser.contents, 'queue-alsa-utils-4-arrow')
  <img width="14" height="14" src="/@@/treeCollapsed" alt="view files"
       id="queue-alsa-utils-4-arrow" />

The 'filelist' is expanded as one or more table rows, right below the
clicked item:

  >>> filelist = find_tags_by_class(
  ...     anon_browser.contents, 'queue-alsa-utils-4')

It contains a list of files related to the queue item clicked, followed
by its size, one file per line:

  >>> for row in filelist:
  ...     print extract_text(row)
  alsa-utils_1.0.9a-4ubuntu1.dsc (3 bytes)

Each filename links to its respective librarian URL:

  >>> print row.find('a')
  <a href="http://localhost:58000/43/alsa-utils_1.0.9a-4ubuntu1.dsc">
    alsa-utils_1.0.9a-4ubuntu1.dsc
  </a>

On binary queue items we also present the stamp 'NEW' for files never
published in the archive (it helps archive admins when reviewing
candidates).  The binary items will also individually show their
version, component, section and priority.

  >>> [filelist] = find_tags_by_class(anon_browser.contents, 'queue-pmount-2')
  >>> print extract_text(filelist)
  pmount_1.0-1_all.deb (18 bytes) NEW 0.1-1 main base important

XXX cprov 20070726: we should extend the test when we are able to
probe javascripts events.


== Accepting items ==

Inspect the ACCEPTED queue:

  >>> anon_browser.getControl(
  ...     name="queue_state", index=0).displayValue = ['Accepted']
  >>> anon_browser.getControl("Update").click()
  >>> for message in get_feedback_messages(anon_browser.contents):
  ...     print message
  The Accepted queue is empty.

Now we act on the queue, which requires admin or upload_manager permission.
First, we need to add fake librarian files so that email notifications work:

  >>> from canonical.archiveuploader.tests import (
  ...     insertFakeChangesFileForAllPackageUploads)
  >>> insertFakeChangesFileForAllPackageUploads()

And store a chroot for ubuntu breezy-autotest/i386 architectures, so
the builds can be created.

  >>> from zope.component import getUtility
  >>> from canonical.launchpad.ftests import login, logout
  >>> from canonical.launchpad.interfaces import (
  ...     IDistributionSet, ILibraryFileAliasSet)
  >>> from canonical.launchpad.ftests import syncUpdate

  >>> login('foo.bar@canonical.com')

  >>> ubuntu = getUtility(IDistributionSet).getByName('ubuntu')
  >>> fake_chroot = getUtility(ILibraryFileAliasSet)[1]
  >>> breezy_autotest = ubuntu.getSeries('breezy-autotest')
  >>> new_chroot = breezy_autotest["i386"].addOrUpdateChroot(fake_chroot)
  >>> syncUpdate(new_chroot)

Upload a new "bar" source so we can accept it later.  We need to login to
upload.

  >>> from canonical.archiveuploader.tests import (
  ...     datadir, getPolicy, mock_logger_quiet)
  >>> from canonical.archiveuploader.nascentupload import NascentUpload

  >>> sync_policy = getPolicy(
  ...     name='sync', distro='ubuntu', distroseries='breezy-autotest')
  >>> bar_src = NascentUpload(
  ...     datadir('suite/bar_1.0-1/bar_1.0-1_source.changes'),
  ...     sync_policy, mock_logger_quiet)
  >>> bar_src.process()
  >>> bar_src.do_accept()
  True
  >>> bar_queue_id = str(bar_src.queue_root.id)

  >>> import transaction
  >>> transaction.commit()
  >>> logout()

Swallow any email generated at the upload:

  >>> from canonical.launchpad.mail import stub
  >>> from canonical.launchpad.tests.mail_helpers import pop_notifications
  >>> swallow = pop_notifications()

Go back to the "new" queue and accept "bar":

  >>> upload_manager_browser.open(
  ...    "http://localhost/ubuntu/breezy-autotest/+queue")
  >>> upload_manager_browser.getControl(
  ...     name="QUEUE_ID").value = [bar_queue_id]
  >>> upload_manager_browser.getControl(name="Accept").click()
  >>> print_queue(upload_manager_browser.contents)
  Package             Version     Component Section Priority Pocket  When
  netapplet...ddtp... -                                      Release 2005-...
  netapplet...dist... -                                      Release 2005-...
  alsa-utils (source) 1.0.9a-4... main      base    low      Release 2005-...
  netapplet (source)  0.99.6-1    main      web     low      Release 2005-...
  pmount (i386)       0.1-1                                  Release 2005-...
  moz...irefox (i386) 0.9                                    Release 2006-...

Accepting queue items results in an email to the uploader and (usually) an
email to the distroseries' announcement list (see
nascentupload-announcements.txt).

  >>> [notification, announcement] = pop_notifications()
  >>> notification['To']
  'Daniel Silverstone <daniel.silverstone@canonical.com>'
  >>> announcement['To']
  'autotest_changes@ubuntu.com'

Forcing a duplicated submission on a queue item is recognised:

  >>> upload_manager_browser.reload()
  >>> message = 'FAILED: bar (The source bar - 1.0-1 is already accepted'
  >>> message in upload_manager_browser.contents
  True

No emails are sent in this case:

  >>> len(stub.test_emails)
  0

Because it's a single source upload, accepting bar will not put it in the
accepted queue since it skips that state and goes straight to being published.
Let's accept mozilla-firefox so we can see it in the accepted queue:

  >>> upload_manager_browser.open(
  ...    "http://localhost/ubuntu/breezy-autotest/+queue")
  >>> upload_manager_browser.getControl(name="QUEUE_ID").value = ['1']
  >>> upload_manager_browser.getControl(name="Accept").click()
  >>> for message in get_feedback_messages(upload_manager_browser.contents):
  ...     print message
  Accepting Results:
  OK: mozilla-firefox

The item is moved to the ACCEPTED queue:

  >>> upload_manager_browser.getControl(
  ...    name="queue_state", index=0).displayValue = ['Accepted']
  >>> upload_manager_browser.getControl("Update").click()
  >>> print_queue(upload_manager_browser.contents)
  Package             Version     Component Section Priority Pocket  When
  moz...irefox (i386) 0.9                                    Release 2006-...

Going back to the "new" queue, we can see our item has gone:

  >>> upload_manager_browser.getControl(
  ...    name="queue_state", index=0).displayValue = ['New']
  >>> upload_manager_browser.getControl("Update").click()
  >>> print_queue(upload_manager_browser.contents)
  Package             Version     Component Section Priority Pocket  When
  netapplet...ddtp... -                                      Release 2005-...
  netapplet...dist... -                                      Release 2005-...
  alsa-utils (source) 1.0.9a-4... main      base    low      Release 2005-...
  netapplet (source)  0.99.6-1    main      web     low      Release 2005-...
  pmount (i386)       0.1-1                                  Release 2005-...

When accepting items from the unapproved queue, the page will remain on the
unapproved list after the items are accepted, to allow piecemeal
selection and acceptance.

    >>> upload_manager_browser.getControl(
    ...    name="queue_state", index=0).displayValue = ['Unapproved']
    >>> upload_manager_browser.getControl("Update").click()

Accept "cnews" source:

    >>> upload_manager_browser.getControl(name="QUEUE_ID").value = ['9']
    >>> upload_manager_browser.getControl(name="Accept").click()
    >>> for message in get_feedback_messages(upload_manager_browser.contents):
    ...     print message
    Accepting Results:
    OK: cnews

And the page is still on the Unapproved list:

    >>> upload_manager_browser.getControl(
    ...     name="queue_state", index=0).displayValue
    ['Unapproved']

Move back to the New queue:

    >>> upload_manager_browser.getControl(
    ...     name="queue_state", index=0).displayValue = ['New']
    >>> upload_manager_browser.getControl("Update").click()


== Overriding items ==

At acceptance time, the component, section and priority (for binaries)
may be overridden to new values by changing the value in any or all of
the drop-down (select) boxes to the left of the "accept" button.  Source
uploads can only have their component and section overridden.  Binary
uploads can have all three properties overrdden but can be overridden
only at their file level.  Currently, this UI only permits overriding
all of the binary files in an upload at once, or not at all.

Thus, the items that are checked for acceptance will also be overriden
depending on the selected values.  This allows many items to be
all overridden at once with the same value(s).

The upload manager selects netapplet(source) and pmount(i386) for acceptance:

  >>> upload_manager_browser.getControl(name="QUEUE_ID").value=['2', '3']

And changes some override values:

  >>> upload_manager_browser.getControl(
  ...     name="component_override").displayValue = ['restricted']
  >>> upload_manager_browser.getControl(
  ...     name="section_override").displayValue = ['admin']
  >>> upload_manager_browser.getControl(
  ...     name="priority_override").displayValue = ['extra']

And now accepts the checked items:

  >>> upload_manager_browser.getControl(name="Accept").click()

He sees the informational message that confirms the details of what was
overridden:

  >>> for message in get_feedback_messages(upload_manager_browser.contents):
  ...     print message
  Accepting Results:
  OK: netapplet(restricted/admin), OK: pmount(restricted/admin/extra)

  >>> print_queue(upload_manager_browser.contents)
  Package             Version     Component Section Priority Pocket  When
  netapplet...ddtp... -                                      Release 2005-...
  netapplet...dist... -                                      Release 2005-...
  alsa-utils (source) 1.0.9a-4... main      base    low      Release 2005-...

Any user can now see the 'accepted' queue contains pmount with its
overridden values.

  >>> anon_browser.getControl(
  ...     name="queue_state", index=0).displayValue=['Accepted']
  >>> anon_browser.getControl("Update").click()
  >>> print_queue(anon_browser.contents)
  Package             Version     Component Section Priority Pocket  When
  pmount (i386)       0.1-1                                  Release 2005-...
  ...

The user can drill down into the file list to see the overridden binary
values:

  >>> filelist = find_tags_by_class(
  ...     anon_browser.contents, 'queue-pmount-2')
  >>> for row in filelist:
  ...     print extract_text(row)
  pmount_1.0-1_all.deb (18 bytes) NEW 0.1-1 restricted admin extra

'netapplet' has gone straight to the 'done' queue because it's a single
source upload, and we can see its overridden values there:

  >>> anon_browser.getControl(
  ...     name="queue_state", index=0).displayValue=['Done']
  >>> anon_browser.getControl("Update").click()
  >>> print_queue(anon_browser.contents)
  Package             Version     Component  Section Priority Pocket  When
  ...
  netapplet (source)  0.99.6-1    restricted admin   low ...


== Rejecting items ==

Rejecting 'alsa-utils' source:

  >>> upload_manager_browser.getControl(name="QUEUE_ID").value = ['4']
  >>> upload_manager_browser.getControl(name="Reject").disabled
  False
  >>> upload_manager_browser.getControl(name="Reject").click()
  >>> for message in get_feedback_messages(upload_manager_browser.contents):
  ...     print message
  Rejecting Results:
  OK: alsa-utils

  >>> print_queue(upload_manager_browser.contents)
  Package             Version     Component Section Priority Pocket  When
  netapplet...ddtp... -                                      Release 2005-...
  netapplet...dist... -                                      Release 2005-...

One rejection email is generated:

  >>> [rejection] = pop_notifications()
  >>> rejection['Subject']
  'netapplet-1.0.0.tar.gz rejected'

Please note that in this case the rejection reason is not available
and how that's stated in the notification email body.

  >>> body = rejection.get_payload()[0]
  >>> print body.as_string() # doctest: -NORMALIZE_WHITESPACE
  Content-Type: text/plain; charset="utf-8"
  MIME-Version: 1.0
  Content-Transfer-Encoding: quoted-printable
  <BLANKLINE>
  Rejected:
  Rejected by archive administrator.
  ...
  You are receiving this email because you are the uploader, maintainer or
  signer of the above package.
  <BLANKLINE>

The override controls are now available for rejected packages.

Navigate to the rejected items queue.

    >>> upload_manager_browser.getControl(
    ...    name="queue_state", index=0).displayValue = ['Rejected']
    >>> upload_manager_browser.getControl("Update").click()

    >>> upload_manager_browser.getControl(
    ...     name="queue_state", index=0).displayValue
    ['Rejected']

The various override controls are present now.

    >>> upload_manager_browser.getControl(
    ...     name="component_override").displayValue
    ['(no change)']
    >>> upload_manager_browser.getControl(
    ...     name="section_override").displayValue
    ['(no change)']
    >>> upload_manager_browser.getControl(
    ...     name="priority_override").displayValue
    ['(no change)']

Since the user looks at packages in the rejected queue the "Reject"
button will be disabled.

  >>> upload_manager_browser.getControl(name="Reject").disabled
  True


== Clean up ==

  >>> from canonical.librarian.ftests.harness import cleanupLibrarianFiles
  >>> cleanupLibrarianFiles()

