= Fully Transactional Security Uploads =

In order to allow security uploads to be transactional, i.e., either
get published entirely, source and binaries, or get fully rejected; we
have to allow the security uploads to produce a changesfile that
includes the source and all binaries for the task in question.

This is an extension of the already implemented mixed_mode upload,
which previously allow the user to upload the source and one
respective binary.

While we don't have Security-in-Soyuz (s-i-s) implemented, this will
be a more secure way to perform security uploads of binaires built in
dak, since it guarantee that the interactions will be atomic.

We need to be logged into the security framework in order to get any further

  >>> login('foo.bar@canonical.com')

A NascentUpload is a collection of files in a directory. They
represent what may turn out to be an acceptable upload to a launchpad
managed archive.

  >>> from lp.archiveuploader.nascentupload import NascentUpload
  >>> from lp.archiveuploader.tests import (
  ...    datadir, getPolicy, mock_logger, mock_logger_quiet)

  >>> security_policy = getPolicy(name='security', distro='ubuntu')

We are going to use 'warty/powerpc' distroarchseries and its
respective processorfamily and processor. Let's create them
on-the-fly:

  >>> from canonical.launchpad.interfaces import IDistributionSet
  >>> from canonical.launchpad.database import (
  ...    Processor, ProcessorFamily)

  >>> powerpc_family = ProcessorFamily.selectOneBy(name='powerpc')
  >>> powerpc_proc = Processor(
  ...     family=powerpc_family, name='G4', title='foo', description='nahh')

  >>> ubuntu = getUtility(IDistributionSet)['ubuntu']
  >>> warty = ubuntu['warty']
  >>> warty_powerpc = warty.newArch('powerpc', powerpc_family, True, warty.owner)

  >>> import transaction
  >>> transaction.commit()


== Mixed Security Upload ==

The upload in question contains a source and its 2 builds for i386 and
powerpc:

  >>> foo_mixed_upload = NascentUpload(
  ...     datadir('suite/foo_1.0-1_multi_binary/foo_1.0-1_multi.changes'),
  ...     security_policy, mock_logger_quiet)
  >>> foo_mixed_upload.process()

Inspecting the files processed:

  >>> for file in foo_mixed_upload.changes.files:
  ...    print file.filename
  foo_1.0-1.dsc
  foo_1.0.orig.tar.gz
  foo_1.0-1.diff.gz
  foo_1.0-1_i386.deb
  foo_1.0-1_powerpc.deb

Perform acceptance, creating the respective PackageUpload item and children.
Please note how the package name appears only one time in the subject line
(although the upload has one source and two builds associated with it).

  >>> foo_mixed_upload.logger = mock_logger
  >>> success = foo_mixed_upload.do_accept()
  DEBUG: ...
  DEBUG:     Subject: [ubuntu/warty-security] foo 1.0-1 (New)
  ...

  >>> foo_mixed_queue = foo_mixed_upload.queue_root
  >>> foo_mixed_queue.status.name
  'NEW'

Ensure we have only one source attaches to the PackageUpload record:

  >>> foo_mixed_queue.sources.count()
  1

And it is the right one:

  >>> for source in foo_mixed_queue.sources:
  ...     source.sourcepackagerelease.name
  u'foo'

Ensure we have the two expected builds attached to the PackageUpload record:

  >>> foo_mixed_queue.builds.count()
  2

And they are the correct ones:

  >>> for build in foo_mixed_queue.builds:
  ...     build.build.title
  u'i386 build of foo 1.0-1 in ubuntu warty SECURITY'
  u'powerpc build of foo 1.0-1 in ubuntu warty SECURITY'

Including the uploaded binaries

  >>> for build in foo_mixed_queue.builds:
  ...     [(bin.name, bin.version) for bin in build.build.binarypackages]
  [(u'foo', u'1.0-1')]
  [(u'foo', u'1.0-1')]


== Detecting Inconsistencies ==

NascentUpload code will be able to detect inconsistencies in a
security upload, for example, detecting that the source and the
binaries sent do not match.

  >>> bar_mixed_upload = NascentUpload(
  ...     datadir('suite/foo_1.0-1_broken_binary/bar_1.0-1_multi.changes'),
  ...     security_policy, mock_logger_quiet)
  >>> bar_mixed_upload.process()

Inspecting the files processed:

  >>> for file in bar_mixed_upload.changes.files:
  ...    print file.filename
  bar_1.0-1.dsc
  bar_1.0.orig.tar.gz
  bar_1.0-1.diff.gz
  foo_1.0-1_i386.deb
  foo_1.0-1_powerpc.deb

  >>> bar_mixed_upload.is_rejected
  True

  >>> print bar_mixed_upload.rejection_message
  foo_1.0-1_i386.deb: control file lists name as 'foo', which isn't in changes file.
  foo_1.0-1_powerpc.deb: control file lists name as 'foo', which isn't in changes file.
