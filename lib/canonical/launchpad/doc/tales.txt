TALES expressions
=================

There are several kinds of TALES expressions we've implemented in
Launchpad, to help make it easier to create page templates, without
the need to introduce complex Python code in the template itself.

First, let's bring in a small helper function:

   >>> from canonical.launchpad.ftests import test_tales

count:len gives you a number which is len(thing).

   >>> test_tales('foo/count:len', foo=[])
   0
   >>> test_tales('foo/count:len', foo=[1, 2, 3])
   3
   >>> test_tales('foo/count:len', foo=object())
   Traceback (most recent call last):
   ...
   TypeError: len() of unsized object

To display the icon for a milestone, use fmt:icon:

   >>> from canonical.launchpad.database import MilestoneSet
   >>> milestone = MilestoneSet().get(1)
   >>> test_tales("milestone/fmt:icon", milestone=milestone)
   '<img alt="" src="/++resource++target" />'

datetimes can be formatted with fmt:date, fmt:time and fmt:datetime.

   >>> from datetime import datetime, timedelta
   >>> dt = datetime(2005, 4, 1, 16, 22)
   >>> test_tales('dt/fmt:date', dt=dt)
   '2005-04-01'
   >>> test_tales('dt/fmt:time', dt=dt)
   '16:22:00'
   >>> test_tales('dt/fmt:datetime', dt=dt)
   '2005-04-01 16:22:00'

Test the 'lp:' namespace for presenting DBSchema classes.

    >>> from canonical.lp.dbschema import BinaryPackageFormat
    >>> deb = BinaryPackageFormat.DEB.value
    >>> test_tales('deb/lp:BinaryPackageFormat', deb=deb)
    'Ubuntu Package'

To truncate a long string, use fmt:shorten:

    >>> test_tales('foo/fmt:shorten/8', foo='abcdefghij')
    'abcde...'

To preserve newlines in text when displaying as HTML, use
fmt:nl_to_br:

    >>> test_tales('foo/fmt:nl_to_br',
    ...             foo='icicle\nbicycle\ntricycle & troika')
    'icicle<br />\nbicycle<br />\ntricycle &amp; troika'

To "<pre>" format a string, use fmt:nice_pre:

    >>> import pprint, textwrap
    >>> pprint.pprint(textwrap.wrap(
    ...     test_tales('foo/fmt:nice_pre', foo='hello & goodbye')
    ... ))
    ['<pre style="white-space: -moz-pre-wrap;white-space: -o-pre-wrap;word-',
     'wrap: break-word;">hello &amp; goodbye</pre>']

== Test the 'fmt:' namespace where the context is a dict. ==

fmt:pagetitle takes a page template CONTEXTS dict, and gives you a string
for use in the <title> element of a page.

This case ought to apply only to a page template's CONTEXTS dict.  However, we
have to make this namespace available for all dicts, as there is no type
information to distinguish a page template CONTEXTS dict from any other dict.

    >>> class MockPageTemplateFile:
    ...     filename = '/blah/blah/debug-root-index.pt'
    ...
    >>> CONTEXTS = {'template': MockPageTemplateFile}
    >>> test_tales('foo/fmt:pagetitle', foo=CONTEXTS)
    'Launchpad Debug Home Page'


Test the 'fmt:url' namespace for canonical urls.

    >>> from canonical.launchpad.interfaces import ICanonicalUrlData
    >>> from zope.interface import implements
    >>> class ObjectThatHasUrl:
    ...     implements(ICanonicalUrlData)
    ...     path = 'bonobo/saki'
    ...     inside = None

    >>> object_having_url = ObjectThatHasUrl()
    >>> test_tales('foo/fmt:url', foo=object_having_url)
    'http://localhost:8086/bonobo/saki'

Now, we need to test that it gets the correct application URL from the
request.

Make a mock-up IBrowserRequest, and use this as the interaction.

    >>> from zope.publisher.interfaces.browser import \
    ...     IBrowserApplicationRequest
    >>> from zope.interface import implements
    >>> class MockBrowserRequest:
    ...     implements(IBrowserApplicationRequest)
    ...
    ...     interaction = None
    ...     principal = None
    ...
    ...     def getApplicationURL(self):
    ...         return 'https://mandrill.example.org:23'

    >>> participation = MockBrowserRequest()

    >>> login(ANONYMOUS, participation)

    >>> test_tales('foo/fmt:url', foo=object_having_url)
    'https://mandrill.example.org:23/bonobo/saki'


Test the 'fmt:' namespace where the context is None. In general, these
will return an empty string.  They are provided for ease of handling
NULL values from the database, which become None values for attributes
in content classes.

Everything you can do with 'something/fmt:foo', you should be able to
do with 'None/fmt:foo'.

    >>> test_tales('foo/fmt:shorten', foo=None)
    Traceback (most recent call last):
    ...
    TraversalError: 'you need to traverse a number after fmt:shorten'

    >>> test_tales('foo/fmt:shorten/8', foo=None)
    ''
    >>> test_tales('foo/fmt:nl_to_br', foo=None)
    ''
    >>> test_tales('foo/fmt:nice_pre', foo=None)
    ''
    >>> test_tales('foo/fmt:breadcrumbs', foo=None)
    ''
    >>> test_tales('foo/fmt:date', foo=None)
    ''
    >>> test_tales('foo/fmt:time', foo=None)
    ''
    >>> test_tales('foo/fmt:datetime', foo=None)
    ''
    >>> test_tales('foo/fmt:pagetitle', foo=None)
    ''
    >>> test_tales('foo/fmt:text-to-html', foo=None)
    ''
    >>> test_tales('foo/fmt:url', foo=None)
    ''
    >>> test_tales('foo/fmt:exactduration', foo=None)
    ''
    >>> test_tales('foo/fmt:icon', foo=None)
    ''

Test the 'required:' namespace.  We're already logged in as the anonymous user,
and anonymous users can't edit any person:

    >>> from canonical.launchpad.interfaces import IPersonSet
    >>> person = getUtility(IPersonSet).getByName('sabdfl')
    >>> test_tales('person/required:launchpad.Edit', person=person)
    False

Anonymous users can do anything with the zope.Public permission.

    >>> test_tales('person/required:zope.Public', person=person)
    True

Queries about permissions that don't exist will raise an exception:

    >>> test_tales('person/required:mushroom.Badger', person=person)
    Traceback (most recent call last):
    ...
    ValueError: ('Undefined permission id', 'mushroom.Badger')


