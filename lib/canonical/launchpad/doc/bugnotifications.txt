Malone Bug Notifications
========================

What is a bug notification?
---------------------------

A bug notification is an email that gets sent to Cc'd subscribers of a bug when
something interesting happens to that bug.

When do bug notifications get sent?
-----------------------------------

Not *every* change on a bug causes a notification to be sent. This section will
give a rundown of the things that do cause notifications to be sent. To start
with, let's login:

    >>> login("test@canonical.com")

Then, let's get a handle to our mailer. This is the thing we'll examine to show
what email has been sent, to whom, and what the body of the message contains:

    >>> from canonical.launchpad.mail import stub

And with that, here are the things that cause bug notifications to be sent, and
what those notifications look like.

1. Filing a new bug

    >>> import email
    >>> from zope.event import notify
    >>> from zope.component import getUtility
    >>> from zope.publisher.browser import TestRequest
    >>> from canonical.launchpad.event.sqlobjectevent import (
    ...     SQLObjectModifiedEvent, SQLObjectToBeModifiedEvent,
    ...     SQLObjectCreatedEvent)
    >>> from canonical.launchpad.interfaces import (
    ...     IProductSet, IPersonSet, IDistributionSet, IDistroReleaseSet,
    ...     ISourcePackageNameSet, IBugSet)

    >>> bug_submitter = getUtility(IPersonSet).get(12)
    >>> firefox = getUtility(IProductSet).get(4)

    >>> firefox_crashes = getUtility(IBugSet).createBug(
    ...     product=firefox, title="firefox crashes all the time",
    ...     comment="this is a comment", owner=bug_submitter)
    >>> notify(SQLObjectCreatedEvent(firefox_crashes))

    >>> import transaction
    >>> transaction.commit()

Before we examine the results, we'll define a small helper function
that we will use to sort sent emails by recipient addresses in various
examples throughout the rest of this document.

    >>> def by_to_addrs(a, b):
    ...     return cmp(a[1], b[1])

    >>> test_emails = list(stub.test_emails)
    >>> test_emails.sort(by_to_addrs)
    >>> len(test_emails)
    2
    >>> from_addr, to_addr, raw_message = test_emails.pop()
    >>> print from_addr
    bounces@canonical.com
    >>> print to_addr
    ['test@canonical.com']
    >>> msg = email.message_from_string(raw_message)
    >>> msg["From"]
    'Sample Person <test@canonical.com>'
    >>> msg["Subject"]
    '[Bug ...] firefox crashes all the time'
    >>> msg["Reply-To"]
    'Bug ... <...@bugs...>'
    >>> msg["Sender"]
    'bounces@canonical.com'

Note that all bug notification emails include an absolute URL to the
bug:

    >>> print msg.get_payload(decode=True)
    Public bug reported:
    http://.../malone/bugs/...
    ...

Lastly, let's verify that dilys also received her own notification of
this bug report. Note that each recipient receives their own copy of
the bugmail to overcome issues with Reply-To-All causing people to get
duplicate copies of messages. By having exactly one email address as
the recipient, this issue is avoided:

    >>> from_addr, to_addr, raw_message = test_emails.pop()
    >>> print to_addr
    ['dilys@muse.19inch.net']

    >>> stub.test_emails = []

2. Editing a bug

    >>> from zope.interface import implements
    >>> from canonical.launchpad.interfaces import IBug

    >>> class MockObject(object):
    ...     implements(IBug)

    >>> bug_before_modification = MockObject()
    >>> for name in IBug.names(all=True):
    ...     setattr(bug_before_modification, name,
    ...             getattr(firefox_crashes, name))
    >>> firefox_crashes.summary = "a new summary"
    >>> firefox_crashes_modified = SQLObjectModifiedEvent(
    ...     firefox_crashes, bug_before_modification,
    ...     ["summary"])
    >>> notify(firefox_crashes_modified)

    >>> transaction.commit()

    >>> test_emails = list(stub.test_emails)
    >>> test_emails.sort(by_to_addrs)
    >>> len(test_emails)
    2
    >>> all_to_addrs = [
    ...     to_addrs for from_addr, to_addrs, raw_message in test_emails]
    >>> print all_to_addrs
    [['dilys@muse.19inch.net'], ['test@canonical.com']]

    >>> stub.test_emails = []

3. Filing a new task on an existing bug

There are three kinds of tasks that can be added to an existing
bug. Let's take a look at each type, demonstrating the implications
they each have on notification recipients.

Before we do that, note that BugTaskFactory uses the ILaunchBag
utility to figure out the "current bug" on which to file the task, so
let's hang a bug onto the ILaunchBag utility.

    >>> from canonical.launchpad.interfaces import IOpenLaunchBag
    >>> getUtility(IOpenLaunchBag).add(firefox_crashes)

  3.1 Distro Task

    A task that says this bug must be fixed in a certain distro. Because no
    specific release is specified, the developer will assume that the fix
    belongs in the current development release. For backporting a fix to a
    specific distro release, see 2.2.

    >>> from canonical.launchpad.database.bugtask import BugTaskFactory

    >>> debian = getUtility(IDistributionSet).get(3)
    >>> firefox_source = getUtility(ISourcePackageNameSet).get(1)
    >>> firefox_crashes_in_debian = BugTaskFactory(
    ...     None, distribution = debian.id,
    ...     sourcepackagename = firefox_source.id,
    ...     owner = bug_submitter.id)
    >>> notify(SQLObjectCreatedEvent(firefox_crashes_in_debian))

    >>> transaction.commit()

    >>> test_emails = list(stub.test_emails)
    >>> test_emails.sort(by_to_addrs)
    >>> len(test_emails)
    3
    >>> all_to_addrs = [
    ...     to_addrs for from_addr, to_addrs, raw_message in test_emails]
    >>> print all_to_addrs
    [['dilys@muse.19inch.net'], ['mark@hbd.com'], ['test@canonical.com']]
    >>> from_addr, to_addr, raw_message = test_emails.pop()
    >>> print from_addr
    bounces@canonical.com
    >>> msg = email.message_from_string(raw_message)
    >>> msg["From"]
    'Sample Person <test@canonical.com>'
    >>> msg["Subject"]
    '[Bug ...] firefox crashes all the time'
    >>> msg["Reply-To"]
    'Bug ... <...@bugs...>'
    >>> msg["Sender"]
    'bounces@canonical.com'

    >>> print msg.get_payload(decode=True)
    Public bug report changed:
    http://.../malone/bugs/...
    ...

    >>> stub.test_emails = []

  3.2 Distro Release Task

    Similar to a distro task, except that a task filed on a specific distro
    release is meant to be used for backport fixes (e.g. for critical data
    loss or security bugs.) Tasks filed on specific distro releases are not
    listed in the more generic, distro-wide bug task listings.

    >>> sid = getUtility(IDistroReleaseSet).get(8)
    >>> firefox_crashes_in_sid = BugTaskFactory(
    ...     None, distrorelease = sid.id,
    ...     sourcepackagename = firefox_source.id, owner = bug_submitter.id)
    >>> notify(SQLObjectCreatedEvent(firefox_crashes_in_sid))

    >>> transaction.commit()

    >>> test_emails = list(stub.test_emails)
    >>> test_emails.sort(by_to_addrs)
    >>> len(test_emails)
    3
    >>> all_to_addrs = [
    ...     to_addrs for from_addr, to_addrs, raw_message in test_emails]
    >>> print all_to_addrs
    [['dilys@muse.19inch.net'], ['mark@hbd.com'], ['test@canonical.com']]
    >>> from_addr, to_addr, raw_message = test_emails.pop()
    >>> print from_addr
    bounces@canonical.com
    >>> msg = email.message_from_string(raw_message)
    >>> msg["From"]
    'Sample Person <test@canonical.com>'
    >>> msg["Subject"]
    '[Bug ...] firefox crashes all the time'
    >>> msg["Reply-To"]
    'Bug ... <...@bugs...>'
    >>> msg["Sender"]
    'bounces@canonical.com'

    >>> print msg.get_payload(decode=True)
    Public bug report changed:
    http://.../malone/bugs/...
    ...

    >>> stub.test_emails = []

  3.3 Upstream Task

    An upstream tasks notes that a bug needs to be fixed upstream. "Upstream"
    is a somewhat ambiguous term -- it can have different meanings in the eyes
    of an Ubuntu maintainer vs. a maintainer of a package from an Ubuntu
    derivative. At the moment, "upstream" means "the distro-agnostic place from
    which we procured a source tarball to create a source package for a distro."
    The common case will be that bugs filed in distros bubble up to upstream,
    and are fixed there then bubble back down (via patches) to the various
    distros via patches.

    >>> evolution = getUtility(IProductSet).get(5)
    >>> evolution_crashes_too = BugTaskFactory(
    ...     None, product = evolution.id, owner = bug_submitter.id)
    >>> notify(SQLObjectCreatedEvent(evolution_crashes_too))

    >>> transaction.commit()

    >>> test_emails = list(stub.test_emails)
    >>> test_emails.sort(by_to_addrs)
    >>> len(test_emails)
    3
    >>> all_to_addrs = [
    ...     to_addrs for from_addr, to_addrs, raw_message in test_emails]
    >>> print all_to_addrs
    [['dilys@muse.19inch.net'], ['mark@hbd.com'], ['test@canonical.com']]
    >>> from_addr, to_addr, raw_message = test_emails.pop()
    >>> print from_addr
    bounces@canonical.com
    >>> msg = email.message_from_string(raw_message)
    >>> msg["From"]
    'Sample Person <test@canonical.com>'
    >>> msg["Subject"]
    '[Bug ...] firefox crashes all the time'
    >>> msg["Reply-To"]
    'Bug ... <...@bugs...>'
    >>> msg["Sender"]
    'bounces@canonical.com'

    >>> print msg.get_payload(decode=True)
    Public bug report changed:
    http://.../malone/bugs/...
    ...

    >>> stub.test_emails = []

4. Commenting on a bug

    >>> from canonical.launchpad.interfaces import IBugMessageSet

    >>> bugmessageset = getUtility(IBugMessageSet)
    >>> current_bug = getUtility(IOpenLaunchBag).bug
    >>> current_user = getUtility(IOpenLaunchBag).user
    >>> comment_on_firefox_crashes_in_debian = bugmessageset.createMessage(
    ...     subject="some title", content="just a test comment",
    ...     bug=current_bug, owner=current_user)
    >>> notify(SQLObjectCreatedEvent(comment_on_firefox_crashes_in_debian))

    >>> transaction.commit()

    >>> test_emails = list(stub.test_emails)
    >>> test_emails.sort(by_to_addrs)
    >>> len(test_emails)
    3
    >>> all_to_addrs = [
    ...     to_addrs for from_addr, to_addrs, raw_message in test_emails]
    >>> print all_to_addrs
    [['dilys@muse.19inch.net'], ['mark@hbd.com'], ['test@canonical.com']]
    >>> from_addr, to_addr, raw_message = test_emails.pop()
    >>> print from_addr
    bounces@canonical.com
    >>> msg = email.message_from_string(raw_message)
    >>> msg["From"]
    'Sample Person <test@canonical.com>'
    >>> msg["Subject"]
    '[Bug ...] firefox crashes all the time'
    >>> msg["Reply-To"]
    'Bug ... <...@bugs...>'
    >>> msg["Sender"]
    'bounces@canonical.com'

    >>> print msg.get_payload(decode = True)
    Public bug report changed:
    http://.../malone/bugs/...
    ...

    >>> stub.test_emails = []

5. Editing a task.

Let's demonstrate a notification email where Sample Person marks a
task Accepted, assigns himself to it, and adds a status note.

    >>> from canonical.launchpad.interfaces import IDistroBugTask
    >>> from canonical.lp.dbschema import BugTaskStatus

    >>> class MockObject(object):
    ...     implements(IDistroBugTask)

    >>> bugtask_before_modification = MockObject()
    >>> for name in IDistroBugTask.names(all=True):
    ...     setattr(bugtask_before_modification, name,
    ...             getattr(firefox_crashes_in_debian, name))
    >>> firefox_crashes_in_debian.status = BugTaskStatus.FIXED
    >>> firefox_crashes_in_debian.assignee = bug_submitter.id
    >>> debian_task_modified = SQLObjectModifiedEvent(
    ...     firefox_crashes_in_debian, bugtask_before_modification,
    ...     ["status", "assignee"])
    >>> notify(debian_task_modified)

    >>> transaction.commit()

    >>> test_emails = list(stub.test_emails)
    >>> test_emails.sort(by_to_addrs)
    >>> len(test_emails)
    3
    >>> all_to_addrs = [
    ...     to_addrs for from_addr, to_addrs, raw_message in test_emails]
    >>> print all_to_addrs
    [['dilys@muse.19inch.net'], ['mark@hbd.com'], ['test@canonical.com']]
    >>> from_addr, to_addr, raw_message = test_emails.pop()
    >>> print from_addr
    bounces@canonical.com
    >>> msg = email.message_from_string(raw_message)
    >>> msg["From"]
    'Sample Person <test@canonical.com>'
    >>> msg["Subject"]
    '[Bug ...] firefox crashes all the time'
    >>> msg["Reply-To"]
    'Bug ... <...@bugs...>'
    >>> msg["Sender"]
    'bounces@canonical.com'

    >>> print msg.get_payload(decode=True) #doctest: -NORMALIZE_WHITESPACE
    Public bug report changed:
    http://.../malone/bugs/...
    ...

    >>> stub.test_emails = []

6. Adding and editing a bug watch.

A bug watch can be added to a bug to watch the status of this bug in a
remote bug tracker. A notification is sent out to the bug notification
recipients when a bug watch is added to a bug. Let's demonstrate by
pretending we've just added a watch to a bug.

    >>> from canonical.launchpad.interfaces import IBugWatchSet
    >>> bugwatch = getUtility(IBugWatchSet).get(2)
    >>> bugwatch_added = SQLObjectCreatedEvent(bugwatch)
    >>> notify(bugwatch_added)

    >>> transaction.commit()

    >>> test_emails = list(stub.test_emails)
    >>> test_emails.sort(by_to_addrs)
    >>> len(test_emails)
    4
    >>> all_to_addrs = [
    ...     to_addrs for from_addr, to_addrs, raw_message in test_emails]
    >>> print all_to_addrs
    [['dilys@muse.19inch.net'], ['mark@hbd.com'], ['support@ubuntu.com'], ['test@canonical.com']]
    >>> from_addr, to_addr, raw_message = test_emails.pop()
    >>> print from_addr
    bounces@canonical.com
    >>> msg = email.message_from_string(raw_message)
    >>> msg["From"]
    'Sample Person <test@canonical.com>'
    >>> msg["Subject"]
    '[Bug 1] Firefox does not support SVG'
    >>> msg["Reply-To"]
    'Bug ... <...@bugs...>'
    >>> msg["Sender"]
    'bounces@canonical.com'

    >>> print msg.get_payload(decode=True) #doctest: -NORMALIZE_WHITESPACE
    Public bug report changed:
    http://.../malone/bugs/1
    ...

    >>> stub.test_emails = []

If the bug watch is modified, a notification is sent out describing
the changes made:

    >>> bugwatch_before_modification = MockObject()
    >>> bugwatch_before_modification.bugtracker = bugwatch.bugtracker
    >>> bugwatch_before_modification.remotebug = bugwatch.remotebug
    >>> bugwatch.remotebug = "2001"
    >>> bugwatch_modified = SQLObjectModifiedEvent(
    ...     object = bugwatch,
    ...     object_before_modification = bugwatch_before_modification,
    ...     edited_fields = ("remotebug"))

    >>> notify(bugwatch_modified)

    >>> transaction.commit()

    >>> test_emails = list(stub.test_emails)
    >>> test_emails.sort(by_to_addrs)
    >>> len(test_emails)
    4
    >>> all_to_addrs = [
    ...     to_addrs for from_addr, to_addrs, raw_message in test_emails]
    >>> print all_to_addrs
    [['dilys@muse.19inch.net'], ['mark@hbd.com'], ['support@ubuntu.com'], ['test@canonical.com']]
    >>> from_addr, to_addr, raw_message = test_emails.pop()
    >>> print from_addr
    bounces@canonical.com
    >>> msg = email.message_from_string(raw_message)
    >>> msg["From"]
    'Sample Person <test@canonical.com>'
    >>> msg["Subject"]
    '[Bug 1] Firefox does not support SVG'
    >>> msg["Reply-To"]
    'Bug ... <...@bugs...>'
    >>> msg["Sender"]
    'bounces@canonical.com'

    >>> print msg.get_payload(decode=True) #doctest: -NORMALIZE_WHITESPACE
    Public bug report changed:
    http://.../malone/bugs/1
    ...

    >>> stub.test_emails = []

7. Adding and editing a CVE ref.

Adding a CVE reference to a bug also causes a notification email to go
out to the bug notification recipient list. Let's create a CVE ref and
attach it to the firefox_crashes bug that we've been using throughout
this document:

    >>> from canonical.launchpad.interfaces import ICveSet
    >>> from canonical.lp.dbschema import CveStatus
    >>> cve = getUtility(ICveSet).new(sequence="2004-0276",
    ...     description="a brief CVE description", status=CveStatus.ENTRY)
    >>> from canonical.launchpad.database import Bug
    >>> bug = Bug.get(1)
    >>> bugcve = cve.linkBug(bug) # note this creates the event and notifies

    >>> transaction.commit()

    >>> test_emails = list(stub.test_emails)
    >>> test_emails.sort(by_to_addrs)
    >>> len(test_emails)
    4
    >>> all_to_addrs = [
    ...     to_addrs for from_addr, to_addrs, raw_message in test_emails]
    >>> print all_to_addrs
    [['dilys@muse.19inch.net'], ['mark@hbd.com'], ['support@ubuntu.com'], ['test@canonical.com']]
    >>> from_addr, to_addr, raw_message = test_emails.pop()
    >>> print from_addr
    bounces@canonical.com
    >>> msg = email.message_from_string(raw_message)
    >>> msg["From"]
    'Sample Person <test@canonical.com>'
    >>> msg["Subject"]
    '[Bug 1] Firefox does not support SVG'
    >>> msg["Reply-To"]
    'Bug ... <...@bugs...>'
    >>> msg["Sender"]
    'bounces@canonical.com'

    >>> print msg.get_payload(decode=True) #doctest: -NORMALIZE_WHITESPACE
    Public bug report changed:
    http://.../malone/bugs/1
    ...

    >>> stub.test_emails = []

8. Adding an external URL reference.

When someone adds a web link to a bug report (e.g. to a related
mailing list discussion), an email is sent to the notification
recipients. We'll demonstrate by creating an external link and
publishing an object created event.

    >>> from canonical.launchpad.interfaces import IBugExternalRefSet
    >>> extref = getUtility(IBugExternalRefSet).createBugExternalRef(
    ...     bug = 1, url = "http://www.example.com", title="test",
    ...     owner = 12)
    >>> extref_added = SQLObjectCreatedEvent(extref)
    >>> notify(extref_added)

    >>> transaction.commit()

    >>> test_emails = list(stub.test_emails)
    >>> test_emails.sort(by_to_addrs)
    >>> len(test_emails)
    4
    >>> all_to_addrs = [
    ...     to_addrs for from_addr, to_addrs, raw_message in test_emails]
    >>> print all_to_addrs
    [['dilys@muse.19inch.net'], ['mark@hbd.com'], ['support@ubuntu.com'], ['test@canonical.com']]
    >>> from_addr, to_addr, raw_message = test_emails.pop()
    >>> print from_addr
    bounces@canonical.com
    >>> msg = email.message_from_string(raw_message)
    >>> msg["From"]
    'Sample Person <test@canonical.com>'
    >>> msg["Subject"]
    '[Bug 1] Firefox does not support SVG'
    >>> msg["Reply-To"]
    'Bug ... <...@bugs...>'
    >>> msg["Sender"]
    'bounces@canonical.com'

    >>> print msg.get_payload(decode=True) #doctest: -NORMALIZE_WHITESPACE
    Public bug report changed:
    http://.../malone/bugs/1
    ...

    >>> stub.test_emails = []

When a link is edited, the notification will look as follows:

    >>> extref_before_modification = MockObject()
    >>> extref_before_modification.url = extref.url
    >>> extref_before_modification.title = extref.title
    >>> extref.url = "http://www.example.com/somewhere.html"

    >>> extref_changed = SQLObjectModifiedEvent(
    ...     object_before_modification = extref_before_modification,
    ...     object = extref,
    ...     edited_fields = ("url",))
    >>> notify(extref_changed)

    >>> transaction.commit()

    >>> test_emails = list(stub.test_emails)
    >>> test_emails.sort(by_to_addrs)
    >>> len(test_emails)
    4
    >>> all_to_addrs = [
    ...     to_addrs for from_addr, to_addrs, raw_message in test_emails]
    >>> print all_to_addrs
    [['dilys@muse.19inch.net'], ['mark@hbd.com'], ['support@ubuntu.com'], ['test@canonical.com']]
    >>> from_addr, to_addr, raw_message = test_emails.pop()
    >>> print from_addr
    bounces@canonical.com
    >>> msg = email.message_from_string(raw_message)
    >>> msg["From"]
    'Sample Person <test@canonical.com>'
    >>> msg["Subject"]
    '[Bug 1] Firefox does not support SVG'
    >>> msg["Reply-To"]
    'Bug ... <...@bugs...>'
    >>> msg["Sender"]
    'bounces@canonical.com'

    >>> print msg.get_payload(decode=True) #doctest: -NORMALIZE_WHITESPACE
    Public bug report changed:
    http://.../malone/bugs/1
    ...

    >>> stub.test_emails = []

9. Marking a bug as a duplicate

When someone marks a bug as a duplicate two emails are sent. One to the
duplicate bug's subscribers, telling that the bug has been marked a
duplicate, and one email to the subscribers of the bug that the duplicate
bug is a duplicate of, telling which bug has been marked as a
duplicate.

    >>> from canonical.launchpad.helpers import Snapshot
    >>> bug_one = getUtility(IBugSet).get(1)
    >>> bug_two = getUtility(IBugSet).get(2)
    >>> bug_two_unmodified = Snapshot(bug_two, providing=IBug)
    >>> bug_two.duplicateof = bug_one
    >>> marked_duplicate = SQLObjectModifiedEvent(
    ...     bug_two, bug_two_unmodified, edited_fields=['duplicateof'])
    >>> notify(marked_duplicate)

    >>> transaction.commit()

    >>> test_emails = list(stub.test_emails)
    >>> test_emails.sort(by_to_addrs)
    >>> len(test_emails)
    8
    >>> all_to_addrs = [
    ...     to_addrs for from_addr, to_addrs, raw_message in test_emails]
    >>> print all_to_addrs
    [['dilys@muse.19inch.net'], ['dilys@muse.19inch.net'],
     ['mark@hbd.com'], ['mark@hbd.com'],
     ['support@ubuntu.com'], ['support@ubuntu.com'],
     ['test@canonical.com'], ['test@canonical.com']]

    >>> sample_person_mails = [email.message_from_string(raw_message)
    ...                        for from_, to, raw_message in test_emails
    ...                        if 'test@canonical.com' in to]
    >>> sample_person_mails.sort(key=lambda msg: msg['Subject'])
    >>> bug_one_notification = sample_person_mails[0]
    >>> print bug_one_notification['Subject']
    [Bug 1] Firefox does not support SVG
    >>> body = bug_one_notification.get_payload(decode=True)
    >>> print body #doctest: -NORMALIZE_WHITESPACE
    http://.../malone/bugs/1
    ...
    *** Bug 2 has been marked a duplicate of this bug ***

    >>> bug_two_notification = sample_person_mails[1]
    >>> print bug_two_notification['Subject']
    [Bug 2] Blackhole Trash folder
    >>> body = bug_two_notification.get_payload(decode=True)
    >>> print body #doctest: -NORMALIZE_WHITESPACE
    Public bug report changed:
    http://.../malone/bugs/2
    ...
    *** This bug has been marked a duplicate of bug 1 ***
    ...
   
    >>> stub.test_emails = []


Now we change the target of a bug that's already marked as a dupe and check if the correct notification message is sent.


    >>> bug_six = getUtility(IBugSet).get(6)
    >>> bug_three = getUtility(IBugSet).get(3)
    >>> bug_six_unmodified = Snapshot(bug_six, providing=IBug)
    >>> bug_six.duplicateof = bug_three 
    >>> marked_duplicate = SQLObjectModifiedEvent(
    ...     bug_six, bug_six_unmodified, edited_fields=['duplicateof'])
    >>> notify(marked_duplicate)

    >>> transaction.commit()
    
    >>> test_emails = list(stub.test_emails)
    >>> test_emails.sort(by_to_addrs)
    >>> len(test_emails)
    5
    >>> all_to_addrs = [
    ...     to_addrs for from_addr, to_addrs, raw_message in test_emails]
    >>> print all_to_addrs
    [['dilys@muse.19inch.net'], ['dilys@muse.19inch.net'], ['foo.bar@canonical.com'], ['mark@hbd.com'], ['test@canonical.com']]
    >>> sample_person_mails = [email.message_from_string(raw_message)
    ...                        for from_, to, raw_message in test_emails
    ...                        if 'test@canonical.com' in to]
    >>> sample_person_mails.sort(key=lambda msg: msg['Subject'])

    >>> bug_six_notification = sample_person_mails[0]
    >>> print bug_six_notification['Subject']
    [Bug 6] Firefox crashes when Save As dialog for a nonexistent...
    >>> body = bug_six_notification.get_payload(decode=True)
    >>> print body #doctest: -NORMALIZE_WHITESPACE
    Public bug report changed:
    http://.../malone/bugs/6
    <BLANKLINE>
    *** This bug is no longer a duplicate of bug 5 ***
    <BLANKLINE>
    *** This bug has been marked a duplicate of bug 3 ***
    <BLANKLINE>
    <BLANKLINE>

    >>> stub.test_emails = []

Now we unduplicate the above bug and check if the correct notification message is sent.


    >>> bug_six = getUtility(IBugSet).get(6)
    >>> bug_six_unmodified = Snapshot(bug_six, providing=IBug)
    >>> bug_six.duplicateof = None 
    >>> marked_duplicate = SQLObjectModifiedEvent(
    ...     bug_six, bug_six_unmodified, edited_fields=['duplicateof'])
    >>> notify(marked_duplicate)

    >>> transaction.commit()
    
    >>> test_emails = list(stub.test_emails)
    >>> test_emails.sort(by_to_addrs)
    >>> len(test_emails)
    2
    >>> all_to_addrs = [
    ...     to_addrs for from_addr, to_addrs, raw_message in test_emails]
    >>> print all_to_addrs
    [['dilys@muse.19inch.net'], ['test@canonical.com']]
    >>> sample_person_mails = [email.message_from_string(raw_message)
    ...                        for from_, to, raw_message in test_emails
    ...                        if 'test@canonical.com' in to]
    >>> sample_person_mails.sort(key=lambda msg: msg['Subject'])

    >>> bug_six_notification = sample_person_mails[0]
    >>> print bug_six_notification['Subject']
    [Bug 6] Firefox crashes when Save As dialog for a nonexistent...
    >>> body = bug_six_notification.get_payload(decode=True)
    >>> print body #doctest: -NORMALIZE_WHITESPACE
    Public bug report changed:
    http://.../malone/bugs/6
    ...
    *** This bug is no longer a duplicate of bug 3 ***
    ...

    >>> stub.test_emails = []


    
Implications of Bug Privacy
---------------------------

Making a bug private changes notification semantics. When a bug is
made private, the only users that will receive notifcations for that
bug are those who are explicitly CC'd to the bug.

To learn more of the specifics of these semantics, consult the
BugPrivacy spec:

    https://wiki.launchpad.canonical.com/BugPrivacy

and as well, the system document:

    lib/canonical/launchpad/doc/bugsubscription.txt

To demonstrate what we mean, let's make the firefox crashing bug
report private:

    >>> firefox_bug = getUtility(IBugSet).get(firefox_crashes.id)

    >>> new_values = {"private" : True}
    >>> bug_will_be_set_private = SQLObjectToBeModifiedEvent(
    ...     firefox_bug, new_values)

    >>> notify(bug_will_be_set_private)

    >>> firefox_bug.private = True
    >>> bug_before_modification = MockObject()
    >>> bug_before_modification.title = firefox_bug.title
    >>> bug_before_modification.summary = firefox_bug.summary
    >>> bug_before_modification.description = firefox_bug.description
    >>> bug_before_modification.name = firefox_bug.name
    >>> bug_before_modification.id = firefox_bug.id
    >>> bug_before_modification.private = False
    >>> bug_before_modification.subscriptions = firefox_bug.subscriptions
    >>> bug_before_modification.bugtasks = firefox_bug.bugtasks
    >>> bug_before_modification.duplicateof = firefox_bug.duplicateof
    >>> bug_modified = SQLObjectModifiedEvent(
    ...     firefox_bug, bug_before_modification,
    ...     ["private"])

    >>> notify(bug_modified)

    >>> transaction.commit()
    >>> stub.test_emails = []

Now, when we add a new task to that bug, the maintainer of the task
target will *not* get a notification (when a bug is marked private,
implicit subscription is disabled):

XXX: Brad Bollenbach, 2005-03-07: This is a totally CONTRIVED example!
I should be adding this to another source package in another distro,
but that would mean adding more sample sourcepackage data, which I
don't want to do until after Nukesourcepackage is implemented, because
the SourcePackage table is going to be blown away anyway.

    >>> applets = getUtility(IProductSet).get(9)
    >>> applets_crashes_too = BugTaskFactory(
    ...     None, product = applets.id, owner = bug_submitter.id)

Normally, you might expect to see the maintainer of applets (Foo Bar,
email foo.bar@canonical.com) now be included in the list of recipients
that will get notified of changes on this bug. Because the bug is
private, and Foo Bar is not an explicit subscriber to the bug, he will
*not* be included in the list of recipients!

    >>> notify(SQLObjectCreatedEvent(applets_crashes_too))

    >>> transaction.commit()

    >>> test_emails = list(stub.test_emails)
    >>> test_emails.sort(by_to_addrs)
    >>> len(test_emails)
    2
    >>> all_to_addrs = [
    ...     to_addrs for from_addr, to_addrs, raw_message in test_emails]
    >>> print all_to_addrs
    [['mark@hbd.com'], ['test@canonical.com']]
    >>> from_addr, to_addr, raw_message = test_emails.pop()
    >>> print from_addr
    bounces@canonical.com
    >>> msg = email.message_from_string(raw_message)
    >>> msg["From"]
    'Sample Person <test@canonical.com>'
    >>> msg["Subject"]
    '[Bug ...] firefox crashes all the time'
    >>> msg["Reply-To"]
    'Bug ... <...@bugs...>'
    >>> msg["Sender"]
    'bounces@canonical.com'

    >>> stub.test_emails = []

If, for some odd reason, none of the subscribers on a bug have a
preferred email set, no attempt to send a notification email will
occur. Let's use another example to demonstrate what we mean; the same
thing as the previous example, but this time let's "mock out" the
bug's notificationRecipientAddresses method to pretend there are no
recipient addresses:

    >>> from canonical.launchpad.interfaces import IBugTask
    >>> from canonical.launchpad.database import Bug
    >>> from canonical.launchpad import mailnotification

    >>> class MockBugNoRecipientAddresses(Bug):
    ...     _table = 'Bug'
    ...     def notificationRecipientAddresses(self):
    ...         return []
    >>> class MockBugTask(object):
    ...     implements(IBugTask)
    ...     def __init__(self, bugtask):
    ...         self.bugtask = bugtask
    ...         self.bug = MockBugNoRecipientAddresses.get(1)
    ...     def __getattr__(self, name):
    ...         return getattr(self.bugtask, name)

    >>> old_global_emails = mailnotification.GLOBAL_NOTIFICATION_EMAIL_ADDRS
    >>> mailnotification.GLOBAL_NOTIFICATION_EMAIL_ADDRS = []
    >>> task_with_no_subscribers = MockBugTask(evolution_crashes_too)
    >>> notify(SQLObjectCreatedEvent(task_with_no_subscribers))

    >>> transaction.commit()

    >>> len(stub.test_emails)
    0
    >>> mailnotification.GLOBAL_NOTIFICATION_EMAIL_ADDRS = old_global_emails
