Tests for our PO parser.
========================

  >>> from canonical.launchpad.components.poparser import (
  ...     POMessage, POHeader, POParser)


POHeader.getPORevisionDate
--------------------------

Test that the function does not fails if the date field has unicode chars:

  >>> header = POHeader(msgstr="""
  ... Project-Id-Version: foo
  ... Report-Msgid-Bugs-To: foo@bar.com
  ... POT-Creation-Date: 2005-01-26 01:01+0100
  ... PO-Revision-Date: \xc3\xa1 2004-03-06 20:06+0100
  ... Last-Translator: Foo translator <footranslator@bar.com>
  ... MIME-Version: 1.0
  ... Content-Type: text/plain; charset=UTF-8
  ... Content-Transfer-Encoding: 8bit
  ... """)
  >>> header.updateDict()
  >>> header.getPORevisionDate()
  (u'\xe1 2004-03-06 20:06+0100', None)
  >>> header.getPluralFormExpression() == None
  True


Parsing a PO template
---------------------

Parsing a PO template:

  >>> content = """
  ... msgid ""
  ... msgstr ""
  ... "Project-Id-Version: Foobar 1.0\\n"
  ... "Report-Msgid-Bugs-To: \\n"
  ... "POT-Creation-Date: 2004-05-11 20:22+0800\\n"
  ... "PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\\n"
  ... "Last-Translator: FULL NAME <EMAIL@ADDRESS>\\n"
  ... "Language-Team: LANGUAGE <LL@li.org>\\n"
  ... "MIME-Version: 1.0\\n"
  ... "Content-Type: text/plain; charset=CHARSET\\n"
  ... "Content-Transfer-Encoding: 8bit\\n"
  ... #: foo/bar.c:42
  ... msgid "Foo"
  ... msgstr ""
  ... """

  >>> parser = POParser()
  >>> parser.write(content)
  >>> parser.finish()

  >>> print parser.header['project-id-version']
  Foobar 1.0
  >>> print parser.header['content-type']
  text/plain; charset=CHARSET
  >>> len(parser.messages)
  1
  >>> print parser.messages[0].msgid
  Foo


Split Multibyte Sequences
-------------------------

The PO file parser can incrementally parse files.  When multibyte
character encodings are used, this opens up the possibility that a
chunk fed to the parser will start or end with part of a character.

The PO parser handles this case correctly:

  >>> chunk1 = """
  ... msgid ""
  ... msgstr ""
  ... "POT-Creation-Date: 2004-05-11 20:22+0800\\n"
  ... "PO-Revision-Date: 2004-05-11 20:22+0800\\n"
  ... "Content-Type: text/plain; charset=UTF-8\\n"
  ... "Content-Transfer-Encoding: 8bit\\n"
  ... #: foo/bar.c: 42
  ... msgid "Foo"
  ... msgstr "\xE2"""
  >>> chunk2 = """\x96\x84"
  ... """

  >>> parser = POParser()
  >>> parser.write(chunk1)
  >>> parser.write(chunk2)
  >>> parser.finish()

  >>> len(parser.messages)
  1
  >>> parser.messages[0].msgid
  u'Foo'
  >>> parser.messages[0].msgstr
  u'\u2584'


Evil Big5 Multibyte Sequences
-----------------------------

To parse a PO file, it is necessary to know what encoding it is in,
which is specified in the PO file header.

This is particularly important with some encodings such as Big5, which
may include backslashes inside multibyte sequences.  These backslashes
must be interpreted as part of the character rather than as an escape
character.

  >>> content = """
  ... msgid ""
  ... msgstr ""
  ... "Last-Translator:  \xb5\x7b\xa6\xa1\xbf\xf9\xbb\x7e\\n"
  ... "Content-Type: text/plain; charset=Big5\\n"
  ... "Content-Transfer-Encoding: 8bit\\n"
  ... #: lib/regex.c:1367
  ... msgid "Success"
  ... msgstr "\xa6\xa8\xa5\\"
  ... """

  >>> parser = POParser()
  >>> parser.write(content)
  >>> parser.finish()

Check that Big5 characters in the PO header have been correctly
converted:

  >>> parser.header['last-translator']
  u'\u7a0b\u5f0f\u932f\u8aa4'

Check that the translation of the first message has been interpreted
correctly, despite the backslash in the second multibyte sequence:

  >>> parser.messages[0].msgstr
  u'\u6210\u529f'
