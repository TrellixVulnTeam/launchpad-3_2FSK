= Generic ExternalBugTracker Tests =

ExternalBugTracker instances are used to communicate with remote bug
trackers. This document tests those features that are common to all
ExternalBugTracker instances.

== Updating bug watches ==

All the ExternalBugTrackers know how to update the status of a bug
watch. The method that updates the bug watches is
BugWatchUpdater.updateBugWatches(), which expects an IExternalBugTracker
and the bug watches to update.


=== Initializing ===

Before updating the bug watches, the initializeRemoteBugDB() method on
the ExternalBugTracker is called. It gets the information for the bug
watches from the external bug tracker, and it's called outside a DB
transaction, since it doesn't need DB access.

    >>> from canonical.launchpad.ftests.externalbugtracker import (
    ...     TestExternalBugTracker)
    >>> class InitializingExternalBugTracker(TestExternalBugTracker):
    ...
    ...     def initializeRemoteBugDB(self, remote_bug_ids):
    ...         print "initializeRemoteBugDB() called: %r" % (
    ...             remote_bug_ids, )

    >>> class FakeTransaction:
    ...     """Transaction class to track transaction boundaries."""
    ...     def commit(self):
    ...         print "COMMIT"
    ...     def abort(self):
    ...         print "ABORT"
    ...     def begin(self):
    ...         print "BEGIN"

    >>> from canonical.launchpad.scripts.checkwatches import BugWatchUpdater
    >>> bug_watch_updater = BugWatchUpdater(FakeTransaction())
    >>> bug_watch_updater.updateBugWatches(
    ...     InitializingExternalBugTracker(), [])
    COMMIT
    initializeRemoteBugDB() called: []
    BEGIN


=== Choosing another ExternalBugTracker instance ===

Sometimes there is more than one ExternalBugTracker instance for a
single bug tracker type. For example, for different versions, for
intances having our Launchpad plugin installed, and so on. This is done
with the getExternalBugTrackerToUse() method, which returns the correct
instance.  Usually there is only one version, so the default for the
original instance is to return itself.

    >>> from canonical.launchpad.components.externalbugtracker import (
    ...     ExternalBugTracker)
    >>> external_bugtracker = ExternalBugTracker('http://example.com/')
    >>> chosen_bugtracker = external_bugtracker.getExternalBugTrackerToUse()
    >>> chosen_bugtracker is external_bugtracker
    True

BugWatchUpdater calls externalbugtracker.get_external_bugtracker(),
follwed by ExternalBugTracker.getExternalBugTrackerToUse() to get the
correct ExternalBugTracker for a given BugTracker. It does this via the
private _getExternalBugTrackersAndWatches() method, which returns a set of
(ExternalBugTracker, bug_watches) tuples.

    >>> from canonical.launchpad.components.externalbugtracker import (
    ...     Bugzilla, BugzillaLPPlugin, BUG_TRACKER_CLASSES)
    >>> from canonical.launchpad.interfaces.bugtracker import (
    ...     BugTrackerType)
    >>> from canonical.launchpad.testing import LaunchpadObjectFactory

    >>> factory = LaunchpadObjectFactory()
    >>> standard_bugzilla = factory.makeBugTracker()

    >>> class NonConnectingBugzilla(Bugzilla):
    ...     def getExternalBugTrackerToUse(self):
    ...         print "Getting external bugtracker to use..."
    ...         return Bugzilla(self.baseurl)

We'll create a helper method to allow us to avoid having to connect to a
remote server.

    >>> def get_trackers_and_watches(bugtracker, watches):
    ...     try:
    ...         BUG_TRACKER_CLASSES[BugTrackerType.BUGZILLA] = (
    ...             NonConnectingBugzilla)
    ...         trackers_and_watches = (
    ...             bug_watch_updater._getExternalBugTrackersAndWatches(
    ...                 bugtracker, watches))
    ...     finally:
    ...         BUG_TRACKER_CLASSES[BugTrackerType.BUGZILLA] = Bugzilla
    ...
    ...     return trackers_and_watches

    >>> trackers_and_watches = get_trackers_and_watches(
    ...     standard_bugzilla, [])
    Getting external bugtracker to use...

    >>> chosen_bugtracker, watches = trackers_and_watches[0]
    >>> isinstance(chosen_bugtracker, Bugzilla)
    True

_getExternalBugTrackersAndWatches() also takes a list of bug watches as a
parameter. For most calls, this remains unaltered and only one
(ExternalBugTracker, bug_watches) tuple will be returned.

    >>> bug_watches = [
    ...     factory.makeBugWatch(bugtracker=standard_bugzilla)
    ...         for useless_int in range(10)]

    >>> trackers_and_watches = get_trackers_and_watches(
    ...     standard_bugzilla, bug_watches)
    Getting external bugtracker to use...

    >>> chosen_bugtracker, watches = trackers_and_watches[0]
    >>> isinstance(chosen_bugtracker, Bugzilla)
    True

    >>> watches == bug_watches
    True

The only bug tracker for which _getExternalBugTrackersAndWatches() will
return more than one (ExternalBugTracker, bug_watches) tuple: the Gnome
Bugzilla. This is because the Gnome Bugzilla is a special case.

Bugzilla allows users to track bugs in more than one product. Launchpad
supports this functionality through the BugzillaLPPlugin
ExternalBugTracker subclass. Since the Gnome Bugzilla contains a very
large number of bugs we only want to synchronise comments and bugs for
some products. For the others, we want to use the standard
ExternalBugTracker functionality, without tapping into the functionality
offered by the Bugzilla Launchpad plugin.

The Gnome Bugzilla is a celebrity in Launchpad.

    >>> from canonical.launchpad.ftests.externalbugtracker import (
    ...     TestBugzillaXMLRPCTransport, TestInternalXMLRPCTransport)
    >>> from canonical.launchpad.interfaces import ILaunchpadCelebrities
    >>> gnome_bugzilla = getUtility(ILaunchpadCelebrities).gnome_bugzilla

If the gnome_bugzilla doesn't have the Launchpad plugin installed, it
will behave exactly the same as any other bug tracker.

    >>> gnome_bugzilla.has_lp_plugin = False
    >>> trackers_and_watches = get_trackers_and_watches(
    ...     gnome_bugzilla, bug_watches)
    Getting external bugtracker to use...

    >>> chosen_bugtracker, watches = trackers_and_watches[0]
    >>> isinstance(chosen_bugtracker, Bugzilla)
    True

    >>> watches == bug_watches
    True


=== Checking the server DB time ===

Before initializeRemoteBugDB is called and we start importing
information from the remote bug tracker, we check what the bug tracker
thinks the current time is. Returning None means that we don't know what
the time is.

    >>> class TimeUnknownExternalBugTracker(InitializingExternalBugTracker):
    ...
    ...     def getCurrentDBTime(self):
    ...         print "getCurrentDBTime() called"
    ...         return None

    >>> bug_watch_updater.updateBugWatches(
    ...     TimeUnknownExternalBugTracker(), [])
    COMMIT
    getCurrentDBTime() called
    initializeRemoteBugDB() called: []
    BEGIN

If the difference between what we and the remote system think the time
is, an error is raised.

    >>> import pytz
    >>> from datetime import datetime, timedelta
    >>> utc_now = datetime.now(pytz.timezone('UTC'))
    >>> class PositiveTimeSkewExternalBugTracker(TestExternalBugTracker):
    ...
    ...     def getCurrentDBTime(self):
    ...         return utc_now + timedelta(minutes=20)

    >>> bug_watch_updater.updateBugWatches(
    ...     PositiveTimeSkewExternalBugTracker(), [], now=utc_now)
    Traceback (most recent call last):
    ...
    TooMuchTimeSkew: ...

    >>> class NegativeTimeSkewExternalBugTracker(TestExternalBugTracker):
    ...
    ...     def getCurrentDBTime(self):
    ...         return utc_now - timedelta(minutes=20)

    >>> bug_watch_updater.updateBugWatches(
    ...     NegativeTimeSkewExternalBugTracker(), [], now=utc_now)
    Traceback (most recent call last):
    ...
    TooMuchTimeSkew: ...

If it's only a little skewed, it won't raise an error.

    >>> class CorrectTimeExternalBugTracker(TestExternalBugTracker):
    ...
    ...     def getCurrentDBTime(self):
    ...         return utc_now + timedelta(minutes=1)
    >>> bug_watch_updater.updateBugWatches(
    ...     CorrectTimeExternalBugTracker(), [], now=utc_now)
    COMMIT
    BEGIN

If the timezone is known, the local time time should be returned, rather
than the UTC time.

    >>> class LocalTimeExternalBugTracker(TestExternalBugTracker):
    ...
    ...     def getCurrentDBTime(self):
    ...         local_time = utc_now.astimezone(pytz.timezone('US/Eastern'))
    ...         return local_time + timedelta(minutes=1)
    >>> bug_watch_updater.updateBugWatches(
    ...     LocalTimeExternalBugTracker(), [], now=utc_now)
    COMMIT
    BEGIN

If the remote server time is unknown, we will refuse to import any
comments from it. Bug watches will still be updated, but a warning is
logged saying that comments won't be imported.

    >>> from zope.interface import implements
    >>> from canonical.launchpad.interfaces import ISupportsCommentImport
    >>> class CommentImportExternalBugTracker(TimeUnknownExternalBugTracker):
    ...     implements(ISupportsCommentImport)
    ...     sync_comments = True
    >>> bug_watch_updater.updateBugWatches(
    ...     CommentImportExternalBugTracker(), [], now=utc_now)
    COMMIT
    getCurrentDBTime() called
    initializeRemoteBugDB() called: []
    BEGIN
    WARNING:...:Comment importing supported, but server time can't be
                trusted. No comments will be imported.


=== Limiting which bug watches to update ===

In order to reduce the amount of data we have to transfer over the
network, each IExternalBugTracker has the ability to filter out bugs
that haven't been modified. The method responsible for this is
getModifiedRemoteBugs(), which accepts the set of bugs that should be
checked, as well as the oldest time any of the bugs were last checked.
The getModifiedRemoteBugs() is only called for bug trackers where we
know that their time is similar to ours.

    >>> class CheckModifiedExternalBugTracker(InitializingExternalBugTracker):
    ...     def getCurrentDBTime(self):
    ...         return datetime.now(pytz.timezone('UTC'))
    ...     def getModifiedRemoteBugs(self, remote_bug_ids, last_checked):
    ...         print "last_checked: %s" % last_checked
    ...         print "getModifiedRemoteBugs() called: %r" % (
    ...             remote_bug_ids, )
    ...         return [remote_bug_ids[0], remote_bug_ids[-1]]
    ...     def getRemoteStatus(self, bug_id):
    ...         print "getRemoteStatus() called: %r" % bug_id
    ...         return 'UNKNOWN'

Only bugs that haven't been checked before are passed on to
getModifiedRemoteBugs(). I.e., if we have a set of newly created bug
watches, the getModifiedRemoteBugs() method won't be called.

    >>> from canonical.launchpad.database import BugTracker
    >>> from canonical.launchpad.interfaces import (
    ...     BugTrackerType, IBugSet, IBugWatchSet, IPersonSet)

    >>> sample_person = getUtility(IPersonSet).getByEmail(
    ...     'test@canonical.com')

    >>> example_bug_tracker = BugTracker(
    ...     name="example-bugs",
    ...     title="Example.com Bug Tracker",
    ...     bugtrackertype=BugTrackerType.BUGZILLA,
    ...     baseurl="http://bugs.example.com",
    ...     summary="Contains bugs for Example.com",
    ...     contactdetails="foo.bar@example.com",
    ...     owner=sample_person)
    >>> example_bug = getUtility(IBugSet).get(10)

    >>> bug_watches = [
    ...     getUtility(IBugWatchSet).createBugWatch(
    ...         example_bug, sample_person, example_bug_tracker, bug_id)
    ...     for bug_id in ['1', '2', '3', '4']]
    >>> bug_watch_ids = [bug_watch.id for bug_watch in bug_watches]
    >>> [bug_watch.lastchecked for bug_watch in bug_watches
    ...  if bug_watch.lastchecked is not None]
    []

    >>> bug_watch_updater.updateBugWatches(
    ...     CheckModifiedExternalBugTracker('http://example.com/'),
    ...     bug_watches)
    COMMIT
    initializeRemoteBugDB() called: [u'1', u'2', u'3', u'4']
    BEGIN
    getRemoteStatus() called: u'1'
    getRemoteStatus() called: u'2'
    getRemoteStatus() called: u'3'
    getRemoteStatus() called: u'4'

If the bug watches have the lastchecked attribute set, they will be
passed to getModifiedRemoteBugs(). Only the bugs that have been modified
will then be passed on to initializeRemoteBugDB().

    >>> some_time_ago = datetime(
    ...     2007, 03, 17, 16, 00, tzinfo=pytz.timezone('UTC'))
    >>> bug_watches = [
    ...     getUtility(IBugWatchSet).get(bug_watch_id)
    ...     for bug_watch_id in bug_watch_ids]
    >>> for bug_watch in bug_watches:
    ...     bug_watch.lastchecked = some_time_ago
    >>> flush_database_updates()

    >>> bug_watch_updater.updateBugWatches(
    ...     CheckModifiedExternalBugTracker('http://example.com/'),
    ...     bug_watches)
    COMMIT
    last_checked: 2007-03-17 15:...:...
    getModifiedRemoteBugs() called: [u'1', u'2', u'3', u'4']
    initializeRemoteBugDB() called: [u'1', u'4']
    BEGIN
    getRemoteStatus() called: u'1'
    getRemoteStatus() called: u'4'

The bug watches that are deemed as not being modified are still marked
as being checked.

    >>> bug_watches = [
    ...     getUtility(IBugWatchSet).get(bug_watch_id)
    ...     for bug_watch_id in bug_watch_ids]
    >>> for bug_watch in bug_watches:
    ...     if bug_watch.lastchecked > some_time_ago:
    ...         print "Bug %s was marked checked" % bug_watch.remotebug
    ...     else:
    ...         print "Bug %s was NOT marked checked" % bug_watch.remotebug
    Bug 1 was marked checked
    Bug 2 was marked checked
    Bug 3 was marked checked
    Bug 4 was marked checked

The time being passed to getModifiedRemoteBugs() is the oldest one of the
bug watches' lastchecked attribute, minus the acceptable time skew, and
then some more just to be safe.

    >>> bug_watches[0].lastchecked = some_time_ago
    >>> bug_watches[1].lastchecked = some_time_ago + timedelta(days=1)
    >>> bug_watches[2].lastchecked = some_time_ago - timedelta(hours=1)
    >>> bug_watches[3].lastchecked = some_time_ago - timedelta(days=1)
    >>> flush_database_updates()

    >>> bug_watch_updater.updateBugWatches(
    ...     CheckModifiedExternalBugTracker(), bug_watches)
    COMMIT
    last_checked: 2007-03-16 15:...:...

If some of the bug watches are new, they won't be passed on to
getModifiedRemoteBugs(), but they will still be passed to
initializeRemoteBugDB() since we do need to update them.

    >>> bug_watches[0].lastchecked = some_time_ago
    >>> bug_watches[1].lastchecked = None
    >>> bug_watches[2].lastchecked = None
    >>> bug_watches[3].lastchecked = some_time_ago - timedelta(days=1)
    >>> flush_database_updates()
    >>> bug_watch_updater.updateBugWatches(
    ...     CheckModifiedExternalBugTracker(), bug_watches)
    COMMIT
    last_checked: 2007-03-16 15:...:...
    getModifiedRemoteBugs() called: [u'1', u'4']
    initializeRemoteBugDB() called: [u'1', u'2', u'3', u'4']
    BEGIN
    getRemoteStatus() called: u'1'
    getRemoteStatus() called: u'2'
    getRemoteStatus() called: u'3'
    getRemoteStatus() called: u'4'

As mentioned earlier, getModifiedRemoteBugs() is only called if we can
get the current time of the remote system. If the time is unknown, we
always update all the bug watches.

    >>> class TimeUnknownExternalBugTracker(CheckModifiedExternalBugTracker):
    ...     def getCurrentDBTime(self):
    ...         return None
    >>> for bug_watch in bug_watches:
    ...     bug_watch.lastchecked = some_time_ago
    >>> flush_database_updates()
    >>> bug_watch_updater.updateBugWatches(
    ...     TimeUnknownExternalBugTracker(), bug_watches)
    COMMIT
    initializeRemoteBugDB() called: [u'1', u'2', u'3', u'4']
    BEGIN
    getRemoteStatus() called: u'1'
    getRemoteStatus() called: u'2'
    getRemoteStatus() called: u'3'
    getRemoteStatus() called: u'4'


=== Converting statuses ===

Once it has retrieved the bugs from the remote server, BugWatchUpdater
attempts to convert their statuses into Launchpad BugTaskStatuses by
calling the convertRemoteStatus() method on the ExternalBugTracker via
its own _convertRemoteStatus() method.

ExternalBugTracker.convertRemoteStatus() will either return a
BugTaskStatus or will raise an UnknownRemoteStatusError.

    >>> from canonical.launchpad.interfaces import BugTaskStatus
    >>> from canonical.launchpad.components.externalbugtracker import (
    ...     UnknownRemoteStatusError)
    >>> class StatusConvertingExternalBugTracker(TestExternalBugTracker):
    ...
    ...     def convertRemoteStatus(self, remote_status):
    ...         if remote_status == 'new':
    ...             return BugTaskStatus.NEW
    ...         else:
    ...             raise UnknownRemoteStatusError(remote_status)

BugWatchUpdater._convertRemoteStatus() will handle these errors and will
return BugTaskStatus.UNKNOWN when they occur. It will also log a
warning.

    >>> status = bug_watch_updater._convertRemoteStatus(
    ...     StatusConvertingExternalBugTracker(), 'new')
    >>> print status.title
    New

    >>> status = bug_watch_updater._convertRemoteStatus(
    ...     StatusConvertingExternalBugTracker(), 'spam')
    WARNING...Unknown remote status 'spam'.
    >>> print status.title
    Unknown


== Configuration Options ==

All ExternalBugTrackers have a batch_query_threshold attribute which is
set by configuration options in launchpad.conf. This attribute is used
to decide whether or not bugs are exported from the remote server as a
batch (where possible) or individually.

The batch_query_threshold for a vanilla ExternalBugTracker should be the
same as that specified in launchpad.conf. We use a test version of
ExternalBugTracker here that doesn't actually do anything besides
fulfill the implementation requirements of IExternalBugTracker.

    >>> from canonical.config import config
    >>> from canonical.launchpad.ftests.externalbugtracker import (
    ...     TestExternalBugTracker)
    >>> tracker = TestExternalBugTracker('http://example.com/')
    >>> (tracker.batch_query_threshold ==
    ...     config.checkwatches.batch_query_threshold)
    True


== Error Handling ==

When an error occurs during the updating of bug watches it will be
recorded against the bug watches themselves so that it can be displayed
to users. We can test this by using a test version of
ExternalBugTracker.

    >>> import transaction
    >>> from canonical.launchpad.ftests.externalbugtracker import (
    ...     TestBrokenExternalBugTracker)
    >>> external_bugtracker = TestBrokenExternalBugTracker(
    ...     'http://example.com')
    >>> from canonical.launchpad.scripts.logger import QuietFakeLogger
    >>> bug_watch_updater = BugWatchUpdater(transaction, QuietFakeLogger())

We'll create an example bug watch with which to test this. This will
be passed to external_bugtracker's updateBugWatches() method and should
have errors recorded against it. We log in as Sample Person to make
these changes since there's no particular need to use one Person over
another.

    >>> login('test@canonical.com')

    >>> example_bugwatch = example_bug.addWatch(
    ...     example_bug_tracker, '1', sample_person)

    >>> from canonical.launchpad.components.externalbugtracker import (
    ...     BugNotFound, BugTrackerConnectError, InvalidBugId,
    ...     UnparseableBugData, UnparseableBugTrackerVersion)

TestBrokenExternalBugTracker allows us to force errors to occur, so we
can use it to check that bug watches' last_error_types are being set
correctly.

We start with those errors that may be raised by
ExternalBugTracker.initializeRemoteBugDB(). We supress exceptions
because the bug watch's last error field will contain the data we need
for this test.

The bug watch's lastchecked field will also be updated, since not doing
so would mean that error-prone bug watches would be checked every time
checkwatches ran instead of just once every 24 hours like any other bug
watch.

    >>> for error in [BugTrackerConnectError, UnparseableBugData,
    ...               UnparseableBugTrackerVersion, Exception]:
    ...     example_bugwatch.lastchecked = None
    ...     external_bugtracker.initialize_remote_bugdb_error = error
    ...     try:
    ...         bug_watch_updater.updateBugWatches(
    ...             external_bugtracker, [example_bugwatch])
    ...     except error:
    ...         pass
    ...     print "%s: %s" % (example_bugwatch.last_error_type.title,
    ...         example_bugwatch.lastchecked is not None)
    Connection Error: True
    Unparsable Bug: True
    Unparsable Bug Tracker Version: True
    Unknown: True

We can run the same test on getRemoteStatus(), which can raise different
errors. Errors in getRemoteStatus() also produce OOPS reports. The OOPS
reports all have URLs specified, set to the URL of the most recent
watches for which an update was attempted.

We temporarily silence the logging from this function because we're not
interested in it. Again, the watch's lastchecked field will also be
updated.

    >>> from canonical.launchpad.scripts.checkwatches import (
    ...     CheckWatchesErrorUtility)
    >>> error_utility = CheckWatchesErrorUtility()

    >>> external_bugtracker.initialize_remote_bugdb_error = None
    >>> for error in [BugNotFound, InvalidBugId, UnparseableBugData,
    ...               Exception]:
    ...     example_bugwatch.lastchecked = None
    ...     external_bugtracker.get_remote_status_error = error
    ...     bug_watch_updater.updateBugWatches(
    ...         external_bugtracker, [example_bugwatch])
    ...     oops = error_utility.getLastOopsReport()
    ...     print "%s: %s (%s; %s)" % (
    ...         example_bugwatch.last_error_type.title,
    ...         example_bugwatch.lastchecked is not None,
    ...         oops.id, oops.url)
    Bug Not Found: True (OOPS-...; http://bugs.example.com/show_bug.cgi?id=1)
    Invalid Bug ID: True (OOPS-...; http://bugs.example.com/show_bug.cgi?id=1)
    Unparsable Bug: True (OOPS-...; http://bugs.example.com/show_bug.cgi?id=1)
    Unknown: True (OOPS-...; http://bugs.example.com/show_bug.cgi?id=1)


== Using `LookupTree` to map statuses ==

Most of the status conversions are assisted by a customized LookupTree
class.

  >>> from canonical.launchpad.components.externalbugtracker import (
  ...     LookupTree)

This is flexible enough to cover all current mapping scenarios with
minimal preparation from `convertRemoteStatus`. Crucially, it also
lets us generate documentation directory from the status mapping
rules.

First, we need a tree to document.

  >>> tree = LookupTree(
  ...     ('ASSIGNED', 'STARTED', BugTaskStatus.INPROGRESS),
  ...     ('NEEDINFO', 'WAITING', 'SUSPENDED', BugTaskStatus.INCOMPLETE),
  ...     ('PENDINGUPLOAD', 'RELEASE_PENDING', BugTaskStatus.FIXCOMMITTED),
  ...     ('REJECTED', BugTaskStatus.INVALID),
  ...     ('RESOLVED', 'CLOSED', LookupTree(
  ...         ('ERRATA', 'FIXED', BugTaskStatus.FIXRELEASED),
  ...         ('WONTFIX', BugTaskStatus.WONTFIX),
  ...         (BugTaskStatus.INVALID,))),
  ...     ('REOPENED', 'NEW', 'DEFERRED', BugTaskStatus.CONFIRMED),
  ...     ('UNCONFIRMED', BugTaskStatus.NEW),
  ...     (BugTaskStatus.UNKNOWN,),
  ...     )

The customized LookupTree instance has a method to generate a MoinMoin
compatible table that describes the paths through the tree. The result
is always assumed to be a member of `BugTaskStatus`.

  >>> for line in tree.moinmoin_table():
  ...     print line
  || ASSIGNED '''or''' STARTED || - (''ignored'') || In Progress ||
  || NEEDINFO '''or''' WAITING '''or''' SUSPENDED || - (''ignored'') ...
  || PENDINGUPLOAD '''or''' RELEASE_PENDING || - (''ignored'') || Fix...
  || REJECTED || - (''ignored'') || Invalid ||
  || RESOLVED '''or''' CLOSED || ERRATA '''or''' FIXED || Fix Released ||
  ||  || WONTFIX || Won't Fix ||
  ||  || * (''any'') || Invalid ||
  || REOPENED '''or''' NEW '''or''' DEFERRED || - (''ignored'') || Co...
  || UNCONFIRMED || - (''ignored'') || New ||
  || * (''any'') || - (''ignored'') || Unknown ||

Titles can also be provided for the table.

  >>> titles = ('Status', 'Resolution', 'LP status')
  >>> for line in tree.moinmoin_table(titles):
  ...     print line
  || '''Status''' || '''Resolution''' || '''LP status''' ||
  || ASSIGNED '''or''' STARTED || - (''ignored'') || In Progress ||
  || NEEDINFO '''or''' WAITING '''or''' SUSPENDED || - (''ignored'') ...
  ...

It will complain if you don't provide a suitable number of titles.

  >>> titles = ('Status', 'Resolution')
  >>> for line in tree.moinmoin_table(titles):
  ...     print line
  Traceback (most recent call last):
  ...
  ValueError: Table of 3 columns needs 3 titles, but 2 given.

When constructing a status mapping tree, you are forced to choose a
valid Launchpad status as the result of any lookup. This goes some way
to ensuring that the tree is valid, and that `moinmoin_table` is safe
to make that assumption.

  >>> tree = LookupTree(
  ...     ('ASSIGNED', BugTaskStatus.INPROGRESS),
  ...     ('NEEDSINFO', 'Not a BugTaskStatus'),
  ...     )
  Traceback (most recent call last):
  ...
  TypeError: Result is not a member of BugTaskStatus: 'Not a BugTaskStatus'
