This pagetest describes the workflow used to validate sign only gpg keys.
The reference spec associated with this pagetest is available on the Launchpad
wiki:

    https://launchpad.canonical.com/ValidatingSignOnlyGpgKeys

Setup the stub KeyServer

  >>> from canonical.zeca.ftests.harness import ZecaTestSetup
  >>> z = ZecaTestSetup()
  >>> z.setUp()

Sign only keys are registered on the standard +editpgpkeys page.

  >>> user_browser.open('http://localhost/people/name12/+editpgpkeys')
  >>> user_browser.title
  "Sample Person's OpenPGP keys"

Claim a sign-only OpenPGP key:

  >>> fingerprint = '447DBF38C4F9C4ED752246B77D88913717B05A8F'
  >>> user_browser.getControl(name="fingerprint").value = fingerprint
  >>> user_browser.getControl('Import Key').click()

  >>> from BeautifulSoup import BeautifulSoup
  >>> soup = BeautifulSoup(user_browser.contents)
  >>> for tag in soup('p', 'error message'):
  ...     print tag.renderContents()
   A message has been sent to ...test@canonical.com... To confirm the
   key ...1024D/17B05A8F... is yours, follow the link inside.

Recover Token URL

  >>> import email, re
  >>> from canonical.launchpad.mail import stub
  >>> from_addr, to_addrs, raw_msg = stub.test_emails.pop()
  >>> msg = email.message_from_string(raw_msg)

Get the message content, and verify that it is not encrypted (we can't
encrypt to sign-only keys):

  >>> body = msg.get_payload(decode=True)
  >>> '-----BEGIN PGP MESSAGE-----' in body
  False

Do the usual procedure to extract the token URL

  >>> link = re.findall(r'http.*/token/.*', body)[0]
  >>> token = re.sub(r'.*token/', '', link)

Ensure token is ascii to avoid utf-8 mess in URL  

  >>> base_path = '/token/%s' % token.encode('ascii')


When processing a sign-only key, the user is asked to sign some
content that includes the date of the request (to avoid replay
attacks).  To make this testable, we set the date of the token in the
database to a fixed value:

  >>> import pytz, datetime
  >>> from canonical.launchpad.database import LoginToken
  >>> logintoken = LoginToken.selectOneBy(token=token)
  >>> logintoken.created = datetime.datetime(2005,04,01, 12,00,00,
  ...                                        tzinfo=pytz.timezone('UTC'))
  >>> logintoken.sync()


Go to the link given in the email. Note that we get redirected to the
sign-only key validation page instead of the regular sign-up page.

  >>> user_browser.open('http://localhost' + base_path)
  >>> user_browser.url
  'http://localhost/token/.../+validatesignonlygpg'

We get redirected to the sign-only OpenPGP key validation page, which
includes a phrase that must be signed by the user.  Some things to
note about the phrase:
 * Includes the Launchpad user name, key fingerprint and request time.
 * consists of only ASCII characters

This should make us immune to replay attacks and encoding issues.

  >>> user_browser.title
  'Confirm sign-only OpenPGP key'

  >>> soup = BeautifulSoup(user_browser.contents)
  >>> for tag in soup('pre'):
  ...     print tag.string
  Please register 447DBF38C4F9C4ED752246B77D88913717B05A8F to the
  Launchpad user name12.  2005-04-01 12:00:00 UTC

Below is a clear-signed version signed with a different key (DFD20543):

  >>> signedcontent = """
  ... -----BEGIN PGP SIGNED MESSAGE-----
  ... Hash: SHA1
  ... 
  ... Please register 447DBF38C4F9C4ED752246B77D88913717B05A8F to the
  ... Launchpad user name12.  2005-04-01 12:00:00 UTC
  ... -----BEGIN PGP SIGNATURE-----
  ... Version: GnuPG v1.4.1 (GNU/Linux)
  ... 
  ... iD8DBQFDcLOh2yWXVgK6XvYRAkpWAKDFHRpVJc2flFwpQMMxub4cl+TcCACgyciu
  ... s7GH1fQGOQMqpvpinwOjGto=
  ... =w7/b
  ... -----END PGP SIGNATURE-----
  ... """

The key validation does not succeed with this key:

  >>> user_browser.getControl(name="signedcontent").value = signedcontent
  >>> user_browser.getControl('Confirm').click()

  >>> message = (
  ...     'The key used to sign the content '
  ...     '(A419AE861E88BC9E04B9C26FBA2B9389DFD20543) is not the key you '
  ...     'were registering')
  >>> message in user_browser.contents
  True

Next we try proceeding using a message with an invalid signature (in
this case, a truncated signature):

  >>> signedcontent = """
  ... -----BEGIN PGP SIGNED MESSAGE-----
  ... Hash: SHA1
  ... 
  ... Please register 447DBF38C4F9C4ED752246B77D88913717B05A8F to the
  ... Launchpad user name12.  2005-04-01 12:00:00 UTC
  ... -----BEGIN PGP SIGNATURE-----
  ... Version: GnuPG v1.4.1 (GNU/Linux)
  ... 
  ... """

The key validation does not succeed with this key:

  >>> user_browser.getControl(name="signedcontent").value = signedcontent
  >>> user_browser.getControl('Confirm').click()

  >>> message = (
  ...     'Launchpad could not verify your signature: No data')
  >>> message in user_browser.contents
  True

Below is the clear-signed version of the message we are required to
sign, signed with the correct key:

  >>> signedcontent = """
  ... -----BEGIN PGP SIGNED MESSAGE-----
  ... Hash: SHA1
  ... 
  ... Please register 447DBF38C4F9C4ED752246B77D88913717B05A8F to the
  ... Launchpad user name12.  2005-04-01 12:00:00 UTC
  ... -----BEGIN PGP SIGNATURE-----
  ... Version: GnuPG v1.4.1 (GNU/Linux)
  ... 
  ... iD8DBQFDb8MIfYiRNxewWo8RAhtJAJ0TsZWBG9lDZEgterdNQxLI0F9ajACgmx+M
  ... fe5bet4x/Y8R576T9/VFso8=
  ... =JL4/
  ... -----END PGP SIGNATURE-----
  ... """


Confirm the OpenPGP key by proving that we can sign the given phrase with
the key:

  >>> user_browser.getControl(name="signedcontent").value = signedcontent
  >>> user_browser.getControl('Confirm').click()

On success, redirect to Sample Person's home page.

  >>> user_browser.url
  'http://localhost/people/name12'

  >>> '1024D/17B05A8F' in user_browser.contents
  True

Check that the key has been imported:

  >>> user_browser.getLink('OpenPGP Keys').click()

  >>> user_browser.title
  "Sample Person's OpenPGP keys"

  >>> "1024D/17B05A8F" in user_browser.contents
  True
  >>> "(sign only)" in user_browser.contents
  True

Mark the key as inactive.

  >>> user_browser.getControl(name="DEACTIVATE_GPGKEY").value = ['2']
  >>> user_browser.getControl('Deactivate Key').click()

  >>> soup = BeautifulSoup(user_browser.contents)
  >>> for tag in soup('p', 'error message'):
  ...     print tag.renderContents()
  Key(s):...1024D/17B05A8F...deactivated

Ask for a re-validation of the key.

  >>> user_browser.getControl(name="REVALIDATE_GPGKEY").value = ['2']
  >>> user_browser.getControl('Revalidate Key').click()

  >>> soup = BeautifulSoup(user_browser.contents)
  >>> for tag in soup('p', 'error message'):
  ...     print tag.renderContents()
  Key(s):...1024D/17B05A8F...revalidation email sent to test@canonical.com.

Open the page again and check that the key is still displayed, pending
revalidation.

  >>> user_browser.reload()
  >>> 'Keys pending validation' in user_browser.contents
  True
  >>> '1024D/17B05A8F' in user_browser.contents
  True

Now that the key has been validated, the login token is consumed:

  >>> print LoginToken.selectOneBy(token=token).date_consumed is not None
  True

Kill stub KeyServer

  >>> z.tearDown()
