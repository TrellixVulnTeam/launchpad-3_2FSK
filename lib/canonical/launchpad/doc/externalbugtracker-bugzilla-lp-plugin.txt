= Bugzilla bugtrackers with the Launchpad plugin =

These tests cover the BugzillaLPPlugin ExternalBugTracker, which handles
Bugzilla instances that have the Launchpad plugin installed.

For testing purposes, a custom XML-RPC transport can be passed to it,
so that we can avoid network traffic in tests.

    >>> from canonical.launchpad.components.externalbugtracker import (
    ...     BugzillaLPPlugin)
    >>> from canonical.launchpad.ftests.externalbugtracker import (
    ...     TestBugzillaXMLRPCTransport)
    >>> test_transport = TestBugzillaXMLRPCTransport()
    >>> bugzilla = BugzillaLPPlugin(
    ...     'http://example.com/', xmlrpc_transport=test_transport)
    >>> bugzilla.xmlrpc_transport is test_transport
    True


== Getting the current time ==

The BugzillaLPPlugin ExternalBugTracker, like all other
ExternalBugTrackers, has a getCurrentDBTime() method, which returns the
current time on the remote server.

    >>> from datetime import datetime
    >>> # It seems there's no way to create a UTC timestamp without
    >>> # monkey-patching the TZ environment variable. Rather than do
    >>> # that, we create our own timestamp and work with that.
    >>> datetime.utcfromtimestamp(1210953200.0)
    datetime.datetime(2008, 5, 16, 15, 53, 20)

    >>> test_transport.utc_offset = 60**2
    >>> test_transport.timezone = 'CET'
    >>> test_transport.seconds_since_epoch = 1210956800.0
    >>> bugzilla.getCurrentDBTime()
    datetime.datetime(2008, 5, 16, 15, 53, 20, tzinfo=<UTC>)


== Initializing the remote bug database ==

The BugzillaLPPlugin implements the standard initializeRemoteBugDB()
method, taking a list of the bug ids that need to be updated. It uses
the Bugzilla Bug.get_bugs() API to retrieve bugs from the remote system.

    >>> bugzilla.xmlrpc_transport.print_method_calls = True
    >>> bugzilla.initializeRemoteBugDB([1, 2])
    CALLED Bug.get_bugs({'ids': [1, 2], 'permissive': True})

The bug data is stored as a list of dicts:

    >>> for bug in sorted(bugzilla.bugs.keys()):
    ...     print "Bug %s:" % bug
    ...     for key in sorted(bugzilla.bugs[bug].keys()):
    ...         print "    %s: %s" % (key, bugzilla.bugs[bug][key])
    ...     print "\n"
    Bug 1:
        alias: 
        assigned_to: test@canonical.com
        component: GPPSystems
        creation_time: 20080610T16:19:53
        id: 1
        internals:...
        is_open: True
        last_change_time: 20080610T16:19:53
        priority: P1
        product: HeartOfGold
        resolution: FIXED
        severity: normal
        status: RESOLVED
        summary: That bloody robot still exists.
    <BLANKLINE>
    Bug 2:
        alias: bug-two
        assigned_to: marvin@heartofgold.ship
        component: Crew
        creation_time: 20080611T09:23:12
        id: 2
        internals:...
        is_open: True
        last_change_time: 20080611T09:24:29
        priority: P1
        product: HeartOfGold
        resolution: 
        severity: high
        status: NEW
        summary: Collect unknown persons in docking bay 2.
    <BLANKLINE>
    <BLANKLINE>

initializeRemoteBugDB() will only store a bug once, even if it is
requested both by alias and ID.

    >>> bugzilla.initializeRemoteBugDB([2, 'bug-two'])
    CALLED Bug.get_bugs({'ids': [2, 'bug-two'], 'permissive': True})

    >>> for bug in sorted(bugzilla.bugs.keys()):
    ...     print "Bug %r:" % bug
    ...     for key in sorted(bugzilla.bugs[bug].keys()):
    ...         print "    %s: %s" % (key, bugzilla.bugs[bug][key])
    ...     print "\n"
    Bug 2:
        alias: bug-two
        assigned_to: marvin@heartofgold.ship
        component: Crew
        creation_time: 20080611T09:23:12
        id: 2
        internals:...
        is_open: True
        last_change_time: 20080611T09:24:29
        priority: P1
        product: HeartOfGold
        resolution: 
        severity: high
        status: NEW
        summary: Collect unknown persons in docking bay 2.
    <BLANKLINE>
    <BLANKLINE>

Aliases are stored in a separate dict, which contains a mapping between
the alias and the bug's actual ID.

    >>> for alias, bug_id in bugzilla.bug_aliases.items():
    ...     print "%s: %s" % (alias, bug_id)
    bug-two: 2


== Getting remote statuses ==

BugzillaLPPlugin.getRemoteStatus() will return the remote status of a
given bug as a string. If the bug has a resolution, that will be
returned too.

    >>> bugzilla.initializeRemoteBugDB([1, 2])
    CALLED Bug.get_bugs({'ids': [1, 2], 'permissive': True})

    >>> print bugzilla.getRemoteStatus(1)
    RESOLVED FIXED

    >>> print bugzilla.getRemoteStatus(2)
    NEW

If a bug can't be found a BugNotFound error will be raised.

    >>> bugzilla.getRemoteStatus('no-such-bug')
    Traceback (most recent call last):
      ...
    BugNotFound: no-such-bug


== Retrieving remote comments ==

BugzillaLPPlugin implments the ISupportsCommentImport interface, which
means that we can use it to import comments from the remote Bugzilla
instance.

    >>> from canonical.launchpad.interfaces import ISupportsCommentImport
    >>> ISupportsCommentImport.providedBy(bugzilla)
    True

To test the comment importing methods we need to add an example bug,
bugtracker and a couple of bugwatches.

    >>> from canonical.config import config
    >>> from canonical.database.sqlbase import commit
    >>> from canonical.launchpad.interfaces.person import IPersonSet

    >>> from canonical.launchpad.testing.factory import (
    ...     LaunchpadObjectFactory)
    >>> factory = LaunchpadObjectFactory()

    >>> from canonical.testing import LaunchpadZopelessLayer

    >>> from canonical.launchpad.interfaces.bug import CreateBugParams
    >>> from canonical.launchpad.interfaces.bugtracker import BugTrackerType
    >>> from canonical.launchpad.interfaces.person import IPersonSet
    >>> from canonical.launchpad.interfaces.product import IProductSet
    >>> from canonical.launchpad.ftests.externalbugtracker import (
    ...     new_bugtracker)

    >>> bug_tracker = new_bugtracker(BugTrackerType.TRAC)

    >>> LaunchpadZopelessLayer.switchDbUser('launchpad')
    >>> sample_person = getUtility(IPersonSet).getByEmail(
    ...     'test@canonical.com')
    >>> firefox = getUtility(IProductSet).getByName('firefox')
    >>> bug = firefox.createBug(
    ...     CreateBugParams(sample_person, "Yet another test bug",
    ...         "Yet another test description.",
    ...         subscribe_reporter=False))

    >>> bug_watch = bug.addWatch(bug_tracker, '1', sample_person)
    >>> bug_watch_two = bug.addWatch(bug_tracker, '2', sample_person)
    >>> bug_watch_broken = bug.addWatch(bug_tracker, '42', sample_person)
    >>> commit()

    >>> LaunchpadZopelessLayer.switchDbUser(config.checkwatches.dbuser)


=== getCommentIds() ===

ISupportsCommentImport.getCommentIds() is the method used to get all the
comment IDs for a given bug on a remote bugtracker.

    >>> bugzilla.xmlrpc_transport.print_method_calls = False
    >>> bug_comment_ids = bugzilla.getCommentIds(bug_watch)
    >>> print sorted(bug_comment_ids)
    [1, 3]

getCommentIds() can only be called if initializeRemoteBugDB() has been
called and the bug exists locally.

    >>> bugzilla.getCommentIds(bug_watch_broken)
    Traceback (most recent call last):
      ...
    BugNotFound: 42


=== fetchComments() ===

ISupportsCommentImport.fetchComments() is the method used to fetch a
given set of comments from the remote bugtracker. It takes a bug watch
and a list of the comment IDs to retrieve for that bug watch.

    >>> bugzilla.fetchComments(bug_watch, [1, 3])

The comments will be stored in the bugs dict as a dict of comment id =>
comment dict mappings under the key 'comments'.

    >>> import operator
    >>> comments = bugzilla.bugs[1]['comments']
    >>> for comment_id in sorted(comments.keys()):
    ...     print "Comment %s:" % comment_id
    ...     comment = comments[comment_id]
    ...     for key in sorted(comment.keys()):
    ...         print "    %s: %s" % (key, comment[key])
    Comment 1:
        author: trillian
        id: 1
        number: 1
        text: I'd really appreciate it if Marvin would enjoy life a bit.
        time: 20080616T12:44:29
    Comment 3:
        author: marvin
        id: 3
        number: 2
        text: Life? Don't talk to me about life.
        time: 20080616T13:22:29


=== getPosterForComment() ===

ISupportsCommentImport.getPosterForComment() returns a tuple of
(displayname, email) for the author of a remote comment.

    >>> bugzilla.fetchComments(bug_watch_two, [2, 4])
    >>> displayname, email = bugzilla.getPosterForComment(bug_watch_two, 4)
    >>> print displayname, email
    Ford Prefect ford.prefect@h2g2.com

If the author's name as stored in the comment isn't a valid email
address then the method will return displayname = None and will return
the whole of the author's name in the email field.

    >>> displayname, email = bugzilla.getPosterForComment(bug_watch_two, 2)
    >>> print displayname, email
    None trillian


=== getMessageForComment() ===

ISupportsCommentImport.getMessageForComment() returns a Launchpad
IMessage instance for a given comment. It takes a bug watch, a comment
ID and a Person object generated from the return value of
getPosterForComment(), above. For the sake of this test we'll use
Sample Person as our poster.

    >>> message = bugzilla.getMessageForComment(
    ...     bug_watch_two, 2, sample_person)
    >>> print message.text_contents
    Bring the passengers to the bridge please Marvin.

    >>> print message.owner.displayname
    Sample Person

The datecreated attribute of the Message will be the same as the 'time'
field on the imported comment.

    >>> print bugzilla.bugs[2]['comments'][2]['time']
    20080616T13:08:08

    >>> print message.datecreated
    2008-06-16 13:08:08+00:00
