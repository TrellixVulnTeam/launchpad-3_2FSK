= TranslationImportQueueEntry =

The TranslationImportQueueEntry is an entry of the queue that will be imported
into Rosetta.

== getGuessedPOFile ==

This property gives us the IPOFile where we think we should import this entry.

To test it, we need to add an entry to the queue.

Here we have some imports and utility fetch.

    >>> import transaction
    >>> from zope.component import getUtility
    >>> from canonical.database.sqlbase import flush_database_updates
    >>> from canonical.launchpad.interfaces import ITranslationImportQueue
    >>> from canonical.launchpad.interfaces import ILaunchpadCelebrities
    >>> from canonical.launchpad.database import ProductSeries
    >>> from canonical.launchpad.database import DistroSeries
    >>> from canonical.launchpad.database import SourcePackageName
    >>> from canonical.launchpad.ftests import login
    >>> from canonical.lp.dbschema import RosettaImportStatus
    >>> translationimportqueue = getUtility(ITranslationImportQueue)
    >>> rosetta_expert = getUtility(ILaunchpadCelebrities).rosetta_expert

Login as a user without privileges.

    >>> login('no-priv@canonical.com')

First, we are going to try to do the guess against the Evolution product. That
means that we are going to use the ProductSeries.id = 3

    >>> evolution_productseries = ProductSeries.get(3)

Attach the file to the product series, without associating it with any
potemplate.

    >>> entry = translationimportqueue.addOrUpdateEntry(
    ...     u'po/sr.po', 'foo', True, rosetta_expert,
    ...      productseries=evolution_productseries)

This entry has no information about the IPOFile where it should be attached to:

    >>> entry.import_into is None
    True

And the guessing algorithm will not be able to guess anything as there is no
IPOFiles on the same path and we have two IPOTemplates on the same path where
this IPOFile is located ('po/')

    >>> entry.getGuessedPOFile() is None
    True

Now let's try the same against the evolution sourcepackage that only has an
IPOTemplate.

    >>> hoary_distroseries = DistroSeries.get(3)
    >>> evolution_sourcepackagename = SourcePackageName.get(9)
    >>> entry = translationimportqueue.addOrUpdateEntry(
    ...     u'po/sr.po', 'foo', True, rosetta_expert,
    ...      distroseries=hoary_distroseries,
    ...      sourcepackagename=evolution_sourcepackagename)
    >>> transaction.commit()

This entry has no information about the IPOFile where it should be attached to:

    >>> entry.import_into is None
    True

And the guessing algorithm is able to give us an IPOFile where it should be
imported.

    >>> entry.getGuessedPOFile() is None
    False

    >>> entry.getGuessedPOFile().title
    u'Serbian (sr) translation of evolution-2.2 in Ubuntu Hoary package "evolution"'


Let's try now to update the entries.

We need to know the status that the entry has.

    >>> entry.status.title
    'Needs Review'

And store current creation and status change date:

    >>> previous_dateimported = entry.dateimported
    >>> previous_date_status_changed = entry.date_status_changed

Now, we do a new upload.

    >>> entry = translationimportqueue.addOrUpdateEntry(
    ...     u'po/sr.po', 'foo', True, rosetta_expert,
    ...      distroseries=hoary_distroseries,
    ...      sourcepackagename=evolution_sourcepackagename)
    >>> transaction.commit()

And the new status is

    >>> entry.status.title
    'Needs Review'

The dateimported remains the same as it was already waiting to be imported.

    >>> entry.dateimported == previous_dateimported
    True

And the date_status_changed is newer

    >>> entry.date_status_changed > previous_date_status_changed
    True

Let's change now its status to imported and see what happens. To do it,
we need to be logged in as an admin.

    >>> login('carlos@canonical.com')
    >>> entry.status = RosettaImportStatus.IMPORTED

Need to update our saved date_status_changed to detect if it changes now.

    >>> previous_date_status_changed = entry.date_status_changed

Do the new upload. It will be a published upload.

    >>> published = True
    >>> po_sr_entry = translationimportqueue.addOrUpdateEntry(
    ...     u'po/sr.po', 'foo', published, rosetta_expert,
    ...      distroseries=hoary_distroseries,
    ...      sourcepackagename=evolution_sourcepackagename)

And the new status is

    >>> po_sr_entry.status.title
    'Needs Review'

The dateimported remains the same as it was already waiting to be imported.

    >>> po_sr_entry.dateimported > previous_dateimported
    True

And the date_status_changed is newer

    >>> po_sr_entry.date_status_changed > previous_date_status_changed
    True

First, we import a new .pot file.

    >>> pot_entry = translationimportqueue.addOrUpdateEntry(
    ...     'po/evolution-2.2.pot', 'foo', True, rosetta_expert,
    ...      distroseries=hoary_distroseries,
    ...      sourcepackagename=evolution_sourcepackagename)

Change pofile.path value to a value that will help to prepare next test.
Basically, we prevent that it's found by its path.

    >>> pofile = po_sr_entry.getGuessedPOFile()
    >>> pofile.path
    u'po/sr.po'
    >>> pofile.path = u'po/sr-old.po'

Reset any pofile/potemplate information we have for the po_sr_entry.

    >>> po_sr_entry.potemplate = None
    >>> po_sr_entry.pofile = None

XXX: CarlosPerelloMarin 20060331 If flush_database_updates is removed from
here we don't see the pofile.path change and the internal code path that we
want to check here doesn't work. For more information, see bug #3989

    >>> flush_database_updates()
    >>> transaction.commit()

Now, let's check that we cannot find the pot_entry as a POTemplate because
the way our code works, we cannot guess it while we have a .pot file pending
to be imported.

    >>> pot_entry.status.title
    'Needs Review'
    >>> po_sr_entry.getGuessedPOFile() is None
    True

But if that entry is imported, the guessing algorithm works.

    >>> pot_entry.status = RosettaImportStatus.IMPORTED
    >>> guessed_pofile = po_sr_entry.getGuessedPOFile()
    >>> guessed_pofile is None
    False

We can see that we got the same POFile as before:

    >>> guessed_pofile == pofile
    True

And because it's a publised upload, the IPOFile in our database got
its path changed to the one noted by this upload instead of having the one
we set a couple of lines ago (u'po/sr-old.pot'):

    >>> po_sr_entry.is_published
    True
    >>> pofile.path == po_sr_entry.path
    True
    >>> pofile.path
    u'po/sr.po'

=== getGuessedPOFile with KDE ===

Official KDE packages have a non standard layout where the .pot files are
stored inside the sourcepackage with the binaries that will use it and the
translations are stored in external packages following the same language pack
ideas that we use with Ubuntu. This layout breaks completely Rosetta because
we don't have a way to link the .po and .pot files coming from different
packages. For this case, we use some extra information to get that link
between different sourcepackages.

The info we use is:
    - The sourcepackagename: All KDE language packs have
      the sourcepackagename following this pattern:
      kde-i18n-LANGCODE. We get from here the language where the .po
      files belong.
    - The .po filename: All .po files are stored using the translation
      domain as its filename. This information helps us to get the
      IPOTemplate where we should associate this .po file.

To do this test, we are going to do all in a single transaction and will
rollback it when it's finished.

First, we are going to add three new sourcepackagenames for this test,
kdebase, kde-i18n-es and kde-i18n-srlatn. The first is from where the .pot
file come and the others have .po files.

    >>> from canonical.launchpad.interfaces import ISourcePackageNameSet
    >>> sourcepackagenameset = getUtility(ISourcePackageNameSet)
    >>> kdebase = sourcepackagenameset.new('kdebase')
    >>> kde_i18n_es = sourcepackagenameset.new('kde-i18n-es')
    >>> kde_i18n_srlatn = sourcepackagenameset.new('kde-i18n-srlatn')

Let's attach the .pot file

    >>> kde_pot_entry = translationimportqueue.addOrUpdateEntry(
    ...     'po/kdebugdialog.pot', 'foo content', True, rosetta_expert,
    ...      distroseries=hoary_distroseries,
    ...      sourcepackagename=kdebase)

Create the template name and attach this new import to it.

    >>> from canonical.launchpad.interfaces import IPOTemplateNameSet
    >>> from canonical.launchpad.interfaces import IPOTemplateSet
    >>> potemplatenameset = getUtility(IPOTemplateNameSet)
    >>> kdebugdialog_template_name = potemplatenameset.new(
    ...     'kdebugdialog', 'kdebugdialog')
    >>> potemplateset = getUtility(IPOTemplateSet)
    >>> subset = potemplateset.getSubset(
    ...     distroseries=hoary_distroseries, sourcepackagename=kdebase)
    >>> kde_pot_entry.potemplate = subset.new(
    ...     kdebugdialog_template_name, 'po/kdebugdialog.pot', rosetta_expert)
    >>> kde_pot_entry.potemplate.title
    u'Template "kdebugdialog" in Ubuntu Hoary package "kdebase"'

And set this entry as already imported.

    >>> kde_pot_entry.status = RosettaImportStatus.IMPORTED
    >>> flush_database_updates()

Let's attach a .po file from kde-i18n-es

    >>> es_entry = translationimportqueue.addOrUpdateEntry(
    ...     'messages/kdebase/kdebugdialog.po', 'foo content', True,
    ...     rosetta_expert, distroseries=hoary_distroseries,
    ...      sourcepackagename=kde_i18n_es)

And we will get the right IPOFile.

    >>> es_entry.getGuessedPOFile().title
    u'Spanish (es) translation of kdebugdialog in Ubuntu Hoary package "kdebase"'

The kde-i18n-srlatn is a bit special, the language is sr@Latn and we should be
able to know that.

    >>> srlatn_entry = translationimportqueue.addOrUpdateEntry(
    ...     'messages/kdebase/kdebugdialog.po', 'foo content', True,
    ...     rosetta_expert, distroseries=hoary_distroseries,
    ...      sourcepackagename=kde_i18n_srlatn)

And we will get the right IPOFile.

    >>> srlatn_entry.getGuessedPOFile().title
    u'Serbian (sr) translation of kdebugdialog in Ubuntu Hoary package "kdebase"'
    >>> srlatn_entry.getGuessedPOFile().variant
    u'Latn'

Now, we are going to see what happens if we get a .po file for a template
that is not yet imported.

    >>> es_without_potemplate_entry = translationimportqueue.addOrUpdateEntry(
    ...     'messages/kdebase/konqueror.po', 'foo content', True,
    ...     rosetta_expert, distroseries=hoary_distroseries,
    ...      sourcepackagename=kde_i18n_es)

We don't know the IPOFile where it should be imported.

    >>> es_without_potemplate_entry.getGuessedPOFile() is None
    True

Sometimes, a translation domain is not following the restrictions we have for
name fields, and thus, we need to be sure that we look for KDE .pot files
using the translation domain instead the name.

We will see it working here with this example:

    >>> kde_pot_entry = translationimportqueue.addOrUpdateEntry(
    ...     'po/kio_sftp.pot', 'foo content', True, rosetta_expert,
    ...      distroseries=hoary_distroseries,
    ...      sourcepackagename=kdebase)

Create the template name and attach this new import to it.

    >>> from canonical.launchpad.interfaces import IPOTemplateNameSet
    >>> from canonical.launchpad.interfaces import IPOTemplateSet
    >>> potemplatenameset = getUtility(IPOTemplateNameSet)
    >>> kdebugdialog_template_name = potemplatenameset.new(
    ...     'kio_sftp', 'kio_sftp')
    >>> potemplateset = getUtility(IPOTemplateSet)
    >>> subset = potemplateset.getSubset(
    ...     distroseries=hoary_distroseries, sourcepackagename=kdebase)
    >>> kde_pot_entry.potemplate = subset.new(
    ...     kdebugdialog_template_name, 'po/kio_sftp.pot', rosetta_expert)
    >>> kde_pot_entry.potemplate.title
    u'Template "kio-sftp" in Ubuntu Hoary package "kdebase"'

And set this entry as already imported.

    >>> kde_pot_entry.status = RosettaImportStatus.IMPORTED
    >>> flush_database_updates()

Let's attach a .po file from kde-i18n-es

    >>> es_entry = translationimportqueue.addOrUpdateEntry(
    ...     'messages/kdebase/kio_sftp.po', 'foo content', True,
    ...     rosetta_expert, distroseries=hoary_distroseries,
    ...      sourcepackagename=kde_i18n_es)

And we will get the right IPOFile.

    >>> es_entry.getGuessedPOFile().title
    u'Spanish (es) translation of kio-sftp in Ubuntu Hoary package "kdebase"'

Finally, we abort the transaction to undo all changes done.

    >>> transaction.abort()


=== getGuessedPOFile with KOffice ===

Like official KDE packages, KOffice stores the .pot and .po files in different
packages, the only difference it has is that there is just one source package
and the language information is stored as part of the path, but hidden with
more text. The source package with translations is koffice-l10n, and
the layout is:

koffice-i18n-LANGCODE-VERSION/messages/koffice/TRANSLATIONDOMAIN.po

To do this test, we are going to do all in a single transaction and will
rollback it when it's finished.

First, we are going to add two new sourcepackagenames for this test,
koffice and koffice-l10n. The first is from where the .pot
file come and the other for the .po files.

    >>> from canonical.launchpad.interfaces import ISourcePackageNameSet
    >>> sourcepackagenameset = getUtility(ISourcePackageNameSet)
    >>> koffice = sourcepackagenameset.new('koffice')
    >>> koffice_l10n = sourcepackagenameset.new('koffice-l10n')

Let's attach the .pot file

    >>> koffice_pot_entry = translationimportqueue.addOrUpdateEntry(
    ...     'po/koffice.pot', 'foo content', True, rosetta_expert,
    ...      distroseries=hoary_distroseries,
    ...      sourcepackagename=koffice)

Create the template name and attach this new import to it.

    >>> koffice_template_name = potemplatenameset.new(
    ...     'koffice', 'koffice')
    >>> potemplateset = getUtility(IPOTemplateSet)
    >>> subset = potemplateset.getSubset(
    ...     distroseries=hoary_distroseries, sourcepackagename=koffice)
    >>> koffice_pot_entry.potemplate = subset.new(
    ...     koffice_template_name, 'po/koffice.pot', rosetta_expert)
    >>> koffice_pot_entry.potemplate.title
    u'Template "koffice" in Ubuntu Hoary package "koffice"'

And set this entry as already imported.

    >>> koffice_pot_entry.status = RosettaImportStatus.IMPORTED
    >>> flush_database_updates()

Let's attach a .po file from koffice-l10n

    >>> es_entry = translationimportqueue.addOrUpdateEntry(
    ...     'koffice-i18n-es-1.5.2/messages/koffice/koffice.po',
    ...     'foo content', True, rosetta_expert,
    ...     distroseries=hoary_distroseries, sourcepackagename=koffice_l10n)

And we will get the right IPOFile.

    >>> es_entry.getGuessedPOFile().title
    u'Spanish (es) translation of koffice in Ubuntu Hoary package "koffice"'

Let's try now a language with variant information like sr@Latn.

    >>> srlatn_entry = translationimportqueue.addOrUpdateEntry(
    ...     'koffice-i18n-sr@Latn-1.5.2/messages/koffice/koffice.po',
    ...     'foo content', True, rosetta_expert,
    ...     distroseries=hoary_distroseries, sourcepackagename=koffice_l10n)

And we will get the right IPOFile.

    >>> srlatn_entry.getGuessedPOFile().title
    u'Serbian (sr) translation of koffice in Ubuntu Hoary package "koffice"'
    >>> srlatn_entry.getGuessedPOFile().variant
    u'Latn'

Now, we are going to see what happens if we get a .po file for a template
that is not yet imported.

    >>> es_without_potemplate_entry = translationimportqueue.addOrUpdateEntry(
    ...     'koffice-i18n-es-1.5.2/messages/koffice/kchart.po',
    ...     'foo content', True, rosetta_expert,
    ...     distroseries=hoary_distroseries, sourcepackagename=koffice_l10n)

We don't know the IPOFile where it should be imported.

    >>> es_without_potemplate_entry.getGuessedPOFile() is None
    True

Finally, we abort the transaction to undo all changes done.

    >>> transaction.abort()


=== getGuessedPOFile with .po files in different directories ===

Some packages have translations and templates inside the same package, but
they don't have them inside the same directory. The layout is:

DIRECTORY/TRANSLATION_DOMAIN.pot
DIRECTORY/LANG_CODE/TRANSLATION_DOMAIN.po

sometimes the layout changes a bit, for instance in ktorrent, and looks like:

DIRECTORY/TRANSLATION_DOMAIN.pot
DIRECTORY/LANG_CODE/messages/TRANSLATION_DOMAIN.po

Or in the zope packages:

DIRECTORY/TRANSLATION_DOMAIN.pot
DIRECTORY/LANG_CODE/LC_MESSAGES/TRANSLATION_DOMAIN.po

We have also packages like k3b that has its translations in its own k3b-i18n
package, but with a layout quite similar to the ones here:

LANG_CODE/messages/TRANSLATION_DOMAIN.po

Also, there is the layout used with GNOME documentation:

DIRECTORY/help/TRANSLATION_DOMAIN.pot
DIRECTORY/help/LANG_CODE/LANG_CODE.po

Let's test every know layout. For the first one, we create an adept
sourcepackagename to test that layout.

    >>> adept = sourcepackagenameset.new('adept')

Let's attach the .pot file

    >>> adept_pot_entry = translationimportqueue.addOrUpdateEntry(
    ...     'po/adept.pot', 'foo content', True, rosetta_expert,
    ...      distroseries=hoary_distroseries,
    ...      sourcepackagename=adept)

Create the template name and attach this new import to it.

    >>> adept_template_name = potemplatenameset.new(
    ...     'adept', 'adept')
    >>> subset = potemplateset.getSubset(
    ...     distroseries=hoary_distroseries, sourcepackagename=adept)
    >>> adept_pot_entry.potemplate = subset.new(
    ...     adept_template_name, 'po/adept.pot', rosetta_expert)
    >>> adept_pot_entry.potemplate.title
    u'Template "adept" in Ubuntu Hoary package "adept"'

And set this entry as already imported.

    >>> adept_pot_entry.status = RosettaImportStatus.IMPORTED
    >>> flush_database_updates()

Let's attach a .po file now.

    >>> es_entry = translationimportqueue.addOrUpdateEntry(
    ...     'po/es/adept.po', 'foo content', True,
    ...     rosetta_expert, distroseries=hoary_distroseries,
    ...      sourcepackagename=adept)

And we will get the right IPOFile.

    >>> es_entry.getGuessedPOFile().title
    u'Spanish (es) translation of adept in Ubuntu Hoary package "adept"'

Now, we are going to see what happens if we get a .po file for a template
that is not yet imported.

    >>> es_without_potemplate_entry = translationimportqueue.addOrUpdateEntry(
    ...     'po/es/adept-foo.po', 'foo content', True,
    ...     rosetta_expert, distroseries=hoary_distroseries,
    ...      sourcepackagename=adept)

We don't know the IPOFile where it should be imported.

    >>> es_without_potemplate_entry.getGuessedPOFile() is None
    True

Let's move to the second case, to test it, we create a ktorrent
sourcepackagename and test that layout.

    >>> ktorrent = sourcepackagenameset.new('ktorrent')

Let's attach the .pot file

    >>> ktorrent_pot_entry = translationimportqueue.addOrUpdateEntry(
    ...     'po/ktorrent.pot', 'foo content', True, rosetta_expert,
    ...      distroseries=hoary_distroseries,
    ...      sourcepackagename=ktorrent)

Create the template name and attach this new import to it.

    >>> ktorrent_template_name = potemplatenameset.new(
    ...     'ktorrent', 'ktorrent')
    >>> subset = potemplateset.getSubset(
    ...     distroseries=hoary_distroseries, sourcepackagename=ktorrent)
    >>> ktorrent_pot_entry.potemplate = subset.new(
    ...     ktorrent_template_name, 'po/ktorrent.pot', rosetta_expert)
    >>> ktorrent_pot_entry.potemplate.title
    u'Template "ktorrent" in Ubuntu Hoary package "ktorrent"'

And set this entry as already imported.

    >>> ktorrent_pot_entry.status = RosettaImportStatus.IMPORTED
    >>> flush_database_updates()

Let's attach a .po file now.

    >>> es_entry = translationimportqueue.addOrUpdateEntry(
    ...     'translations/es/messages/ktorrent.po', 'foo content', True,
    ...     rosetta_expert, distroseries=hoary_distroseries,
    ...      sourcepackagename=ktorrent)

And we will get the right IPOFile.

    >>> es_entry.getGuessedPOFile().title
    u'Spanish (es) translation of ktorrent in Ubuntu Hoary package "ktorrent"'

Now, we are going to see what happens if we get a .po file for a template
that is not yet imported.

    >>> es_without_potemplate_entry = translationimportqueue.addOrUpdateEntry(
    ...     'translations/es/messages/ktorrent-foo.po', 'foo content', True,
    ...     rosetta_expert, distroseries=hoary_distroseries,
    ...      sourcepackagename=ktorrent)

We don't know the IPOFile where it should be imported.

    >>> es_without_potemplate_entry.getGuessedPOFile() is None
    True

Now, let's move to the third case, to test it, we create a zope
sourcepackagename and test that layout.

    >>> zope = sourcepackagenameset.new('zope')

Let's attach the .pot file

    >>> zope_pot_entry = translationimportqueue.addOrUpdateEntry(
    ...     'debian/zope3/usr/lib/python2.4/site-packages/zope/app/locales/zope.pot',
    ...     'foo content', True, rosetta_expert,
    ...     distroseries=hoary_distroseries, sourcepackagename=zope)

Create the template name and attach this new import to it.

    >>> zope_template_name = potemplatenameset.new(
    ...     'zope', 'zope')
    >>> subset = potemplateset.getSubset(
    ...     distroseries=hoary_distroseries, sourcepackagename=zope)
    >>> zope_pot_entry.potemplate = subset.new(
    ...     zope_template_name,
    ...     'debian/zope3/usr/lib/python2.4/site-packages/zope/app/locales/zope.pot',
    ...     rosetta_expert)
    >>> zope_pot_entry.potemplate.title
    u'Template "zope" in Ubuntu Hoary package "zope"'

And set this entry as already imported.

    >>> zope_pot_entry.status = RosettaImportStatus.IMPORTED
    >>> flush_database_updates()

Let's attach a .po file now.

    >>> es_entry = translationimportqueue.addOrUpdateEntry(
    ...     'debian/zope3/usr/lib/python2.4/site-packages/zope/app/locales/es/LC_MESSAGES/zope.po',
    ...     'foo content', True, rosetta_expert,
    ...     distroseries=hoary_distroseries, sourcepackagename=zope)

And we will get the right IPOFile.

    >>> es_entry.getGuessedPOFile().title
    u'Spanish (es) translation of zope in Ubuntu Hoary package "zope"'

Now, we are going to see what happens if we get a .po file for a template
that is not yet imported.

    >>> es_without_potemplate_entry = translationimportqueue.addOrUpdateEntry(
    ...     'debian/zope3/usr/lib/python2.4/site-packages/zope/app/locales/es/LC_MESSAGES/zope-test.po',
    ...     'foo content', True, rosetta_expert,
    ...     distroseries=hoary_distroseries, sourcepackagename=zope)

We don't know the IPOFile where it should be imported.

    >>> es_without_potemplate_entry.getGuessedPOFile() is None
    True

Now, let's move to the fourth case, to test it, we create a k3b
sourcepackagename from where the .pot file comes and a k3b-i18n one
from where the translations come.

    >>> k3b = sourcepackagenameset.new('k3b')
    >>> k3b_i18n = sourcepackagenameset.new('k3b-i18n')

Let's attach the .pot file

    >>> k3b_pot_entry = translationimportqueue.addOrUpdateEntry(
    ...     'po/k3b.pot', 'foo content', True, rosetta_expert,
    ...     distroseries=hoary_distroseries, sourcepackagename=k3b)

Create the template name and attach this new import to it.

    >>> k3b_template_name = potemplatenameset.new(
    ...     'k3b', 'k3b')
    >>> subset = potemplateset.getSubset(
    ...     distroseries=hoary_distroseries, sourcepackagename=k3b)
    >>> k3b_pot_entry.potemplate = subset.new(
    ...     k3b_template_name, 'po/k3b.pot', rosetta_expert)
    >>> k3b_pot_entry.potemplate.title
    u'Template "k3b" in Ubuntu Hoary package "k3b"'

And set this entry as already imported.

    >>> k3b_pot_entry.status = RosettaImportStatus.IMPORTED
    >>> flush_database_updates()

Let's attach a .po file now.

    >>> es_entry = translationimportqueue.addOrUpdateEntry(
    ...     'es/messages/k3b.po', 'foo content', True, rosetta_expert,
    ...     distroseries=hoary_distroseries, sourcepackagename=k3b_i18n)

And we will get the right IPOFile.

    >>> es_entry.getGuessedPOFile().title
    u'Spanish (es) translation of k3b in Ubuntu Hoary package "k3b"'

Now, we are going to see what happens if we get a .po file for a template
that is not yet imported.

    >>> es_without_potemplate_entry = translationimportqueue.addOrUpdateEntry(
    ...     'es/messages/libk3b.po', 'foo content', True, rosetta_expert,
    ...     distroseries=hoary_distroseries, sourcepackagename=k3b_i18n)

We don't know the IPOFile where it should be imported.

    >>> es_without_potemplate_entry.getGuessedPOFile() is None
    True

Finally, let's move to the last case, to test it, we create a gnome-terminal
sourcepackagename that will host the .pot and .po files.

    >>> gnome_terminal = sourcepackagenameset.new('gnome-terminal')

Let's attach the .pot file

    >>> terminal_pot_entry = translationimportqueue.addOrUpdateEntry(
    ...     'drivemount/help/drivemount.pot', 'foo content', True,
    ...     rosetta_expert, distroseries=hoary_distroseries,
    ...     sourcepackagename=gnome_terminal)

Create the template name and attach this new import to it.

    >>> gnome_terminal_template_name = potemplatenameset.new(
    ...     'help', 'help')
    >>> subset = potemplateset.getSubset(
    ...     distroseries=hoary_distroseries,
    ...     sourcepackagename=gnome_terminal)
    >>> terminal_pot_entry.potemplate = subset.new(
    ...     gnome_terminal_template_name,
    ...     'drivemount/help/drivemount.pot', rosetta_expert)
    >>> terminal_pot_entry.potemplate.title
    u'Template "help" in Ubuntu Hoary package "gnome-terminal"'

And set this entry as already imported.

    >>> k3b_pot_entry.status = RosettaImportStatus.IMPORTED
    >>> flush_database_updates()

Let's attach a .po file now.

    >>> es_entry = translationimportqueue.addOrUpdateEntry(
    ...     'drivemount/help/es/es.po', 'foo content', True, rosetta_expert,
    ...     distroseries=hoary_distroseries,
    ...     sourcepackagename=gnome_terminal)

And we will get the right IPOFile.

    >>> es_entry.getGuessedPOFile().title
    u'Spanish (es) translation of help in Ubuntu Hoary package "gnome-terminal"'

Now, we are going to see what happens if we get a .po file for a template
that is not yet imported.

    >>> es_without_potemplate_entry = translationimportqueue.addOrUpdateEntry(
    ...     'wanda/help/es/es.po', 'foo content', True, rosetta_expert,
    ...     distroseries=hoary_distroseries, sourcepackagename=gnome_terminal)

We don't know the IPOFile where it should be imported.

    >>> es_without_potemplate_entry.getGuessedPOFile() is None
    True


Finally, we abort the transaction to undo all changes done.

    >>> transaction.abort()


== executeOptimisticBlock ==

This method looks on the queue to find entries to block based on other .pot
entries that are stored on the same directory and are already blocked.

Check the number of entries on the queue. We have the two sample data entries
plus the ones added in this test.

    >>> translationimportqueue.entryCount()
    5

First, let's check the status of the existing entries.

    >>> entry1 = translationimportqueue.get(1)
    >>> entry1.path
    u'po/evolution-2.2-test.pot'
    >>> entry1.status == RosettaImportStatus.IMPORTED
    True

    >>> entry2 = translationimportqueue.get(2)
    >>> entry2.path
    u'po/pt_BR.po'
    >>> entry2.status == RosettaImportStatus.IMPORTED
    True

    >>> entry3 = translationimportqueue.get(3)
    >>> entry3.path
    u'po/sr.po'
    >>> entry3.status == RosettaImportStatus.NEEDS_REVIEW
    True

    >>> entry4 = translationimportqueue.get(4)
    >>> entry4.path
    u'po/sr.po'
    >>> entry4.status == RosettaImportStatus.NEEDS_REVIEW
    True

    >>> entry5 = translationimportqueue.get(5)
    >>> entry5.path
    u'po/evolution-2.2.pot'

We need it blocked for this test.

    >>> entry5.status = RosettaImportStatus.BLOCKED

Let's see how many entries are blocked.

    >>> translationimportqueue.executeOptimisticBlock()
    1

Now is time to check that we only have one item on the NeedsReview status.

    >>> entry3 = translationimportqueue.get(3)
    >>> entry3.path
    u'po/sr.po'

This entry is for a productseries, and it's not blocked because the blocked
.pot entry is for a distroseries-sourcepackagename.

    >>> entry3.status == RosettaImportStatus.NEEDS_REVIEW
    True

On the other hand, this other one is for the same
distroseries/sourcepackagename than the .pot file we have so it's also blocked.

    >>> entry4 = translationimportqueue.get(4)
    >>> entry4.path
    u'po/sr.po'
    >>> entry4.status == RosettaImportStatus.BLOCKED
    True

And the .pot entry is still blocked.

    >>> entry5 = translationimportqueue.get(5)
    >>> entry5.path
    u'po/evolution-2.2.pot'
    >>> entry5.status == RosettaImportStatus.BLOCKED
    True


== getElapsedTimeText ==

This method returns a string representing the elapsed time since the entry
was added to the queue.

We need to attach a new entry to play with:

    >>> productseries = ProductSeries.get(1)
    >>> entry = translationimportqueue.addOrUpdateEntry(
    ...     'foo/bar.po', 'foo content', True,
    ...     rosetta_expert, productseries=productseries)

When we just import it, this method tells us that it's "just requested"

    >>> entry.getElapsedTimeText()
    'just requested'

Now, we need to update the 'dateimported' field to check that we get a good
value when takes more time since the import. We need to force the date here
because doing it with sample data would be a time bomb.

To edit this field, we need to have Edit permissions.

    >>> login('carlos@canonical.com')

Let's change the field with a date 2 days, 13 hours and 5 minutes ago.

    >>> import pytz
    >>> import datetime
    >>> UTC = pytz.timezone('UTC')
    >>> delta = datetime.timedelta(days=2, hours=13, minutes=5)
    >>> entry.dateimported = datetime.datetime.now(UTC) - delta

And this method gets the right text.

    >>> entry.getElapsedTimeText()
    '2 days 13 hours 5 minutes ago'


= TranslationImportQueue =

The translation import queue is the place where the new translation imports
end before being imported into Rosetta.


== getTemplatesOnSameDirectory ==

This method allows us to get the set of .pot files we have on the same
directory that a given entry.

For the third entry, we have one .pot file on that directory, which is already
in sample data.

    >>> entry3.status = RosettaImportStatus.NEEDS_REVIEW
    >>> entries = entry3.getTemplatesOnSameDirectory()
    >>> entries.count()
    1
    >>> entries[0].status == RosettaImportStatus.IMPORTED
    True
    >>> entries[0].id
    1

For the fourth entry, we have one.

    >>> entry4.status = RosettaImportStatus.NEEDS_REVIEW
    >>> entries = entry4.getTemplatesOnSameDirectory()
    >>> entries.count()
    1

Which is blocked.

    >>> entries[0].status == RosettaImportStatus.BLOCKED
    True

And finally, the .pot entry doesn't have other .pot in the same directory and
obviously, we are not returning it as being at the same directory as it makes
no sense at all.

    >>> entry5.status = RosettaImportStatus.NEEDS_REVIEW
    >>> entries = entry5.getTemplatesOnSameDirectory()
    >>> entries.count()
    0


== getPillarObjectsWithImports ==

This method returns all objects which have entries in the translation
import queue waiting to be imported.  Object can be a Product or
a DistroSeries.

To test it, we need to add a few items to the queue first, so lets
start with adding a single item to a source package inside Hoary
distroseries:

    >>> from canonical.launchpad.interfaces.distribution import IDistributionSet
    >>> ubuntu = getUtility(IDistributionSet).getByName('ubuntu')
    >>> hoary_distroseries = ubuntu.getSeries('hoary')
    >>> evolution_sourcepackagename = (
    ...     SourcePackageName.selectOne("name='evolution'"))
    >>> entry1 = translationimportqueue.addOrUpdateEntry(
    ...     u'po/sr.po', 'foo', True, rosetta_expert,
    ...      distroseries=hoary_distroseries,
    ...      sourcepackagename=evolution_sourcepackagename)

Now, lets add another which will be ignored since we are setting this
distroseries with defer_translation_imports = True.

    >>> warty_distroseries = ubuntu.getSeries('warty')
    >>> entry3 = translationimportqueue.addOrUpdateEntry(
    ...     u'po/sr.po', 'foo', True, rosetta_expert,
    ...      distroseries=warty_distroseries,
    ...      sourcepackagename=evolution_sourcepackagename)
    >>> print entry3.status.name
    NEEDS_REVIEW
    >>> warty_distroseries.defer_translation_imports = True

Next, lets add one item to a ProductSeries as well:

    >>> productseries = ProductSeries.get(1)
    >>> entry2 = translationimportqueue.addOrUpdateEntry(
    ...     'foo/bar.pot', 'foo content', True,
    ...     rosetta_expert, productseries=productseries)
    >>> transaction.commit()

The list of objects with approved entries should still be empty, since
we haven't approved any.

    >>> importqueues = translationimportqueue.getPillarObjectsWithImports(
    ...     RosettaImportStatus.APPROVED)
    >>> len(importqueues)
    0
    >>> print entry3.status.name
    NEEDS_REVIEW

Now we approve these entries (we need to be Rosetta administrator to do this).

    >>> login('carlos@canonical.com')
    >>> entry1.status = RosettaImportStatus.APPROVED
    >>> entry2.status = RosettaImportStatus.APPROVED

    >>> flush_database_updates()
    >>> translationimportqueue = getUtility(ITranslationImportQueue)

If we re-get the list of objects which have approved entries, we'll
get these recently approved ones.

    >>> importqueues = translationimportqueue.getPillarObjectsWithImports(
    ...     RosettaImportStatus.APPROVED)
    >>> len(importqueues)
    2

Lets check that the returned entries are actually the same ones we submitted.
Each of the objects returned provides a getFirstEntryToImport method
which returns the TranslationImportQueueEntry which is next up for import.

    >>> sortedqueues = sorted(importqueues,
    ...                       cmp=lambda x,y: cmp(y.title, x.title))
    >>> queue1 = sortedqueues[0]
    >>> queue1.title
    u'The Hoary Hedgehog Release'
    >>> entry = queue1.getFirstEntryToImport()
    >>> entry == entry1
    True

    >>> queue2 = sortedqueues[1]
    >>> queue2.title
    u'Mozilla Firefox'
    >>> entry = queue2.getFirstEntryToImport()
    >>> entry == entry2
    True

Note that our third entry never received approval, so it is still awaiting
review.

    >>> print entry3.status.name
    NEEDS_REVIEW


= Invalid data =

If administrators fail to correct certain errors in requests while approving
them, and the admin user interface mistakenly accepts the approval, we may
end up with an approved but incomplete entry that has no place to go (see
bug 138650 for an example).

If such bad requests do end up on the import queue, the import queue code will
raise errors about them.

    >>> entry = translationimportqueue.addOrUpdateEntry(
    ...     u'po/sr.po', 'foo', True, rosetta_expert,
    ...      productseries=evolution_productseries)

    >>> entry.import_into is None
    True

    >>> entry.status = RosettaImportStatus.APPROVED

    >>> import logging
    >>> from canonical.launchpad.scripts.po_import import ImportProcess
    >>> ImportProcess(transaction, logging).run()
    Traceback (most recent call last):
    ...
    AssertionError: Broken translation import queue entry 4 (for evolution):
    ...

    >>> entry = translationimportqueue.addOrUpdateEntry(
    ...     u'po/th.po', 'bar', False, rosetta_expert,
    ...     distroseries=hoary_distroseries,
    ...     sourcepackagename=evolution_sourcepackagename)

    >>> entry.import_into is None
    True

    >>> entry.status = RosettaImportStatus.APPROVED

    >>> import logging
    >>> from canonical.launchpad.scripts.po_import import ImportProcess
    >>> ImportProcess(transaction, logging).run()
    Traceback (most recent call last):
    ...
    AssertionError: Broken translation import queue entry 4 (for evolution):
    ...


