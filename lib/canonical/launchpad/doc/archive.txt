= Personal Package Archives =

An Archive models a Debian Archive, providing operations like
publication lookups and the complete publishing-pipeline from database
records to disk, including configuration and indexes.

    >>> from canonical.launchpad.webapp.testing import verifyObject
    >>> from canonical.launchpad.interfaces import (
    ...     ArchivePurpose, IPersonSet, IArchiveSet, IArchive,
    ...     IDistributionSet)

    >>> cprov = getUtility(IPersonSet).getByName('cprov')
    >>> cprov_archive = cprov.archive

    >>> cprov_archive.owner.name
    u'cprov'
    >>> cprov_archive.distribution.name
    u'ubuntu'
    >>> cprov_archive.purpose.name
    'PPA'
    >>> cprov_archive.enabled
    True
    >>> cprov_archive.authorized_size
    1024
    >>> cprov_archive.whiteboard
    u'It is not my fault.'
    >>> cprov_archive.private
    False
    >>> cprov_archive.require_virtualized
    True
    >>> cprov_archive.sources_cached
    3
    >>> cprov_archive.binaries_cached
    3
    >>> cprov_archive.is_ppa
    True

The buildd_secret is used by the slave scanner when generating a
sources.list entry for the builder to access a private archive.  It is
essentially the password to the archive for the builder.

    >>> login("foo.bar@canonical.com")
    >>> cprov_archive.buildd_secret = "secret"
    >>> login(ANONYMOUS)
    >>> print cprov_archive.buildd_secret
    secret

Useful properties:

    >>> cprov_archive.title
    u'PPA for Celso Providelo'

    >>> cprov_archive.archive_url
    u'http://ppa.launchpad.dev/cprov/ubuntu'

Inquire what Distribution Series this archive has published sources to:

    >>> [s.name for s in cprov_archive.series_with_sources]
    [u'breezy-autotest', u'warty']


== Published Source and Binary Lookup ==

IArchive implements a published source & binary lookup methods,
returning I{Source, Binary}PackagePublishingHistory objects.

    >>> cprov_archive.getPublishedSources().count()
    3

    >>> cprov_archive.getPublishedOnDiskBinaries().count()
    3

    >>> cprov_archive.getAllPublishedBinaries().count()
    4

This lookup also supports optional filters:

 * 'name': as in SQL "LIKE '%%' || NAME || '%%'");
 * 'version': exact version string matching;
 * 'status': a item or a list of PackagePublishingStatus.

    >>> from canonical.launchpad.interfaces import PackagePublishingStatus

    >>> active_status = [PackagePublishingStatus.PENDING,
    ...                  PackagePublishingStatus.PUBLISHED]

    >>> inactive_status = [PackagePublishingStatus.SUPERSEDED,
    ...                    PackagePublishingStatus.DELETED]

Let's inspect source publications in Cprov PPA:

    >>> all_sources = cd_lookup = cprov_archive.getPublishedSources()
    >>> for pub in all_sources:
    ...     title = pub.sourcepackagerelease.title
    ...     pub_ds = pub.distroseries.name
    ...     print "%s -> %s" % (title, pub_ds)
    cdrkit - 1.0 -> breezy-autotest
    iceweasel - 1.0 -> warty
    pmount - 0.1-1 -> warty

Using 'name' filter:

    >>> cprov_archive.getPublishedSources(name='cd').count()
    1

    >>> cprov_archive.getPublishedSources(name='ice').count()
    1

Combining 'name' filter and 'exact_match' flag:

    >>> cprov_archive.getPublishedSources(
    ...     name='iceweasel', exact_match=True).count()
    1
    >>> cprov_archive.getPublishedSources(
    ...     name='ice', exact_match=True).count()
    0

Using 'version' filter:

    >>> ice_version_lookup = cprov_archive.getPublishedSources(
    ...     version='1.0')
    Traceback (most recent call last):
    ...
    AssertionError: 'version' can be only used when name is set

    >>> ice_version_lookup = cprov_archive.getPublishedSources(
    ...     name='ice', version='1.0')
    >>> ice_version_lookup.count()
    1

    >>> cprov_archive.getPublishedSources(
    ...     name='ice', version='666').count()
    0

Using 'status' filter:

    >>> cprov_archive.getPublishedSources(
    ...     status=PackagePublishingStatus.PUBLISHED).count()
    3

    >>> cprov_archive.getPublishedSources(
    ...     status=active_status).count()
    3

    >>> cprov_archive.getPublishedSources(
    ...     status=inactive_status).count()
    0

Using 'distroseries' filter:

    >>> warty = cprov_archive.distribution['warty']
    >>> hoary = cprov_archive.distribution['hoary']
    >>> breezy_autotest = cprov_archive.distribution['breezy-autotest']

    >>> cprov_archive.getPublishedSources(
    ...     distroseries=warty).count()
    2
    >>> cprov_archive.getPublishedSources(
    ...     distroseries=hoary).count()
    0
    >>> cprov_archive.getPublishedSources(
    ...     distroseries=breezy_autotest).count()
    1

Using 'pocket' filter:

    >>> from canonical.launchpad.interfaces import PackagePublishingPocket
    >>> cprov_archive.getPublishedSources(
    ...     distroseries=warty,
    ...     pocket=PackagePublishingPocket.RELEASE).count()
    2

    >>> cprov_archive.getPublishedSources(
    ...     distroseries=warty,
    ...     pocket=PackagePublishingPocket.UPDATES).count()
    0

Combining 'name' and 'distroseries' filters:

    >>> cprov_archive.getPublishedSources(
    ...     name='ice', distroseries=warty).count()
    1
    >>> cprov_archive.getPublishedSources(
    ...     name='ice', distroseries=breezy_autotest).count()
    0

    >>> cprov_archive.getPublishedSources(
    ...     name='cd', distroseries=warty).count()
    0
    >>> cprov_archive.getPublishedSources(
    ...     name='cd', distroseries=breezy_autotest).count()
    1


=== Binary publication lookups ===

'getPublishedOnDiskBinaries' returns only unique publications, i.e., it
excludes architecture-independent duplications which is necessary for
having correct publication counters and archive size.

    >>> def check_bin_pubs(pubs):
    ...     """Print binary publication details."""
    ...     for pub in pubs:
    ...         title = pub.binarypackagerelease.title
    ...         arch_spec = pub.binarypackagerelease.architecturespecific
    ...         pub_arch = pub.distroarchseries.architecturetag
    ...         print "%s (%s) -> %s" % (title, arch_spec, pub_arch)

The PPA for cprov contains only 4 binary publications, however 'pmount' is
'architecture independent', which means that the same binary (DB) is
published for all available architectures, i386 & hppa:

    >>> all_cprov_bin_pubs = cprov_archive.getAllPublishedBinaries()

    >>> check_bin_pubs(all_cprov_bin_pubs)
    mozilla-firefox-1.0 (True) -> hppa
    mozilla-firefox-1.0 (True) -> i386
    pmount-0.1-1 (False) -> hppa
    pmount-0.1-1 (False) -> i386

'getPublishedOnDiskBinaries' automatically filters multiple publications of
'pmount' considering only the publication to the 'nominatedarchindep'
(defined for each distroseries).

    >>> unique_cprov_bin_pubs = cprov_archive.getPublishedOnDiskBinaries()

    >>> check_bin_pubs(unique_cprov_bin_pubs)
    mozilla-firefox-1.0 (True) -> i386
    pmount-0.1-1 (False) -> i386
    mozilla-firefox-1.0 (True) -> hppa

'name' filter supporting partial string matching and 'not-found':

    >>> cprov_archive.getPublishedOnDiskBinaries(name='pmou').count()
    1
    >>> cprov_archive.getAllPublishedBinaries(name='pmou').count()
    2
    >>> cprov_archive.getPublishedOnDiskBinaries(name='foo').count()
    0
    >>> cprov_archive.getAllPublishedBinaries(name='foo').count()
    0

Combining 'name' filter and 'exact_match' flag:

    >>> cprov_archive.getAllPublishedBinaries(
    ...     name='pmou', exact_match=True).count()
    0
    >>> cprov_archive.getAllPublishedBinaries(
    ...     name='pmount', exact_match=True).count()
    2
    >>> cprov_archive.getPublishedOnDiskBinaries(
    ...     name='pmou', exact_match=True).count()
    0
    >>> cprov_archive.getPublishedOnDiskBinaries(
    ...     name='pmount', exact_match=True).count()
    1

It's possible to associate 'name' and 'version' filters:

    >>> cprov_archive.getPublishedOnDiskBinaries(
    ...     name='moz', version='1.0').count()
    2

    >>> cprov_archive.getAllPublishedBinaries(
    ...     name='moz', version='1.0').count()
    2

    >>> cprov_archive.getPublishedOnDiskBinaries(
    ...     name='moz', version='666').count()
    0

    >>> cprov_archive.getAllPublishedBinaries(
    ...     name='moz', version='666').count()
    0

Both methods do not support passing the 'version' filter if the 'name'
filter is not passed too.

    >>> moz_version_lookup = cprov_archive.getAllPublishedBinaries(
    ...     version='1.0')
    Traceback (most recent call last):
    ...
    AssertionError: 'version' can be only used when name is set

    >>> moz_version_lookup = cprov_archive.getPublishedOnDiskBinaries(
    ...     version='1.0')
    Traceback (most recent call last):
    ...
    AssertionError: 'version' can be only used when name is set

Both methods support 'status' filter:

    >>> cprov_archive.getPublishedOnDiskBinaries(
    ...     status=PackagePublishingStatus.PUBLISHED).count()
    3

    >>> cprov_archive.getAllPublishedBinaries(
    ...     status=PackagePublishingStatus.PUBLISHED).count()
    4

    >>> cprov_archive.getPublishedOnDiskBinaries(
    ...     status=active_status).count()
    3

    >>> cprov_archive.getAllPublishedBinaries(
    ...     status=active_status).count()
    4

    >>> cprov_archive.getPublishedOnDiskBinaries(
    ...     status=inactive_status).count()
    0

    >>> cprov_archive.getAllPublishedBinaries(
    ...     status=inactive_status).count()
    0

Using 'distroarchseries' filter:

    >>> warty_i386 = warty['i386']
    >>> warty_hppa = warty['hppa']

    >>> cprov_archive.getAllPublishedBinaries(
    ...     distroarchseries=warty_i386).count()
    2
    >>> cprov_archive.getAllPublishedBinaries(
    ...     distroarchseries=warty_hppa).count()
    2

    >>> cprov_archive.getPublishedOnDiskBinaries(
    ...     distroarchseries=warty_i386).count()
    2
    >>> cprov_archive.getPublishedOnDiskBinaries(
    ...     distroarchseries=warty_hppa).count()
    1

    >>> cprov_archive.getAllPublishedBinaries(
    ...     distroarchseries=[warty_i386, warty_hppa]).count()
    4
    >>> cprov_archive.getPublishedOnDiskBinaries(
    ...     distroarchseries=[warty_i386, warty_hppa]).count()
    3

Using 'pocket' filter:

    >>> cprov_archive.getAllPublishedBinaries(
    ...     distroarchseries=warty_i386,
    ...     pocket=PackagePublishingPocket.RELEASE).count()
    2
    >>> cprov_archive.getPublishedOnDiskBinaries(
    ...     distroarchseries=warty_i386,
    ...     pocket=PackagePublishingPocket.RELEASE).count()
    2

    >>> cprov_archive.getAllPublishedBinaries(
    ...     distroarchseries=warty_i386,
    ...     pocket=PackagePublishingPocket.UPDATES).count()
    0
    >>> cprov_archive.getPublishedOnDiskBinaries(
    ...     distroarchseries=warty_i386,
    ...     pocket=PackagePublishingPocket.UPDATES).count()
    0

Associating 'name' and 'status' filters:

    >>> status_lookup = cprov_archive.getPublishedOnDiskBinaries(
    ...     name='pmount', status=active_status)
    >>> status_lookup.count()
    1

    >>> status_lookup = cprov_archive.getAllPublishedBinaries(
    ...     name='pmount', status=active_status)
    >>> status_lookup.count()
    2

    >>> status_lookup = cprov_archive.getPublishedOnDiskBinaries(
    ...     name='foo', status=active_status)
    >>> status_lookup.count()
    0

    >>> status_lookup = cprov_archive.getAllPublishedBinaries(
    ...     name='foo', status=active_status)
    >>> status_lookup.count()
    0

Associating 'name', 'version' and 'status' filters:

    >>> status_lookup = cprov_archive.getPublishedOnDiskBinaries(
    ...     name='pmount', version='0.1-1', status=active_status)
    >>> status_lookup.count()
    1

    >>> status_lookup = cprov_archive.getAllPublishedBinaries(
    ...     name='pmount', version='0.1-1', status=active_status)
    >>> status_lookup.count()
    2

    >>> status_lookup = cprov_archive.getPublishedOnDiskBinaries(
    ...     name='pmount', version='666', status=active_status)
    >>> status_lookup.count()
    0

    >>> status_lookup = cprov_archive.getAllPublishedBinaries(
    ...     name='pmount', version='666', status=active_status)
    >>> status_lookup.count()
    0

Associating 'name', 'version', 'status' and 'distroarchseries' filters
and 'exact_match' flag:

    >>> status_lookup = cprov_archive.getAllPublishedBinaries(
    ...     name='pmount', version='0.1-1', distroarchseries=warty_i386,
    ...     status=active_status, exact_match=True)
    >>> status_lookup.count()
    1

    >>> status_lookup = cprov_archive.getAllPublishedBinaries(
    ...     name='pmount', version='0.1-1',
    ...     distroarchseries=[warty_i386, warty_hppa],
    ...     status=active_status, exact_match=True)
    >>> status_lookup.count()
    2


== Package Counters ==

IArchive provides properties to calculate the number and the size of
the packages (sources and binaries) currently published in the
archive. They are based in the publication lookup methods.

    >>> cprov_archive.number_of_sources
    3
    >>> cprov_archive.number_of_binaries
    3
    >>> cprov_archive.sources_size
    9923399
    >>> cprov_archive.binaries_size
    3

Additionally we have another property to sum up the sources and the
binaries size and a pre-defined increment related to the files created
in the archive (+1kbytes for each publication)

    >>> pool_size = (
    ...     cprov_archive.sources_size + cprov_archive.binaries_size)

    >>> number_of_publications = (
    ...     cprov_archive.number_of_sources +
    ...     cprov_archive.number_of_binaries)
    >>> indexes_size = number_of_publications * 1024

    >>> estimated_size = cprov_archive.estimated_size
    >>> estimated_size
    9929546

    >>> estimated_size == pool_size + indexes_size
    True

The 'estimated_size' property automatically excludes duplicated published
files as it happens in the archive filesystem (pool/):

    >>> def print_published_files(archive):
    ...     pub_sources = archive.getPublishedSources()
    ...     for pub_source in pub_sources:
    ...         for src_file in pub_source.sourcepackagerelease.files:
    ...             print '%s: %s (%s, %d bytes)' % (
    ...                 src_file.sourcepackagerelease.title,
    ...                 src_file.libraryfile.filename,
    ...                 src_file.filetype.name,
    ...                 src_file.libraryfile.content.filesize)

First, let's print the currently published files in cprov's PPA:

    >>> print_published_files(cprov_archive)
    cdrkit - 1.0: foobar-1.0.dsc (DSC, 716 bytes)
    iceweasel - 1.0: firefox-0.9.2.orig.tar.gz (ORIG, 9922560 bytes)
    iceweasel - 1.0: iceweasel-1.0.dsc (DSC, 123 bytes)

Now we will emulate a duplicated reference to the same 'orig.tar.gz',
upstream tarball, as if it was part of two different SourcePackageRelease.

    >>> from canonical.launchpad.interfaces import ILibraryFileAliasSet
    >>> huge_firefox_orig_file = getUtility(ILibraryFileAliasSet)[3]
    >>> cprov_cdrkit_src = cprov_archive.getPublishedSources(
    ...     name='cdrkit')[0]
    >>> unused_src_file = cprov_cdrkit_src.sourcepackagerelease.addFile(
    ...     huge_firefox_orig_file)

As we see below, now we have two references to
'firefox-0.9.2.orig.tar.gz' file.

    >>> print_published_files(cprov_archive)
    cdrkit - 1.0: firefox-0.9.2.orig.tar.gz (ORIG, 9922560 bytes)
    cdrkit - 1.0: foobar-1.0.dsc (DSC, 716 bytes)
    iceweasel - 1.0: firefox-0.9.2.orig.tar.gz (ORIG, 9922560 bytes)
    iceweasel - 1.0: iceweasel-1.0.dsc (DSC, 123 bytes)

Similarly to what happen in the archive disk 'pool', where already
published files satisfy the new reference, the file size is not
computed again in the archive total size.

    >>> estimated_size == cprov_archive.estimated_size
    True

As mentioned before the package counters do not include non-PUBLISHED
packages, to verify this we will mark some package as SUPERSEDED and
see if the counter decreases.

Superseding a source package and verifying that the source counter
decreases.

    >>> cprov_archive.number_of_sources
    3
    >>> superseded = cprov_archive.getPublishedSources(
    ...     name='cdrkit')[0].supersede()
    >>> from canonical.launchpad.ftests import syncUpdate
    >>> syncUpdate(superseded)

    >>> cprov_archive.number_of_sources
    2

Superseding a binary package and verifying that the binary counter
decreases.

    >>> cprov_archive.number_of_binaries
    3
    >>> superseded = cprov_archive.getAllPublishedBinaries(
    ...     name='mozilla-firefox')[0].supersede()
    >>> syncUpdate(superseded)

    >>> cprov_archive.number_of_binaries
    2


== Sources available for deletions ==

'getSourcesForDeletion' is the base for '+delete-packages' page on PPA
context it allows us to lookup for `ISourcePackagePublishingHistory`
records which were not deleted yet.

 1. source publication is in PUBLISHED status OR
 2. source contains one or more binary publication in PUBLISHED status.

    >>> cprov_archive.getSourcesForDeletion().count()
    2

This method can optionally receive a source package name filter (SQL
LIKE) to restrict its result.

    >>> cprov_archive.getSourcesForDeletion(name='ice').count()
    1

If only the source publication is DELETED, leaving its binary behind,
it continues to be considered 'available for deletion'.

    >>> removal_candidate = cprov_archive.getPublishedSources(
    ...     name='ice')[0]
    >>> removal_candidate.getPublishedBinaries().count()
    1

    >>> deleted = removal_candidate.requestDeletion(cprov, 'go away !')
    >>> syncUpdate(deleted)

    >>> cprov_archive.getSourcesForDeletion(name='ice').count()
    1

The source publication is only excluded from 'deletion list' when its
binary is also DELETED.

    >>> for bin in removal_candidate.getPublishedBinaries():
    ...     deleted = bin.requestDeletion(cprov, 'go away !')
    ...     syncUpdate(deleted)

    >>> cprov_archive.getSourcesForDeletion(name='ice').count()
    0

Flush the database caches to invalidate old caches from the
corresponding publishing Postgres views.

    >>> from canonical.database.sqlbase import flush_database_caches
    >>> flush_database_caches()


== Build Lookup ==

It also implements a build lookup method, which supports, 'name',
'status' and 'pocket'.

This method can return build records for sources matching the given
'name' as in SQL LIKE:

    >>> cd_lookup = cprov_archive.getBuildRecords(name='cd')
    >>> cd_lookup.count()
    1
    >>> cd_lookup[0].sourcepackagerelease.name
    u'cdrkit'

    >>> ice_lookup = cprov_archive.getBuildRecords(name='ice')
    >>> ice_lookup.count()
    1
    >>> ice_lookup[0].sourcepackagerelease.name
    u'iceweasel'

    >>> cprov_archive.getBuildRecords(name='foo').count()
    0

Or return build records in a specific status:

    >>> from canonical.launchpad.interfaces import BuildStatus
    >>> cprov_archive.getBuildRecords(
    ...     build_state=BuildStatus.FULLYBUILT).count()
    3

    >>> cprov_archive.getBuildRecords(
    ...     build_state=BuildStatus.FAILEDTOBUILD).count()
    1

    >>> cprov_archive.getBuildRecords(
    ...     build_state=BuildStatus.NEEDSBUILD).count()
    0

And finally build records target to a given pocket:

    >>> cprov_archive.getBuildRecords(
    ...     pocket=PackagePublishingPocket.RELEASE).count()
    4

    >>> cprov_archive.getBuildRecords(
    ...     pocket=PackagePublishingPocket.UPDATES).count()
    0

All the attributes can be combined in order to refine the result:

    >>> cprov_archive.getBuildRecords(
    ...     name='ice',
    ...     build_state=BuildStatus.FULLYBUILT,
    ...     pocket=PackagePublishingPocket.RELEASE).count()
    1


== Publisher configuration provider ==

IArchive has a method to provide a modified Publisher Configuration (see
lib/archivepublisher/config.py), which provides the right paths for its
publication according to the given distribution:

    >>> # cprov 20061127: We should *never* be able to change a PPA
    >>> # distribution, however 'ubuntu' is not prepared for publication, thus
    >>> # we have to override the PPA to 'ubuntutest' in order to perform the
    >>> # tests.

    >>> from zope.security.proxy import removeSecurityProxy
    >>> ubuntutest = getUtility(IDistributionSet)['ubuntutest']

    >>> naked_cprov_archive = removeSecurityProxy(cprov_archive)
    >>> naked_cprov_archive.distribution = ubuntutest
    >>> pubconfig = naked_cprov_archive.getPubConfig()

The base Archive publication location is set in the current Launchpad
configuration file:

    >>> from canonical.config import config
    >>> pubconfig.distroroot == config.personalpackagearchive.root
    True

There is a separate location for private PPAs that is used if the
archive is marked as private:

    >>> (config.personalpackagearchive.private_root !=
    ...  config.personalpackagearchive.root)
    True

    >>> naked_cprov_archive.private = True
    >>> private_pubconfig = naked_cprov_archive.getPubConfig()
    >>> (private_pubconfig.distroroot ==
    ...  config.personalpackagearchive.private_root)
    True

    >>> naked_cprov_archive.private = False

Then, the archive topology will follow:

<PPA_BASE_DIR>/<PERSONNAME>/<DISTRIBUTION>

    >>> pubconfig.archiveroot
    u'/var/tmp/ppa.test/cprov/ubuntutest'

    >>> pubconfig.poolroot
    u'/var/tmp/ppa.test/cprov/ubuntutest/pool'

    >>> pubconfig.distsroot
    u'/var/tmp/ppa.test/cprov/ubuntutest/dists'

Path not used in *personal* archives publication workflow are set to
None, so they won't get created:

    >>> pubconfig.overrideroot is None
    True
    >>> pubconfig.cacheroot is None
    True
    >>> pubconfig.miscroot is None
    True

Usual methods from Publisher Configuration are preserved:

    >>> pubconfig.distroSeriesNames()
    ['breezy-autotest', 'hoary-test']

    >>> pubconfig.archTagsForSeries('breezy-autotest')
    []

    >>> pubconfig.componentsForSeries('breezy-autotest')
    ['main', 'restricted', 'universe', 'multiverse']

Let's restore Celso's PPA state, attaching it to ubuntu distribution
again.

    >>> ubuntu = getUtility(IDistributionSet)['ubuntu']
    >>> naked_cprov_archive.distribution = ubuntu
    >>> naked_cprov_archive.syncUpdate()


== Archive dependencies ==

An Archive can depend on one or more other archives, such
relationships affects mainly its builds, which will be querying build
dependencies also in dependent archives, and its client system which
will have to enable apt to look for package dependencies in the
dependent archive as well.

Currently only one level of dependency is supported, i.e., PPA X
depends on PPA Y, if PPA W wants to use packages of PPA X it will have
to depend also on PPA Y, otherwise it won't be able to install all the
required dependencies when building.

    >>> def print_dependencies(archive):
    ...     dependencies = archive.dependencies
    ...     if not dependencies:
    ...         print "No dependencies recorded."
    ...         return
    ...     for dep in dependencies:
    ...         print dep.dependency.title

Celso's PPA has no dependencies stored in the sampledata.

    >>> print_dependencies(cprov.archive)
    No dependencies recorded.

We will make Celso's PPA to depend on Mark's PPA.

    >>> sabdfl = getUtility(IPersonSet).getByName('sabdfl')
    >>> archive_dependency = cprov.archive.addArchiveDependency(
    ...     sabdfl.archive)

The `IArchiveDependency` object simply maps the desired relationship.

    >>> print archive_dependency.archive.title
    PPA for Celso Providelo

    >>> print archive_dependency.dependency.title
    PPA for Mark Shuttleworth

The archive dependency is immediately recorded on Celso's PPA.

    >>> print_dependencies(cprov.archive)
    PPA for Mark Shuttleworth

'getArchiveDependency' returns the corresponding `IArchiveDependency`
for a given 'dependency' if it exists, otherwise it returns None.

    >>> print cprov.archive.getArchiveDependency(
    ...     sabdfl.archive).dependency.title
    PPA for Mark Shuttleworth

    >>> no_priv = getUtility(IPersonSet).getByName('no-priv')
    >>> print cprov.archive.getArchiveDependency(no_priv.archive)
    None

As mentioned above, the archive dependency engine doesn't follow
cross dependencies. When a PPA depends only on Celso's PPA it might
result in issues while building package if a required package
dependency is published in Mark's PPA.

    >>> print_dependencies(no_priv.archive)
    No dependencies recorded.

    >>> archive_dependency = no_priv.archive.addArchiveDependency(
    ...     cprov.archive)

    >>> print_dependencies(no_priv.archive)
    PPA for Celso Providelo

`IArchive.addArchiveDependency` raises an error if the given
'dependency' violates the system overall constraints.

'dependency' is already recorded (duplicated).

    >>> no_priv.archive.addArchiveDependency(cprov.archive)
    Traceback (most recent call last):
    ...
    ArchiveDependencyError: This dependency is already recorded.

'dependency' and target archive are the same.

    >>> no_priv.archive.addArchiveDependency(no_priv.archive)
    Traceback (most recent call last):
    ...
    ArchiveDependencyError: An archive should not depend on itself.

A 'dependency' can only be a PPA. Other archives (PRIMARY, PARTNER or
EMBARGOED) are explicitly forbidden until we can analyse the impact of
allowing them.

    >>> ubuntu = no_priv.archive.distribution
    >>> no_priv.archive.addArchiveDependency(ubuntu.main_archive)
    Traceback (most recent call last):
    ...
    ArchiveDependencyError: Archive dependencies only applies to PPAs.

'removeArchiveDependency' allow us to purge a recorded 'dependency'.

    >>> print_dependencies(no_priv.archive)
    PPA for Celso Providelo

    >>> no_priv.archive.removeArchiveDependency(cprov.archive)

    >>> print_dependencies(no_priv.archive)
    No dependencies recorded.

Since the 'dependency' property only returns explicitly recorded
archive dependencies and we usually need the expanded list when
inspecting the build domain we have also implemented the
'expanded_archive_dependencies' property. It returns implicit
dependencies, including the archive itself and the PRIMARY archive
dependency for PPAs.

    >>> def print_expanded_archive_dependencies(archive):
    ...     for dep in archive.expanded_archive_dependencies:
    ...         print dep.title

    >>> print_expanded_archive_dependencies(ubuntu.main_archive)
    Primary Archive for Ubuntu Linux

    >>> print_expanded_archive_dependencies(cprov.archive)
    Primary Archive for Ubuntu Linux
    PPA for Celso Providelo
    PPA for Mark Shuttleworth


== Find binary package dependency candidates ==

Archive allows a lookup on a single binary package dependency
candidate by its name, via the `PublishedPackage` table:

    >>> warty_i386 = warty['i386']

    >>> candidate = ubuntu.main_archive.findDepCandidateByName(
    ...     warty_i386, "pmount")
    >>> print candidate.binarypackagename
    pmount

    >>> candidate = cprov.archive.findDepCandidateByName(
    ...     warty_i386, "pmount")
    >>> print candidate.binarypackagename
    pmount

Since 'python2.4' isn't available in our sampledata (not even
published), None is returned:

    >>> print ubuntu.main_archive.findDepCandidateByName(
    ...     warty_i386, "python2.4")
    None

    >>> print cprov.archive.findDepCandidateByName(
    ...     warty_i386, "python2.4")
    None

This method is aware of the archive dependency tree. So, even when a
package is not published on the context PPA but is available somewhere
in the archive dependency domain it will be found.

'at' binary package is not present in Celso's PPA.

    >>> cprov_archive.getAllPublishedBinaries(name='at').count()
    0

But it is available in PRIMARY ubuntu archive.

    >>> primary_candidate = ubuntu.main_archive.findDepCandidateByName(
    ...     warty_i386, "at")
    >>> primary_candidate is not None
    True

Then a lookup on Celso's PPA will find it.

    >>> ppa_candidate = cprov.archive.findDepCandidateByName(
    ...     warty_i386, "at")
    >>> ppa_candidate is not None
    True

    >>> primary_candidate == ppa_candidate
    True


== IArchiveSet Utility ==

This utility provides useful methods to deal with IArchive in other
parts of the system.

    >>> archive_set = getUtility(IArchiveSet)

A new Archive can be created by passing a name and an owner

    >>> name16 = getUtility(IPersonSet).getByName('name16')
    >>> sandbox_archive = archive_set.new(
    ...    purpose=ArchivePurpose.PPA, owner=name16)

    >>> verifyObject(IArchive, sandbox_archive)
    True

    >>> sandbox_archive.owner == name16
    True

We can take the opportunity to check if the default 'authorized_size'
corresponds to what we state in our policy, 1024 MiB:

    >>> name16.archive.authorized_size
    1024

IArchiveSet.ensure will either return an existing archive, or make a new
one if there is no existing one.

    >>> name12 = getUtility(IPersonSet).getByName('name12')
    >>> name12_archive = archive_set.ensure(
    ...     owner=name12, distribution=None, purpose=ArchivePurpose.PPA,
    ...     description="Holy mackerel")
    >>> name12_archive.description
    u'Holy mackerel'

Repeating this call with a different description results in the archive
created above returned instead of a new one:

    >>> name12_archive = archive_set.ensure(
    ...     owner=name12, distribution=None, purpose=ArchivePurpose.PPA,
    ...     description="Flaming trousers")
    >>> name12_archive.description
    u'Holy mackerel'

An archive is also associated with a distribution.  This can be found on
the distribution property.  The default distribution is "ubuntu":

     >>> sandbox_archive.distribution.name
     u'ubuntu'

An Archive can be retrieved via IPerson.archive property:

    >>> name16.archive == sandbox_archive
    True

IArchiveSet.getByDistroPurpose retrieves an IArchive given a distribution
and an ArchivePurpose:

    >>> from canonical.launchpad.interfaces import ArchivePurpose
    >>> partner_archive = getUtility(IArchiveSet).getByDistroPurpose(
    ...     ubuntutest, ArchivePurpose.PARTNER)
    >>> partner_archive.description
    u'Partner archive'

IArchive.archive_url will return a URL for the archive that the builder can
use to retrieve files from it.

    >>> partner_archive.archive_url
    u'http://launchpad.dev/ubuntutest-partner'

    >>> sandbox_archive.archive_url
    u'http://ppa.launchpad.dev/name16/ubuntu'

    >>> getUtility(IArchiveSet).getByDistroPurpose(
    ...     ubuntutest, ArchivePurpose.PRIMARY).archive_url
    u'http://launchpad.dev/ubuntutest'

If the archive is private, the url may be different as private PPAs
are published to a secure location.

    >>> naked_cprov_archive.archive_url
    u'http://ppa.launchpad.dev/cprov/ubuntu'

    >>> naked_cprov_archive.private = True
    >>> naked_cprov_archive.syncUpdate()

    >>> naked_cprov_archive.archive_url
    u'http://private.ppa.launchpad.dev/cprov/ubuntu'

The publisher config for PARTNER contains only 'partner' in its
components.  This prevents non-partner being published in the partner
archive.

    >>> comm_pubconf = removeSecurityProxy(
    ...     partner_archive.getPubConfig())
    >>> for distroseries in comm_pubconf._distroserieses.keys():
    ...     print set(
    ...         comm_pubconf._distroserieses[distroseries]['components'])
    set(['partner'])
    set(['partner'])

IArchive.allowUpdatesToReleasePocket returns whether the archive is allowed
to publish to the RELEASE pocket no matter what state the distroseries is in.

    >>> partner_archive.allowUpdatesToReleasePocket()
    True

    >>> cprov_archive.allowUpdatesToReleasePocket()
    True

    >>> getUtility(IArchiveSet).getByDistroPurpose(
    ...     ubuntutest, ArchivePurpose.PRIMARY).allowUpdatesToReleasePocket()
    False

getPPAByDistributionAndOwnerName method allow PPA lookups based on a
distribution and a person name. This method is used in
`PackageLocation` to provide a homogeneous way to refer to a Location
(archive, distribution, distroseries, pocket).

    >>> cprov_archive == archive_set.getPPAByDistributionAndOwnerName(
    ...     ubuntu, 'cprov')
    True

    >>> sabdfl = getUtility(IPersonSet).getByName('sabdfl')
    >>> sabdfl.archive == archive_set.getPPAByDistributionAndOwnerName(
    ...     ubuntu, 'sabdfl')
    True

Iteration over the own utility is performed against all archives,
including the *main_archives*:

    >>> main_archives = 0
    >>> ppas = 0
    >>> for archive in archive_set:
    ...     if archive.owner is None:
    ...         main_archives += 1
    ...     else:
    ...         ppas += 1
    >>> main_archives, ppas
    (9, 5)

ArchiveSet utility also offers counters for:

 * The number of published sources in public PPAs
   (number_of_ppa_sources);

 * The number of published binaries in public PPAs
   (number_of_ppa_binaries)

Those counters are obtained from the cached package counters for each
PPA, so they will change when the caches get updated.

Those counters explicity exclude packages in private PPAs.

The current counters says we only have 1 source and 1 binary published
in public PPAs.

    >>> archive_set.number_of_ppa_sources
    1
    >>> archive_set.number_of_ppa_binaries
    1

As mentioned caches for private PPAs are not considered.

    >>> print cprov.archive.private
    True

    >>> cprov.archive.sources_cached
    3
    >>> cprov.archive.binaries_cached
    3

    >>> naked_cprov_archive.sources_cached = 1000
    >>> naked_cprov_archive.binaries_cached = 2000
    >>> naked_cprov_archive.syncUpdate()

    >>> archive_set.number_of_ppa_sources
    1
    >>> archive_set.number_of_ppa_binaries
    1

On the other hand, changes in the a public PPA are immediately
considered.

    >>> print no_priv.archive.private
    False

    >>> no_priv.archive.sources_cached
    0
    >>> no_priv.archive.binaries_cached
    0
    >>> naked_no_priv_archive = removeSecurityProxy(no_priv.archive)
    >>> naked_no_priv_archive.sources_cached = 10
    >>> naked_no_priv_archive.binaries_cached = 2
    >>> naked_no_priv_archive.syncUpdate()

    >>> archive_set.number_of_ppa_sources
    11
    >>> archive_set.number_of_ppa_binaries
    3

'getPPAsForUser' returns all the PPAs a given user participates in. It
uses `TeamParticipation` relationships to calculate all the PPAs the
user is allowed to upload or copy packages to.

In the sampledata, 'cprov' only participates in his own PPA.

    >>> for ppa in archive_set.getPPAsForUser(cprov):
    ...     print ppa.title
    Private PPA for Celso Providelo

However 'cprov' is also a member of 'launchpad-buildd-admins' team,
which doesn't have a PPA yet.

    >>> lp_buildd_team = getUtility(IPersonSet).getByName(
    ...     'launchpad-buildd-admins')

    >>> cprov.inTeam(lp_buildd_team)
    True

    >>> lp_buildd_team.archive is None
    True

When the 'launchpad-buildd-admins' PPA gets created, 'getPPAsForUser'
immediately recognises 'cprov' rights on it.

    >>> buildd_archive = archive_set.ensure(
    ...     owner=lp_buildd_team, purpose=ArchivePurpose.PPA,
    ...     distribution=ubuntu, description='Yo !')

    >>> for ppa in archive_set.getPPAsForUser(cprov):
    ...     print ppa.title
    Private PPA for Celso Providelo
    PPA for Launchpad Buildd Admins

When there is no active PPA for the team a user participates the
method returns a empty SelectResults.

    >>> jblack = getUtility(IPersonSet).getByName('jblack')

    >>> jblack_ppas = archive_set.getPPAsForUser(jblack)

    >>> jblack_ppas.count()
    0

For the next test we will make Celso's PPA public again, so it can
appear in public lists. We do that because that PPA contains relevant
contents for testing.

    >>> naked_cprov_archive.private = False
    >>> naked_cprov_archive.syncUpdate()

'getLatestPPASourcePublicationsForDistribution' returns up to 5
lastest source publications available for a given distribution ordered
by descending 'datecreated'.

    >>> latest_uploads = (
    ...     archive_set.getLatestPPASourcePublicationsForDistribution(ubuntu))
    >>> latest_uploads.count()
    4

It doesn't filter by status, so pending (copied), deleted and
superseded publications continue to be presented.

    >>> def print_latest_uploads():
    ...     latest_uploads = (
    ...         archive_set.getLatestPPASourcePublicationsForDistribution(
    ...         ubuntu))
    ...     for pub in latest_uploads:
    ...         print pub.displayname, pub.status.name, pub.archive.owner.name

    >>> print_latest_uploads()
    cdrkit 1.0 in breezy-autotest SUPERSEDED cprov
    iceweasel 1.0 in breezy-autotest PUBLISHED sabdfl
    pmount 0.1-1 in warty PUBLISHED cprov
    iceweasel 1.0 in warty DELETED cprov

When we copy a source from Celso's PPA to Mark's PPA, it will be
presented as a new record in the results.

    >>> cprov_iceweasel = latest_uploads[1]
    >>> copy = cprov_iceweasel.copyTo(
    ...      ubuntu['hoary'], PackagePublishingPocket.RELEASE, sabdfl.archive)

    >>> print_latest_uploads()
    iceweasel 1.0 in hoary PENDING sabdfl
    cdrkit 1.0 in breezy-autotest SUPERSEDED cprov
    iceweasel 1.0 in breezy-autotest PUBLISHED sabdfl
    pmount 0.1-1 in warty PUBLISHED cprov
    iceweasel 1.0 in warty DELETED cprov

When we do another copy the result will be limited, so the previous
last publication (Celso's deleted iceweasel) will be excluded.

    >>> cprov_cdrkit = latest_uploads[1]
    >>> copy = cprov_cdrkit.copyTo(
    ...      ubuntu['hoary'], PackagePublishingPocket.RELEASE, sabdfl.archive)

    >>> print_latest_uploads()
    cdrkit 1.0 in hoary PENDING sabdfl
    iceweasel 1.0 in hoary PENDING sabdfl
    cdrkit 1.0 in breezy-autotest SUPERSEDED cprov
    iceweasel 1.0 in breezy-autotest PUBLISHED sabdfl
    pmount 0.1-1 in warty PUBLISHED cprov

Private source publications are excluded from this list, the fact that
they exist should never leak. If we make Celso's PPA private, its
contents will not be listed anymore. The same happens for uploaded
sources, since they are essentially another source publication in this
context.

    >>> naked_cprov_archive.private = True
    >>> naked_cprov_archive.syncUpdate()

    >>> print_latest_uploads()
    cdrkit 1.0 in hoary PENDING sabdfl
    iceweasel 1.0 in hoary PENDING sabdfl
    iceweasel 1.0 in breezy-autotest PUBLISHED sabdfl

'getMostActivePPAsForDistribution' returns a list of dictionaries
containing up to 5 PPAs with the highest number of publications in the
last 7 days. Each dictionary contains the following keys:

 * 'archive': The `IArchive` object;
 * 'uploads': the number of sources uploaded in the last 7 days.

The list is ordered by descending number of uploads and then database
record ID.

    >>> most_active_ppas = (
    ...     archive_set.getMostActivePPAsForDistribution(ubuntu))
    >>> len(most_active_ppas)
    1

As expected only Mark's PPA had activity, all the sampledata records
are old.

    >>> def print_most_active_ppas():
    ...     most_active_ppas = (
    ...         archive_set.getMostActivePPAsForDistribution(ubuntu))
    ...     for most_active in most_active_ppas:
    ...         print most_active['archive'].title, most_active['uploads']

    >>> print_most_active_ppas()
    PPA for Mark Shuttleworth 2

We will create some activity.

    >>> a_pub = cprov_archive.getPublishedSources()[0]
    >>> def create_activity(where, how_many):
    ...     for i in range(how_many):
    ...         a_pub.copyTo(
    ...             ubuntu['hoary'], PackagePublishingPocket.RELEASE, where)

    >>> create_activity(cprov_archive, 20)
    >>> create_activity(sandbox_archive, 10)
    >>> create_activity(name12.archive, 4)
    >>> create_activity(no_priv.archive, 4)
    >>> create_activity(lp_buildd_team.archive, 8)

Celso's PPA is still private, so despite having the highest number of
uploads it's not listed.

    >>> print_most_active_ppas()
    PPA for Foo Bar 10
    PPA for Launchpad Buildd Admins 8
    PPA for No Privileges Person 4
    PPA for Sample Person 4
    PPA for Mark Shuttleworth 2

When we make Celso's PPA public the result gets limited to 5 items.
The previous last item (Mark's PPA) will now be excluded in place of
Celso's PPA.

    >>> naked_cprov_archive.private = False
    >>> naked_cprov_archive.syncUpdate()

    >>> print_most_active_ppas()
    PPA for Celso Providelo 20
    PPA for Foo Bar 10
    PPA for Launchpad Buildd Admins 8
    PPA for No Privileges Person 4
    PPA for Sample Person 4


== Archive Permission Checking ==

IArchive has two public methods, canUpload() and canAdministerQueue()
that check a user's permission to upload and/or administer a
distroseries upload queue respectively.  See archivepermission.txt
for more details.

    >>> from canonical.launchpad.interfaces import IComponentSet
    >>> main_component = getUtility(IComponentSet)['main']
    >>> ubuntu_team = getUtility(IPersonSet).getByName('ubuntu-team')
    >>> carlos = getUtility(IPersonSet).getByName('carlos')

    >>> ubuntu.main_archive.canUpload(carlos, main_component)
    False

    >>> ubuntu.main_archive.canAdministerQueue(carlos, main_component)
    False

    >>> ubuntu.main_archive.canUpload(ubuntu_team, main_component)
    True

    >>> ubuntu.main_archive.canAdministerQueue(ubuntu_team, main_component)
    True

canUpload() can also check someone's permission to upload a specific
source package.  Carlos, who does not have permission to upload to any
Ubuntu components, has permission to upload "mozilla-firefox".

    >>> from canonical.launchpad.interfaces import ISourcePackageNameSet
    >>> mozilla = getUtility(
    ...     ISourcePackageNameSet).queryByName("mozilla-firefox")
    >>> ubuntu.main_archive.canUpload(carlos, mozilla)
    True
