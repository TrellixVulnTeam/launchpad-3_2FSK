= Archive signing =

`IArchive ` objects may be signed using its a IGPGKey pointed by its
'signing_key' attribute.

PPAs are created (activated, in production jargon) without a defined
'signing_key'. A GPG key will be generated later by a auxiliary script
and attached to the corresponding `IArchive`.

The secret part of the key will be stored in the path pointed by
`config.personalpackagearchive.sigining_keys_root`, named by their
fingerprint. E.g.: ABCDEF0123456789ABCDDCBA0000111112345678.key

Once the signing key is available, the subsequent publications will
result in a signed repository.

The signed repository will contained a detached signature of the
top-level 'Release' file, named 'Release.gpg' and a ASCII-armoded
export of the public GPG key (name 'key.gpg')

We will setup and use the test-keyserver (zeca).

    >>> from canonical.zeca.ftests.harness import ZecaTestSetup
    >>> z = ZecaTestSetup()
    >>> z.setUp()


== Querying 'pending sigining key' PPAs ==

`IArchiveSet.getPPAsPendingSigningKey` allows call-sites to query for
PPA pending signing key generation.

    >>> from canonical.launchpad.interfaces.archive import IArchiveSet
    >>> from canonical.launchpad.interfaces.person import IPersonSet

Only PPAs with at least one source publication are considered.

    >>> archive_set = getUtility(IArchiveSet)
    >>> for ppa in archive_set.getPPAsPendingSigningKey():
    ...     print ppa.title
    PPA for Celso Providelo
    PPA for Mark Shuttleworth

The PPA for 'No Privileges' user exists, is enabled and has no
signing, but it also does not contain any source publications, that's
why it's skipped in the getPPAsPendingSigningKey() results.

    >>> cprov = getUtility(IPersonSet).getByName('cprov')
    >>> no_priv = getUtility(IPersonSet).getByName('no-priv')

    >>> print no_priv.archive.title
    PPA for No Privileges Person

    >>> no_priv.archive.enabled
    True

    >>> print no_priv.archive.signing_key
    None

    >>> no_priv.archive.number_of_sources
    0

'No Privileges' PPA will be considered for signing_key creation when
we copy an arbitrary source into it.

    >>> a_source = cprov.archive.getPublishedSources()[0]
    >>> copied_sources = a_source.copyTo(
    ...     a_source.distroseries, a_source.pocket, no_priv.archive)

    >>> for ppa in archive_set.getPPAsPendingSigningKey():
    ...     print ppa.title
    PPA for Celso Providelo
    PPA for Mark Shuttleworth
    PPA for No Privileges Person

Disabled PPAs are excluded from the 'PendingSigningKey' pool:

    >>> no_priv.archive.enabled = False

    >>> for ppa in archive_set.getPPAsPendingSigningKey():
    ...     print ppa.title
    PPA for Celso Providelo
    PPA for Mark Shuttleworth

Indeed, Marks's PPA does not have a defined 'sigining_key'.

    >>> sabdfl = getUtility(IPersonSet).getByName('sabdfl')
    >>> print sabdfl.archive.signing_key
    None

We will select the only available IGPGKey from the sampledata.

    >>> foo_bar = getUtility(IPersonSet).getByName('name16')
    >>> [a_key] = foo_bar.gpgkeys
    >>> print a_key.displayname
    1024D/12345678

And use it as the Mark's PPA sigining key.

    >>> sabdfl.archive.signing_key = a_key

It will exclude Mark's PPA from the 'PendingSigningKey' pool as well.

    >>> for ppa in archive_set.getPPAsPendingSigningKey():
    ...     print ppa.title
    PPA for Celso Providelo


== Generating a PPA signing key ==

As mentioned above, generated sigining_keys will be stored in a
location defined by the system configuration.

    >>> from canonical.config import config
    >>> print config.personalpackagearchive.signing_keys_root
    /var/tmp/ppa-signing-keys

In order to manipulate 'signing_keys' securily the target archive
object has to be adapted to `IArchiveSigningKey`.

    >>> from canonical.launchpad.interfaces.archivesigningkey import (
    ...     IArchiveSigningKey)

We will adapt Celso's PPA after modifing its distribution to allow
proper publish configuration based on the sampledata.

    >>> cprov = getUtility(IPersonSet).getByName('cprov')

    >>> from canonical.launchpad.interfaces.distribution import (
    ...     IDistributionSet)
    >>> cprov.archive.distribution = getUtility(
    ...     IDistributionSet).getByName('ubuntutest')

    >>> archive_signing_key = IArchiveSigningKey(cprov.archive)

Once adapted `IArchiveSigningKey` is properly implemented.

    >>> from zope.interface.verify import verifyObject
    >>> verifyObject(IArchiveSigningKey, archive_signing_key)
    True

`IArchiveSigningKey` object contain the corresponding IArchive
object.

    >>> print archive_signing_key.archive.title
    PPA for Celso Providelo

It also implements exportSecretKey() which receive a `PymeKey` and
export it in the appropriate location.

We will create MockKey objects implementing only the methods required
to test the export funtions

    >>> class MockKey:
    ...     def __init__(self, secret):
    ...         self.secret = secret
    ...         self.fingerprint = 'fpr'
    ...     def export(self):
    ...         return "Secret %s" % self.secret

exportSecretKey() raises an error if given a public key.

    >>> archive_signing_key.exportSecretKey(MockKey(False))
    Traceback (most recent call last):
    ...
    AssertionError: Only secret keys should be exported.

Now, if given the right type of key, it will result in a exported key
in the expected path.

    >>> mock_key = MockKey(True)
    >>> archive_signing_key.exportSecretKey(mock_key)
    >>> print open(
    ...     archive_signing_key.getPathForSecretKey(mock_key)).read()
    Secret True

At this point we can use the `IArchiveSigningKey` to generate and
assign a real signing_key, although this procedure depends heavily on
machine entropy and ends up being very slow in our test machine.

    ### archive_signing_key.generateSigningKey()

We will use a pre-exiting key in our tree which is virtually
identical to the one that would be generated. The key will be 'set' by
using a method `IArchiveSigningKey` skips the key generation but uses
exactly the same procedure for setting the signing_key information.

    >>> import os
    >>> from canonical.launchpad.ftests.keys_for_tests import gpgkeysdir
    >>> key_path = os.path.join(gpgkeysdir, 'ppa-sample@canonical.com.sec')
    >>> archive_signing_key.setSigningKey(key_path)

The assigned key is a sign-only, password-less 1024-RSA GPG key owner
by the 'PPA key guard' celebrity and represented by a IGPGKey record.

    >>> signing_key = archive_signing_key.archive.signing_key

    >>> from canonical.launchpad.interfaces.gpg import IGPGKey
    >>> verifyObject(IGPGKey, signing_key)
    True

    >>> print signing_key.owner.name
    ppa-key-guard

    >>> print signing_key.algorithm.description
    RSA

    >>> print signing_key.keysize
    1024

    >>> print signing_key.active
    True

    >>> print signing_key.can_encrypt
    False

The generated key UID follows "Launchpad %(ppa.title)s" format.

    >>> from canonical.launchpad.interfaces.gpghandler import IGPGHandler
    >>> gpghandler = getUtility(IGPGHandler)

    >>> retrieved_key = gpghandler.retrieveKey(
    ...    signing_key.fingerprint)

    >>> [uid] = retrieved_key.uids
    >>> print uid.name
    Launchpad PPA for Celso Providelo

The secret key is securily stored in the designed configuration
path. So only the IGPGHandler itself can access it.

    >>> print open(
    ...     archive_signing_key.getPathForSecretKey(signing_key)).read()
    -----BEGIN PGP PRIVATE KEY BLOCK-----
    ...
    -----END PGP PRIVATE KEY BLOCK-----
    <BLANKLINE>

If called against a PPA which already has a 'signing_key'
`generateSigningKey` will raise an error.

    >>> archive_signing_key.generateSigningKey()
    Traceback (most recent call last):
    ...
    AssertionError: Cannot override signing_keys.

Let's reset the gpg local key ring, so we can check that the public
key is available in the keyserver.

    >>> gpghandler.resetLocalState()

    >>> retrieved_key = gpghandler.retrieveKey(
    ...    signing_key.fingerprint)
    >>> retrieved_key.fingerprint == signing_key.fingerprint
    True


== Sigining PPA repository ==

`IArchiveSigningKey.signRepository` can be user to sign repositories
for archive which already contains a 'signing_key'.

When signing repositores we assert they contain the right format and
the expected file.

    >>> test_suite = 'hoary'
    >>> archive_signing_key.signRepository(test_suite)
    Traceback (most recent call last):
    ...
    AssertionError: Release file doesn't exist in the repository:
    /var/tmp/ppa.test/cprov/default/ubuntutest/dists/hoary/Release

It produces a detached signature for the repository Release current
file contents.

    XXX cprov 20081205: PublishingConfig doesn't implement any
    interfaces, when it's returned from a content class no attributes
    can be accessed.

    >>> from zope.security.proxy import removeSecurityProxy
    >>> archive_root = removeSecurityProxy(
    ...     cprov.archive.getPubConfig()).archiveroot

    >>> import os
    >>> suite_path = os.path.join(archive_root, 'dists', test_suite)
    >>> os.makedirs(suite_path)
    >>> release_path = os.path.join(suite_path, 'Release')

    >>> release_file = open(release_path, 'w')
    >>> release_file.write('This is a fake release file.')
    >>> release_file.close()

    >>> archive_signing_key.signRepository(test_suite)

    >>> print open(release_path + '.gpg').read()
    -----BEGIN PGP SIGNATURE-----
    ...
    -----END PGP SIGNATURE-----
    <BLANKLINE>

The signature can be verified by retrieving the public key from the
keyserver.

    >>> gpghandler.resetLocalState()

    >>> retrieved_key = gpghandler.retrieveKey(
    ...    signing_key.fingerprint)

    >>> signature = gpghandler.getVerifiedSignature(
    ...     content=open(release_path).read(),
    ...     signature=open(release_path + '.gpg').read())

    >>> expected_fingerprint = (
    ...     archive_signing_key.archive.signing_key.fingerprint)
    >>> signature.fingerprint == expected_fingerprint
    True

Finally, if we try to sign a repository for which the archive doesn't
have a 'signing_key' set,  it raises an error.

    >>> cprov.archive.signing_key = None

    >>> archive_signing_key.signRepository(test_suite)
    Traceback (most recent call last):
    ...
    AssertionError: No signing key available for PPA for Celso Providelo

We'll purge 'signing_keys_root' and the PPA repository root so that
other tests don't choke on it.

    >>> import shutil
    >>> shutil.rmtree(config.personalpackagearchive.signing_keys_root)
    >>> shutil.rmtree(config.personalpackagearchive.root)

Let's shut zeca down.

    >>> z.tearDown()
