= Searching BugTasks =

BugTasks are usually searched through an IBugTarget's searchTasks()
method, but they all delegate the search to IBugTaskSet.search(). That
method accepts a single parameter; an BugTaskSearchParams instance.

    >>> from canonical.launchpad.interfaces import (
    ...     BugTaskSearchParams, IBugTaskSet)
    >>> bugtask_set = getUtility(IBugTaskSet)
    >>> all_public = BugTaskSearchParams(user=None)
    >>> found_bugtasks = bugtask_set.search(all_public)

    >>> from canonical.launchpad.database import BugTask
    >>> all_public_bugtasks = BugTask.select(
    ...     "BugTask.bug = Bug.id AND Bug.private = false",
    ...     clauseTables=['Bug'])
    >>> found_bugtasks.count() == all_public_bugtasks.count()
    True


== Searching by bug contact ==

The 'bug_contact' parameter allows you to search bugtasks that a certain
person is responsible for. A person can be a bug contact for a product,
a distribution, or a distribution source package. No Privileges Person
isn't a bug contact, so no bugs are found for him:

    >>> from canonical.launchpad.interfaces import IPersonSet
    >>> no_priv = getUtility(IPersonSet).getByName('no-priv')
    >>> no_priv_bug_contact = BugTaskSearchParams(
    ...     user=None, bug_contact=no_priv)
    >>> found_bugtasks = bugtask_set.search(no_priv_bug_contact)
    >>> found_bugtasks.count()
    0


=== Product bug contact ===

Firefox has a few bugs:

    >>> from canonical.launchpad.interfaces import IProductSet
    >>> firefox = getUtility(IProductSet).getByName('firefox')
    >>> firefox_bugs = firefox.searchTasks(all_public)
    >>> firefox_bugs.count() > 0
    True

If No Privileges is specified as Firefox' bug contact, searching for his
bugs return all of Firefox' bugs.

    >>> login('foo.bar@canonical.com')
    >>> from canonical.launchpad.ftests import syncUpdate
    >>> firefox.bugcontact = no_priv
    >>> syncUpdate(firefox)

    >>> found_bugtasks = bugtask_set.search(no_priv_bug_contact)
    >>> found_bugtasks.count() == firefox_bugs.count()
    True

    >>> found_targets = set(
    ...     bugtask.target.bugtargetdisplayname for bugtask in found_bugtasks)
    >>> for target_name in sorted(found_targets):
    ...     print target_name
    Mozilla Firefox


=== Package bug contact ===

Firefox in Ubuntu also has a few bugs:

    >>> from canonical.launchpad.interfaces import (
    ...     IDistributionSet, IDistributionSourcePackage)
    >>> ubuntu = getUtility(IDistributionSet).getByName("ubuntu")
    >>> ubuntu_firefox = ubuntu.getSourcePackage("mozilla-firefox")
    >>> all_public = BugTaskSearchParams(user=None)
    >>> ubuntu_firefox_bugs = ubuntu_firefox.searchTasks(all_public)
    >>> ubuntu_firefox_bugs.count() > 0
    True

If No Privileges Person is added as a bug contact for this package,
searching for his bugs returns all bugs in this package, as well as the
previous bugs (since he is also a bug contact for the Firefox product).

    >>> ubuntu_firefox.addBugContact(no_priv)
    >>> found_bugtasks = bugtask_set.search(no_priv_bug_contact)
    >>> found_bugtasks.count() == (
    ...     firefox_bugs.count() + ubuntu_firefox_bugs.count())
    True

    >>> found_targets = set(
    ...     bugtask.target.bugtargetdisplayname for bugtask in found_bugtasks)
    >>> for target_name in sorted(found_targets):
    ...     print target_name
    Mozilla Firefox
    mozilla-firefox (Ubuntu)


=== Distribution bug contact ===

If someone is bug contact for Firefox, Firefox in Ubuntu, and Ubuntu,
all bugs in Firefox and Ubuntu are returned. Bugs in the Ubuntu Firefox
package are included in the Ubuntu bugs, so they won't be returned
twice.

    >>> all_public = BugTaskSearchParams(user=None)
    >>> ubuntu_bugs = ubuntu.searchTasks(all_public)
    >>> ubuntu_bugs.count() > 0
    True

    >>> ubuntu.bugcontact = no_priv
    >>> syncUpdate(ubuntu)
    >>> found_bugtasks = bugtask_set.search(no_priv_bug_contact)
    >>> found_bugtasks.count() == firefox_bugs.count() + ubuntu_bugs.count()
    True


== Searching in comments ==

By default, comments are also searched when specifying a search text.
For example, no Firefox bugs are found when searching for
'wordincomment'.

    >>> comment_search = BugTaskSearchParams(
    ...     user=None, searchtext='wordincomment')
    >>> found_bugtasks = firefox.searchTasks(comment_search)
    >>> found_bugtasks.count()
    0

If we add a comment containg the the search string to bug one, that bug
will be returned by the search.

    >>> from canonical.launchpad.interfaces import IBugSet
    >>> bug_one = getUtility(IBugSet).get(1)
    >>> bug_one.newMessage(no_priv, 'No subject', 'some wordincomment')
    <Message at ...>

    # Add another comment to make sure that it won't cause the same
    # bugtask to be returned twice.
    >>> bug_one.newMessage(no_priv, 'No subject', 'another wordincomment')
    <Message at ...>

    >>> found_bugtasks = firefox.searchTasks(comment_search)
    >>> for bugtask in found_bugtasks:
    ...     print "#%s" % bugtask.bug.id
    #1

    # Of course, searching in a project not containing bug #1 doesn't
    # return any matches.
    >>> evolution = getUtility(IProductSet).getByName('evolution')
    >>> found_bugtasks = evolution.searchTasks(comment_search)
    >>> found_bugtasks.count()
    0


== Searching using bug full-text index ==

The searchtext parameter does an extensive and expensive search (it
looks through the bug's full text index, bug comments, bugtask
target name, etc.) For some use cases, it is often easier and cheaper
to simply search on the bug's full text index and omit the more
expensive search on other related information.

For example, there are no bugs with the word 'Fnord' in Firefox.

    >>> text_search = BugTaskSearchParams(user=None, fast_searchtext='Fnord')
    >>> found_bugtasks = firefox.searchTasks(text_search)
    >>> found_bugtasks.count()
    0

But if we put that word in the bug #4 description, it will be found.

    >>> bug_four = getUtility(IBugSet).get(4)
    >>> bug_four.description += (
    ...     '\nThat happens pretty often with the Fnord Highlighter '
    ...     'extension installed.')
    >>> syncUpdate(bug_four)

    >>> found_bugtasks = firefox.searchTasks(text_search)
    >>> for bugtask in found_bugtasks:
    ...     print "#%s" % bugtask.bug.id
    #4


== Searching by bug reporter ==

The 'bug_reporter' parameter allows you to search for bugs reported by a
certain person.

    >>> foo_bar = getUtility(IPersonSet).getByEmail('foo.bar@canonical.com')
    >>> reported_by_foo_bar = BugTaskSearchParams(
    ...     user=None, bug_reporter=foo_bar)
    >>> reported_by_foo_bar.setDistribution(ubuntu)
    >>> found_bugtasks = bugtask_set.search(reported_by_foo_bar)
    >>> for bugtask in found_bugtasks:
    ...     print "#%s in %s reported by %s" % (
    ...         bugtask.bug.id, bugtask.bugtargetname,
    ...         bugtask.bug.owner.displayname)
    #9 in thunderbird (Ubuntu) reported by Foo Bar
    #10 in linux-source-2.6.15 (Ubuntu) reported by Foo Bar


== Searching for nominated bugs ==

We can search for bugs nominated to a distribution series by using the
nominated_for parameter.

    >>> ubuntu = getUtility(IDistributionSet).getByName('ubuntu')
    >>> warty = ubuntu.getSeries('warty')

    >>> from canonical.launchpad.database import BugNomination
    >>> print list(BugNomination.selectBy(distroseries=warty))
    []

    >>> from canonical.launchpad.interfaces import CreateBugParams
    >>> nominated_for_warty = BugTaskSearchParams(
    ...     user=None, nominated_for=warty)
    >>> list(ubuntu.searchTasks(nominated_for_warty))
    []

    >>> nominated_bug = ubuntu.createBug(
    ...     CreateBugParams(owner=no_priv, title='Test nominated bug',
    ...                     comment='Something'))
    >>> BugNomination(
    ...     owner=no_priv, distroseries=warty, bug=nominated_bug)
    <BugNomination at ...>

    >>> for bugtask in ubuntu.searchTasks(nominated_for_warty):
    ...     print bugtask.bug.title
    Test nominated bug

The same parameter is used to search for bugs nominated to a product
series.

    >>> firefox = getUtility(IProductSet).getByName('firefox')
    >>> firefox_trunk = firefox.getSeries('trunk')
    >>> print list(BugNomination.selectBy(productseries=firefox_trunk))
    []
    >>> nominated_for_trunk = BugTaskSearchParams(
    ...     user=None, nominated_for=firefox_trunk)
    >>> list(firefox.searchTasks(nominated_for_trunk))
    []

    >>> nominated_bug = firefox.createBug(
    ...     CreateBugParams(owner=no_priv, title='Bug to be fixed in trunk',
    ...                     comment='Something'))
    >>> BugNomination(
    ...     owner=no_priv, productseries=firefox_trunk, bug=nominated_bug)
    <BugNomination at ...>

    >>> for bugtask in firefox.searchTasks(nominated_for_trunk):
    ...     print bugtask.bug.title
    Bug to be fixed in trunk

== Filter by Upstream Status ==

Add an Ubuntu bugtask for a bug that is confirmed upstream.

    >>> from canonical.lp.dbschema import BugTaskImportance
    >>> from canonical.launchpad.interfaces import BugTaskStatus
    >>> from canonical.launchpad.ftests.test_bugtask import (
    ...     BugTaskSearchBugsElsewhereTest)
    >>> def bugTaskInfo(bugtask):
    ...     return '%i %i %s %s' % (
    ...         bugtask.id, bugtask.bug.id, bugtask.bugtargetdisplayname,
    ...         bugtask.bug.title)
    >>> test_helper = BugTaskSearchBugsElsewhereTest(helper_only=True)
    >>> bug_twelve =  getUtility(IBugSet).get(12)
    >>> task_open_upstream = bugtask_set.createTask(
    ...     bug=bug_twelve, distribution=ubuntu, owner=foo_bar,
    ...     status=BugTaskStatus.NEW,
    ...     importance=BugTaskImportance.MEDIUM)
    >>> test_helper.assertBugTaskIsOpenUpstream(task_open_upstream)

Pass the resolved_upstream flag to include only bugtasks linked to
watches that are rejected, fixed committed or fix released, or bugtasks
related to upstream bugtasks (i.e. filed on the same bug) that are fix
committed or fix released.

    >>> test_helper.setUpBugsResolvedUpstreamTests()
    >>> params = BugTaskSearchParams(
    ...     resolved_upstream=True, orderby='id', user=None)
    >>> closed_elsewhere_tasks = ubuntu.searchTasks(params)
    >>> for bugtask in closed_elsewhere_tasks:
    ...     test_helper.assertBugTaskIsResolvedUpstream(bugtask)
    ...     print bugTaskInfo(bugtask)
    17 1 mozilla-firefox (Ubuntu) Firefox does not support SVG
    26 2 Ubuntu Blackhole Trash folder
    23 9 thunderbird (Ubuntu) Thunderbird crashes


Pass the open_upstream flag to include only bugtasks linked to those
watches or those upstream bugtasks that have the status "unconfirmed",
"needs info", "confirmed", "in progress" or "unknown". Note that a bug
may be associated with three or more bugtasks. If one upstream task
has a state associated with "open upstream", and another upstream task
has a state associated with "resolved upstream", the bug is included
in the results of the "open upstream" filter as well as the "resolved
upstream" filter.

    >>> params = BugTaskSearchParams(
    ...     open_upstream=True, orderby='id', user=None)
    >>> open_elsewhere_tasks = ubuntu.searchTasks(params)
    >>> for bugtask in open_elsewhere_tasks:
    ...     test_helper.assertBugTaskIsOpenUpstream(bugtask)
    ...     print bugTaskInfo(bugtask)
    17  1 mozilla-firefox (Ubuntu) Firefox does not support SVG
    26  2 Ubuntu Blackhole Trash folder
    34 12 Ubuntu Copy, Cut and Delete operations should work on selections


We can also filter our search to include only bugs that are not known to
affect upstream, i.e., bugs that don't have an IUpstreamBugTask.

    >>> params = BugTaskSearchParams(
    ...     has_no_upstream_bugtask=True, orderby='id', user=None)
    >>> tasks_with_no_upstreams = ubuntu.searchTasks(params)
    >>> for bugtask in tasks_with_no_upstreams:
    ...     test_helper.assertShouldBeShownOnNoUpstreamTaskSearch(bugtask)
    ...     print bugTaskInfo(bugtask)
    25 10 linux-source-2.6.15 (Ubuntu) another test bug
    32 13 Ubuntu Test nominated bug

If we combine upstream-related filters, we get the union of the results
of the single filters.

    >>> params = BugTaskSearchParams(
    ...     has_no_upstream_bugtask=True, resolved_upstream=True,
    ...     orderby='id', user=None)
    >>> tasks_with_no_upstreams = ubuntu.searchTasks(params)
    >>> for bugtask in tasks_with_no_upstreams:
    ...     print bugTaskInfo(bugtask)
    17  1 mozilla-firefox (Ubuntu) Firefox does not support SVG
    26  2 Ubuntu Blackhole Trash folder
    23  9 thunderbird (Ubuntu) Thunderbird crashes
    25 10 linux-source-2.6.15 (Ubuntu) another test bug
    32 13 Ubuntu Test nominated bug


    >>> test_helper.tearDownBugsElsewhereTests()

The search filter can also return bugs that are related to CVE reports:

    >>> from canonical.launchpad.interfaces import ICveSet
    >>> def getCves(bugtask):
    ...     bugcve = getUtility(ICveSet).getBugCvesForBugTasks([bugtask])[0]
    ...     return bugcve.cve.sequence
    >>> params = BugTaskSearchParams(
    ...     has_cve=True, orderby='id', user=None)
    >>> tasks_with_cves = ubuntu.searchTasks(params)
    >>> for bugtask in tasks_with_cves:
    ...     print bugTaskInfo(bugtask), getCves(bugtask)
    17 1 mozilla-firefox (Ubuntu) Firefox does not support SVG 1999-8979
    26 2 Ubuntu Blackhole Trash folder 1999-2345


== Searching by bug commenter ==

The 'bug_commenter' parameter allows you to search bugtasks on which a certain
person has commented. No Privileges Person hasn't commented on any bugs, so no
bugs are found for him:

    >>> from canonical.launchpad.interfaces import IPersonSet
    >>> import transaction
    >>> transaction.abort()

    >>> no_priv = getUtility(IPersonSet).getByName('no-priv')
    >>> no_priv_bug_commenter = BugTaskSearchParams(
    ...     user=None, bug_commenter=no_priv)
    >>> found_bugtasks = bugtask_set.search(no_priv_bug_commenter)
    >>> found_bugtasks.count()
    0

If No Privileges Person comments on some bugs, those bugs can then be found by
a bug commenter search. There will be one bug task instance returned for each
bug target that the task is registered against, so in the test below three
comments will produce eight found bug tasks (three for bug 1, five for bug 2).

    >>> bug_one = getUtility(IBugSet).get(1)
    >>> bug_one.newMessage(no_priv, 'No subject', 'some comment')
    <Message at ...>

    >>> bug_two = getUtility(IBugSet).get(2)
    >>> bug_two.newMessage(no_priv, 'No subject', 'another comment')
    <Message at ...>

    >>> bug_two.newMessage(no_priv, 'No subject', 'yet another comment')
    <Message at ...>

    >>> for (bug_id, target) in sorted((bugtask.bug.id, bugtask.bugtargetname)
    ...                                for bugtask in found_bugtasks):
    ...     print bug_id, target
    1 firefox
    1 mozilla-firefox (Debian)
    1 mozilla-firefox (Ubuntu)
    2 Ubuntu Hoary
    2 mozilla-firefox (Debian Woody)
    2 mozilla-firefox (Debian)
    2 tomcat
    2 ubuntu

If No Privileges Person reports a bug and does not comment on it, that bug
will not be included in the results returned by the bug commenter search.

    >>> from canonical.launchpad.interfaces import CreateBugParams
    >>> from canonical.launchpad.interfaces import IProductSet

    >>> firefox = getUtility(IProductSet).getByName('firefox')
    >>> firefox.createBug(
    ...     CreateBugParams(no_priv, "Some bug", "Some comment"))
    <Bug at ...>

    >>> for (bug_id, target) in sorted((bugtask.bug.id, bugtask.bugtargetname)
    ...                                for bugtask in found_bugtasks):
    ...     print bug_id, target
    1 firefox
    1 mozilla-firefox (Debian)
    1 mozilla-firefox (Ubuntu)
    2 Ubuntu Hoary
    2 mozilla-firefox (Debian Woody)
    2 mozilla-firefox (Debian)
    2 tomcat
    2 ubuntu


== Searching incomplete bugs ==

Bugs marked `Incomplete` can be searched using special pseudo-statuses,
`Incomplete (without response)` (bugs that have been marked incomplete
and have no new comments since then) and `Incomplete (with response)`
(incomplete bugs with new information in the form of comments).

    >>> from canonical.launchpad.interfaces import BugTaskStatusSearch
    >>> import transaction
    >>> incomplete_params = BugTaskSearchParams(
    ...     user=None, status=BugTaskStatus.INCOMPLETE)
    >>> firefox.searchTasks(incomplete_params).count()
    0

We create a new bug in the firefox product and set its status to `Incomplete`.

    >>> incomplete_bug = firefox.createBug(CreateBugParams(
    ...     owner=no_priv, title='An incomplete bug',
    ...     comment='not enough info'))
    >>> incomplete_bugtask = incomplete_bug.setStatus(
    ...     firefox, BugTaskStatus.INCOMPLETE, no_priv)

We flush and commit, so that we can search the database.

    >>> flush_database_updates()
    >>> transaction.commit()

Searching for incomplete bugs in firefox now returns 1 bug.

    >>> firefox.searchTasks(incomplete_params).count()
    1

Since no new information was supplied (in a comment) since we marked the
bug `Incomplete`, searching for `Incomplete (without response)` in the
firefox product should return the same lonely bug. Searching for
`Incomplete (with response)` bugs shuold return no bugs at all.

    >>> incomplete_without_response_params = BugTaskSearchParams(
    ...     user=None, status=BugTaskStatusSearch.INCOMPLETE_WITHOUT_RESPONSE)
    >>> firefox.searchTasks(incomplete_without_response_params).count()
    1
    >>> incomplete_with_response_params = BugTaskSearchParams(
    ...     user=None, status=BugTaskStatusSearch.INCOMPLETE_WITH_RESPONSE)
    >>> firefox.searchTasks(incomplete_with_response_params).count()
    0

We create a new comment for the bug.

    >>> message = incomplete_bug.newMessage(no_priv, 'No subject', 'more info')
    >>> flush_database_updates()
    >>> transaction.commit()

Now searching for `Incomplete (with response)` should return this bug.

    >>> firefox.searchTasks(incomplete_with_response_params).count()
    1

And searching for `Incomplete (without response)` should return nothing.

    >>> firefox.searchTasks(incomplete_without_response_params).count()
    0


== Search for BugTasks assigned to milestones ==

BugTaskSet.search() can return bugtasks associated with milestones. 
No BugTask is associated yet with firefox milestone 1.0.

    >>> product_milestone = firefox.getMilestone('1.0')
    >>> params = BugTaskSearchParams(milestone=product_milestone, user=None)
    >>> milestone_tasks = bugtask_set.search(params)
    >>> print milestone_tasks.count()
    0

Similary, no BugTasks are associated with the project firexfox belongs to.

    >>> mozilla = firefox.project
    >>> project_milestone = mozilla.getMilestone('1.0')
    >>> params = BugTaskSearchParams(milestone=project_milestone, user=None)
    >>> milestone_tasks = bugtask_set.search(params)
    >>> print milestone_tasks.count()
    0

When a BugTask is associated with a milestone, it is returned in a search
for bugs of this milestone.

    >>> bugtask = firefox.searchTasks(BugTaskSearchParams(user=None))[0]
    >>> print bugTaskInfo(bugtask)
    2 1 Mozilla Firefox Firefox does not support SVG
    >>> bugtask.milestone = product_milestone
    >>> syncUpdate(bugtask)
    >>> params = BugTaskSearchParams(milestone=product_milestone, user=None)
    >>> milestone_tasks = bugtask_set.search(params)
    >>> for bugtask in milestone_tasks:
    ...     print bugTaskInfo(bugtask)
    2 1 Mozilla Firefox Firefox does not support SVG

This BugTask is also a BugTask of the milestone of the mozilla project.

    >>> params = BugTaskSearchParams(milestone=project_milestone, user=None)
    >>> milestone_tasks = bugtask_set.search(params)
    >>> for bugtask in milestone_tasks:
    ...     print bugTaskInfo(bugtask)
    2 1 Mozilla Firefox Firefox does not support SVG
