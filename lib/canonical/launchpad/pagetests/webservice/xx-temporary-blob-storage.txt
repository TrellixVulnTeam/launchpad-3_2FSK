The set of temporary blobs
==========================

The set of temporary blobs in Launchpad is represented by the collection
found at /temporary-blobs. The collection contains all the temporary
blobs whose file aliases have not expired.

    >>> temporary_blobs = webservice.get('/temporary-blobs').jsonBody()
    >>> len(temporary_blobs['entries'])
    0

If we add a new blob, it will show up in the temporary_blobs entries
set.

    >>> login('foo.bar@canonical.com')
    >>> import os
    >>> from zope.component import getUtility
    >>> from canonical.config import config
    >>> from canonical.launchpad.interfaces.temporaryblobstorage import (
    ...     ITemporaryStorageManager)

    >>> testfiles = os.path.join(config.root,
    ...     'lib/lp/bugs/tests/testfiles')
    >>> blob_file = open(
    ...     os.path.join(testfiles, 'extra_filebug_data.msg'))
    >>> blob_data = blob_file.read()
    >>> print blob_data[307:373]
    --boundary
    Content-disposition: attachment; filename='attachment1'

    >>> blob_token = getUtility(ITemporaryStorageManager).new(blob_data)

    >>> logout()

    >>> temporary_blobs = webservice.get('/temporary-blobs').jsonBody()
    >>> len(temporary_blobs['entries'])
    1

Each of the entries in the temporary_blobs entries set is an
ITemporaryBlobStorage instance. A blob is identified by its UUID, which
is exported via the webservice as 'token', in keeping with how it's
referred to in the UI.

    >>> blob = temporary_blobs['entries'][0]
    >>> blob['token'] == blob_token
    True

It's possible to fetch a blob directly using its token.

    >>> blob_link = '/temporary-blobs/' + blob_token
    >>> blob = webservice.get(blob_link).jsonBody()
    >>> blob['token'] == blob_token
    True

It's also possible to fetch the blob by calling temporary_blobs.fetch()
and passing it a token.

    >>> blob = webservice.named_get(
    ...     '/temporary-blobs', 'fetch', token=blob_token).jsonBody()
    >>> blob['token'] == blob_token
    True

Checking whether a blob has been processed
------------------------------------------

Launchpad processes blobs after they've been uploaded, so that any data
that can be used whilst filing a bug (or in any other operation,
ostensibly) can be extracted from the blob without affecting the
processing time of web requests.

It's possible to see whether a blob has been processed by calling its
hasBeenProcessed() method. In the case of the blob we created above, it
hasn't been processed because no job was created to process it.

    >>> print webservice.named_get(
    ...     blob['self_link'], 'hasBeenProcessed').jsonBody()
    False

However, since the blob has not been processed there will be no
job status or processed data at this point.

    >>> print webservice.named_get(
    ...     blob['self_link'], 'getJobStatus').jsonBody()
    None

    >>> print webservice.named_get(
    ...     blob['self_link'], 'getProcessedData').jsonBody()
    None

Once the blob has been processed, its hasBeenProcessed() method will
return True.

    >>> from lp.bugs.interfaces.apportjob import IProcessApportBlobJobSource
    >>> login('foo.bar@canonical.com')
    >>> job = getUtility(IProcessApportBlobJobSource).create(
    ...     getUtility(ITemporaryStorageManager).fetch(blob_token))
    >>> job.job.start()
    >>> job.job.complete()
    >>> job.run()
    >>> logout()

    >>> print webservice.named_get(
    ...     blob['self_link'], 'hasBeenProcessed').jsonBody()
    True

The job status now shows additional details about the job completion.

    >>> job_status = webservice.named_get(
    ...     blob['self_link'], 'getJobStatus').jsonBody()
    >>> print job_status['status']
    Completed

    >>> print job_status['attempt_count']
    1

    >>> print job_status['apport_job_id']
    1
    
    >>> print job_status['apport_job_type']
    Process a BLOB and extract salient data from it.

And at this point the blob's parsed-out metadata is now accessible.

    >>> metadata = webservice.named_get(
    ...     blob['self_link'], 'getProcessedData').jsonBody()

    >>> print metadata['extra_description']
    This should be added to the description.

    >>> print len(metadata['comments'])
    2

    >>> attachment = metadata['attachments'][0]
    >>> print attachment['description']
    attachment1
