= ExternalBugTracker: RT =

This covers the implementation of an ExternalBugTracker class for RT
instances.


== Basics ==

When importing bugs from remote RT instances, we use an RT-specific
implementation of ExternalBugTracker, RequestTracker.

    >>> from canonical.launchpad.components.externalbugtracker import (
    ...     RequestTracker)
    >>> from canonical.launchpad.interfaces import (
    ...     BugTrackerType, IExternalBugTracker)
    >>> from canonical.launchpad.ftests.externalbugtracker import (
    ...     new_bugtracker)
    >>> from canonical.launchpad.webapp.testing import verifyObject
    >>> verifyObject(
    ...     IExternalBugTracker,
    ...     RequestTracker('http://example.com/'))
    True

The RequestTracker class offers an _opener property, an instance of
urllib2.OpenerDirector which will handle cookies and so allow the
RequestTracker instance to work correctly with RT cookies.

We can demonstrate this by creating a test class which contains a stub
method for RequestTracker._logIn().

    >>> class NoLogInRequestTracker(RequestTracker):
    ...     def _logIn(self, opener):
    ...         """This method does nothing but say it's been called."""
    ...         print "_logIn() has been called."

    >>> request_tracker = NoLogInRequestTracker('http://example.com/')
    >>> request_tracker._opener
    _logIn() has been called.
    <urllib2.OpenerDirector...>


== Status Conversion ==

The RequestTracker class can convert the default RT ticket statuses into
Launchpad statuses:

    >>> rt = RequestTracker('http://example.com/')
    >>> rt.convertRemoteStatus('new').title
    'New'
    >>> rt.convertRemoteStatus('open').title
    'Confirmed'
    >>> rt.convertRemoteStatus('stalled').title
    'Confirmed'
    >>> rt.convertRemoteStatus('rejected').title
    'Invalid'
    >>> rt.convertRemoteStatus('resolved').title
    'Fix Released'

Passing a status which the RequestTracker instance can't understand will
result in an UnknownRemoteStatusError being raised.

    >>> rt.convertRemoteStatus('spam').title
    Traceback (most recent call last):
      ...
    UnknownRemoteStatusError


== Initialisation ==

Calling initializeRemoteBugDB() on our RequestTracker instance and
passing it a set of remote bug IDs will fetch those bug IDs from the
server and file them in a local variable for later use.

We use a test-oriented implementation of RequestTracker for the purposes
of these tests, which allows us to not rely on a working network
connection.

    >>> from canonical.launchpad.ftests.externalbugtracker import (
    ...     TestRequestTracker)
    >>> rt = TestRequestTracker('http://example.com/')
    >>> rt.initializeRemoteBugDB([1585, 1586, 1587, 1588, 1589])
    >>> sorted(rt.bugs.keys())
    [1585, 1586, 1587, 1588, 1589]


== Export Methods ==

There are two means by which we can export RT bug statuses: on a
bug-by-bug basis and as a batch. When the number of bugs that need
updating is less than a given bug RT instances's batch_query_threshold
the bugs will be fetched one-at-a-time:

    >>> rt.batch_query_threshold
    1

    >>> rt.trace_calls = True
    >>> rt.initializeRemoteBugDB([1585])
    CALLED urlopen('REST/1.0/ticket/1585/show')

    >>> rt.bugs.keys()
    [1585]

If there are more than batch_query_threshold bugs to update then they are
fetched as a batch:

    >>> rt.initializeRemoteBugDB([1585, 1586, 1587, 1588, 1589])
    CALLED urlopen('REST/1.0/search/ticket/')

    >>> sorted(rt.bugs.keys())
    [1585, 1586, 1587, 1588, 1589]

If something goes wrong when we request a bug from the remote server a
BugTrackerConnectError will be raised. We can demonstrate this by making
our test RT instance simulate such a situation.

    >>> rt.simulate_bad_response = True
    >>> rt.initializeRemoteBugDB([1585])
    Traceback (most recent call last):
      ...
    BugTrackerConnectError...

This can also be demonstrated for importing bugs as a batch:

    >>> rt.initializeRemoteBugDB([1585, 1586, 1587, 1588, 1589])
    Traceback (most recent call last):
      ...
    BugTrackerConnectError...
    >>> rt.simulate_bad_response = False

== Updating Bug Watches ==

First, we create some bug watches to test with. Example.com hosts an RT
instance which has several bugs that we wish to watch:

    >>> from canonical.launchpad.interfaces import (
    ...     IBugSet, IBugWatchSet, IPersonSet)
    >>> from canonical.launchpad.ftests.externalbugtracker import (
    ...     print_bugwatches)

Launchpad.dev bug #10 is the same bug as reported in example.com bug
#1585, so we add a watch against the remote bug.

    >>> example_bug_tracker = new_bugtracker(BugTrackerType.RT)
    >>> example_bug = getUtility(IBugSet).get(10)
    >>> sample_person = getUtility(IPersonSet).getByEmail(
    ...     'test@canonical.com')
    >>> example_bugwatch = example_bug.addWatch(
    ...     example_bug_tracker, '1585', sample_person)

    >>> print_bugwatches(example_bug_tracker.watches)
    Remote bug 1585: None

Our RequestTracker ExternalBugTracker can now process, and retrieve a
remote status for, the bug watch that we have created.

    >>> from canonical.launchpad.scripts.checkwatches import BugWatchUpdater
    >>> from canonical.testing import LaunchpadZopelessLayer
    >>> txn = LaunchpadZopelessLayer.txn
    >>> bug_watch_updater = BugWatchUpdater(txn)
    >>> rt = TestRequestTracker(example_bug_tracker.baseurl)
    >>> bug_watch_updater.updateBugWatches(rt, example_bug_tracker.watches)
    INFO:...:Updating 1 watches on http://bugs.some.where

    >>> print_bugwatches(example_bug_tracker.watches)
    Remote bug 1585: new

We now add some more watches against remote bugs in the example.com bug
tracker with a variety of statuses.

    >>> from canonical.launchpad.interfaces import IBugSet, IBugWatchSet
    >>> print_bugwatches(example_bug_tracker.watches,
    ...     rt.convertRemoteStatus)
    Remote bug 1585: New

    >>> remote_bugs = [
    ...     1586,
    ...     1587,
    ...     1588,
    ...     1589,
    ... ]

    >>> bug_watch_set = getUtility(IBugWatchSet)
    >>> for remote_bug_id in remote_bugs:
    ...     bug_watch = bug_watch_set.createBugWatch(
    ...         bug=example_bug, owner=sample_person,
    ...         bugtracker=example_bug_tracker,
    ...         remotebug=str(remote_bug_id))

    >>> rt.trace_calls = True
    >>> bug_watch_updater.updateBugWatches(rt, example_bug_tracker.watches)
    INFO:...:Updating 5 watches on http://bugs.some.where
    CALLED urlopen(u'REST/1.0/search/ticket/')

The bug statuses have now been imported from the Example.com bug
tracker, so the bug watches should now have valid Launchpad bug
statuses:

    >>> print_bugwatches(example_bug_tracker.watches,
    ...     rt.convertRemoteStatus)
    Remote bug 1585: New
    Remote bug 1586: Confirmed
    Remote bug 1587: Confirmed
    Remote bug 1588: Fix Released
    Remote bug 1589: Invalid
