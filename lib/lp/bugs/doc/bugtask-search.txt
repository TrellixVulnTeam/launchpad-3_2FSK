= Searching BugTasks =

BugTasks are usually searched through an IBugTarget's searchTasks()
method, but they all delegate the search to IBugTaskSet.search(). That
method accepts a single parameter; an BugTaskSearchParams instance.

    >>> from lp.bugs.interfaces.bugtask import IBugTaskSet
    >>> from lp.bugs.interfaces.bugtasksearch import BugTaskSearchParams
    >>> bugtask_set = getUtility(IBugTaskSet)
    >>> all_public = BugTaskSearchParams(user=None)
    >>> found_bugtasks = bugtask_set.search(all_public)

    >>> from lp.bugs.model.bugtask import BugTask
    >>> all_public_bugtasks = BugTask.select(
    ...     "BugTask.bug = Bug.id AND Bug.information_type IN (1, 2)",
    ...     clauseTables=['Bug'])
    >>> found_bugtasks.count() == all_public_bugtasks.count()
    True


== Searching by bug supervisor ==

The 'bug_supervisor' parameter allows you to search bugtasks that a certain
person is responsible for. A person can be a bug supervisor for a product,
a distribution, or a distribution source package. No Privileges Person
isn't a bug supervisor, so no bugs are found for him:

    >>> from lp.registry.interfaces.person import IPersonSet
    >>> no_priv = getUtility(IPersonSet).getByName('no-priv')
    >>> no_priv_bug_supervisor = BugTaskSearchParams(
    ...     user=None, bug_supervisor=no_priv)
    >>> found_bugtasks = bugtask_set.search(no_priv_bug_supervisor)
    >>> found_bugtasks.count()
    0

== Product bugs ==

Firefox has a few bugs:

    >>> from lp.registry.interfaces.product import IProductSet
    >>> firefox = getUtility(IProductSet).getByName('firefox')
    >>> firefox_bugs = firefox.searchTasks(all_public)
    >>> firefox_public_bugs = firefox_bugs.count()
    >>> firefox_public_bugs > 0
    True

== Distribution and package bugs ==

Ubuntu does too:

    >>> from lp.registry.interfaces.distribution import IDistributionSet
    >>> ubuntu = getUtility(IDistributionSet).getByName("ubuntu")
    >>> all_public = BugTaskSearchParams(user=None)
    >>> ubuntu_bugs = ubuntu.searchTasks(all_public)
    >>> ubuntu_bugs.count() > 0
    True

and in particular, mozilla-firefox in Ubuntu has 'em:

    >>> ubuntu_firefox = ubuntu.getSourcePackage("mozilla-firefox")
    >>> ubuntu_firefox_bugs = ubuntu_firefox.searchTasks(all_public)
    >>> ubuntu_firefox_bugs.count() > 0
    True

== Person bugs ==

To get all related tasks to a person call searchTasks() on the person
object:

    >>> from lp.registry.interfaces.person import IPersonSet
    >>> user = getUtility(IPersonSet).getByName('name16')
    >>> user_bugs = user.searchTasks(None, user=None)
    >>> user_bugs.count() > 0
    True

== Dupes and Conjoined tasks ==

You can set flags to omit duplicates:

    >>> no_dupes = BugTaskSearchParams(user=None, omit_dupes=True)
    >>> firefox = getUtility(IProductSet).getByName('firefox')
    >>> sans_dupes = firefox.searchTasks(no_dupes)
    >>> sans_dupes.count() < firefox_public_bugs
    True

and also series-targeted bugs:

    >>> no_targeted = BugTaskSearchParams(user=None, omit_targeted=True)
    >>> sans_targeted = ubuntu.searchTasks(no_targeted)
    >>> sans_targeted.count() < ubuntu_bugs
    True

=== Product bug supervisor ===

If No Privileges is specified as Firefox's bug supervisor, searching for his
bugs return all of Firefox's bugs.

    >>> login('foo.bar@canonical.com')
    >>> firefox.bug_supervisor = no_priv

    >>> found_bugtasks = bugtask_set.search(no_priv_bug_supervisor)
    >>> found_bugtasks.count() == firefox_bugs.count()
    True

    >>> found_targets = set(
    ...     bugtask.target.bugtargetdisplayname for bugtask in found_bugtasks)
    >>> for target_name in sorted(found_targets):
    ...     print target_name
    Mozilla Firefox


=== Distribution bug supervisor ===

If someone is bug supervisor for Firefox, Firefox in Ubuntu, and Ubuntu,
all bugs in Firefox and Ubuntu are returned. Bugs in the Ubuntu Firefox
package are included in the Ubuntu bugs, so they won't be returned
twice.

    >>> all_public = BugTaskSearchParams(user=None)
    >>> ubuntu_bugs = ubuntu.searchTasks(all_public)
    >>> ubuntu_bugs.count() > 0
    True

    >>> ubuntu.bug_supervisor = no_priv
    >>> found_bugtasks = bugtask_set.search(no_priv_bug_supervisor)
    >>> found_bugtasks.count() == firefox_bugs.count() + ubuntu_bugs.count()
    True

== Searching using bug full-text index ==

The searchtext parameter does an extensive and expensive search (it
looks through the bug's full text index, bug comments, bugtask
target name, etc.) For some use cases, it is often easier and cheaper
to simply search on the bug's full text index and omit the more
expensive search on other related information.

For example, there are no bugs with the word 'Fnord' in Firefox.

    >>> text_search = BugTaskSearchParams(user=None, searchtext=u'Fnord')
    >>> found_bugtasks = firefox.searchTasks(text_search)
    >>> found_bugtasks.count()
    0

But if we put that word in the bug #4 description, it will be found.

    >>> from lp.bugs.interfaces.bug import IBugSet
    >>> bug_four = getUtility(IBugSet).get(4)
    >>> bug_four.description += (
    ...     '\nThat happens pretty often with the Fnord Highlighter '
    ...     'extension installed.')

    >>> found_bugtasks = firefox.searchTasks(text_search)
    >>> for bugtask in found_bugtasks:
    ...     print "#%s" % bugtask.bug.id
    #4

=== BugTaskSearchParams' parameters searchtext and fast_searchtext ===

Normally, the parameter searchtext should be used. The alternative
parameter fast_searchtext requires a syntactically correct tsquery
expression containing stemmed words.

A simple phrase can be passed as searchtext, but not as fast_searchtext,
see below.

    >>> good_search = BugTaskSearchParams(
    ...     user=None, searchtext=u'happens pretty often')
    >>> found_bugtasks = firefox.searchTasks(good_search)
    >>> for bugtask in found_bugtasks:
    ...     print "#%s" % bugtask.bug.id
    #4

The unstemmed word "happens" does not yield any results when used
as fast_textsearch.

    >>> bad_search = BugTaskSearchParams(
    ...     user=None, fast_searchtext=u'happens')
    >>> found_bugtasks = firefox.searchTasks(bad_search)
    >>> print found_bugtasks.count()
    0

If the stem of "happens" is used, we get results.

    >>> good_search = BugTaskSearchParams(
    ...     user=None, fast_searchtext=u'happen')
    >>> found_bugtasks = firefox.searchTasks(good_search)
    >>> for bugtask in found_bugtasks:
    ...     print "#%s" % bugtask.bug.id
    #4
    #6

Stemmed words may be combined into a valid tsquery expression.

    >>> good_search = BugTaskSearchParams(
    ...     user=None, fast_searchtext=u'happen&pretti&often')
    >>> found_bugtasks = firefox.searchTasks(good_search)
    >>> for bugtask in found_bugtasks:
    ...     print "#%s" % bugtask.bug.id
    #4

Passing invalid tsquery expressions as fast_searchtext raises an exception.

    >>> bad_search = BugTaskSearchParams(
    ...     user=None, fast_searchtext=u'happens pretty often')
    >>> list(firefox.searchTasks(bad_search))
    Traceback (most recent call last):
    ...
    ProgrammingError: syntax error in tsquery: "happens pretty often"
    ...

    >>> import transaction
    >>> transaction.abort()


== Searching by bug reporter ==

The 'bug_reporter' parameter allows you to search for bugs reported by a
certain person.

    >>> foo_bar = getUtility(IPersonSet).getByEmail('foo.bar@canonical.com')
    >>> reported_by_foo_bar = BugTaskSearchParams(
    ...     user=None, bug_reporter=foo_bar)
    >>> reported_by_foo_bar.setDistribution(ubuntu)
    >>> found_bugtasks = bugtask_set.search(reported_by_foo_bar)
    >>> for bugtask in found_bugtasks:
    ...     print "#%s in %s reported by %s" % (
    ...         bugtask.bug.id, bugtask.bugtargetname,
    ...         bugtask.bug.owner.displayname)
    #9 in thunderbird (Ubuntu) reported by Foo Bar
    #10 in linux-source-2.6.15 (Ubuntu) reported by Foo Bar


== Searching for nominated bugs ==

We can search for bugs nominated to a distribution series by using the
nominated_for parameter.

    >>> ubuntu = getUtility(IDistributionSet).getByName('ubuntu')
    >>> warty = ubuntu.getSeries('warty')

    >>> from lp.bugs.model.bugnomination import BugNomination
    >>> print list(BugNomination.selectBy(distroseries=warty))
    []

    >>> from lp.bugs.interfaces.bug import CreateBugParams
    >>> nominated_for_warty = BugTaskSearchParams(
    ...     user=None, nominated_for=warty)
    >>> list(ubuntu.searchTasks(nominated_for_warty))
    []

    >>> nominated_bug = ubuntu.createBug(
    ...     CreateBugParams(owner=no_priv, title='Test nominated bug',
    ...                     comment='Something'))
    >>> BugNomination(
    ...     owner=no_priv, distroseries=warty, bug=nominated_bug)
    <BugNomination at ...>

    >>> for bugtask in ubuntu.searchTasks(nominated_for_warty):
    ...     print bugtask.bug.title
    Test nominated bug

The same parameter is used to search for bugs nominated to a product
series.

    >>> firefox = getUtility(IProductSet).getByName('firefox')
    >>> firefox_trunk = firefox.getSeries('trunk')
    >>> print list(BugNomination.selectBy(productseries=firefox_trunk))
    []
    >>> nominated_for_trunk = BugTaskSearchParams(
    ...     user=None, nominated_for=firefox_trunk)
    >>> list(firefox.searchTasks(nominated_for_trunk))
    []

    >>> nominated_bug = firefox.createBug(
    ...     CreateBugParams(owner=no_priv, title='Bug to be fixed in trunk',
    ...                     comment='Something'))
    >>> BugNomination(
    ...     owner=no_priv, productseries=firefox_trunk, bug=nominated_bug)
    <BugNomination at ...>

    >>> for bugtask in firefox.searchTasks(nominated_for_trunk):
    ...     print bugtask.bug.title
    Bug to be fixed in trunk

== Filter by Upstream Status ==

Add an Ubuntu bugtask for a bug that is confirmed upstream.

    >>> from lp.bugs.interfaces.bugtask import (
    ...     BugTaskImportance,
    ...     BugTaskStatus,
    ...     )
    >>> from lp.bugs.model.tests.test_bugtask import (
    ...     BugTaskSearchBugsElsewhereTest)
    >>> def bugTaskInfo(bugtask):
    ...     return '%i %i %s %s' % (
    ...         bugtask.id, bugtask.bug.id, bugtask.bugtargetdisplayname,
    ...         bugtask.bug.title)
    >>> test_helper = BugTaskSearchBugsElsewhereTest(helper_only=True)
    >>> bug_twelve =  getUtility(IBugSet).get(12)
    >>> task_open_upstream = bugtask_set.createTask(
    ...     bug_twelve, foo_bar, ubuntu,
    ...     status=BugTaskStatus.NEW, importance=BugTaskImportance.MEDIUM)
    >>> test_helper.assertBugTaskIsOpenUpstream(task_open_upstream)

Pass the resolved_upstream flag to include only bugtasks linked to
watches that are rejected, fixed committed or fix released, or bugtasks
related to upstream bugtasks (i.e. filed on the same bug) that are fix
committed or fix released.

    >>> test_helper.setUpBugsResolvedUpstreamTests()
    >>> params = BugTaskSearchParams(
    ...     resolved_upstream=True, orderby='id', user=None)
    >>> closed_elsewhere_tasks = ubuntu.searchTasks(params)
    >>> for bugtask in closed_elsewhere_tasks:
    ...     test_helper.assertBugTaskIsResolvedUpstream(bugtask)
    ...     print bugTaskInfo(bugtask)
    17 1 mozilla-firefox (Ubuntu) Firefox does not support SVG
    26 2 Ubuntu Blackhole Trash folder
    23 9 thunderbird (Ubuntu) Thunderbird crashes


Pass the open_upstream flag to include only bugtasks linked to those
watches or those upstream bugtasks that have the status "unconfirmed",
"needs info", "confirmed", "in progress" or "unknown". Note that a bug
may be associated with three or more bugtasks. If one upstream task
has a state associated with "open upstream", and another upstream task
has a state associated with "resolved upstream", the bug is included
in the results of the "open upstream" filter as well as the "resolved
upstream" filter.

(In the examples below, the last bugtask is ellipsized because its ID
 is generated here and therefore sampledata-dependent.)

    >>> params = BugTaskSearchParams(
    ...     open_upstream=True, orderby='id', user=None)
    >>> open_elsewhere_tasks = ubuntu.searchTasks(params)
    >>> for bugtask in open_elsewhere_tasks:
    ...     test_helper.assertBugTaskIsOpenUpstream(bugtask)
    ...     print bugTaskInfo(bugtask)
    17  1 mozilla-firefox (Ubuntu) Firefox does not support SVG
    26  2 Ubuntu Blackhole Trash folder
    ... ... Ubuntu Copy, Cut and Delete operations should work on selections


We can also filter our search to include only bugs that are not known to
affect upstream, i.e., bugs that don't have an IUpstreamBugTask.

    >>> params = BugTaskSearchParams(
    ...     has_no_upstream_bugtask=True, orderby='id', user=None)
    >>> tasks_with_no_upstreams = ubuntu.searchTasks(params)
    >>> for bugtask in tasks_with_no_upstreams:
    ...     test_helper.assertShouldBeShownOnNoUpstreamTaskSearch(bugtask)
    ...     print bugTaskInfo(bugtask)
    25 10 linux-source-2.6.15 (Ubuntu) another test bug
    ... ... Ubuntu Test nominated bug

If we combine upstream-related filters, we get the union of the results
of the single filters.

    >>> params = BugTaskSearchParams(
    ...     has_no_upstream_bugtask=True, resolved_upstream=True,
    ...     orderby='id', user=None)
    >>> tasks_with_no_upstreams = ubuntu.searchTasks(params)
    >>> for bugtask in tasks_with_no_upstreams:
    ...     print bugTaskInfo(bugtask)
    17  1 mozilla-firefox (Ubuntu) Firefox does not support SVG
    26  2 Ubuntu Blackhole Trash folder
    23  9 thunderbird (Ubuntu) Thunderbird crashes
    25 10 linux-source-2.6.15 (Ubuntu) another test bug
    ... ... Ubuntu Test nominated bug


    >>> test_helper.tearDownBugsElsewhereTests()


== Bugs with partner packages ==

Bugs may also be targeted to partner packages.  First turn "cdrkit" into
a partner package:

    >>> from zope.security.proxy import removeSecurityProxy
    >>> from lp.soyuz.interfaces.component import IComponentSet
    >>> proxied_cdrkit = ubuntu.getSourcePackage("cdrkit")
    >>> cdrkit = removeSecurityProxy(proxied_cdrkit)
    >>> cdrkit.component = getUtility(IComponentSet)['partner']
    >>> cdrkit.archive = ubuntu.getArchiveByComponent('partner')
    >>> transaction.commit()

It starts off with no bugs:

    >>> cdrkit_bugs = cdrkit.searchTasks(all_public)
    >>> cdrkit_bugs.count()
    0

We can file a bug against it and see that show up in a search:

    >>> from lp.bugs.interfaces.bug import CreateBugParams
    >>> from lp.registry.interfaces.person import IPersonSet
    >>> no_priv = getUtility(IPersonSet).getByName('no-priv')
    >>> bug = cdrkit.createBug(
    ...     CreateBugParams(owner=no_priv, title='Bug to be fixed in trunk',
    ...                     comment='Something'))
    >>> cdrkit_bugs = cdrkit.searchTasks(all_public)
    >>> cdrkit_bugs.count()
    1


== Searching for bugs related to hardware ==

We can search for bugs which are related to a given hardware device or
a given driver.

We can search for bugs whose reporters own a given device. A device
must be specified by a bus as enumerated by HWBus, a vendor ID and a
product ID. If we search for bugs related to the PCI device (0x10de,
0x0455), which appears in a HWDB submission from Sample Person, bugs
reported by him will be returned.

    >>> from lp.hardwaredb.interfaces.hwdb import HWBus
    >>> search_params = BugTaskSearchParams(
    ...     user=None, hardware_bus=HWBus.PCI, hardware_vendor_id='0x10de',
    ...     hardware_product_id='0x0455', hardware_owner_is_bug_reporter=True)
    >>> for bugtask in ubuntu.searchTasks(search_params):
    ...     print bugtask.bug.id, bugtask.bug.owner.displayname
    1 Sample Person
    2 Sample Person

If one of the parameters bus, vendor ID or prodct ID is missing,
the query is not limited to any devices. In other words, we get
the same result as if we would not have specified any hardware
related parameters.

    >>> search_params = BugTaskSearchParams(
    ...     user=None, hardware_bus=HWBus.PCI, hardware_vendor_id='0x10de',
    ...     hardware_owner_is_bug_reporter=True)
    >>> for bugtask in ubuntu.searchTasks(search_params):
    ...     print bugtask.bug.id, bugtask.bug.owner.displayname
    1 Sample Person
    9 Foo Bar
    10 Foo Bar
    2 Sample Person
    18 No Privileges Person

Similary, we can search for device drivers appearing in HWDB submissions
of a bug reporter.

    >>> search_params = BugTaskSearchParams(
    ...     user=None, hardware_driver_name='ehci_hcd',
    ...     hardware_owner_is_bug_reporter=True)
    >>> for bugtask in ubuntu.searchTasks(search_params):
    ...     print bugtask.bug.id, bugtask.bug.owner.displayname
    1 Sample Person
    2 Sample Person

We can additionally specify a packge name.

    >>> search_params = BugTaskSearchParams(
    ...     user=None, hardware_driver_name='ehci_hcd',
    ...     hardware_driver_package_name='linux-image-2.6.24-19-generic',
    ...     hardware_owner_is_bug_reporter=True)
    >>> for bugtask in ubuntu.searchTasks(search_params):
    ...     print bugtask.bug.id, bugtask.bug.owner.displayname
    1 Sample Person
    2 Sample Person

    >>> search_params = BugTaskSearchParams(
    ...     user=None, hardware_driver_name='ehci_hcd',
    ...     hardware_driver_package_name='linux-image',
    ...     hardware_owner_is_bug_reporter=True)
    >>> ubuntu.searchTasks(search_params).count()
    0

If we specify a driver and a device, we'll get those bugs whose owners
use the given device together with the given driver.

    >>> search_params = BugTaskSearchParams(
    ...     user=None, hardware_bus=HWBus.PCI, hardware_vendor_id='0x10de',
    ...     hardware_product_id='0x0455', hardware_driver_name='ehci_hcd',
    ...     hardware_owner_is_bug_reporter=True)
    >>> for bugtask in ubuntu.searchTasks(search_params):
    ...     print bugtask.bug.id, bugtask.bug.owner.displayname
    1 Sample Person
    2 Sample Person

The PCI device (0x10de, 0x0455) is not controlled in any HWDB submission
by the sd driver, so we'll get an empty result set for this query.

    >>> from lp.registry.interfaces.product import IProductSet
    >>> firefox = getUtility(IProductSet).getByName('firefox')
    >>> search_params = BugTaskSearchParams(
    ...     user=None, hardware_bus=HWBus.PCI, hardware_vendor_id='0x10de',
    ...     hardware_product_id='0x0455', hardware_driver_name='sd',
    ...     hardware_owner_is_bug_reporter=True)
    >>> firefox.searchTasks(search_params).count()
    0

We can also search for device owners which are subscribed to a bug.

    >>> sample_person = getUtility(IPersonSet).getByEmail('test@canonical.com')
    >>> search_params = BugTaskSearchParams(
    ...     user=None, hardware_bus=HWBus.PCI, hardware_vendor_id='0x10de',
    ...     hardware_product_id='0x0455',
    ...     hardware_owner_is_subscribed_to_bug=True)
    >>> for bugtask in ubuntu.searchTasks(search_params):
    ...     print bugtask.bug.id, bugtask.bug.isSubscribed(sample_person)
    1 True
    9 True

And we can search for device owners who are affected by a bug.

    >>> bug_ten = getUtility(IBugSet).get(10)
    >>> bug_ten.markUserAffected(sample_person, affected=True)
    >>> search_params = BugTaskSearchParams(
    ...     user=None, hardware_bus=HWBus.PCI, hardware_vendor_id='0x10de',
    ...     hardware_product_id='0x0455',
    ...     hardware_owner_is_affected_by_bug=True)
    >>> for bugtask in ubuntu.searchTasks(search_params):
    ...     print bugtask.bug.id, bugtask.bug.isUserAffected(sample_person)
    10 True

Finally, we can search for who bugs which are directly linked to
a HWDB submission, where the submission contains the given device or
driver.

    >>> from lp.hardwaredb.interfaces.hwdb import IHWSubmissionSet
    >>> hw_submission = getUtility(IHWSubmissionSet).getBySubmissionKey(
    ...     'sample-submission')
    >>> bug_18 = getUtility(IBugSet).get(18)
    >>> bug_18.linkHWSubmission(hw_submission)
    >>> search_params = BugTaskSearchParams(
    ...     user=None, hardware_bus=HWBus.PCI, hardware_vendor_id='0x10de',
    ...     hardware_product_id='0x0455', hardware_is_linked_to_bug=True)
    >>> for bugtask in ubuntu.searchTasks(search_params):
    ...     print bugtask.bug.id
    18

If a device appears in a private submission, related bugs are shown
only if the user running the request is the owner of the submission
or an admin.

    >>> naked_hw_submission = removeSecurityProxy(hw_submission)
    >>> naked_hw_submission.private = True
    >>> search_params = BugTaskSearchParams(
    ...     user=sample_person, hardware_bus=HWBus.PCI,
    ...     hardware_vendor_id='0x10de', hardware_product_id='0x0455',
    ...     hardware_is_linked_to_bug=True)
    >>> for bugtask in ubuntu.searchTasks(search_params):
    ...     print bugtask.bug.id
    18

    >>> search_params = BugTaskSearchParams(
    ...     user=foo_bar, hardware_bus=HWBus.PCI, hardware_vendor_id='0x10de',
    ...     hardware_product_id='0x0455', hardware_is_linked_to_bug=True)
    >>> for bugtask in ubuntu.searchTasks(search_params):
    ...     print bugtask.bug.id
    18

Other users cannot see that a bug is related to a device from a
private submission.

    >>> search_params = BugTaskSearchParams(
    ...     user=no_priv, hardware_bus=HWBus.PCI, hardware_vendor_id='0x10de',
    ...     hardware_product_id='0x0455', hardware_is_linked_to_bug=True)
    >>> ubuntu.searchTasks(search_params).count()
    0

    >>> search_params = BugTaskSearchParams(
    ...     user=None, hardware_bus=HWBus.PCI, hardware_vendor_id='0x10de',
    ...     hardware_product_id='0x0455', hardware_is_linked_to_bug=True)
    >>> ubuntu.searchTasks(search_params).count()
    0


== Ordering search results ==

The result returned by bugtask searches can come sorted by a specified order


=== Ordering by number of duplicates ===

It is possible to sort the results by the number of duplicates each bag has.

Here is the list of bugs for Ubuntu.

    >>> params = BugTaskSearchParams(
    ...     orderby='-number_of_duplicates', user=None)
    >>> ubuntu_tasks = ubuntu.searchTasks(params)
    >>> for bugtask in ubuntu_tasks:
    ...     print bugTaskInfo(bugtask)
    17 1 mozilla-firefox (Ubuntu) Firefox does not support SVG
    23 9 thunderbird (Ubuntu) Thunderbird crashes
    25 10 linux-source-2.6.15 (Ubuntu) another test bug
    26 2 Ubuntu Blackhole Trash folder
    39 18 cdrkit (Ubuntu) Bug to be fixed in trunk

None of these bugs have any duplicates.

    >>> [bugtask.bug.id for bugtask in ubuntu_tasks
    ...  if bugtask.bug.duplicateof is not None]
    []

    >>> from lp.services.database.sqlbase import flush_database_updates

We mark bug #10 as a duplicate of bug #9.

    >>> bug_nine = getUtility(IBugSet).get(9)
    >>> bug_ten = getUtility(IBugSet).get(10)
    >>> bug_ten.markAsDuplicate(bug_nine)
    >>> flush_database_updates()

Searching again reveals bug #9 at the top of the list, since it now has a duplicate.

    >>> ubuntu_tasks = ubuntu.searchTasks(params)
    >>> for bugtask in ubuntu_tasks:
    ...     print bugTaskInfo(bugtask)
    23 9 thunderbird (Ubuntu) Thunderbird crashes
    17 1 mozilla-firefox (Ubuntu) Firefox does not support SVG
    25 10 linux-source-2.6.15 (Ubuntu) another test bug
    26 2 Ubuntu Blackhole Trash folder
    39 18 cdrkit (Ubuntu) Bug to be fixed in trunk


=== Ordering by number of comments ===

It is also possible to sort the results by the number of comments on a bug.

Here is the list of bugs for Ubuntu, sorted by their number of comments.

    >>> params = BugTaskSearchParams(
    ...     orderby='-message_count', user=None)
    >>> ubuntu_tasks = ubuntu.searchTasks(params)
    >>> for bugtask in ubuntu_tasks:
    ...     bug = bugtask.bug
    ...     print '%s %s [%s comments]' % (
    ...     bug.id, bug.title, bug.message_count)
    2 Blackhole Trash folder [3 comments]
    1 Firefox does not support SVG [2 comments]
    10 another test bug [2 comments]
    9 Thunderbird crashes [1 comments]
    18 Bug to be fixed in trunk [1 comments]


=== Ordering by bug heat ===

Another way of sorting searches is by bug heat.

    >>> params = BugTaskSearchParams(
    ...     orderby='id', user=None)
    >>> ubuntu_tasks = ubuntu.searchTasks(params)
    >>> for task in ubuntu_tasks:
    ...     removeSecurityProxy(task.bug).heat = task.bug.id
    >>> transaction.commit()
    >>> params = BugTaskSearchParams(
    ...     orderby='-heat', user=None)
    >>> ubuntu_tasks = ubuntu.searchTasks(params)
    >>> for bugtask in ubuntu_tasks:
    ...     bug = bugtask.bug
    ...     print '%s %s [heat: %s]' % (
    ...     bug.id, bug.title, bug.heat)
    18 Bug to be fixed in trunk [heat: 18]
    10 another test bug [heat: 10]
    9 Thunderbird crashes [heat: 9]
    2 Blackhole Trash folder [heat: 2]
    1 Firefox does not support SVG [heat: 1]


=== Ordering by patch age ===

We can also sort search results by the creation time of the youngest
patch attached to a bug.

Since we have at present no bugs with patches, we use effectively
the default sort order, by bug task ID (which is implicitly added as
a "second level" sort order to ensure reliable sorting).

    >>> params = BugTaskSearchParams(
    ...     orderby='latest_patch_uploaded', user=None)
    >>> ubuntu_tasks = ubuntu.searchTasks(params)
    >>> for bugtask in ubuntu_tasks:
    ...     print bugTaskInfo(bugtask)
    39 18 cdrkit (Ubuntu) Bug to be fixed in trunk
    26 2 Ubuntu Blackhole Trash folder
    25 10 linux-source-2.6.15 (Ubuntu) another test bug
    23 9 thunderbird (Ubuntu) Thunderbird crashes
    17 1 mozilla-firefox (Ubuntu) Firefox does not support SVG

If we add a patch attachment to bug 2 and bug 10, they are listed first.

    >>> bug_two = getUtility(IBugSet).get(2)
    >>> patch_attachment_bug_2 = factory.makeBugAttachment(
    ...     bug=bug_two, is_patch=True)
    >>> transaction.commit()
    >>> patch_attachment_bug_10 = factory.makeBugAttachment(
    ...     bug=bug_ten, is_patch=True)
    >>> params = BugTaskSearchParams(
    ...     orderby='latest_patch_uploaded', user=None)
    >>> ubuntu_tasks = ubuntu.searchTasks(params)
    >>> for bugtask in ubuntu_tasks:
    ...     print bugTaskInfo(bugtask)
    26 2 Ubuntu Blackhole Trash folder
    25 10 linux-source-2.6.15 (Ubuntu) another test bug
    39 18 cdrkit (Ubuntu) Bug to be fixed in trunk
    23 9 thunderbird (Ubuntu) Thunderbird crashes
    17 1 mozilla-firefox (Ubuntu) Firefox does not support SVG
