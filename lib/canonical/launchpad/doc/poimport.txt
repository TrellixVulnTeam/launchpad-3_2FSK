PO Imports
----------

The tale of a PO template and a PO file and how they get imported into
Rosetta.

    >>> from canonical.launchpad.ftests.harness import LaunchpadFunctionalTestSetup
    >>> from canonical.librarian.ftests.harness import LibrarianTestSetup

    >>> LaunchpadFunctionalTestSetup().setUp()
    >>> LibrarianTestSetup().setUp()

Here's some database classes we'll be using.

    >>> from canonical.launchpad.database import Person
    >>> from canonical.launchpad.database import POTemplate
    >>> from canonical.launchpad.database import POFile

We need this for the Librarian to work properly.

    >>> import transaction

Then, let's get a handle to our mailer. This is the thing we'll examine to show
what email has been sent, to whom, and what the body of the message contains:

    >>> import email
    >>> from canonical.launchpad.mail import stub

Here's a fake logger to capture any errors that happen.

    >>> class FakeLogger:
    ...     def log(self, *stuff, **kw):
    ...         print 'log>', ' '.join(stuff)
    ...
    ...         if 'exc_info' in kw:
    ...             import sys
    ...             import traceback
    ...             exception = traceback.format_exception(*sys.exc_info())
    ...             for thing in exception:
    ...                 for line in thing.splitlines():
    ...                     self.log(line)
    ...
    ...     warning = log

Now, is time to create the new potemplate

    >>> from canonical.launchpad.database import ProductRelease
    >>> release = ProductRelease.get(3)
    >>> release.productseries.product.name
    u'firefox'

    >>> from canonical.launchpad.database import POTemplateNameSet
    >>> ptn = POTemplateNameSet().new('firefox', 'Whatever')

    >>> from canonical.launchpad.database import POTemplateSubset
    >>> subset = POTemplateSubset(productrelease=release)

Here's the person who'll be doing the import.

    >>> person = Person.get(1)

    >>> potemplate = subset.new(
    ...     potemplatename=ptn,
    ...     contents='# Not much.',
    ...     owner=person)

And this is the file that'll get imported.

    >>> potemplate_contents = r'''
    ... msgid ""
    ... msgstr ""
    ... "Content-Type: text/plain; charset=UTF-8\n"
    ... "Plural-Forms: nplurals=INTEGER; plural=EXPRESSION;\n"
    ...
    ... msgid "foo"
    ... msgstr ""
    ...
    ... msgid "bar"
    ... msgstr ""
    ...
    ... #: test.c:13
    ... msgid "baz"
    ... msgstr ""
    ...
    ... #, c-format
    ... msgid "Foo %s"
    ... msgstr ""
    ...
    ... #, c-format
    ... msgid "Singular %d"
    ... msgid_plural "Plural %d"
    ... msgstr[0] ""
    ... msgstr[1] ""
    ... '''

Importing happens in two steps. First, we attach the file data to the
template. The potemplate is always "published"

    >>> potemplate.attachRawFileData(potemplate_contents, True, person)

The file data is stored in the Librarian, so we have to commit the transaction
to make sure it's stored properly.

    >>> transaction.commit()

Second, we tell the PO template to import from the file data it has.

    >>> potemplate.doRawImport(FakeLogger())

Once we've done this, the correct message IDs should show up in the template.

    >>> potmsgsets = list(potemplate.getPOTMsgSets())
    >>> [potmsgset.primemsgid_.msgid for potmsgset in potmsgsets]
    [u'foo', u'bar', u'baz', u'Foo %s', u'Singular %d']

The file references field should be there

    >>> potmsgsets[2].filereferences
    u'test.c:13'

Now let's get a PO file to import.

    >>> pofile = potemplate.getOrCreatePOFile('cy')

It's newly created, so it has no message sets yet.

    >>> len(pofile.currentMessageSets())
    0

Here are the contents of the file we'll be importing.

    >>> pofile_contents = r'''
    ... msgid ""
    ... msgstr ""
    ... "PO-Revision-Date: 2005-06-03 19:41+0100\n"
    ... "Content-Type: text/plain; charset=UTF-8\n"
    ... "Plural-Forms: nplurals=4; plural=n==1) ? 0 : n==2 ? 1 : (n != 8 || n != 11) ? 2 : 3;\n"
    ...
    ... msgid "foo"
    ... msgstr "blah"
    ...
    ... #, fuzzy
    ... msgid "bar"
    ... msgstr "heffalump"
    ...
    ... msgid "balloon"
    ... msgstr "blah"
    ...
    ... #, c-format
    ... msgid "Foo %s"
    ... msgstr "blah %i"
    ...
    ... #, c-format
    ... msgid "Singular %d"
    ... msgid_plural "Plural %d"
    ... msgstr[0] "Foos"
    ... msgstr[1] "Bars"
    ... msgstr[2] "Welsh power!"
    ... msgstr[3] "We have four!"
    ... '''

This is the dbschema that controls the validation of a translation.
    >>> from canonical.lp.dbschema import TranslationValidationStatus

The process of importing a PO file is much like that of importing a PO
template. Remember, we need to tell the system that this po file is a
"published" one.

    >>> pofile.attachRawFileData(pofile_contents, True, person)
    >>> transaction.commit()
    >>> pofile.doRawImport(FakeLogger())

Here's a current message set: i.e. it has a corresponding current message set
in the PO template. It should not be publishedfuzzy.

    >>> messageSets = list(pofile.currentMessageSets())
    >>> messageSets[0].potmsgset.primemsgid_.msgid
    u'foo'
    >>> messageSets[0].publishedfuzzy
    False

And should be accepted by our validator.

    >>> published = messageSets[0].publishedSubmission(0)
    >>> published.validationstatus == TranslationValidationStatus.OK
    True

And here's a non-current message set. It shouldn't be fuzzy either.

    >>> messageSets = list(pofile.messageSetsNotInTemplate())
    >>> messageSets[0].potmsgset.primemsgid_.msgid
    u'balloon'
    >>> messageSets[0].publishedfuzzy
    False

This message set should be fuzzy, however.

    >>> messageSet = pofile.messageSet(u'bar')
    >>> messageSet.publishedfuzzy
    True

And this one should have the validation status with an error.

    >>> messageSet = pofile.messageSet(u'Foo %s')
    >>> published = messageSet.publishedSubmission(0)
    >>> published.validationstatus == TranslationValidationStatus.UNKNOWNERROR
    True

Check that the plural form was imported correctly.

    >>> messageSet = pofile.messageSet(u'Singular %d')
    >>> published = messageSet.publishedSubmission(0)
    >>> published.validationstatus == TranslationValidationStatus.OK
    True
    >>> messageSet.published_texts
    [u'Foos', u'Bars', u'Welsh power!', u'We have four!']


Now, is time to check the notification email.

    >>> transaction.commit()

    >>> len(stub.test_emails)
    1

    >>> from_addr, to_addrs, raw_message = stub.test_emails.pop()
    >>> to_addrs
    ['mark@hbd.com']
    >>> msg = email.message_from_string(raw_message)
    >>> msg["Subject"]
    'Translation problems - Welsh (cy) - firefox in Mozilla Firefox 0.9'
    >>> print msg.get_payload(decode=True)
    Hello Mark Shuttleworth,
    <BLANKLINE>
    On ... (just requested), you uploaded 5
    Welsh (cy) translations for firefox in Mozilla Firefox 0.9 in Rosetta.
    <BLANKLINE>
    There were problems with 1 of these translations.
    <BLANKLINE>
    4.  [msg 4]
    "format specifications in 'msgid' and 'msgstr' for argument 1 are not the same":
    <BLANKLINE>
    #, c-format
    msgid "Foo %s"
    msgstr "blah %i"
    <BLANKLINE>
    <BLANKLINE>
    <BLANKLINE>
    The other 4 translations have been accepted.
    <BLANKLINE>
    ...

    >>> LibrarianTestSetup().tearDown()
    >>> LaunchpadFunctionalTestSetup().tearDown()

