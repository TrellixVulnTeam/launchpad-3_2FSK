= Distribution mirrors =

First of all we'll create a new mirror for the Ubuntu distribution...

    >>> browser.addHeader('Authorization', 'Basic test@canonical.com:test')
    >>> browser.open('http://launchpad.dev/ubuntu/+newmirror')
    >>> http_url = 'http://my.mirror.com/pub'
    >>> browser.getControl('Link Speed').value = ['1 Mbps']
    >>> browser.getControl('Location').value =  ['9']
    >>> browser.getControl('Content').value = ['Archive']
    >>> browser.getControl('HTTP URL').value = http_url
    >>> browser.getControl('Create Mirror').click()
 
    >>> browser.url
    'http://launchpad.dev/ubuntu/+mirror/my.mirror.com-archive'
    >>> print extract_text(find_tag_by_id(browser.contents, 'mirror-details'))
    Speed: 1 Mbps
    Country: Antarctica
    Content: Archive

Note that even though the http_url we used didn't contain a trailing slash,
the value stored in our database will contain it.
 
    >>> browser.getLink('Change details').click()
    >>> http_url + "/" == browser.getControl('HTTP URL').value
    True
 
It's possible to change the auto-generated mirror name, if we want, but
the name is unique, and so we can't use a name that is already in use by
another mirror.
 
    >>> browser.url
    'http://launchpad.dev/ubuntu/+mirror/my.mirror.com-archive/+edit'
    >>> browser.getControl(name='field.name').value = 'archive-mirror'
    >>> browser.getControl('Save').click()
 
    >>> message = "is already in use by another distribution mirror."
    >>> message in browser.contents
    True
 
Like the name, we can also change the URLs of a mirror:

    >>> browser.getLink('Change details').click()
    >>> browser.url
    'http://launchpad.dev/ubuntu/+mirror/my.mirror.com-archive/+edit'
    
    >>> browser.getControl('HTTP URL').value = 'http://foo.bar/baz'
    >>> browser.getControl('FTP URL').value = 'ftp://foo.bar/baz'
    >>> browser.getControl('Rsync URL').value = 'rsync://foo.bar/baz'
    >>> browser.getControl('Save').click()

    >>> browser.url
    'http://launchpad.dev/ubuntu/+mirror/my.mirror.com-archive'

    >>> print extract_text(find_tag_by_id(browser.contents, 'mirror-urls'))
    Web: http://foo.bar/baz/
    FTP: ftp://foo.bar/baz/
    Rsync: rsync://foo.bar/baz/

The mirror can't be probed before it's marked as official by one of the
distribution owners.
 
    >>> browser.open(
    ...     'http://launchpad.dev/ubuntu/+mirror/my.mirror.com-archive/')
    >>> print extract_text(find_tag_by_id(browser.contents, 'last-probe'))
    Last probe
    This mirror is an unofficial Ubuntu Linux mirror, and will not be
    verified.

To make a mirror official, one has to go to the +mark-official page, which
is accessible only to mirror admins of that distribution and the
distribution owner.
 
    >>> browser.open(
    ...     'http://launchpad.dev/ubuntu/+mirror/my.mirror.com-archive/'
    ...     '+mark-official')
    Traceback (most recent call last):
    ...
    Unauthorized...
 
Now one of the mirror administrators goes and make this an official mirror,
leaving a comment on the whiteboard (which is visible to mirror admins and to
the mirror owner, but can only be edited by mirror admins).
 
    # XXX: matsubara 2006-05-18: We need to reset the Browser object to
    # reset the headers.  https://launchpad.net/launchpad/+bug/45226
    >>> from zope.testbrowser.testing import Browser
    >>> browser = Browser()
    >>> browser.handleErrors = False
 
    >>> browser.addHeader('Authorization', 'Basic karl@canonical.com:test')
    >>> browser.open(
    ...     'http://launchpad.dev/ubuntu/+mirror/my.mirror.com-archive')
    >>> browser.getLink('Mark as official').click()
 
    >>> official_approved = browser.getControl(
    ...     'This is one of the official mirrors of this distribution')
    >>> official_approved.selected = True
    >>> browser.getControl('Whiteboard').value = 'This is a good mirror'
    >>> browser.getControl('Save').click()
 
    >>> browser.url
    'http://launchpad.dev/ubuntu/+mirror/my.mirror.com-archive'
    >>> print extract_text(find_tag_by_id(browser.contents, 'whiteboard'))
    This is a good mirror 
    >>> print extract_text(find_tag_by_id(browser.contents, 'status'))
    Official Ubuntu Linux Mirror registered by Sample Person ... 

The whiteboard can also be seen by the mirror owner, but not by anybody
else.

    >>> browser = Browser()
    >>> browser.addHeader('Authorization', 'Basic test@canonical.com:test')
    >>> browser.open(
    ...     'http://launchpad.dev/ubuntu/+mirror/my.mirror.com-archive')
    >>> print extract_text(find_tag_by_id(browser.contents, 'whiteboard'))
    This is a good mirror 

    >>> anon_browser.open(
    ...     'http://launchpad.dev/ubuntu/+mirror/my.mirror.com-archive')
    >>> print find_tag_by_id(anon_browser.contents, 'whiteboard')
    None

== Error checking ==

When creating a new mirror, at least an HTTP or FTP URL must be given.

    # XXX: matsubara 2006-05-18: We need to reset the Browser object to
    # reset the headers.  https://launchpad.net/launchpad/+bug/45226
    >>> browser = Browser()
    >>> browser.handleErrors = False
    >>> browser.addHeader('Authorization', 'Basic test@canonical.com:test')

    >>> browser.open('http://launchpad.dev/ubuntu/+newmirror')
    >>> browser.getControl('Link Speed').value = ['1 Mbps']
    >>> browser.getControl('Location').value =  ['9']
    >>> browser.getControl('Content').value = ['Archive']
    >>> browser.getControl('Create Mirror').click()
 
    >>> for tag in find_tags_by_class(browser.contents, 'error message'):
    ...     print tag.renderContents()
    There is 1 error.
    A mirror must have at least an HTTP or FTP URL.
 
If we try to register the mirror using the same HTTP URL of a existing one,
we should also get a nice error message. (Even if we forget to add the
trailing slash in the new URL by mistake)
 
    >>> http_url = 'http://localhost:11375/invalid-mirror'
    >>> browser.getControl('HTTP URL').value = http_url
    >>> browser.getControl('Create Mirror').click()
 
    >>> for tag in find_tags_by_class(browser.contents, 'message'):
    ...     print tag.renderContents()
    There is 1 error.
    The distribution mirror ... is already registered with this URL.
 
We'll have to add some URLs to sample data to test the validator for FTP and
Rsync URLs.
 
    >>> from zope.component import getUtility
    >>> from canonical.database.sqlbase import flush_database_updates
    >>> from canonical.launchpad.interfaces import IDistributionMirrorSet
    >>> from canonical.launchpad.ftests import login, logout
    >>> login("mark@hbd.com")
    >>> mirrorset = getUtility(IDistributionMirrorSet)
    >>> example_mirror = mirrorset.getByName('invalid-mirror')
    >>> ftp_url = 'ftp://localhost:11375/invalid-mirror'
    >>> example_mirror.ftp_base_url = ftp_url
    >>> rsync_url = 'rsync://localhost:11375/invalid-mirror'
    >>> example_mirror.rsync_base_url = rsync_url
    >>> flush_database_updates()
    >>> logout()
 
And now we test the validator for the FTP URL
 
    >>> browser.getControl('FTP URL').value = ftp_url
    >>> browser.getControl('Create Mirror').click()
 
    >>> for tag in find_tags_by_class(browser.contents, 'message'):
    ...     print tag.renderContents()
    There is 1 error.
    The distribution mirror ... is already registered with this URL.
 
And for the Rsync URL
 
    >>> browser.getControl('Rsync URL').value = rsync_url
    >>> browser.getControl('Create Mirror').click()
 
    >>> for tag in find_tags_by_class(browser.contents, 'message'):
    ...     print tag.renderContents()
    There is 1 error.
    The distribution mirror ... is already registered with this URL.
 
Note also that neither query strings nor fragments are allowed in the URLs.
 
    >>> browser.getControl('HTTP URL').value = 'http://foo.bar/baz#someid'
    >>> browser.getControl('Create Mirror').click()
    >>> for tag in find_tags_by_class(browser.contents, 'message'):
    ...     print tag.renderContents()
    There is 1 error.
    URIs with fragment identifiers are not allowed.
 
    >>> browser.getControl('HTTP URL').value = 'http://foo.bar/baz?q=string'
    >>> browser.getControl('Create Mirror').click()
    >>> for tag in find_tags_by_class(browser.contents, 'message'):
    ...     print tag.renderContents()
    There is 1 error.
    URIs with query strings are not allowed.
 
