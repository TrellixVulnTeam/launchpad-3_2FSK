'foo' is a dupe account for 'no-priv'. Let's merge them, and keep only
'no-priv'.

Workaround while https://launchpad.net/products/launchpad/+bug/39016 is not
fixed.

    >>> from canonical.launchpad.mail import stub
    >>> stub.test_emails[:] = []

First we have to go to the +requestmerge page.

    >>> browser.addHeader('Authorization','Basic no-priv@canonical.com:test')
    >>> browser.open('http://localhost:9000/people/+requestmerge')
    >>> '<h1>Merge Launchpad accounts</h1>' in browser.contents
    True

If we try to merge a nonexistent account, we'll get an error page.

    >>> browser.getControl('Duplicated Account').value = 'bar'
    >>> browser.getControl('Submit').click()
    >>> 'There are <strong>1</strong> input errors' in browser.contents
    True

The same will happen if we try to merge a team.

    >>> browser.getControl(
    ...     'Duplicated Account').value = 'support@canonical.com'
    >>> browser.getControl('Submit').click()
    >>> 'There are <strong>1</strong> input errors' in browser.contents
    True

Then we find the duplicate account and request the merge.
This redirects to the page which displays all email addresses owned by the
duplicate account. Here the user choses the ones which he want to claim.

    >>> browser.getControl(
    ...     'Duplicated Account').value = 'foo'
    >>> browser.getControl('Submit').click()
    >>> 'has more than one registered e-mail address' in browser.contents
    True

Make sure we haven't got leftovers from a previous test

    >>> len(stub.test_emails)
    0

Claim all the email addresses

    >>> email_select_control = browser.getControl(name='selected')
    >>> for ctrl in email_select_control.controls:
    ...     ctrl.selected = True
    >>> browser.getControl('Submit').click()
    >>> 'Individual email messages were sent to' in browser.contents
    True
    >>> 'foo@baz.com' in browser.contents
    True
    >>> 'bar.foo@canonical.com' in browser.contents
    True

Get the token we'll have to use to finish the registration process.

    >>> len(stub.test_emails) == 2
    True
    >>> emails = []
    >>> emails.append(stub.test_emails.pop())
    >>> emails.append(stub.test_emails.pop())
    >>> emails.sort()
    >>> from_addr1, to_addrs1, raw_msg1 = emails.pop()
    >>> from_addr2, to_addrs2, raw_msg2 = emails.pop()

    >>> import email, re
    >>> msg = email.message_from_string(raw_msg1)
    >>> body = msg.get_payload()
    >>> link = re.findall(r'http.*/token/.*', body)[0]
    >>> token = re.sub(r'.*token/', '', link)
    >>> base_path = 'http://localhost:9000/token/%s' % token

Now the user goes to the page we sent a link via email to validate the first
claimed email address.

    >>> browser.open(base_path)
    >>> 'trying to merge the Launchpad account' in browser.contents
    True

User confirms the merge request submitting the form, but the merge wasn't
finished because the duplicate account still have a registered email adresses.

    >>> browser.getControl('Confirm').click()
    >>> 'has other registered e-mail addresses too' in browser.contents
    True

    >>> msg = email.message_from_string(raw_msg2)
    >>> body = msg.get_payload()
    >>> link = re.findall(r'http.*/token/.*', body)[0]
    >>> token = re.sub(r'.*token/', '', link)
    >>> token_base_path = 'http://localhost:9000/token/%s' % token

Now the user proves that he's the owner of the second email address of the
dupe account. And now the merge is completed successfully.

    >>> browser.open(token_base_path)
    >>> 'trying to merge the Launchpad account' in browser.contents
    True
    >>> browser.getControl('Confirm').click()
    >>> 'The accounts have been merged successfully' in browser.contents
    True


# XXX: Removed because things are still failing for me, so this is just
# another variable to worry about. Or maybe it needs to be called more
# often or something -- StuartBishop 20060606
#
# XXX: Hack to start a new transaction and clear caches etc. This should
# not be necessary, but it currently is.
# -- kiko, 2006-05-15
# 
#     >>> def new_transaction():
#     ...     import time
#     ...     time.sleep(2)
#     ...     import gc
#     ...     while gc.collect():
#     ...       pass
#     ...     import transaction
#     ...     import canonical.database.sqlbase
#     ...     transaction.abort()
#     ...     canonical.database.sqlbase.flush_database_caches()
#     ...     transaction.begin()
# 
#     >>> new_transaction()

If the account we were trying to merge had a single email address, the
process would be a little simpler.

To demonstrate that, now we'll merge marilize@hbd.com into
no-priv@canonical.com.

    >>> len(stub.test_emails)
    0

    >>> browser.open('http://localhost:9000/people/+requestmerge')
    >>> browser.getControl('Duplicated Account').value = 'marilize@hbd.com'
    >>> browser.getControl('Submit').click()
    >>> browser.url
    'http://localhost:9000/people/+mergerequest-sent?dupe=55'
    >>> len(stub.test_emails)
    1
    >>> 'An email message was sent to' in browser.contents
    True
    >>> '<strong>marilize@hbd.com</strong' in browser.contents
    True

Revisiting that page gives the same results:

    >>> browser.open('http://localhost:9000/people/+mergerequest-sent?dupe=55')
    >>> 'An email message was sent to' in browser.contents
    True
    >>> '<strong>marilize@hbd.com</strong' in browser.contents
    True

Get the token we'll have to use to finish the registration process.

    >>> from_addr, to_addrs, raw_msg = stub.test_emails.pop()
    >>> assert not stub.test_emails
    >>> msg = email.message_from_string(raw_msg)
    >>> body = msg.get_payload()
    >>> link = re.findall(r'http.*/token/.*', body)[0]
    >>> token = re.sub(r'.*token/', '', link)
    >>> token_base_path = 'http://localhost:9000/token/%s' % token

    >>> browser.open(token_base_path)
    >>> browser.getControl('Confirm').click()
    >>> 'The accounts have been merged successfully' in browser.contents
    True

Revisiting the mergerequest-sent page now safely redirects the user:

    >>> browser.open('http://localhost:9000/people/+mergerequest-sent?dupe=55')
    >>> browser.url
    'http://localhost:9000/people/no-priv'

