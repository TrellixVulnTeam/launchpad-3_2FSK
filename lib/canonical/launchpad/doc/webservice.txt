= RESTful Web Services =

LAZR builds on Zope conventions to make it easy to expose your model
objects as RESTful HTTP resources. I'll demonstrate these features by
defining a model for managing recipes, and then publishing the model
objects as resources through a web service.


== Example model objects ==

Here's the interface for a simple model object that contains a
recipe. This is the kind of model object you'd find in any Zope
application, with no special knowledge of web services.

    # All classes defined in this test are new-style classes.
    >>> __metaclass__ = type

    >>> from zope.interface import Interface
    >>> from zope.schema import Int, TextLine, Object

    >>> class IPerson(Interface):
    ...     name = TextLine(title=u"Name", required=True)

    >>> class IRecipe(Interface):
    ...     id = Int(title=u"Unique ID", required=True)
    ...     name = TextLine(title=u"Name", required=True)
    ...     authorName = TextLine(title=u"The name of the recipe's author")

Here's the interface for the 'set' objects that manage the recipes and
people. The inconsistent naming is intentional.

    >>> class IRecipeSet(Interface):
    ...     def getAll(self):
    ...         "Get all recipes."
    ...
    ...     def get(self, id):
    ...         "Retrieve a single recipe by ID."

    >>> class IPersonSet(Interface):
    ...     def getAllPeople(self):
    ...         "Get all people."
    ...
    ...     def getPerson(self, name):
    ...         "Retrieve a single person by name."


Here are simple implementations of Person and Recipe.

    >>> from zope.interface import implements

    >>> class Person:
    ...     implements(IPerson)
    ...     def __init__(self, name):
    ...         self.name = name

    >>> class Recipe:
    ...     implements(IRecipe)
    ...     def __init__(self, id, name, author):
    ...         self.id = id
    ...         self.name = name
    ...         self.authorName = author.name

Here are the "model objects" themselves:

    >>> P1 = Person("Jacob Berendes")
    >>> P2 = Person("Julia Child")

    >>> R1 = Recipe(1, "Green eggs and ham", P1)
    >>> R2 = Recipe(7, "Steak au poivre", P2)
    >>> R3 = Recipe(10, "Raw celery", P1)

Here's a simple RecipeSet with a predefined list of recipes.

    >>> class RecipeSet:
    ...     implements(IRecipeSet)
    ...     def __init__(self):
    ...         self.recipes = [R1, R2, R3]
    ...
    ...     def getAll(self):
    ...         return self.recipes
    ...
    ...     def get(self, id):
    ...         match = [r for r in self.recipes if r.id == id]
    ...         if len(match) > 0:
    ...             return match[0]
    ...         return None

Here's a simple PersonSet with predefined people.

    >>> class PersonSet:
    ...     implements(IPersonSet)
    ...     def __init__(self):
    ...         self.people = [P1, P2]
    ...
    ...     def getAllPeople(self):
    ...         return self.people
    ...
    ...     def getPerson(self, name):
    ...         match = [p for p in self.people if p.name == name]
    ...         if len(match) > 0:
    ...             return match[0]
    ...         return None


== Defining the resources ==

LAZR provides an interface, IEntry, used by an individual model object
exposed through a specific resource. Right now it's just a marker
interface, but it's expected to define a number of data fields: the
same kind of fields defined by a model interface like IRecipe.

There's not much to our IPerson model, and we can expose it through
the web service exactly as it's defined, by defining a class that
includes both interfaces:

    >>> from canonical.lazr.interfaces import IEntry
    >>> class IPersonEntry(IEntry, IPerson):
    ...     """An IPerson exposed as an entry."""

But most of the time, we don't want to expose our models directly
through the web service. There will be fields we don't want to expose,
synthetic fields we do want to expose, fields we want to expose under
a different name, and so on. In that case, our IEntry subclass will
define the interface we _do_ want to expose through the web
service. Here, we're exposing an IRecipe that exposes the underlying
Recipe's name but not its ID.

    >>> class IRecipeEntry(IEntry):
    ...     "The part of a recipe that we expose through the web service."
    ...     name = IRecipe.get('name')
    ...     author = Object(schema=IPerson)

Here's the implementation of IRecipeEntry: a simple decorator on the
original model object. It subclasses Entry, a simple base class
that defines a constructor.

    >>> from zope.component import adapts
    >>> from canonical.lp import decorates
    >>> from canonical.lazr.rest import Entry

    >>> class PersonEntry(Entry):
    ...     """A person, as exposed through the web service."""
    ...     adapts(IPerson)
    ...     decorates(IPersonEntry)
    ...     schema = IPersonEntry
    ...
    ...     parent_collection_name = 'people'
    ...
    ...     def fragment(self):
    ...         """Use the person's name as its URI fragment."""
    ...         return self.context.name

The "schema" attribute points to the interface class that defines the
attributes exposed through the web service. Here, "schema" is
IPersonEntry, which exposes only 'name'.

    >>> class RecipeEntry(Entry):
    ...     """A recipe, as exposed through the web service."""
    ...     adapts(IRecipe)
    ...     decorates(IRecipeEntry)
    ...     schema = IRecipeEntry
    ...
    ...     parent_collection_name = 'recipes'
    ...
    ...     def fragment(self):
    ...         """Use the recipe's ID as its URI fragment."""
    ...         return str(self.context.id)
    ...
    ...     def lookupEntry(self, name):
    ...         """Look up an associated entry."""
    ...         if name == 'author':
    ...             return PersonSet().getPerson(self.context.authorName)

Here, "schema" is IRecipeEntry, which exposes both "name" and "author".

We need to register these entries as an adapter from IRecipe/IPerson
to IRecipeEntry/IPersonEntry. In ZCML a registration would look like
this.

    <adapter
        for="my.app.interfaces.IPerson"
        provides="my.app.interfaces.IPersonEntry"
        factory="my.app.rest.PersonEntry"
        />

Since we're in the middle of a Python test we need to do the equivalent
in Python code:

    >>> from zope.component import provideAdapter
    >>> provideAdapter(PersonEntry, [IPerson], IPersonEntry)
    >>> provideAdapter(RecipeEntry, [IRecipe], IRecipeEntry)

LAZR also defines an interface and a base class for collections of
objects. I'll use it to expose the RecipeSet collection through the
web service. A collection must define a method called find(), which
returns the model objects in the collection.

    >>> from canonical.lazr.rest import Collection
    >>> from canonical.lazr.interfaces import ICollection

    >>> class PersonCollection(Collection):
    ...     """A collection of people, as exposed through the web service."""
    ...
    ...     def find(self):
    ...        """Find all the people."""
    ...        return self.context.getAllPeople()
    ...
    ...     def lookupEntry(self, name):
    ...        """Find a single person by name."""
    ...        return self.context.getPerson(name)

    >>> provideAdapter(PersonCollection, [IPersonSet], ICollection)

    >>> class RecipeCollection(Collection):
    ...     """A collection of recipes, as exposed through the web service."""
    ...
    ...     def find(self):
    ...        """Find all the recipes."""
    ...        return self.context.getAll()
    ...
    ...     def lookupEntry(self, id):
    ...        """Find a single recipe by ID."""
    ...        return self.context.get(int(id))

    >>> provideAdapter(RecipeCollection, [IRecipeSet], ICollection)

Like Entry, Collection is a simple base class that defines a
constructor.


== Resource objects ==

LAZR's Resource objects are the objects that actually handle incoming
HTTP requests. There are a few very common types of HTTP resources,
and LAZR defines classes for some of them. For instance, there's the
"collection" resource that responds to GET (to get the items in the
collection) and POST (to add a new item to the collection). LAZR
implements this as a CollectionResource which uses the HTTP arguments
to drive Collection methods like find() and createNew() (createNew()
isn't implemented yet).

Of course, a CollectionResource has to expose a collection _of_
something. That's why each CollectionResource is associated with some
concrete implementation of ICollection, like RecipeCollection. All you
have to do is define the behaviour of the collection, and
CollectionResource takes care of exposing the collection through HTTP.

Similarly, you can implement RecipeEntry to the IEntry interface, and
expose it through the web as an EntryResource.


== The Service Root Resource ==

How are these Resource objects connected to the web? Through the
ServiceRootResource. This is a special resource that represents the
root of the object tree.

    >>> from canonical.lazr.rest import ServiceRootResource
    >>> from canonical.launchpad.interfaces import IWebServiceApplication
    >>> class MyServiceRootResource(ServiceRootResource):
    ...    implements(IWebServiceApplication)
    ...    top_level_collections = { 'people': PersonSet,
    ...                              'recipes': RecipeSet }
    ...    rootsite = 'api'

If you call the service root resource, and pass in an HTTP request, it
will act as though you had performed a GET on the URL
'http://api.launchpad.net/'.

    >>> from canonical.launchpad.webapp.servers import LaunchpadTestRequest
    >>> from canonical.launchpad.webapp.servers import WebServicePublication
    >>> request = LaunchpadTestRequest()
    >>> request.setPublication(WebServicePublication(None))
    >>> request.setApplicationServer('api.launchpad.dev')
    >>> app = MyServiceRootResource()
    >>> from canonical.launchpad.interfaces import IOpenLaunchBag
    >>> getUtility(IOpenLaunchBag).add(app)

    >>> app(request)
    'This is a web service.'

The ServiceRoot has a list of top-level collections and implements
IPublishTraverse, so that a request to a registered collection is
delegated to the appropriate CollectionResource. The
top_level_collections attribute maps URL fragments to factory methods
or other callables, and the return value of the factory method is
used as the context of a CollectionResource. In MyServiceRootResource,
the URL fragment "recipes" is mapped to the RecipeSet class.

The following example is equivalent to requesting
'http://api.launchpad.net/recipes/'. The code calls the registered
factory method (RecipeSet()) and wraps the resulting model object
in a CollectionResource.

    >>> collection = app.publishTraverse(request, "recipes")
    >>> collection
    <canonical.lazr.rest.resource.CollectionResource object ...>
    >>> from canonical.launchpad.webapp import canonical_url
    >>> canonical_url(collection, request=request)
    u'http://api.launchpad.dev/recipes'

    >>> import simplejson
    >>> representation = simplejson.loads(collection())
    >>> len(representation)
    3
    >>> representation[0]['self_link']
    u'http://api.launchpad.dev/recipes/1'
    >>> representation[0]['name']
    u'Green eggs and ham'
    >>> representation[0]['author_link']
    u'http://api.launchpad.dev/people/Jacob%20Berendes'

Calling the CollectionResource object makes it process the incoming
request. Since this is a GET request, calling the resource publishes
the resource to the web. A CollectionResource is made up of a bunch of
EntryResources, and the base EntryResource class knows how to use the
entry schema class (in this case, IRecipeEntry) to publish a JSON
document.

A CollectionResource object also implements IPublishTraverse: you can
navigate from a collection to one of the entries in that collection.
It's the corresponding Collection's job to implement lookupEntry() so
that (for instance) /recipes/10 is mapped to the "Raw celery" Entry.

    >>> entry = collection.publishTraverse(request, "10")
    >>> entry
    <canonical.lazr.rest.resource.EntryResource object ...>
    >>> canonical_url(entry, request=request)
    u'http://api.launchpad.dev/recipes/10'

    >>> simplejson.loads(entry())
    {u'self_link': u'http://api.launchpad.dev/recipes/10',
     u'name': u'Raw celery',
     u'author_link': u'http://api.launchpad.dev/people/Jacob%20Berendes'}

If the user tries to traverse to a nonexistent object, the result is a
NotFound exception:

    >>> from zope.publisher.interfaces import NotFound
    >>> app.publishTraverse(request, "nosuchcollection")
    Traceback (most recent call last):
    ...
    NotFound: ... name: 'nosuchcollection'

    >>> collection.publishTraverse(request, "104")
    Traceback (most recent call last):
    ...
    NotFound: ... name: '104'

Eventually, an entry will be responsible for implementing
publishTraverse() to related entries (/recipes/10/owner) and
collections (/recipes/10/ingredients).
