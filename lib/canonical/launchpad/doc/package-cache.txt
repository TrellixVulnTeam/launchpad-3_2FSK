= Package Cache System =

Launchpad caches published packages (sources and binaries) details in
order to get better performance on searches.

Cached information for sources is stored in
DistributionSourcePackageCache table, including:

 * distribution, IDistribution where the source was published
 * sourcepackagename, respective ISourcePackageName
 * name, source name in text format.
 * binpkgnames, text containing all the binary package names generated
   by th source.
 * binpkgsummary, text containing all summaries of the binaries
   generated by this source.
 * binpkgdescription, text containing all descriptions of the binaries
   generated by this source.
 * fti, a tsvector generated on insert or update with the text indexes
   for name, binpkgnames, binpkgsummaries and binpkgdescriptions.

  >>> from canonical.launchpad.interfaces import IDistributionSet
  >>> from canonical.launchpad.database import (
  ...    DistributionSourcePackageCache)

  >>> ubuntu = getUtility(IDistributionSet)['ubuntu']

  >>> ubuntu_caches = DistributionSourcePackageCache.selectBy(
  ...     distribution=ubuntu)

  >>> ubuntu_caches.count()
  10

  >>> for cache in ubuntu_caches.orderBy('name'):
  ...     print cache.name
  alsa-utils
  cnews
  commercialpackage
  evolution
  foobar
  libstdc++
  linux-source-2.6.15
  mozilla-firefox
  netapplet
  pmount


Cached information for binaries is stored in DistroSeriesPackageCache
table, including:

 * distroseries, IDistroSeries where the binary is published.
 * binarypackagename, respective IBinaryPackageName.
 * name, binary name in text format.
 * summary, binary summary in text format.
 * description, binary description in text format.
 * summaries, binary summaries  in text format
 * descriptions, binary description in text format.
 * fti, a tsvector generated on insert or update with the text indexes
   for name, summary, description, summaries and descriptions.

  >>> from canonical.launchpad.database import (
  ...      DistroSeriesPackageCache)

  >>> warty = ubuntu['warty']
  >>> warty_caches = DistroSeriesPackageCache.selectBy(distroseries=warty)
  >>> warty_caches.count()
  5
  >>> for cache in warty_caches.orderBy('name'):
  ...     print cache.name
  at
  foobar
  linux-2.6.12
  mozilla-firefox
  pmount

Different than sources, where multiple generated binaries are very
common, multiple binaries of with the same name are only possible when
versions are not the same across architectures.

Building these caches we can reach good performance on full and
partial term searching.

  >>> len(ubuntu.searchSourcePackages('mozilla'))
  1

  >>> len(ubuntu.searchSourcePackages('moz'))
  1

  >>> len(ubuntu.searchSourcePackages('biscoito'))
  0

The cache update procedure is done by cronscripts/update-pkgcache.py,
which removes obsolete records, update existing ones and add new
records during the scanning of all the publishing records. This
scripts runs periodically in our infrastructure. See usage at
package-cache-script.txt.


== Dealing with Source Caches ==

A SourcePackage that has the status REMOVED will be deleted from the
cache when it's updated.

  >>> foobar_in_ubuntu = ubuntu.getSourcePackage('foobar')
  >>> foobar_rel = foobar_in_ubuntu.releases[0]
  >>> foobar_pub = foobar_rel.publishing_history[0]
  >>> foobar_pub.status.name
  'REMOVED'

  >>> len(ubuntu.searchSourcePackages('foobar'))
  1

  >>> foobar_cache = DistributionSourcePackageCache.selectOneBy(
  ...     distribution=ubuntu, name='foobar')

  >>> foobar_cache is not None
  True

Source cache updates are driven by distribution, IDistribution
instance offers a method for removing obsolete records in cache:

Let's use a fake logger object:

  >>> class TestLog:
  ...     def debug(self, msg):
  ...         print 'DEBUG: %s' % msg

  >>> ubuntu.removeOldCacheItems(log=TestLog())
  DEBUG: Removing source cache for 'foobar' (10)

  >>> import transaction
  >>> transaction.commit()

  >>> len(ubuntu.searchSourcePackages('foobar'))
  0

  >>> foobar_cache = DistributionSourcePackageCache.selectOneBy(
  ...     distribution=ubuntu, name='foobar')

  >>> foobar_cache is None
  True

A source package that has the status PUBLISHED will be added to the
cache when it's updated the next time.

  >>> cdrkit_in_ubuntu = ubuntu.getSourcePackage('cdrkit')
  >>> cdrkit_rel = cdrkit_in_ubuntu.releases[0]
  >>> cdrkit_pub = cdrkit_rel.publishing_history[0]
  >>> cdrkit_pub.status.name
  'PUBLISHED'

  >>> len(ubuntu.searchSourcePackages('cdrkit'))
  0

  >>> cdrkit_cache = DistributionSourcePackageCache.selectOneBy(
  ...     distribution=ubuntu, name='cdrkit')

  >>> cdrkit_cache is None
  True

We can invoke the cache updater directly on IDistroSeries:

  >>> ubuntu.updateCompleteSourcePackageCache(
  ...    ztm=transaction, log=TestLog())
  DEBUG: Considering source 'mozilla-firefox'
  ...
  DEBUG: Considering source 'cdrkit'
  DEBUG: Creating new source cache entry.
  ...

The current transaction should be committed since the script only
commits full batches of 50 elements:

  >>> transaction.commit()

Also updates should be flushed since the 'name' (among other texts)
are set after the row creation:

XXX cprov 20061201: flush_database_updates should not be required
after issuing a commit(), bug #3989

  >>> from canonical.database.sqlbase import flush_database_updates
  >>> flush_database_updates()

Now we see that the 'cdrkit' source is part of the caches and can be
reached via searches:

  >>> len(ubuntu.searchSourcePackages('cdrkit'))
  1

  >>> cdrkit_cache = DistributionSourcePackageCache.selectOneBy(
  ...     distribution=ubuntu, name='cdrkit')

  >>> cdrkit_cache is not None
  True


== Dealing with Binary Caches ==

A BinaryPackage that has the status REMOVED will be deleted from the
cache when it's updated.

  >>> foobar_bin_in_warty = warty.getBinaryPackage('foobar')
  >>> foobar_bin_rel = foobar_in_ubuntu.releases[0]
  >>> foobar_bin_pub = foobar_rel.publishing_history[0]
  >>> foobar_bin_pub.status.name
  'REMOVED'

  >>> len(warty.searchPackages('foobar'))
  1

  >>> foobar_bin_cache = DistroSeriesPackageCache.selectOneBy(
  ...     distroseries=warty, name='foobar')

  >>> foobar_bin_cache is not None
  True

Binary cache updates are driven by distroseries, IDistroSeries
instance offers a method for removing obsolete records in cache:

  >>> warty.removeOldCacheItems(log=TestLog())
  DEBUG: Removing binary cache for 'foobar' (8)

  >>> transaction.commit()

  >>> len(warty.searchPackages('foobar'))
  0

  >>> foobar_bin_cache = DistroSeriesPackageCache.selectOneBy(
  ...     distroseries=warty, name='foobar')

  >>> foobar_bin_cache is None
  True

A binary package that has been published since the last update of the
cache will be added to it.

  >>> cdrkit_bin_in_warty = warty.getBinaryPackage('cdrkit')
  >>> cdrkit_bin_pub = cdrkit_bin_in_warty.current_publishings[0]
  >>> cdrkit_bin_pub.status.name
  'PUBLISHED'

  >>> len(warty.searchPackages('cdrkit'))
  0

  >>> cdrkit_bin_cache = DistroSeriesPackageCache.selectOneBy(
  ...     distroseries=warty, name='cdrkit')

  >>> cdrkit_bin_cache is None
  True

We can invoke the cache updater directly on IDistroSeries:

  >>> warty.updateCompletePackageCache(
  ...    ztm=transaction, log=TestLog())
  DEBUG: Considering binary 'mozilla-firefox'
  ...
  DEBUG: Considering binary 'cdrkit'
  DEBUG: Creating new binary cache entry.
  ...

Transaction behaves exactly the same as for Source Caches, except that
it commits full batches of 100 elements.

  >>> transaction.commit()

XXX cprov 20061201: see above, same than Source cache interface), bug #3989

  >>> from canonical.database.sqlbase import flush_database_updates
  >>> flush_database_updates()

Now we see that the 'cdrkit' binary is part of the caches and can be
reached via searches:

  >>> len(warty.searchPackages('cdrkit'))
  1

  >>> cdrkit_bin_cache = DistroSeriesPackageCache.selectOneBy(
  ...     distroseries=warty, name='cdrkit')

  >>> cdrkit_bin_cache is not None
  True


== Package Counters ==

We also store counters for the number of Sources and Binaries
published in a DistroSeries pocket RELEASE:

  >>> warty.sourcecount
  3
  >>> warty.binarycount
  4

Since we have modified the publication list for warty in order to test
the caching system, we expect similar changes in the
counters. IDistroSeries provides a method to update its own cache:

  >>> warty.updatePackageCount()

New values were stored:

  >>> warty.sourcecount
  5
  >>> warty.binarycount
  6

A similar mechanism is offered by IDistroArchSeries, but only for
binaries (of course):

  >>> warty_i386 = warty['i386']

  >>> warty_i386.package_count
  5

Invoke the counter updater on this architecture:

  >>> warty_i386.updatePackageCount()

New values were stored:

  >>> warty_i386.package_count
  8
