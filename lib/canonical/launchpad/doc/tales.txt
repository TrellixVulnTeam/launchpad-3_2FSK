TALES expressions
=================

There are several kinds of TALES expressions we've implemented in
Launchpad, to help make it easier to create page templates, without
the need to introduce complex Python code in the template itself.

First, let's bring in a small helper function:

   >>> from canonical.launchpad.ftests import test_tales


== The count: namespace to get numbers ==

count:len gives you a number which is len(thing).

   >>> test_tales('foo/count:len', foo=[])
   0
   >>> test_tales('foo/count:len', foo=[1, 2, 3])
   3
   >>> test_tales('foo/count:len', foo=object())
   Traceback (most recent call last):
   ...
   TypeError: len() of unsized object


== The fmt: namespace to get strings ==

To display the icon for a milestone, use fmt:icon:

   >>> from canonical.launchpad.database import MilestoneSet
   >>> milestone = MilestoneSet().get(1)
   >>> test_tales("milestone/fmt:icon", milestone=milestone)
   '<img alt="" src="/@@/milestone" />'

datetimes can be formatted with fmt:date, fmt:time, fmt:datetime and
fmt:rfc822utcdatetime.

   >>> from datetime import datetime, timedelta
   >>> dt = datetime(2005, 4, 1, 16, 22)
   >>> test_tales('dt/fmt:date', dt=dt)
   '2005-04-01'
   >>> test_tales('dt/fmt:time', dt=dt)
   '16:22:00'
   >>> test_tales('dt/fmt:datetime', dt=dt)
   '2005-04-01 16:22:00'
   >>> test_tales('dt/fmt:rfc822utcdatetime', dt=dt)
   'Fri, 01 Apr 2005 16:22:00 -0000'

To truncate a long string, use fmt:shorten:

    >>> test_tales('foo/fmt:shorten/8', foo='abcdefghij')
    'abcde...'

To preserve newlines in text when displaying as HTML, use
fmt:nl_to_br:

    >>> test_tales('foo/fmt:nl_to_br',
    ...             foo='icicle\nbicycle\ntricycle & troika')
    'icicle<br />\nbicycle<br />\ntricycle &amp; troika'

To "<pre>" format a string, use fmt:nice_pre:

    >>> import pprint, textwrap
    >>> pprint.pprint(textwrap.wrap(
    ...     test_tales('foo/fmt:nice_pre', foo='hello & goodbye')
    ... ))
    ['<pre style="white-space: -moz-pre-wrap;white-space: -o-pre-wrap;word-',
     'wrap: break-word;">hello &amp; goodbye</pre>']

Add manual word breaks to long words in a string

    >>> test_tales('foo/fmt:break-long-words', foo='short words')
    'short words'
    >>> test_tales('foo/fmt:break-long-words',
    ...     foo='<http://launchpad.net/products/launchpad>')
    '&lt;http:/<wbr></wbr>/launchpad.<wbr></wbr>net/products/<wbr></wbr>launchpad&gt;'


== Test the 'fmt:' namespace where the context is a dict. ==

fmt:pagetitle takes a page template CONTEXTS dict, and gives you a string
for use in the <title> element of a page.

This case ought to apply only to a page template's CONTEXTS dict.  However, we
have to make this namespace available for all dicts, as there is no type
information to distinguish a page template CONTEXTS dict from any other dict.

    >>> class MockPageTemplateFile:
    ...     filename = '/blah/blah/debug-root-index.pt'
    ...
    >>> CONTEXTS = {'template': MockPageTemplateFile}
    >>> test_tales('foo/fmt:pagetitle', foo=CONTEXTS)
    'Launchpad Debug Home Page'


Test the 'fmt:url' namespace for canonical urls.

    >>> from canonical.launchpad.interfaces import ICanonicalUrlData
    >>> from zope.interface import implements
    >>> class ObjectThatHasUrl:
    ...     implements(ICanonicalUrlData)
    ...     path = 'bonobo/saki'
    ...     inside = None
    ...     rootsite = None

    >>> object_having_url = ObjectThatHasUrl()
    >>> test_tales('foo/fmt:url', foo=object_having_url)
    u'http://launchpad.dev/bonobo/saki'

Now, we need to test that it gets the correct application URL from the
request.

Make a mock-up IBrowserRequest, and use this as the interaction.

    >>> from zope.publisher.interfaces.browser import \
    ...     IBrowserApplicationRequest
    >>> from zope.interface import implements
    >>> class MockBrowserRequest:
    ...     implements(IBrowserApplicationRequest)
    ...
    ...     interaction = None
    ...     principal = None
    ...
    ...     def getApplicationURL(self):
    ...         return 'https://mandrill.example.org:23'

    >>> participation = MockBrowserRequest()

    >>> login(ANONYMOUS, participation)

    >>> test_tales('foo/fmt:url', foo=object_having_url)
    u'https://mandrill.example.org:23/bonobo/saki'


== The some_string/fmt:something helper ==

Test the 'fmt:' namespace where the context is None. In general, these
will return an empty string.  They are provided for ease of handling
NULL values from the database, which become None values for attributes
in content classes.

Everything you can do with 'something/fmt:foo', you should be able to
do with 'None/fmt:foo'.

    >>> test_tales('foo/fmt:shorten', foo=None)
    Traceback (most recent call last):
    ...
    TraversalError: 'you need to traverse a number after fmt:shorten'

    >>> test_tales('foo/fmt:shorten/8', foo=None)
    ''
    >>> test_tales('foo/fmt:nl_to_br', foo=None)
    ''
    >>> test_tales('foo/fmt:nice_pre', foo=None)
    ''
    >>> test_tales('foo/fmt:break-long-words', foo=None)
    ''
    >>> test_tales('foo/fmt:breadcrumbs', foo=None)
    ''
    >>> test_tales('foo/fmt:date', foo=None)
    ''
    >>> test_tales('foo/fmt:time', foo=None)
    ''
    >>> test_tales('foo/fmt:datetime', foo=None)
    ''
    >>> test_tales('foo/fmt:rfc822utcdatetime', foo=None)
    ''
    >>> test_tales('foo/fmt:pagetitle', foo=None)
    ''
    >>> test_tales('foo/fmt:text-to-html', foo=None)
    ''
    >>> test_tales('foo/fmt:url', foo=None)
    ''
    >>> test_tales('foo/fmt:exactduration', foo=None)
    ''
    >>> test_tales('foo/fmt:icon', foo=None)
    ''

== The lp: namespace for presenting DBSchema items ==

This is deprecated, and should raise a deprecation warning in the future,
and eventually be removed.  It is no longer needed, now that we have
an EnumCol for sqlobject.

Test the 'lp:' namespace for presenting DBSchema items.

    >>> from canonical.lp.dbschema import BinaryPackageFormat
    >>> deb = BinaryPackageFormat.DEB.value
    >>> test_tales('deb/lp:BinaryPackageFormat', deb=deb)
    'Ubuntu Package'


== The someobject/required:some.Permission helper ==

Test the 'required:' namespace.  We're already logged in as the anonymous user,
and anonymous users can't edit any person:

    >>> from canonical.launchpad.interfaces import IPersonSet
    >>> person = getUtility(IPersonSet).getByName('sabdfl')
    >>> test_tales('person/required:launchpad.Edit', person=person)
    False

Anonymous users can do anything with the zope.Public permission.

    >>> test_tales('person/required:zope.Public', person=person)
    True

Queries about permissions that don't exist will raise an exception:

    >>> test_tales('person/required:mushroom.Badger', person=person)
    Traceback (most recent call last):
    ...
    ValueError: ('Undefined permission id', 'mushroom.Badger')


== The somevalue/enumvalue:ENUMVALUE helper ==

You can test whether a particular value that you have in your page template
matches a particular valid value for that DBSchema enum.

This was going to be called 'enum-value', but Zope doesn't allow this.
To be fixed upstream.

    >>> from canonical.lp.dbschema import BinaryPackageFormat
    >>> deb = BinaryPackageFormat.DEB
    >>> udeb = BinaryPackageFormat.UDEB
    >>> test_tales('deb/enumvalue:DEB', deb=deb)
    True
    >>> test_tales('deb/enumvalue:DEB', deb=udeb)
    False

We don't get a ValueError when we use a value that doesn't appear in the
DBSchema the item comes from.

    >>> test_tales('deb/enumvalue:CHEESEFISH', deb=udeb)
    Traceback (most recent call last):
    ...
    TraversalError: 'The BinaryPackageFormat dbschema does not have a value CHEESEFISH.'

It is possible for dbschemas to have a 'None' value.  This is a bit awkward,
because when the value is None, we can't do any checking whether a new value
is from the correct schema.  In any case, this case is not currently handled.

The enumvalue tales expression is designed to work with security
wrapped dbschema items too:

    >>> from zope.security.proxy import ProxyFactory
    >>> wrapped_deb = ProxyFactory(BinaryPackageFormat.DEB)
    >>> test_tales('deb/enumvalue:DEB', deb=wrapped_deb)
    True
    >>> test_tales('deb/enumvalue:UDEB', deb=wrapped_deb)
    False
    >>> test_tales('deb/enumvalue:CHEESEFISH', deb=wrapped_deb)
    Traceback (most recent call last):
    ...
    TraversalError: 'The BinaryPackageFormat dbschema does not have a value CHEESEFISH.'
