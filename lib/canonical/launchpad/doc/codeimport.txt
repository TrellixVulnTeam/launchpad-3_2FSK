= Code Imports =

CodeImport objects model the process surrounding the code import service
of Launchpad. A CodeImport object is created by a user requesting an
import, the import source is then reviewed by privileged users. Then
importd, the code import daemon, performs the initial import that
populates the import branch, and updates it regularly.

We can import code from CVS or Subversion.


== Code import set utility ==

CodeImports are created and found using the ICodeImportSet interface,
which is registered as a utility.

    >>> from canonical.launchpad.interfaces import ICodeImport, ICodeImportSet
    >>> from zope.interface.verify import verifyObject
    >>> from zope.component import getUtility
    >>> from zope.security.proxy import removeSecurityProxy
    >>> code_import_set = getUtility(ICodeImportSet)
    >>> verifyObject(ICodeImportSet, removeSecurityProxy(code_import_set))
    True

CodeImports record who created them, and as we're also going to create
new Products to create CodeImports for, so we log in as No Privileges
Person.

    >>> login("no-priv@canonical.com")
    >>> from canonical.launchpad.webapp.interfaces import ILaunchBag
    >>> nopriv = getUtility(ILaunchBag).user

CodeImports are associated with a Branch when they are created; this
is how they are linked to a Product.  For the basic tests, we
associate the imports with a new branch for the FireFox project
(arbitrarily many imports can be created for a project).  A helper
function to create these branches the tests below easier to read.

    >>> from canonical.launchpad.interfaces import (
    ...     IBranchSet, ILaunchpadCelebrities, IPersonSet, IProductSet)
    >>> vcs_imports = getUtility(ILaunchpadCelebrities).vcs_imports
    >>> def new_import_branch(name):
    ...     product = getUtility(IProductSet).getByName('firefox')
    ...     return getUtility(IBranchSet).new(
    ...         name, vcs_imports, product,
    ...         None, 'Import branch')


== Supported source systems ==

The rcs_type field, which indicates whether the import is from CVS or
Subversion, takes values from the 'RevisionControlSystems' vocabulary.

    >>> from canonical.lp.dbschema import RevisionControlSystems


=== Import from CVS ===

Code imports from CVS specify the CVSROOT value, and the path to import
in the repository, known as the "module".

    >>> cvs = RevisionControlSystems.CVS
    >>> cvs_root = ':pserver:anonymous@cvs.example.com:/cvsroot'
    >>> cvs_module = 'hello'
    >>> cvs_branch = new_import_branch("trunk-cvs")
    >>> cvs_import = code_import_set.new(
    ...     registrant=nopriv, branch=cvs_branch,
    ...     rcs_type=cvs, cvs_root=cvs_root, cvs_module=cvs_module)
    >>> verifyObject(ICodeImport, removeSecurityProxy(cvs_import))
    True


=== Import from Subversion ===

Code imports from Subversion specify the URL used with "svn checkout" to
retrieve the tree to import.

    >>> svn = RevisionControlSystems.SVN
    >>> svn_url = 'svn://svn.example.com/trunk'
    >>> svn_branch = new_import_branch("trunk-svn")
    >>> svn_import = code_import_set.new(
    ...     registrant=nopriv, branch=svn_branch,
    ...     rcs_type=svn, svn_branch_url=svn_url)
    >>> verifyObject(ICodeImport, removeSecurityProxy(svn_import))
    True


== Creating a CodeImport from existing data ==

The first production code that creates CodeImports will be a sync
script that creates CodeImports from the existing information in the
ProductSeries table.  The only ProductSeries with such information in
the sample data is evolution/main.

    >>> from canonical.launchpad.interfaces import IProductSeriesSet
    >>> from canonical.lp.dbschema import ImportStatus
    >>> [series] = getUtility(IProductSeriesSet).search(
    ...     importstatus=ImportStatus.PROCESSING.value)
    >>> series.cvsroot
    u':pserver:anonymous@anoncvs.gnome.org:/cvs/gnome'
    >>> series.cvsmodule
    u'evolution'

Once we've found the series, creating a new CodeImport with the same
source details is a fairly simple matter.

    >>> from_existing_import = code_import_set.new(
    ...     registrant=vcs_imports, branch=series.import_branch, rcs_type=cvs,
    ...     cvs_root=series.cvsroot, cvs_module=series.cvsmodule)


== Retreiving CodeImports ==

You can retrieve all imports with the `getAll` method of ICodeImport.

    >>> svn_import in code_import_set.getAll()
    True

You can also retrive an import by id, which will be used to present the
object view for an import and also by branch, which will be used to
present the import's details on the page of the branch.

    >>> code_import_set.get(svn_import.id).svn_branch_url
    u'svn://svn.example.com/trunk'
    >>> code_import_set.getByBranch(cvs_branch).cvs_root
    u':pserver:anonymous@cvs.example.com:/cvsroot'


== CodeImportMachine ==

The simple CodeImportMachine table is a record of machines that can
perform code imports.  The table is represented by an object that
provides the ICodeImportMachineSet interface.

    >>> from canonical.launchpad.interfaces import ICodeImportMachineSet
    >>> code_import_machine_set = getUtility(ICodeImportMachineSet)
    >>> verifyObject(ICodeImportMachineSet,
    ...              removeSecurityProxy(code_import_machine_set))
    True

The table just records two people of information: a string "hostname"
that uniquely identifies the machine and a boolean "online" that
records whether the machine is currently online.

    >>> def go_online(hostname):
    ...     machine = code_import_machine_set.getByHostname(hostname)
    ...     if machine is None:
    ...         machine = code_import_machine_set.new(hostname, True)
    ...     else:
    ...         machine.online = True
    ...     return machine


