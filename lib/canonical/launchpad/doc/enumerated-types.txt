= Enumerated Types =

Enumerated types are used primarily in two distinct places in the Launchpad
code: selector types; and database types.

Simple enumerated types do not have values, whereas database enumerated
types are a mapping from an integer value to something meaningful in the
code.

    >>> from canonical.launchpad.webapp.enum import (
    ...     EnumeratedType, DBEnumeratedType, Item, DBItem, use_template)

The `enum` values of EnumeratedTypes are instances of Item.

    >>> class Fruit(EnumeratedType):
    ...     "A choice of fruit."
    ...     APPLE = Item('Apple')
    ...     PEAR = Item('Pear')
    ...     ORANGE = Item('Orange')


== IVocabulary support ==

Enumerated types support IVocabularyTokenized.

    >>> from zope.interface.verify import verifyObject
    >>> from zope.schema.interfaces import (
    ...     ITitledTokenizedTerm, IVocabularyTokenized)
    >>> verifyObject(IVocabularyTokenized, Fruit)
    True

The items themselves do not support any interface.  Items returned
by the methods for vocabularies return wrapped items that support
the ITitledTokenizedTerm interface.

The token used to identify terms in the vocabulary is the name of the
Item variable.

    >>> item = Fruit.getTermByToken('APPLE')
    >>> type(item)
    <class 'canonical.launchpad.webapp.enum.TokenizedItem'>
    >>> verifyObject(ITitledTokenizedTerm, item)
    True

TokenizedItems have three attributes (in order to support
ITitledTokenizedTerm):

    >>> item.value
    <Item Fruit.APPLE, Apple>
    >>> item.token
    'APPLE'
    >>> item.title
    'Apple'

The length of an EnumeratedType returns the number of items it has.

    >>> print len(Fruit)
    3


== Enumerated Type basics ==

An EnumeratedType has a name and a description.  The name is the same as the
class name, and the description is the docstring for the class.

    >>> print Fruit.name
    Fruit
    >>> print Fruit.description
    A choice of fruit.

If you do not specify an explicit sort_order for the items of the
EnumeratedType one is created for you.  This is tuple of the tokens.

    >>> print Fruit.sort_order
    ('APPLE', 'PEAR', 'ORANGE')

The items of an enumerated type can be iterated over.  However the type that
is returned by the iteration is the TokenizedItem, not the item itself.

    >>> for item in Fruit:
    ...     print item.token, item.title
    APPLE Apple
    PEAR Pear
    ORANGE Orange

Items in an enumerator support comparison and equality checks.

    >>> apple = Fruit.APPLE
    >>> pear = Fruit.PEAR
    >>> orange = Fruit.ORANGE
    >>> apple < pear
    True
    >>> apple == pear
    False
    >>> apple != pear
    True
    >>> apple > pear
    False
    >>> pear < orange
    True
    >>> apple < orange
    True

The string representation of an Item is the title, and the representation
also shows the enumeration that the Item is from.

    >>> print apple
    Apple
    >>> print repr(apple)
    <Item Fruit.APPLE, Apple>


== Database Enumerated Types ==

A very common use of enumerated types are to give semantic meaning to integer
values stored in database columns.  EnumeratedType Items themselves don't have
any integer values.

The DBEnumeratedType provides the semantic framework for a type that is used to
map integer values to python enumerated values.

    >>> class BranchType(DBEnumeratedType):
    ...     HOSTED = DBItem(1, """
    ...         Hosted
    ...
    ...         Hosted braches use the supermirror as the main repository
    ...         for the branch.""")
    ...
    ...     MIRRORED = DBItem(2, """
    ...         Mirrored
    ...
    ...         Mirrored branches are "pulled" from a remote location.""")
    ...
    ...     IMPORTED = DBItem(3, """
    ...         Imported
    ...
    ...         Imported branches are natively maintained in CVS or SVN""")

Note carefully that the value of a DBItem is the integer represenation.  But the
value of the TokenizedItem is the DBItem itself.

    >>> hosted = BranchType.HOSTED
    >>> hosted.value
    1
    >>> tokenized_item = BranchType.getTermByToken('HOSTED')
    >>> tokenized_item.value
    <DBItem BranchType.HOSTED, (1) Hosted>

DBEnumeratedTypes also support IVocabularyTokenized

    >>> verifyObject(IVocabularyTokenized, BranchType)
    True

DBEnumeratedTypes also have a method to retrieve the item based on the database
integer representation.

    >>> BranchType.getDBItemByValue(3)
    <DBItem BranchType.IMPORTED, (3) Imported>

Items in a DBEnumeratedType class must be of type DBItem.

    >>> class BadItemType(DBEnumeratedType):
    ...     TESTING = Item("Testing")
    Traceback (most recent call last):
    ...
    TypeError: Items must be of the appropriate type for the DBEnumeratedType, __builtin__.BadItemType.TESTING


== Overriding the sort order ==

By default the sort order of the items in an enumerated type is defined by the
order in which the Items are declared.  This my be overridden by specifying
a sort_order attribute in the class.

If a sort_order is specified, it has to specify every item in the enumeration.

    >>> class AnimalClassification(EnumeratedType):
    ...     sort_order = "REPTILE", "INSECT", "MAMMAL"
    ...     INSECT = Item("Insect")
    ...     MAMMAL = Item("Mammal")
    ...     FISH = Item("Fish")
    ...     REPTILE = Item("Reptile")
    Traceback (most recent call last):
    ...
    TypeError: sort_order for EnumeratedType must contain all and only Item instances ...

The sort_order may also appear anywhere in the definition of the class, although
convention has it that it appears first, before the Item instances.

    >>> class AnimalClassification(EnumeratedType):
    ...     sort_order = "REPTILE", "FISH", "INSECT", "MAMMAL"
    ...     INSECT = Item("Insect")
    ...     MAMMAL = Item("Mammal")
    ...     FISH = Item("Fish")
    ...     REPTILE = Item("Reptile")

The items attribute of the enumerated type is ordered based on the sort_order.
The items attribute is also used to control iteration using __iter__.

    >>> for item in AnimalClassification.items:
    ...     print item.title
    Reptile
    Fish
    Insect
    Mammal

The sort order also drives the comparison operations.

    >>> reptile, fish, insect, mammal = AnimalClassification.items
    >>> reptile < fish < insect < mammal
    True


== Extending enumerated types ==

The simplest way to extend a class is to derive from it.

    >>> class AnimalClassificationExtended(AnimalClassification):
    ...     INVERTEBRATE = Item("Invertebrate")

    >>> for item in AnimalClassificationExtended:
    ...     print item.title
    Reptile
    Fish
    Insect
    Mammal
    Invertebrate

The use_template function inserts the items from the specified enumerated type
into the new enumerated type.  The default case is to take all the enumerated
items.

    >>> class UIBranchType(EnumeratedType):
    ...     use_template(BranchType)
    >>> for item in UIBranchType:
    ...     print item.title
    Hosted
    Mirrored
    Imported

You can also specify items to be excluded by referring to the attribute name
in the exclude parameter.  This can be either a string referring to one name
or a tuple or list that refers to multiple attribute names.

    >>> class UIBranchType(EnumeratedType):
    ...     use_template(BranchType, exclude='IMPORTED')
    >>> for item in UIBranchType:
    ...     print item.title
    Hosted
    Mirrored

Or limit the items to those specified:

    >>> class UIBranchType(EnumeratedType):
    ...     use_template(BranchType, include=('HOSTED', 'MIRRORED'))
    >>> for item in UIBranchType:
    ...     print item.title
    Hosted
    Mirrored


== Getting from an item back to the enumerated type ==

Each Item in an EnumeratedType has a reference back to the EnumeratedType.

    >>> print repr(apple)
    <Item Fruit.APPLE, Apple>
    >>> print repr(apple.enum)
    <EnumeratedType 'Fruit'>
    >>> for item in apple.enum:
    ...     print item.title
    Apple
    Pear
    Orange
