Introduction
============

Bugs are problems in software. When a bug gets assigned to a specific
upstream or distro/sourcepackagename/binarypackagename, a bug /task/ is
created. In essence, a bug task is a bug that needs to be fixed in a specific
place. Where a bug has things like a title, comments and subscribers, it's
the bug task that tracks priority, severity, assignee, etc.

Working with Bug Tasks in Launchpad
===================================

Creating Bug Tasks
------------------

All BugTask creation and retrieval is done through an IBugTaskSet utility.

    >>> from zope.component import getUtility
    >>> import transaction
    >>> from canonical.launchpad.interfaces import IBugTaskSet
    >>> bugtaskset = getUtility(IBugTaskSet)

To create a bug task, you have to be logged in:

    >>> import zope.security.management
    >>> from zope.interface import implements
    >>> from zope.app.tests import ztapi
    >>> from canonical.launchpad.webapp.authentication import LaunchpadPrincipal
    >>> from canonical.launchpad.interfaces import ILaunchBag
    >>> class Participation:
    ...     interaction = None
    >>> foobar = LaunchpadPrincipal(
    ...     16, "firefox maintainer",
    ...     "i can't think of a description to write here")
    >>> foobar_participation = Participation()
    >>> foobar_participation.principal = foobar
    >>> zope.security.management.newInteraction(foobar_participation)
    >>> class MockLaunchBag(object):
    ...     implements(ILaunchBag)
    ...     def __init__(self, login=None, user=None):
    ...         self.login = login
    ...         self.user = user
    >>> ztapi.provideUtility(
    ...     ILaunchBag,
    ...     MockLaunchBag("foo.bar@canonical.com", foobar))

There are three kinds of bug tasks. We need to pass the bug task creation
methods some other objects to create a task, so lets get the utilities we need
to access those other objects:

    >>> from canonical.launchpad.interfaces import IBugSet, IPersonSet, \
    ...     IProductSet, IDistributionSet, IDistroReleaseSet
    >>> productset = getUtility(IProductSet)
    >>> distroset = getUtility(IDistributionSet)
    >>> distoreleaseset = getUtility(IDistroReleaseSet)
    >>> bugset = getUtility(IBugSet)
    >>> personset = getUtility(IPersonSet)
    >>> bug_one = bugset.get(1)
    >>> sabdfl = personset.get(1)

Next, we need to grab some values to provide for priority, severity and status.

    >>> from canonical.lp.dbschema import BugTaskStatus, BugSeverity, BugPriority
    >>> STATUS_NEW = BugTaskStatus.NEW.value
    >>> SEVERITY_NORMAL = BugSeverity.NORMAL.value
    >>> PRIORITY_MEDIUM = BugPriority.MEDIUM.value

  i. Upstream -- a bug that has to be fixed in an upstream product

    >>> evolution = productset.get(5)
    >>> upstream_task = bugtaskset.createTask(
    ...     bug = bug_one, product = evolution, owner = sabdfl,
    ...     status = STATUS_NEW, priority = PRIORITY_MEDIUM,
    ...     severity = SEVERITY_NORMAL)
    >>> upstream_task.product == evolution
    True

  ii. Distro -- a bug that has to be fixed in a specific distro

    >>> ubuntu = distroset.get(1)
    >>> distro_task = bugtaskset.createTask(
    ...     bug = bug_one, distribution = ubuntu, owner = sabdfl,
    ...     status = STATUS_NEW, priority = PRIORITY_MEDIUM,
    ...     severity = SEVERITY_NORMAL)
    >>> distro_task.distribution == ubuntu
    True

  ii. Distro Release -- a bug that has to be fixed in a specific distro
  release. This primary use case for distro release bug tasks is for backporting
  fixes (e.g. for security bugs or bugs causing critical data loss.)

    >>> hoary = distoreleaseset.get(3)
    >>> distro_release_task = bugtaskset.createTask(
    ...     bug = bug_one, distrorelease = hoary, owner = sabdfl,
    ...     status = STATUS_NEW, priority = PRIORITY_MEDIUM,
    ...     severity = SEVERITY_NORMAL)
    >>> distro_release_task.distrorelease == hoary
    True

XXX: Brad Bollenbach, 2005-02-24: See the bottom of this file for a chunk of
test documentation that is missing from here, due to problems with resetting
the connection after an IntegrityError is raised. ARGH.

Retrieving and Searching for Bug Tasks
--------------------------------------

To retrieve a specific BugTask, use IBugTaskSet.get. As an example, interacting
with the system as an anonymous (i.e. unauthenticated) user:

    >>> from canonical.launchpad.interfaces import IPerson
    >>> from canonical.launchpad.database import Person
    >>> class Principal:
    ...     def __init__(self, id):
    ...         self.id = id
    ...         self.groups = []
    >>> principal = Principal('launchpad.anonymous')

    >>> anon_participation = Participation()
    >>> anon_participation.principal = principal

    >>> zope.security.management.endInteraction()
    >>> zope.security.management.newInteraction(anon_participation)

    >>> launchbag = MockLaunchBag()
    >>> ztapi.provideUtility(ILaunchBag, launchbag)

let's fetch the BugTask with ID 1:

    >>> bugtask = bugtaskset.get(1)
    >>> bugtask.bugtitle
    u'Firefox does not support SVG'

If you pass an ID for which no object exists, you'll get a
zope.exceptions.NotFoundError:

    >>> bugtask = bugtaskset.get(-1)
    Traceback (most recent call last):
      ...
    NotFoundError: 'BugTask with ID -1 does not exist'

To retrieve a set of bug tasks matching a set of search criteria, use
BugTaskSet.search. Here's how you'd grab all the NEW and ACCEPTED tasks:

    >>> from canonical.launchpad.searchbuilder import any
    >>> from canonical.lp.dbschema import BugTaskStatus
    >>> from canonical.launchpad.database import Product
    >>> upstream_mozilla = Product.get(4)
    >>> bugtasks = bugtaskset.search(
    ...     status = any(BugTaskStatus.NEW.value, BugTaskStatus.ACCEPTED.value),
    ...     product = upstream_mozilla,
    ...     orderby = "id")
    >>> print bugtasks.count()
    4
    >>> bugtask_ids = [bt.id for bt in bugtasks]
    >>> print bugtask_ids
    [2, 13, 14, 15]

To provide null-matching search criteria, use canonical.launchpad.searchbuilder.NULL:

    >>> from canonical.launchpad.searchbuilder import NULL
    >>> bugtasks = bugtaskset.search(product = upstream_mozilla, assignee = NULL)
    >>> print bugtasks.count()
    2
    >>> print [bugtask.bug.id for bugtask in bugtasks]
    [6, 4]

There's also support for searching tasks based on a string of text, e.g.:

    >>> bugtasks = bugtaskset.search(
    ...     product = upstream_mozilla, searchtext = "instructions")
    >>> print bugtasks.count()
    1
    >>> print [bugtask.bug.id for bugtask in bugtasks]
    [5]

Bug Privacy
===========

A bug is either private or public. Private bugs are only visible (e.g. in
search listings) to explicit subscribers. Public bugs are visible to
anyone.

Let's log in as the user Foo Bar (to be allowed to edit bugs):

    >>> foobar = LaunchpadPrincipal(
    ...     16, "firefox maintainer",
    ...     "i can't think of a description to write here")
    >>> foobar_participation = Participation()
    >>> foobar_participation.principal = foobar
    >>> zope.security.management.endInteraction()
    >>> zope.security.management.newInteraction(foobar_participation)
    >>> ztapi.provideUtility(
    ...     ILaunchBag,
    ...     MockLaunchBag("foo.bar@canonical.com", foobar))

and mark one of the Firefox bugs private:

    >>> bug_firefox_no_svg_support = bugtaskset.get(2)
    >>> bug_firefox_no_svg_support.bug.private = True
    >>> transaction.commit()

Now the same search as above yields only three bugs, because Foo Bar can't see
the private bug (XXX: Brad Bollenbach, 2005-02-04: admittedly, this example is
a bit contrived; setting a bug private and then not being able to see it
anymore is not something one could do through the UI. I'm stumbling through
this test this way until bug #104/production gets fixed so that one doesn't
require so much boilerplate to simulate logins in tests.)

    >>> bugtasks = bugtaskset.search(
    ...     status = any(BugTaskStatus.NEW.value, BugTaskStatus.ACCEPTED.value),
    ...     product = upstream_mozilla,
    ...     orderby = "id")
    >>> print bugtasks.count()
    3
    >>> bugtask_ids = [bt.id for bt in bugtasks]
    >>> print bugtask_ids
    [13, 14, 15]

Trying to retrieve the bug directly will work fine:

    >>> bug_firefox_no_svg_support = bugtaskset.get(2)

But attribute access on the IBugTask will raise an authorization exception:

    >>> bug_firefox_no_svg_support.bug
    Traceback (most recent call last):
      ...
    Unauthorized: ('bug', 'launchpad.View')

But, logged in as the Firefox maintainer:

    XXX: Brad Bollenbach, 2005-01-26: Simulating a login in a test needs to be
    a one-liner. See: https://launchpad.ubuntu.com/malone/bugs/104

    >>> firefox_maintainer = Person.get(12)
    >>> firefox_maintainer_participation = Participation()
    >>> firefox_maintainer_participation.principal = firefox_maintainer
    >>> zope.security.management.endInteraction()
    >>> zope.security.management.newInteraction(firefox_maintainer_participation)

    >>> ztapi.provideUtility(
    ...     ILaunchBag, MockLaunchBag("test@canonical.com", firefox_maintainer))

We'll find all four IBugTasks that match the search criteria, as the maintainer
is also an explicit subscriber in this case.

    >>> bugtasks = bugtaskset.search(
    ...     status = any(BugTaskStatus.NEW.value, BugTaskStatus.ACCEPTED.value),
    ...     product = upstream_mozilla,
    ...     orderby = "id")
    >>> print bugtasks.count()
    4
    >>> bugtask_ids = [bt.id for bt in bugtasks]
    >>> print bugtask_ids
    [2, 13, 14, 15]

And, as you would expect, we'll also be able to access it directly:

    >>> bug_firefox_no_svg_support = bugtaskset.get(2)
    >>> bug_firefox_no_svg_support.bug.title
    u'Firefox does not support SVG'

XXX: Brad Bollenbach, 2005-02-24: This bit testing the IntegrityError should be
higher up in the file (under the explanation about creating tasks), but I can't
figure out how to reset the connection properly after an IntegrityError is
raised. ARGH.

Note that a task filed on a specific distro release does *not* have its
distribution column set. In fact, a task must have exactly one of its product,
distribution or distrorelease fields set, otherwise the database integrity
constraints will be violated.

    >>> bad_task = bugtaskset.createTask(
    ...     bug = bug_one, distribution = ubuntu, distrorelease = hoary,
    ...     owner = sabdfl, status = STATUS_NEW, priority = PRIORITY_MEDIUM,
    ...     severity = SEVERITY_NORMAL)
    Traceback (most recent call last):
      ...
    IntegrityError: ...

XXX: Brad Bollenbach, 2005-02-03: this shouldn't be in a doctest, but I don't
have time to think about a better place to put this at the moment.

    >>> ztapi.unprovideUtility(ILaunchBag)
    >>> zope.security.management.endInteraction()
