= Bazaar Branches =

The Branch table holds information about an Bazaar Branch. It describes the
Launchpad user model of a branch, and in particular should be able (in the
future) to support un-committing of revisions.

It has a N-N association to the Revision table through the RevisionNumber
table. An association table is required because the sequence of revisions
listed by "bzr log" is defined by a "revision-history" file which has some
freedom with respect to the ancestry of revisions.

  * Distinct revision histories may point to same revision.

  * Revision histories including the same revision may have different starting
    points, they need not trace history back to the initial import. Therefore a
    given revision may have a different order number in different branches.

  * A revision history is required to follow the ancestry DAG, but two
    different branches may have histories tracing a different path between two
    shared revisions. This is exercised by the "convergence" feature of "bzr
    pull".

A Branch is not tied to an URL, since a branch may change locations over time.
It's not tied to a specific revision history because each new commit appends to
the history, and it's not restricted to appending to the history because the
Bazaar model does not forbid users from replacing the history of a branch.

Bazaar does not have a identifiable concept of a Branch below the user
interface level. Since the conceptual model of Bazaar does not define Branch,
Launchpad cannot just implement the Bazaar branch model. You should think of a
Branch, not as "a Bazaar branch in Launchpad", but as a "Launchpad branch based
on Bazaar". If that makes any sense to you. Otherwise, don't worry.

== Creating branches ==

Branches can be created with IBranchSet.new. IBranchSet can be accessed as an
utility.

>>> from zope.component import getUtility
>>> from canonical.launchpad.interfaces import IBranchSet, NotFoundError
>>> branchset = getUtility(IBranchSet)

It must define the IBranchSet interface.

>>> from zope.interface.verify import verifyObject
>>> verifyObject(IBranchSet, branchset)
True

>>> from canonical.launchpad.interfaces import IProductSet
>>> productset = getUtility(IProductSet)
>>> gterm_product = productset.get(6)

>>> print branchset.get(-1)
None

A branch is retrievable via BranchSet's __getitem__ 

>>> branchset[24].name
u'launchpad'

If it doesn't exist an exception NotFoundError is raised

>>> try:
...     branchset[-1]
... except NotFoundError:
...     pass

>>> from canonical.launchpad.interfaces import IPersonSet
>>> personset = getUtility(IPersonSet)
>>> ddaa = personset.getByName('ddaa')

>>> gterm_dev_url = 'http://example.com/~ddaa/gterm.dev'
>>> title = "David Allouche's Main GNOME Terminal Branch"
>>> summary = "Main line of development for David Allouche on GNOME Terminal."
>>> home_page = "http://example.com/~ddaa/"
>>> gterm_dev = branchset.new('dev', ddaa, gterm_product, gterm_dev_url,
...     title, summary=summary, home_page=home_page)
>>> gterm_dev.name
u'dev'
>>> gterm_dev.product == gterm_product
True
>>> gterm_dev.url
u'http://example.com/~ddaa/gterm.dev'

Branches must implement the IBranch interface.

>>> from zope.interface.verify import verifyObject
>>> from canonical.launchpad.interfaces import IBranch
>>> verifyObject(IBranch, gterm_dev)
True

Branch may or may not be associated to a product, and may have no home_page,
no title, and no summary, and even no URL.

Branches with no URL are primarily hosted on the supermirror.

>>> url = 'http://example.com/~ddaa/junkcode'
>>> junkcode = branchset.new('junkcode', ddaa, None, None)
>>> junkcode.name
u'junkcode'
>>> print repr(junkcode.product)
None
>>> print repr(junkcode.home_page)
None
>>> print repr(junkcode.title)
None
>>> print repr(junkcode.summary)
None
>>> print repr(junkcode.url)
None

== Finding a branch by URL ==

It is possible to find a branch by URL. Either using the pull URL:

>>> branchset.getByUrl(gterm_dev_url) == gterm_dev
True

Or using the Supermirror URL of the same branch:

>>> from canonical.database.sqlbase import flush_database_updates
>>> flush_database_updates()
>>> gterm_dev_supermirror = \
...     u'http://bazaar.launchpad.net/~ddaa/gnome-terminal/dev'
>>> branchset.getByUrl(gterm_dev_supermirror) == gterm_dev
True
>>> junkcode_supermirror = \
...     u'http://bazaar.launchpad.net/~ddaa/+junk/junkcode'
>>> branchset.getByUrl(junkcode_supermirror) == junkcode or \
...     ('failed', branchset.getByUrl(junkcode_supermirror))
True

The provided URL must not have any trailing slash:

>>> try: branchset.getByUrl(gterm_dev_url + '/')
... except AssertionError: print 'trailing slash not allowed'
trailing slash not allowed

If no branch is found for the specified URL, the specified default value is
returned.

>>> not_there_url = 'http//example.com/not-in-the-sample-data'
>>> print branchset.getByUrl(not_there_url)
None
>>> print branchset.getByUrl(not_there_url, 123)
123

== Branches and products ==

Branch not associated to a product are called "junk" branch and treated for
navigation purposes as if they were associated to a magic product named
"+junk".

>>> junkcode.product_name
'+junk'
>>> gterm_dev.product_name
u'gnome-terminal'

== Branch names ==

Branches have a unique name, that is based on the names of the owner, product
and branch.

>>> pushed = branchset[25]
>>> pushed.unique_name
u'~name12/gnome-terminal/pushed'
>>> junkcode.unique_name
u'~ddaa/+junk/junkcode'

Branches have a display name that is the Branch.title if it's provided, and the
unique_name otherwise.

>>> assert gterm_dev.title is not None
>>> gterm_dev.displayname == gterm_dev.title
True
>>> assert pushed.title is None
>>> pushed.displayname == pushed.unique_name
True

== Branches registered and authored ==

You can get the list of branches for a given Launchpad owner. These are called
the "registered branches", because the owner is initially set to the current
user by the branch creation forms.

>>> def getName(branch):
...     return branch.name
>>> sorted(ddaa.registered_branches, key=getName) == [gterm_dev, junkcode]
True

Branches are associated to an "author" user, which may be different from the
registrant. You can get the branch authored by a given person. Junk branches
should generally have at least an author, but that is not enforced.

>>> list(ddaa.authored_branches)
[]
>>> junkcode.author = ddaa

>>> from canonical.database.sqlbase import flush_database_caches
>>> flush_database_caches()
>>> list(ddaa.authored_branches) == [junkcode]
True

The list of registered branches does not include branches whose registrant is
also the author. That avoids duplicating the same branch in the registered and
authored branch listings for a person.

>>> list(ddaa.registered_branches) == [gterm_dev]
True

== Branch sort key ==

Branches have a sort_key attribute which is used through Launchpad to order
branch listings in a consistent and predictable way.

The sort key is made of:

  * product name (if applicable)
  * lifecycle status sort key
  * author's browser name (if applicable)
  * branch name
  * owner's nickname

The owner's name is usually not displayed in branch listings, but it is used in
the sort key to garantee a predictable sort order. This relies on the fact that
(owner, product, name) is unique for all branches.

If the product or author of a branch is NULL, the corresponding item in the
sort key is None.

>>> from canonical.lp.dbschema import BranchLifecycleStatus
>>> gterm_slowness = branchset[19]
>>> key = gterm_slowness.sort_key
>>> key
(u'gnome-terminal', ..., u'Sample Person', u'slowness', u'name12')
>>> key[1] == BranchLifecycleStatus.MERGED.sortkey
True

== Branch subscriptions ==

Branches can be subscribed to and unsubscribed from by a Person.

>>> from canonical.launchpad.interfaces import IPerson, IBranchSubscription
>>> sabdfl = personset.getByName('sabdfl')
>>> sabdfl.subscribed_branches
[]
>>> subscription = gterm_dev.subscribe(sabdfl)
>>> verifyObject(IBranchSubscription, subscription)
True
>>> subscription.branch == gterm_dev and subscription.person == sabdfl
True
>>> gterm_dev.subscriptions[0] == subscription
True
>>> gterm_dev.subscribers == [sabdfl]
True
>>> sabdfl.subscribed_branches == [gterm_dev]
True
>>> gterm_dev.unsubscribe(sabdfl)
>>> gterm_dev.subscribers
[]

== Branches related to a person ==

Finally, you can get the list of related branches for a person, that includes
the branches registered, authored and subscribed to by this person.

>>> lifeless = personset.getByName('lifeless')
>>> lifeless.branches
[]
>>> url = 'http://example.com/~lifeless/mesh-merge'
>>> title = "Experimental mesh merging algorithm."
>>> meshmerge = branchset.new('mesh-merge', lifeless, None, url,
...     title, summary=title)
>>> junkcode.author = lifeless
>>> unused = gterm_dev.subscribe(lifeless)
>>> flush_database_caches()
>>> sorted(lifeless.branches, key=getName) == [gterm_dev, junkcode, meshmerge]
True

== Branches and revisions ==

See revision.txt for a doctest covering the creation of revisions and related
objects. Revision data is loaded in the database by a batch job using a
different user, Launchpad code is only concened with using this data.

Let's get a branch with some revisions in it.

>>> sample_person = personset.getByName('name12')
>>> junk = sample_person.getBranch(None, 'junk.dev')

== Revision history of Branch ==

Branch.revision_history gives the sequence of revisions in this branch's
history, latest revisions first. All revision history items must implement the
IRevisionNumber interface. The Branch.revision_count() method gives the length
of the revision_history attribute but without building the list.

>>> from canonical.launchpad.interfaces import IRevisionNumber
>>> count = junk.revision_count()
>>> count
6
>>> [verifyObject(IRevisionNumber, a) for a in junk.revision_history]
[True, True, True, True, True, True]
>>> [revno.sequence for revno in junk.revision_history]
[6, 5, 4, 3, 2, 1]

There are two methods for getting only the the latest items of the revision
history.

Branch.latest_revisions give a specific count of RevisionNumbers at the end of
the history.

>>> three_latest = list(junk.revision_history)[:3]
>>> list(junk.latest_revisions(3)) == three_latest
True

Branch.revisions_since gives all the RevisionNumbers for revisions comitted
since a given timestamp. It may give suprising results if some committers had a
skewed clock.

>>> from datetime import datetime
>>> timestamp = datetime(2005, 10, 31, 12, 00, 00)
>>> two_latest = list(junk.revision_history)[:2]
>>> list(junk.revisions_since(timestamp)) == two_latest
True

== Ancestry of Revision ==

The revision-history of a given branch, is only one possible ancestry path in
the ancestry graph. It is also possible to examine the ancestry graph directly.

A Bazaar branch may contains references (by revision_id) to revisions for which
no data is available. Such revisions are called "ghosts".

Initial commits (after a "bzr init") revisions have no parent.

>>> history = list(junk.revision_history)
>>> initial = history[-1].revision
>>> initial.parent_ids
[]

Normal commits (as opposed to merges) have exactly one parent. The first parent
of a revision is always the revision that was current when committing.

>>> commit = history[-2].revision
>>> [type(a) for a in commit.parent_ids] == [unicode]
True

Merges usually have two parents, but they may have more. Though the bzr user
interface discourage such complex merges.

>>> merge = history[-4].revision
>>> len(merge.parent_ids)
2

Parent revisions are identified by their globally unique id, and not by a
foreign key, so existing parents and ghosts can be modelled in the same way.

To try and retrieve a Revision given its globally unique id, you can use the
RevisionSet utility.

>>> from canonical.launchpad.interfaces import IRevisionSet
>>> revisionset = getUtility(IRevisionSet)
>>> [parent_id] = commit.parent_ids
>>> parent = revisionset.getByRevisionId(parent_id)
>>> parent == initial
True

If the parent was a ghost at import time and is not currently available in the
database. getByRevisionId returns None.

>>> revisionset.getByRevisionId('missing-revision-id') is None
True

