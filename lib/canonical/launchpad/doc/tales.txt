= TALES expressions =

There are several kinds of TALES expressions we've implemented in
Launchpad, to help make it easier to create page templates, without
the need to introduce complex Python code in the template itself.

First, let's bring in a small helper function:

   >>> from canonical.launchpad.ftests import test_tales


== The count: namespace to get numbers ==

count:len gives you a number which is len(thing).

   >>> test_tales('foo/count:len', foo=[])
   0
   >>> test_tales('foo/count:len', foo=[1, 2, 3])
   3
   >>> test_tales('foo/count:len', foo=object())
   Traceback (most recent call last):
   ...
   TypeError: len() of unsized object


== The fmt: namespace to get strings ==

To display the icon for a milestone, use image:icon:

   >>> from canonical.launchpad.database import MilestoneSet
   >>> milestone = MilestoneSet().get(1)
   >>> test_tales("milestone/image:icon", milestone=milestone)
   '<img ... src="/@@/milestone" />'

The same image:icon, as well as a image:logo and a image:logo is also
available for Person, Product, Project, Sprint and Distributions, since
they all implement IHasLogo,.IHasMugshot and IHasIcon.

    >>> from canonical.launchpad.interfaces import IPersonSet
    >>> person = getUtility(IPersonSet).getByName('sabdfl')
    >>> test_tales("person/image:icon", person=person)
    '<img ... src="/@@/person" />'
    >>> test_tales("person/image:logo", person=person)
    '<img ... src="/@@/person-logo" />'

The Mugshot is presented in a div, floating right, with the mugshot inside
it:

    >>> test_tales("person/image:mugshot", person=person)
    '<div...<img...src="/@@/person-mugshot" />.../div>'

For people we even have different images in case the person in question is not
an actual launchpad user.

    >>> spiv = getUtility(IPersonSet).getByName('spiv')
    >>> spiv.is_valid_person
    False
    >>> test_tales("person/image:icon", person=spiv)
    '<img ... src="/@@/person-inactive" />'
    >>> test_tales("person/image:logo", person=spiv)
    '<img ... src="/@@/person-inactive-logo" />'
    >>> test_tales("person/image:mugshot", person=spiv)
    '...<img...src="/@@/person-inactive-mugshot" />...'

If you are on feeds.launchpad.net, you need to specify the rootsite, so
that the links and images are pointing at the right hostname.

    >>> test_tales("person/fmt:link:mainsite/foo/bar", person=spiv)
    u'<a href="http://launchpad.dev/~spiv/foo/bar"><img...src="http://launchpad.dev/@@/person-inactive"...'
    >>> test_tales("person/fmt:link:bugs/foo/bar", person=spiv)
    u'<a href="http://bugs.launchpad.dev/~spiv/foo/bar"><img...src="http://bugs.launchpad.dev/@@/person-inactive"...'

We also have image:icon for KarmaCategory:

    >>> from canonical.launchpad.database import KarmaCategory
    >>> for category in KarmaCategory.select(orderBy='title'):
    ...     print test_tales("category/image:icon", category=category)
    <img ... title="Answer Tracker" src="/@@/question" />
    <img ... title="Bug Management" src="/@@/bug" />
    <img ... title="Specification Tracking" src="/@@/blueprint" />
    <img ... title="Translations in Rosetta" src="/@@/translation" />

datetimes can be formatted with fmt:date, fmt:time, fmt:datetime and
fmt:rfc822utcdatetime.

   >>> from datetime import datetime, timedelta
   >>> dt = datetime(2005, 4, 1, 16, 22)
   >>> test_tales('dt/fmt:date', dt=dt)
   '2005-04-01'
   >>> test_tales('dt/fmt:time', dt=dt)
   '16:22:00'
   >>> test_tales('dt/fmt:datetime', dt=dt)
   '2005-04-01 16:22:00'
   >>> test_tales('dt/fmt:rfc822utcdatetime', dt=dt)
   'Fri, 01 Apr 2005 16:22:00 -0000'

To truncate a long string, use fmt:shorten:

    >>> test_tales('foo/fmt:shorten/8', foo='abcdefghij')
    'abcde...'

To preserve newlines in text when displaying as HTML, use
fmt:nl_to_br:

    >>> test_tales('foo/fmt:nl_to_br',
    ...             foo='icicle\nbicycle\ntricycle & troika')
    'icicle<br />\nbicycle<br />\ntricycle &amp; troika'

To "<pre>" format a string, use fmt:nice_pre:

    >>> import pprint, textwrap
    >>> pprint.pprint(textwrap.wrap(
    ...     test_tales('foo/fmt:nice_pre', foo='hello & goodbye')
    ... ))
    ['<pre style="white-space: -moz-pre-wrap;white-space: -o-pre-wrap;word-',
     'wrap: break-word;">hello &amp; goodbye</pre>']

Add manual word breaks to long words in a string:

    >>> test_tales('foo/fmt:break-long-words', foo='short words')
    'short words'
    >>> test_tales('foo/fmt:break-long-words',
    ...     foo='<http://launchpad.net/products/launchpad>')
    '&lt;http:/<wbr></wbr>/launchpad.<wbr></wbr>net/products/<wbr></wbr>launchpad&gt;'


== The fmt: namespace to get strings (links) ==

The `fmt:link` tales expression provides a way to define a standard link
to a content object.  There are currently links defined for:
  * people / teams
  * branches
  * bugs
  * bug tasks

For a person or team, fmt:link gives us a link to that person's page,
containing the person name and an icon.

    >>> test_tales("person/fmt:link", person=person)
    u'<a ...><img ... src="/@@/person" />&nbsp;Mark Shuttleworth</a>'

    >>> test_tales("person/fmt:link", person=spiv)
    u'<a ...><img ... src="/@@/person-inactive" />&nbsp;Andrew Bennetts</a>'

    >>> ubuntu_team = getUtility(IPersonSet).getByName('ubuntu-team')
    >>> test_tales("person/fmt:link", person=ubuntu_team)
    u'<a ...><img ... src="/@@/team" />&nbsp;Ubuntu Team</a>'

The fmt:link formatter uses additional path components to extend the
link:

    >>> test_tales("person/fmt:link/foo/bar", person=spiv)
    u'<a href=".../~spiv/foo/bar">...'

For branches, fmt:link links to the branch page.

    >>> from canonical.launchpad.interfaces import IBranchSet
    >>> branch = getUtility(IBranchSet).getByUniqueName(
    ...     '~name12/gnome-terminal/main')
    >>> test_tales("branch/fmt:link", branch=branch)
    u'<a href=".../~name12/gnome-terminal/main" title="GNOME Terminal Mainline"><img src="/@@/branch"...>&nbsp;~name12/gnome-terminal/main</a>'

For bugs, fmt:link takes to the bug redirect page.

    >>> from canonical.launchpad.interfaces import IBugSet
    >>> test_tales("bug/fmt:link", bug=getUtility(IBugSet).get(1))
    u'<a href=".../bugs/1"><img src="/@@/bug"...>&nbsp;Bug #1: Firefox does not support SVG</a>'

For bugtasks, fmt:link shows the severity bug icon, and links to the
appropriate project's bug.

    >>> bugtask = getUtility(IBugSet).get(1).bugtasks[0]
    >>> test_tales("bugtask/fmt:link", bugtask=bugtask)
    u'<a href=".../firefox/+bug/1"><img ...src="/@@/bug-low" />&nbsp;Bug #1: Firefox does not support SVG</a>'


== The fmt: namespace to get strings (hiding) ==

PGP blocks, signatures and full-quoted parts of a message can be
wrapped in markup to hide them:

    >>> pgp_open = ('-----BEGIN PGP SIGNED MESSAGE-----\n'
    ...             'Hash: SHA1\n'
    ...             '\n')
    >>> text = ('Top quoting is simply bad netiquette.\n'
    ...         'The words of the leading text should be displayed\n'
    ...         'normally--no markup to hide it from view.\n'
    ...         'Raise your hand if you can read this.\n'
    ...         '\n')
    >>> signature = ('-- \n'
    ...              '__C U R T I S  C.  H O V E Y_______\n'
    ...              'sinzui.is@example.org\n'
    ...              'Guilty of stealing everything I am.\n'
    ...              '\n')
    >>> pgp_close = ('-----BEGIN PGP SIGNATURE-----\n'
    ...              'Version: GnuPG v1.4.1 (GNU/Linux)\n'
    ...              'Comment: Using GnuPG with Thunderbird\n'
    ...              '\n'
    ...              'iD8DBQFED60Y0F+nu1YWqI0RAqrNAJ9hTww5vqDbxp4xJS8ek58W\n'
    ...              'T2PIWy0CUJsX8RXSt/M51WE=\n'
    ...              '=J2S5\n'
    ...              '-----END PGP SIGNATURE-----\n')

The email-to-html formatter marks up text as html using the
text-to-html formatter, then adds additional markup to identify
signatures and quoted passages. The formatters  wraps the text inside
the paragraph in a span of 'foldable' class. Stylesheets and scripts
in the browser can format or change the behaviour of the text as
needed.

When given simple paragraphs it behaves just as the text-to-html
formatter.

    >>> print test_tales('foo/fmt:email-to-html',
    ...                  foo=text)
    <p>Top quoting is simply bad netiquette.<br />
    The words of the leading text should be displayed<br />
    normally--no markup to hide it from view.<br />
    Raise your hand if you can read this.</p>

    >>> print test_tales('foo/fmt:text-to-html',
    ...                  foo=text)
    <p>Top quoting is simply bad netiquette.<br />
    The words of the leading text should be displayed<br />
    normally--no markup to hide it from view.<br />
    Raise your hand if you can read this.</p>


=== Marking PGP blocks ===

PGP signed messages have opening and closing blocks that are
wrapped in a foldable span.

    >>> print test_tales('foo/fmt:email-to-html',
    ...                  foo='\n'.join([pgp_open, text, pgp_close]))
    <p><span class="foldable">-----BEGIN PGP SIGNED MESSAGE-----<br />
    Hash: SHA1
    </span></p>
    <p>Top quoting is simply bad netiquette.<br />
    The words of the leading text should be displayed<br />
    normally--no markup to hide it from view.<br />
    Raise your hand if you can read this.</p>
    <p><span class="foldable">-----BEGIN PGP SIGNATURE-----<br />
    Version: GnuPG v1.4.1 (GNU/Linux)<br />
    Comment: Using GnuPG with Thunderbird<br />
    <br />
    iD8DBQFED60Y0F+<wbr></wbr>nu1YWqI0RAqrNAJ<wbr></wbr>...
    T2PIWy0CUJsX8RX<wbr></wbr>St/M51WE=<br />
    =J2S5<br />
    -----END PGP SIGNATURE-----
    </span></p>

In this example, we see the main paragraph and the signature marked
up as HTML. All the text inside the signature is wrapped with the
foldable span.

    >>> print test_tales('foo/fmt:email-to-html',
    ...                  foo='\n'.join([text, signature]))
    <p>Top quoting is simply bad netiquette.<br />
    The words of the leading text should be displayed<br />
    normally--no markup to hide it from view.<br />
    Raise your hand if you can read this.</p>
    <p><span class="foldable"...>--<br />
    __C U R T I S  C.  H O V E Y_______<br />
    sinzui.<wbr></wbr>is@example.<wbr></wbr>org<br />
    Guilty of stealing everything I am.
    </span></p>


=== Marking quoted passages ===

Quoted passages are treated somewhat different from signatures because
they often have a citation line before the quoted text. In this
example of the main paragraph and the quoted paragraph, only the
lines that start with the quote identifier ('> ' in this case) are
wrapped with the foldable-quoted span.

    >>> quoted_text = ('Somebody said sometime ago:\n'
    ...                '> 1. Remove the letters  c, j, q, x, w\n'
    ...                '>    from the English Language.\n'
    ...                '> 2. Remove the penny from US currency.\n'
    ...                '\n')
    >>> quoted_text_all = ('> continuing from a previous thought.\n'
    ...                    '> 3. Get new handwriting.\n'
    ...                    '> 4. Add Year Zero to the calendar.\n'
    ...                    '\n')
    >>> print test_tales('foo/fmt:email-to-html',
    ...                  foo='\n'.join([text, quoted_text, quoted_text_all]))
    <p>Top quoting is simply bad netiquette.<br />
    The words of the leading text should be displayed<br />
    normally--no markup to hide it from view.<br />
    Raise your hand if you can read this.</p>
    <p>Somebody said sometime ago:<br />
    <span class="foldable-quoted">
    &gt; 1. Remove the letters  c, j, q, x, w<br />
    &gt;    from the English Language.<br />
    &gt; 2. Remove the penny from US currency.
    </span></p>
    <p><span class="foldable-quoted">&gt; continuing from a previous thoug...
    &gt; 3. Get new handwriting.<br />
    &gt; 4. Add Year Zero to the calendar.
    </span></p>


=== Different kinds of content can be marked up in a single call ===

The formatter is indifferent to the number and kinds of paragraphs
it must markup. We can format the three examples at the same time.

    >>> print test_tales('foo/fmt:email-to-html',
    ...     foo='\n'.join(
    ...         [text, quoted_text, text, quoted_text_all, signature]))
    <p>Top quoting is simply bad netiquette.<br />
    The words of the leading text should be displayed<br />
    normally--no markup to hide it from view.<br />
    Raise your hand if you can read this.</p>
    <p>Somebody said sometime ago:<br />
    <span class="foldable-quoted"...>
    &gt; 1. Remove the letters  c, j, q, x, w<br />
    &gt;    from the English Language.<br />
    &gt; 2. Remove the penny from US currency.
    </span></p>
    <p>Top quoting is simply bad netiquette.<br />
    The words of the leading text should be displayed<br />
    normally--no markup to hide it from view.<br />
    Raise your hand if you can read this.</p>
    <p><span class="foldable-quoted">&gt; continuing from a previous thoug...
    &gt; 3. Get new handwriting.<br />
    &gt; 4. Add Year Zero to the calendar.
    </span></p>
    <p><span class="foldable"...>--<br />
    __C U R T I S  C.  H O V E Y_______<br />
    sinzui.<wbr></wbr>is@example.<wbr></wbr>org<br />
    Guilty of stealing everything I am.
    </span></p>


== The fmt: namespace to get strings (obfuscation) ==

Email addresses embedded in text can be obfuscated. In cases where
personal information may be in the content, and it will be shown to
unauthenticated users, the email address can be hidden. The address
is replaced with the message '<email address hidden>'.

    >>> test_tales('foo/fmt:obfuscate-email', foo='name.surname@company.com')
    '<email address hidden>'
    >>> test_tales('foo/fmt:obfuscate-email', foo='name@organization.org.cc')
    '<email address hidden>'
    >>> test_tales('foo/fmt:obfuscate-email', foo='name+sub@domain.org')
    '<email address hidden>'
    >>> test_tales('foo/fmt:obfuscate-email',
    ...     foo='long_name@host.long-network.org.cc')
    '<email address hidden>'
    >>> test_tales('foo/fmt:obfuscate-email',
    ...     foo='"long/name="@organization.org')
    '"<email address hidden>'
    >>> test_tales('foo/fmt:obfuscate-email',
    ...     foo='long-name@building.museum')
    '<email address hidden>'
    >>> test_tales('foo/fmt:obfuscate-email', foo='foo@staticmethod.com')
    '<email address hidden>'
    >>> test_tales('foo/fmt:obfuscate-email', foo='<foo@bar.com>')
    '<email address hidden>'

    >>> print test_tales('foo/fmt:obfuscate-email/fmt:text-to-html',
    ...     foo=signature)
    <p>--<br />
    __C U R T I S  C.  H O V E Y_______<br />
    &lt;email address hidden&gt;<br />
    Guilty of stealing everything I am.</p>

    >>> # Email addresses and credentials in a URL match.
    >>> test_tales('foo/fmt:obfuscate-email',
    ...     foo='mailto:long-name@very.long.dom.cc')
    'mailto:<email address hidden>'
    >>> test_tales('foo/fmt:obfuscate-email',
    ...     foo='http://person:password@site.net')
    'http://person:<email address hidden>'

    >>> # An Invalid email address does not match.
    >>> test_tales('foo/fmt:obfuscate-email', foo='name @ host.school.edu')
    'name @ host.school.edu'
    >>> # SSH is not an email address.
    >>> test_tales('foo/fmt:obfuscate-email', foo='person@host')
    'person@host'
    >>> # Perl/shell arrays are not an email address.
    >>> test_tales('foo/fmt:obfuscate-email', foo='(head, tail)=@array')
    '(head, tail)=@array'
    >>> # Python decorators and Java annotations are not email addresses.
    >>> test_tales('foo/fmt:obfuscate-email', foo='@staticmethod')
    '@staticmethod'
    >>> # XPath expressions are not email addresses.
    >>> test_tales('foo/fmt:obfuscate-email', foo='element/@attribute')
    'element/@attribute'
    >>> # An invalid address, some characters, followed by many dots, and
    >>> # some more characters. This pattern (derived from a real example)
    >>> # caused the re to hang the servers and the test suite.
    >>> # The re used one-or-none in a grouping (\.?), which is expensive.
    >>> bad_address = (
    ...     "medicalwei@sara:~$ Spinning................................"
    ...     "...........................................................not")
    >>> test_tales('foo/fmt:obfuscate-email', foo=bad_address)
    'medicalwei@sara:~$ ...'


== Linkification of email addresses ==

fmt:linkify-email will recognise email addresses that are registered in
Launchpad and linkify them to point at the profile page for that person.
The resulting HTML includes a person icon next to the linked text to
emphasise the linkage.

    >>> test_tales('foo/fmt:linkify-email', foo='foo.bar@canonical.com')
    u'<a href="http://launchpad.dev/~name16"><img alt="" width="14" height="14" src="/@@/person" />&nbsp;foo.bar@canonical.com</a>'

Multiple addresses may be linkified at once:

    >>> test_tales('foo/fmt:linkify-email',
    ...     foo='foo.bar@canonical.com and cprov@ubuntu.com')
    u'<a href="http://launchpad.dev/~name16"><img alt="" width="14" height="14" src="/@@/person" />&nbsp;foo.bar@canonical.com</a> and <a href="http://launchpad.dev/~cprov"><img alt="" width="14" height="14" src="/@@/person" />&nbsp;cprov@ubuntu.com</a>'

Unknown email addresses are not altered in any way:

    >>> test_tales('foo/fmt:linkify-email', foo='nobody@example.com')
    'nobody@example.com'

Users who specifiy that their email adresses must be hidden also do not get
linkified:

    >>> test_tales('foo/fmt:linkify-email', foo='test@canonical.com')
    'test@canonical.com'

== Test the 'fmt:' namespace where the context is a dict. ==

fmt:pagetitle takes a page template CONTEXTS dict, and gives you a string
for use in the <title> element of a page.

This case ought to apply only to a page template's CONTEXTS dict.  However, we
have to make this namespace available for all dicts, as there is no type
information to distinguish a page template CONTEXTS dict from any other dict.

    >>> class MockPageTemplateFile:
    ...     filename = '/blah/blah/debug-root-index.pt'
    ...
    >>> CONTEXTS = {'template': MockPageTemplateFile}
    >>> test_tales('foo/fmt:pagetitle', foo=CONTEXTS)
    'Launchpad Debug Home Page'


Test the 'fmt:url' namespace for canonical urls.

    >>> from canonical.launchpad.webapp.interfaces import ICanonicalUrlData
    >>> from zope.interface import implements
    >>> class ObjectThatHasUrl:
    ...     implements(ICanonicalUrlData)
    ...     path = 'bonobo/saki'
    ...     inside = None
    ...     rootsite = None

    >>> object_having_url = ObjectThatHasUrl()
    >>> test_tales('foo/fmt:url', foo=object_having_url)
    u'http://launchpad.dev/bonobo/saki'

Now, we need to test that it gets the correct application URL from the
request.

Make a mock-up IBrowserRequest, and use this as the interaction.

    >>> from zope.publisher.interfaces.browser import \
    ...     IBrowserApplicationRequest
    >>> from zope.interface import implements
    >>> class MockBrowserRequest:
    ...     implements(IBrowserApplicationRequest)
    ...
    ...     interaction = None
    ...     principal = None
    ...
    ...     def getApplicationURL(self):
    ...         return 'https://mandrill.example.org:23'

    >>> participation = MockBrowserRequest()

    >>> login(ANONYMOUS, participation)

Note how the URL has only a path part, because it is for the same site
as the current request.

    >>> test_tales('foo/fmt:url', foo=object_having_url)
    u'/bonobo/saki'


== The some_string/fmt:something helper ==

Test the 'fmt:' namespace where the context is None. In general, these
will return an empty string.  They are provided for ease of handling
NULL values from the database, which become None values for attributes
in content classes.

Everything you can do with 'something/fmt:foo', you should be able to
do with 'None/fmt:foo'.

    >>> test_tales('foo/fmt:shorten', foo=None)
    Traceback (most recent call last):
    ...
    TraversalError: 'you need to traverse a number after fmt:shorten'

    >>> test_tales('foo/fmt:shorten/8', foo=None)
    ''
    >>> test_tales('foo/fmt:nl_to_br', foo=None)
    ''
    >>> test_tales('foo/fmt:nice_pre', foo=None)
    ''
    >>> test_tales('foo/fmt:break-long-words', foo=None)
    ''
    >>> test_tales('foo/fmt:breadcrumbs', foo=None)
    ''
    >>> test_tales('foo/fmt:date', foo=None)
    ''
    >>> test_tales('foo/fmt:time', foo=None)
    ''
    >>> test_tales('foo/fmt:datetime', foo=None)
    ''
    >>> test_tales('foo/fmt:rfc822utcdatetime', foo=None)
    ''
    >>> test_tales('foo/fmt:pagetitle', foo=None)
    ''
    >>> test_tales('foo/fmt:text-to-html', foo=None)
    ''
    >>> test_tales('foo/fmt:email-to-html', foo=None)
    ''
    >>> test_tales('foo/fmt:url', foo=None)
    ''
    >>> test_tales('foo/fmt:exactduration', foo=None)
    ''
    >>> test_tales('foo/image:icon', foo=None)
    ''


== The lp: namespace for presenting DBSchema items ==

This is deprecated, and should raise a deprecation warning in the future,
and eventually be removed.  It is no longer needed, now that we have
an EnumCol for sqlobject.

Test the 'lp:' namespace for presenting DBSchema items.

    >>> from canonical.launchpad.interfaces import BinaryPackageFormat
    >>> deb = BinaryPackageFormat.DEB.value
    >>> test_tales('deb/lp:BinaryPackageFormat', deb=deb)
    'Ubuntu Package'


== The someobject/required:some.Permission helper ==

Test the 'required:' namespace.  We're already logged in as the anonymous user,
and anonymous users can't edit any person:

    >>> test_tales('person/required:launchpad.Edit', person=person)
    False

Anonymous users can do anything with the zope.Public permission.

    >>> test_tales('person/required:zope.Public', person=person)
    True

Queries about permissions that don't exist will raise an exception:

    >>> test_tales('person/required:mushroom.Badger', person=person)
    Traceback (most recent call last):
    ...
    ValueError: ('Undefined permission id', 'mushroom.Badger')


== The somevalue/enumvalue:ENUMVALUE helper ==

You can test whether a particular value that you have in your page template
matches a particular valid value for that DBSchema enum.

This was going to be called 'enum-value', but Zope doesn't allow this.
To be fixed upstream.

    >>> from canonical.launchpad.interfaces import BinaryPackageFormat
    >>> deb = BinaryPackageFormat.DEB
    >>> udeb = BinaryPackageFormat.UDEB
    >>> test_tales('deb/enumvalue:DEB', deb=deb)
    True
    >>> test_tales('deb/enumvalue:DEB', deb=udeb)
    False

We don't get a ValueError when we use a value that doesn't appear in the
DBSchema the item comes from.

    >>> test_tales('deb/enumvalue:CHEESEFISH', deb=udeb)
    Traceback (most recent call last):
    ...
    TraversalError: 'The enumerated type BinaryPackageFormat does not have a value CHEESEFISH.'

It is possible for dbschemas to have a 'None' value.  This is a bit awkward,
because when the value is None, we can't do any checking whether a new value
is from the correct schema.  In any case, this case is not currently handled.

The enumvalue tales expression is designed to work with security
wrapped dbschema items too:

    >>> from zope.security.proxy import ProxyFactory
    >>> wrapped_deb = ProxyFactory(BinaryPackageFormat.DEB)
    >>> test_tales('deb/enumvalue:DEB', deb=wrapped_deb)
    True
    >>> test_tales('deb/enumvalue:UDEB', deb=wrapped_deb)
    False
    >>> test_tales('deb/enumvalue:CHEESEFISH', deb=wrapped_deb)
    Traceback (most recent call last):
    ...
    TraversalError: 'The enumerated type BinaryPackageFormat does not have a value CHEESEFISH.'
