= Updating Product.remote_product =

The remote_product attribute of a Product is used to present links for
filing and searching bugs in the Product's bug tracker, in case it's not
using Launchpad to track its bugs. We don't expect users to set the
remote_product themselves, so we have a script that tries to set this
automatically.

    >>> from canonical.launchpad.webapp.interfaces import (
    ...     IStoreSelector, DEFAULT_FLAVOR, MAIN_STORE)
    >>> store = getUtility(IStoreSelector).get(MAIN_STORE, DEFAULT_FLAVOR)
    >>> store.execute("UPDATE Product SET remote_product = 'not-None'")
    <storm...>

    >>> from canonical.launchpad.interfaces.bugtracker import BugTrackerType
    >>> from canonical.launchpad.scripts.logger import QuietFakeLogger
    >>> from canonical.launchpad.scripts.updateremoteproduct import (
    ...     RemoteProductUpdater)
    >>> class FakeTransaction:
    ...     def __init__(self, log_calls=False):
    ...         self.log_calls = log_calls
    ...     def commit(self):
    ...         if self.log_calls:
    ...             print "COMMIT"
    >>> updater = RemoteProductUpdater(FakeTransaction(), QuietFakeLogger())


== Testing ==

To help testing, there is a method, _getExternalBugTracker(), that
creates the ExternalBugTracker for the given BugTracker.

    >>> rt = factory.makeBugTracker(
    ...     bugtrackertype=BugTrackerType.RT,
    ...     base_url=u'http://rt.example.com/')
    >>> rt_external = updater._getExternalBugTracker(rt)
    >>> rt_external.__class__.__name__
    'RequestTracker'
    >>> rt_external.baseurl
    u'http://rt.example.com'

For testing, _getExternalBugTracker() can be overridden to return an
ExternalBugTracker that doesn't require network access.

    >>> class FakeExternalBugTracker:
    ...     def getRemoteProduct(self, remote_bug):
    ...         return 'product-for-bug-%s' % remote_bug


    >>> class NoNetworkRemoteProductUpdater(RemoteProductUpdater):
    ...     def _getExternalBugTracker(self, bug_tracker):
    ...         return FakeExternalBugTracker()


== update() ==

The update method simply loops over all the bug tracker types that can
track more than one product, and calls updateByBugTrackerType().

    >>> class TrackerTypeCollectingUpdater(RemoteProductUpdater):
    ...     def __init__(self):
    ...         self.logger = QuietFakeLogger()
    ...         self.looped_over_bug_tracker_types = set()
    ...     def updateByBugTrackerType(self, bugtracker_type):
    ...         self.looped_over_bug_tracker_types.add(bugtracker_type)

    >>> from canonical.launchpad.interfaces.bugtracker import (
    ...     SINGLE_PRODUCT_BUGTRACKERTYPES)
    >>> multi_product_trackers = set(
    ...     bugtracker_type for bugtracker_type in BugTrackerType.items
    ...     if bugtracker_type not in SINGLE_PRODUCT_BUGTRACKERTYPES)

    >>> updater = TrackerTypeCollectingUpdater()
    >>> updater.update()
    >>> multi_product_trackers.difference(
    ...     updater.looped_over_bug_tracker_types)
    set([])


== updateByBugTrackerType() ==

The updateByBugTrackerType() method looks at the bug watches that are
linked to the product, to decide what remote_product should be set to.
It accepts a single parameter, the type of the bug tracker that should
be updated.


=== No bug watches ===

If there are no bug watches, nothing will be done.

    >>> bugzilla_product = factory.makeProduct(
    ...     name=u'bugzilla-product', official_malone=False)
    >>> bugzilla = factory.makeBugTracker(
    ...     bugtrackertype=BugTrackerType.BUGZILLA)
    >>> bugzilla_product.bugtracker = bugzilla
    >>> rt_product = factory.makeProduct(
    ...     name=u'rt-product', official_malone=False)
    >>> rt = factory.makeBugTracker(
    ...     bugtrackertype=BugTrackerType.RT)
    >>> rt_product.bugtracker = rt

    >>> list(bugzilla_product.getLinkedBugWatches())
    []
    >>> updater.updateByBugTrackerType(BugTrackerType.RT)
    >>> print bugzilla_product.remote_product
    None
    >>> print rt_product.remote_product
    None


=== Linked bug watches ===

If there are bug watches for a product having a None remote_product, an
arbitrary bug watch will be retrieved, and queried for its remote
product. Products having a bug tracker of a different type than the
given one are ignored.

    >>> updater = NoNetworkRemoteProductUpdater(
    ...     FakeTransaction(), QuietFakeLogger())
    >>> bugzilla_bugtask = factory.makeBugTask(target=bugzilla_product)
    >>> bugzilla_bugwatch = factory.makeBugWatch(
    ...     '42', bugtracker=bugzilla, bug=bugzilla_bugtask.bug)
    >>> bugzilla_bugtask.bugwatch = bugzilla_bugwatch
    >>> rt_bugtask = factory.makeBugTask(target=rt_product)
    >>> rt_bugwatch = factory.makeBugWatch(
    ...     '84', bugtracker=rt, bug=rt_bugtask.bug)
    >>> rt_bugtask.bugwatch = rt_bugwatch

    >>> updater.updateByBugTrackerType(BugTrackerType.RT)
    >>> print rt_product.remote_product
    product-for-bug-84

    >>> print bugzilla_product.remote_product
    None


=== remote_product already set ===

If a product already has remote_product set, it will not be updated.

    >>> rt_product = factory.makeProduct(official_malone=False)
    >>> rt = factory.makeBugTracker(
    ...     bugtrackertype=BugTrackerType.RT)
    >>> rt_product.bugtracker = rt
    >>> rt_bugtask = factory.makeBugTask(target=rt_product)
    >>> rt_bugwatch = factory.makeBugWatch(
    ...     '84', bugtracker=rt, bug=rt_bugtask.bug)
    >>> rt_bugtask.bugwatch = rt_bugwatch

    >>> rt_product.remote_product = u'already-set'
    >>> updater = NoNetworkRemoteProductUpdater(
    ...     FakeTransaction(), QuietFakeLogger())
    >>> updater.updateByBugTrackerType(BugTrackerType.RT)
    >>> print rt_product.remote_product
    already-set


=== Transaction handling ===

To avoid long-running write transactions, the transaction is committed
after each product's remote_product has been updated.

    >>> for index in range(3):
    ...     rt_product = factory.makeProduct(official_malone=False)
    ...     rt = factory.makeBugTracker(
    ...         bugtrackertype=BugTrackerType.RT)
    ...     rt_product.bugtracker = rt
    ...     rt_bugtask = factory.makeBugTask(target=rt_product)
    ...     rt_bugwatch = factory.makeBugWatch(
    ...         '84', bugtracker=rt, bug=rt_bugtask.bug)
    ...     rt_bugtask.bugwatch = rt_bugwatch
    >>> updater = NoNetworkRemoteProductUpdater(
    ...     FakeTransaction(log_calls=True), QuietFakeLogger())
    >>> updater.updateByBugTrackerType(BugTrackerType.RT)
    COMMIT
    COMMIT
    COMMIT


== update-remote-product.py ==

The script that uses RemoteProductUpdater is update-remote-product.py.

    >>> import subprocess
    >>> process = subprocess.Popen(
    ...     ['cronscripts/update-remote-product.py'],
    ...     stdin=subprocess.PIPE, stdout=subprocess.PIPE,
    ...     stderr=subprocess.PIPE)
    >>> (out, err) = process.communicate()
    >>> out
    ''
    >>> process.returncode
    0

    >>> print err
    INFO    creating lockfile
    INFO    0 projects using BUGZILLA needing updating.
    ...
    INFO    0 projects using RT needing updating.
    ...
    INFO    Time for this run: ... seconds.
