= Create a question from a bug =

Bugs can be converted into questions when a person ascertains that
that is the nature of the issue

The bug's target must be adaptable to IQuestionTarget and must use
Launchpad track bugs--see bugtarget-questiontarget.txt in
interfaces/ftests/ for more information on this issue.

    >>> from canonical.launchpad.interfaces import (
    ...     CreateBugParams, BugTaskStatus, IBugSet, IBugTaskSet,
    ...     IDistributionSet, IPersonSet, IProductSet, IQuestionTarget,
    ...     ISourcePackageNameSet)

Some parts of the IQuestionTarget interface are only accessible
to a registered user. No Privileges Person will create the bugs,
Sample Person will play the role of bug contact.

    >>> no_priv = getUtility(IPersonSet).getByName('no-priv')
    >>> sample_person = getUtility(IPersonSet).getByName('name12')
    >>> login('test@canonical.com')

The bug selects the only bugtask that can provide a QuestionTarget.
The bugtask must be in New, Incomplete, Confirmed, or Wont Fix
status, and the target's pillar must use Launchpad to track bugs.
Jokosher does use Launchpad to track bugs; its bugs can be converted
to questions.

    >>> login('no-priv@canonical.com')

    >>> target = getUtility(IProductSet)['jokosher']
    >>> bug_params = CreateBugParams(
    ...     title="Print is broken", comment="blah blah blah", owner=no_priv)
    >>> bug = target.createBug(bug_params)
    >>> bugtask = bug.bugtasks[0]
    >>> bugtask.status.title
    'New'
    >>> target.official_malone
    True
    >>> IQuestionTarget.providedBy(target)
    True

The primary use case for converting a bug into a question is when
a bug contact recognises a bug is really a question. This happens
at the UI level. For example, Sample Person would recognise that
this bug is a question while reviewing Jokosher's bugs, and choose
to make it into a question. The UI would pass Sample Person as the
Person changing the status, and a message about why the report is
a question.

    >>> login('test@canonical.com')
    >>> bug_subscription = bug.subscribe(sample_person)
    >>> question = bug.convertToQuestion(
    ...     sample_person, "This is a question.")

    >>> question.target == target
    True
    >>> question.owner == bug.owner
    True
    >>> question.title == bug.title
    True
    >>> question.description == bug.description
    True
    >>> question.datecreated == bug.datecreated
    True
    >>> # Bugs save the Bug.description as the first message;
    >>> # questions do not.
    >>> question.messages.count() == bug.messages.count() - 1
    True

The comment parameter for convertToQuestion is optional. When it
id provided, it is added to the bug, and the bug's messages are copied
to the question.

    >>> question.messages[-1].text_contents == bug.messages[-1].text_contents
    True

    >>> question.owner.displayname
    u'No Privileges Person'
    >>> question.title
    u'Print is broken'
    >>> question.description
    u'blah blah blah'
    >>> question.messages[-1].text_contents
    u'This is a question.'

Once converted to a question, the bugtask status is Invalid. The
statusexplanation is set to the comment the user provided to
explain why the bug is a question.

    >>> bugtask.status.title
    'Invalid'
    >>> print bugtask.statusexplanation
    This is a question.

Subscribers to the bug are notified that the bug was made into a
question and that the bugtasks are Invalid.

    >>> recipients = bug.getBugNotificationRecipients()
    >>> [address for address in recipients.getEmails()]
    ['daf@canonical.com', 'no-priv@canonical.com', 'test@canonical.com']

    >>> from canonical.launchpad.database import BugNotification
    >>> bug_notifications = BugNotification.select(orderBy='-id')
    >>> for notification in bug_notifications:
    ...     print notification.message.text_contents
    ** bug changed to question:
       http://answers.launchpad.dev/jokosher/+question/...
    ** Changed in: jokosher
       Status: New => Invalid
    This is a question.

A bug can only be converted to a question once.

    >>> question = bug.convertToQuestion(sample_person, "Fail.")
    Traceback (most recent call last):
    ...
    AssertionError: This bug was already converted to question #...


== getQuestionCreatedFromBug() ==

The question created from the bug is automatically linked to the
original bug. A bug can also retrieve all the questions that link
to it, but QuestionBug links are a many to many relationship. The
question can also be retrieved using the getQuestionCreatedFromBug()
method.

    >>> bug.title
    u'Print is broken'

    >>> [bug_link.question.title for bug_link in question.bug_links]
    [u'Print is broken']

    >>> [question.title for question in bug.questions]
    [u'Print is broken']


== canBeAQuestion() ==

The canBeAQuestion() method can be used to check if a question can be
created from a bug (but it will not state why).


=== The bugtask's target must use Launchpad to track bugs ===

A Firefox bug in Debian cannot be converted to a question because the
Distribution does not use Launchpad to track bugs.

    >>> firefox_bug = getUtility(IBugSet).get(8)
    >>> target = firefox_bug.bugtasks[0].target
    >>> IQuestionTarget.providedBy(target)
    True
    >>> target.distribution.official_malone
    False
    >>> firefox_bug.canBeAQuestion()
    False


== Only one bugtask must be valid ==

In the rare instance where a bug has more than one bugtask, there must
be exactly one bugtask having a non-Invalid status.

    >>> login('no-priv@canonical.com')

    >>> ubuntu = getUtility(IDistributionSet)['ubuntu']
    >>> bug_params = CreateBugParams(
    ...     title="Print is borked", comment="blah blah blah", owner=no_priv)
    >>> ubuntu_bug = ubuntu.createBug(bug_params)

    >>> evo_ubuntu = getUtility(ISourcePackageNameSet)['evolution']
    >>> evo_bugtask = getUtility(IBugTaskSet).createTask(
    ...     bug=ubuntu_bug, distribution=ubuntu, sourcepackagename=evo_ubuntu,
    ...     owner=no_priv)
    >>> bugtasks = ubuntu_bug.bugtasks
    >>> len(bugtasks)
    2

    >>> ['%s: %s' % (bt.target.name, bt.status.title) for bt in bugtasks]
    [u'ubuntu: New', u'evolution: New']

    >>> login('test@canonical.com')

    >>> ubuntu_bug.canBeAQuestion()
    False

The user can choose to Invalidate one or more bugtasks so that only
one bugtask can provide the QuestionTarget. Note that the comment
is not provided

    >>> evo_bugtask.transitionToStatus(BugTaskStatus.INVALID, sample_person)
    >>> ubuntu_bug.canBeAQuestion()
    True

    >>> question = ubuntu_bug.convertToQuestion(sample_person)
    >>> question.title
    u'Print is borked'
    >>> question.target.name
    u'ubuntu'

    >>> ['%s: %s' % (bt.target.name, bt.status.title) for bt in bugtasks]
    [u'ubuntu: Invalid', u'evolution: Invalid']
    >>> [bt.statusexplanation for bt in bugtasks]
    [None, None]
