In order to exercise the estimation of build job start times a setup
with one job building and another job pending/waiting is to be created.

Activate the builders present in sampledata; we need to be logged in
as a member of launchpad-buildd-admin:

    >>> from canonical.launchpad.ftests import login
    >>> login('celso.providelo@canonical.com')
    >>> from lp.buildmaster.interfaces.builder import IBuilderSet
    >>> builder_set = getUtility(IBuilderSet)

Do we have two builders?

    >>> builder_set.count()
    2

These are the builders available.

    >>> from canonical.launchpad.ftests import syncUpdate
    >>> for b in builder_set:
    ...     b.builderok = True
    ...     print "builder: name='%s', id=%d" % (b.name, b.id)
    ...     syncUpdate(b)
    builder: name='bob', id=1
    builder: name='frog', id=2

The 'alsa-utils' package is the one to be built (in the ubuntu/hoary
distroseries).

    >>> from lp.registry.interfaces.distribution import IDistributionSet
    >>> ubuntu = getUtility(IDistributionSet)['ubuntu']
    >>> hoary = ubuntu['hoary']
    >>> hoary.main_archive.require_virtualized
    False

    >>> from lp.registry.interfaces.pocket import (
    ...     PackagePublishingPocket)
    >>> alsa_hoary = hoary.getSourcePackage('alsa-utils')
    >>> alsa_spr = alsa_hoary['1.0.9a-4'].sourcepackagerelease
    >>> print alsa_spr.title
    alsa-utils - 1.0.9a-4

Create new Build and BuildQueue instances (in ubuntu/hoary/i386) for
the pending job.

    >>> from datetime import timedelta
    >>> from canonical.launchpad.interfaces import BuildStatus
    >>> alsa_build = alsa_spr.createBuild(
    ...     hoary['i386'], PackagePublishingPocket.RELEASE,
    ...     hoary.main_archive)
    >>> alsa_bqueue = alsa_build.queueBuild()
    >>> alsa_bqueue.lastscore = 500
    >>> alsa_build.buildstate = BuildStatus.NEEDSBUILD

Access the currently building job via the builder.

    >>> from datetime import datetime
    >>> import pytz
    >>> UTC = pytz.timezone('UTC')
    >>> bob_the_builder = builder_set.get(1)
    >>> cur_bqueue = bob_the_builder.currentjob
    >>> from lp.soyuz.interfaces.build import IBuildSet
    >>> cur_build = getUtility(IBuildSet).getByQueueEntry(cur_bqueue)

Make sure the job at hand is currently being built.

    >>> from canonical.launchpad.interfaces import BuildStatus
    >>> cur_build.buildstate == BuildStatus.BUILDING
    True

The start time estimation mechanism for a pending job N depends on
proper "build start time" and "estimated build duration" values for
other jobs that are either currently building or pending but ahead
of job N in the build queue. These values will now be set for the job
that is currently building.

    >>> from zope.security.proxy import removeSecurityProxy
    >>> cur_bqueue.lastscore = 1111
    >>> cur_bqueue.setDateStarted(
    ...     datetime(2008, 4, 1, 10, 45, 39, tzinfo=UTC))
    >>> print cur_bqueue.date_started
    2008-04-01 10:45:39+00:00

Please note that the "estimated build duration" is an internal property
and not meant to be viewed or modified by an end user.

    >>> removeSecurityProxy(cur_bqueue).estimated_duration = (
    ...     timedelta(minutes=56))

The estimated start time for the pending job is either now or lies
in the future.

    >>> now = datetime.utcnow()
    >>> def job_start_estimate(build):
    ...     return build.buildqueue_record.getEstimatedJobStartTime()
    >>> estimate = job_start_estimate(alsa_build)
    >>> estimate > now
    True

The estimated build start time may only be requested for jobs that are
pending.

    >>> job_start_estimate(cur_build)
    Traceback (most recent call last):
    ...
    AssertionError: The start time is only estimated for pending jobs.

Now let's add two PPA packages to the mix in order to show how builds
associated with disabled archives get ignored when it comes to the calculation
of estimated dispatch times.

We first add a build for the 'pmount' source package to cprov's PPA.

    >>> from lp.registry.interfaces.person import IPersonSet
    >>> cprov = getUtility(IPersonSet).getByName('cprov')
    >>> [pmount_source] = cprov.archive.getPublishedSources(
    ...     name='pmount', version='0.1-1')
    >>> pmount_spr = pmount_source.sourcepackagerelease
    >>> print pmount_spr.title
    pmount - 0.1-1

    >>> pmount_build = pmount_spr.createBuild(
    ...     hoary['i386'], PackagePublishingPocket.RELEASE, cprov.archive)
    >>> pmount_bqueue = pmount_build.queueBuild()
    >>> pmount_bqueue.lastscore = 66
    >>> removeSecurityProxy(pmount_bqueue).estimated_duration = (
    ...     timedelta(minutes=12))
    >>> pmount_build.buildstate = BuildStatus.NEEDSBUILD

Followed by another build for the 'iceweasel' source package that is added
to mark's PPA.

    >>> mark = getUtility(IPersonSet).getByName('mark')
    >>> [iceweasel_source] = cprov.archive.getPublishedSources(
    ...     name='iceweasel', version='1.0')
    >>> iceweasel_spr = iceweasel_source.sourcepackagerelease
    >>> print iceweasel_spr.title
    iceweasel - 1.0

    >>> iceweasel_build = iceweasel_spr.createBuild(
    ...     hoary['i386'], PackagePublishingPocket.RELEASE, mark.archive)
    >>> iceweasel_bqueue = iceweasel_build.queueBuild()
    >>> removeSecurityProxy(iceweasel_bqueue).estimated_duration = (
    ...     timedelta(minutes=48))
    >>> iceweasel_bqueue.lastscore = 666
    >>> iceweasel_build.buildstate = BuildStatus.NEEDSBUILD

Since the 'iceweasel' build has a higher score (666) than the 'pmount'
build (66) its estimated dispatch time is essentially "now".

    >>> now = datetime.utcnow()
    >>> estimate = job_start_estimate(iceweasel_build)
    >>> estimate > now
    True
    >>> estimate - now
    datetime.timedelta(0, 5, ...)

The 'pmount' build comes next in the queue and its estimated dispatch
time is the estimated build time of the 'iceweasel' package i.e. 2880
seconds (48 minutes * 60).

    >>> estimate = job_start_estimate(pmount_build)
    >>> estimate > now
    True
    >>> estimate - now
    datetime.timedelta(0, 2880, ...)

Now mark's PPA will be disabled. This has the effect that all builds
associated with it (i.e. the 'iceweasel' build) are ignored while
calculating the estimated dispatch time and the latter becomes effectively
"now" for the 'pmount' build.

    >>> mark.archive.disable()
    >>> syncUpdate(mark.archive)
    >>> estimate = job_start_estimate(pmount_build)
    >>> estimate > now
    True
    >>> estimate - now
    datetime.timedelta(0, 5, ...)
