Introduction
============

A user can "subscribe" to a bug report to get email notifications when
changes are made to the report.

Accessing Bug Subscriber Lists
==============================

Sometimes you'll want to know which people are subscribed to a bug. For
example, you might want to send out a notification email to everyone that is
Cc'd on a bug when something changes. For the purposes of this document, let's
pretend we're logged in as Foo Bar:

    >>> from canonical.launchpad.ftests import login
    >>> login("foo.bar@canonical.com")

To get the set of subscriptions to a bug, you can access the
IBug.subscriptions attribute:

    >>> from canonical.launchpad.interfaces import IBugSet
    >>> from zope.component import getUtility
    >>> bugset = getUtility(IBugSet)
    >>> bug = bugset.get(1)
    >>> bug.subscriptions.count()
    2

This is slightly misleading though, because this only gives us the
list of explicit subscriptions on the bug, when in fact, there are
special cases where one can be "implicitly" subscribed to a bug.

Implicit vs. Explicit Subscriptions
-----------------------------------

An explicit subscription means that there's a row in the
BugSubscription for that subscription. An implicit subscription does not
have a corresponding row in the BugSubscription table.

To get the entire list of email addresses that should receive a
notification email on a bug, call
IBug.notificationRecipientAddresses().

   >>> bug.notificationRecipientAddresses()
   ['mark@hbd.com', 'test@canonical.com']

To find out if someone is already explicitly subscribed to a bug, call
IBug.isSubscribed, passing in an IPerson:

    >>> from canonical.launchpad.interfaces import IPersonSet
    >>> personset = getUtility(IPersonSet)
    >>> bug.isSubscribed(personset.get(16))
    False
    >>> bug.isSubscribed(personset.get(12))
    True

Subscribing and Unsubscribing
=============================

To subscribe people to and unsubscribe people from a bug, use
IBug.subscribe and IBug.unsubscribe:

    >>> foobar = personset.get(16)
    >>> subscribed_people = [s.person.id for s in bug.subscriptions]
    >>> 16 not in subscribed_people
    True
    >>> bug.subscribe(foobar)
    <BugSubscription at ...>
    >>> subscriptions = [s.person.id for s in bug.subscriptions]
    >>> 16 in subscriptions
    True

Automatic Subscriptions on Bug Creation
=======================================

When a new bug is opened, the following people are automatically added as
explicit Cc subscribers to the bug:

  * The bug reporter

  * The distribution bug contact, if there is one

  * The product bug contact, if there is one

  * The package bug contact(s). There may be zero, one or more package
    bug contacts.

XXX: Brad Bollenbach, 2005-11-25: These bits need real sample data. See
https://launchpad.net/bugs/5484.

Let's have a look at an example for a distribution bug:

    >>> from canonical.launchpad.interfaces import IDistributionSet
    >>> ubuntu = getUtility(IDistributionSet).get(1)
    >>> sample_person = personset.get(12)
    >>> ubuntu.bugcontact = sample_person

    >>> from canonical.launchpad.interfaces import IBugSet

    >>> new_bug = getUtility(IBugSet).createBug(
    ...     title="a test bug", comment="a test description",
    ...     owner=foobar, distribution=ubuntu)

    >>> sorted(new_bug.notificationRecipientAddresses())
    ['foo.bar@canonical.com', 'test@canonical.com']

The distro contact will *not* be subscribed to private bugs:

    >>> new_bug = getUtility(IBugSet).createBug(
    ...     title="a test bug", comment="a test description",
    ...     owner=foobar, distribution=ubuntu, private=True)

    >>> sorted(new_bug.notificationRecipientAddresses())
    ['foo.bar@canonical.com']

Another example, this time for an upstream:

    >>> from canonical.launchpad.interfaces import IProductSet
    >>> sabdfl = personset.get(1)
    >>> firefox = getUtility(IProductSet).get(4)
    >>> firefox.bugcontact = sabdfl

    >>> new_bug = getUtility(IBugSet).createBug(
    ...     title="a test bug", comment="a test description",
    ...     owner=foobar, product=firefox)

    >>> sorted(new_bug.notificationRecipientAddresses())
    ['foo.bar@canonical.com', 'mark@hbd.com']

If we create a bug task on Ubuntu in the same bug, the Ubuntu bug
contact will be subscribed:

    >>> from canonical.launchpad.interfaces import IBugTaskSet
    >>> ubuntu_task = getUtility(IBugTaskSet).createTask(
    ...     bug=new_bug, distribution=ubuntu, owner=sabdfl)

    >>> sorted(new_bug.notificationRecipientAddresses())
    ['foo.bar@canonical.com', 'mark@hbd.com', 'test@canonical.com']

When an upstream does *not* have a specific bug contact set, the
product.owner is used instead. So, if Firefox's bugcontact is unset,
Sample Person, the Firefox "owner" will get subscribed instead:

    >>> firefox.bugcontact = None

    >>> new_bug = getUtility(IBugSet).createBug(
    ...     title="a test bug", comment="a test description",
    ...     owner=foobar, product=firefox)

    >>> sorted(new_bug.notificationRecipientAddresses())
    ['foo.bar@canonical.com', 'test@canonical.com']

The upstream bug contact will *not* be automatically subscribed to
private bugs:

    >>> new_bug = getUtility(IBugSet).createBug(
    ...     title="a test bug", comment="a test description",
    ...     owner=foobar, product=firefox, private=True)

    >>> sorted(new_bug.notificationRecipientAddresses())
    ['foo.bar@canonical.com']

Now let's create a bug on a specific package, which has no package bug
contacts:

    >>> evolution = ubuntu.getSourcePackage("evolution")
    >>> evolution.bugcontacts
    []

    >>> new_bug = getUtility(IBugSet).createBug(
    ...     title="another test bug",
    ...     comment="another test description",
    ...     owner=foobar, distribution=ubuntu,
    ...     sourcepackagename=evolution.sourcepackagename)

    >>> sorted(new_bug.notificationRecipientAddresses())
    ['foo.bar@canonical.com', 'test@canonical.com']

Adding a package bug contact for evolution will mean that that package
bug contact gets subscribed to all bugmail on bugs filed after the point
that the bug contact was set.

So, if the Ubuntu team is added as a bug contact to evolution:

    >>> ubuntu_team = personset.get(17)
    >>> evolution.addBugContact(ubuntu_team)

The team will still *not* be a recipient of bugmail from the previous
bug we created:

    >>> sorted(new_bug.notificationRecipientAddresses())
    ['foo.bar@canonical.com', 'test@canonical.com']

But the team will be subscribed to bugmail for future bugs:

    >>> new_bug = getUtility(IBugSet).createBug(
    ...     title="yet another test bug",
    ...     comment="yet another test description",
    ...     owner=foobar, distribution=ubuntu,
    ...     sourcepackagename=evolution.sourcepackagename)

    >>> sorted(new_bug.notificationRecipientAddresses())
    ['foo.bar@canonical.com', 'support@ubuntu.com', 'test@canonical.com']

The distribution and package contacts do not get subscribed to private
bug reports automatically:

    >>> new_bug = getUtility(IBugSet).createBug(
    ...     title="yet another test bug",
    ...     comment="yet another test description",
    ...     owner=foobar, distribution=ubuntu,
    ...     sourcepackagename=evolution.sourcepackagename,
    ...     private=True)

    >>> sorted(new_bug.notificationRecipientAddresses())
    ['foo.bar@canonical.com']

Subscribers and Duplicate Bugs
------------------------------

If bug A is a duplicate of bug B, the subscribers of bug A will get
notifications when bug B is changed. This ensures that subscribers of
duplicate bugs are kept "in the loop" about the problem. Let's use bug
#4 and bug #10 to demonstrate:

    >>> bug_four = bugset.get(4)
    >>> bug_ten = bugset.get(10)

    >>> sorted(bug_four.notificationRecipientAddresses())
    ['test@canonical.com']

    >>> sorted(bug_ten.notificationRecipientAddresses())
    ['foo.bar@canonical.com']

An IBug has a getSubscribersFromDuplicates() method, which returns a list
of IPerson objects that are subscribed to this bug solely by virtue of
being subscribed to a duplicate of this bug. So if they're subscribed to
a duplicate of this bug, but *also* suscribed directly to this bug, they
are not included in this list.

    >>> def subscriber_names(subscribers):
    ...     return sorted(subscriber.name for subscriber in subscribers)

    >>> subscriber_names(bug_four.getSubscribersFromDuplicates())
    []

When bug #10 is marked as a duplicate of bug #4, the sole subscriber to
bug #10, Foo Bar, will become part of the recipient list for bug #4.

    >>> bug_ten.duplicateof = 4

(Ensure the database is updated with the above change.)

    >>> bug_ten.syncUpdate()

    >>> subscriber_names(bug_four.getSubscribersFromDuplicates())
    [u'name16']

    >>> sorted(bug_four.notificationRecipientAddresses())
    ['foo.bar@canonical.com', 'test@canonical.com']

If bug #4 were *private* though, mail is sent only to its direct
subscribers, in this case, just Sample Person:

    >>> bug_four.private = True

    >>> sorted(bug_four.getSubscribersFromDuplicates())
    []

    >>> sorted(bug_four.notificationRecipientAddresses())
    ['test@canonical.com']
