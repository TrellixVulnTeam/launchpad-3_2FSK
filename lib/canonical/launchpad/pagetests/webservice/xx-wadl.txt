= Launchpad's WADL documents =


== Hosted file resources ==

A hosted file resource is the web service's access point for a binary
file hosted elsewhere. Examples of hosted files include a person's
mugshot image and a project's icon.

A hosted file resource responds to GET requests by redirecting the
client to the externally hosted file. It responds to PUT or DELETE
requests by updating or deleting the underlying binary file.

The behavior laid out in the previous paragraph is also defined in the
WADL documents served by the web service itself. You can use content
negotiation to get a WADL description of any hosted file resource.

The 'salgado' user starts out with no hosted mugshot, and an ordinary
GET to the place where the mugshot would be results in a 404 error.

    >>> print webservice.get('/~salgado/mugshot')
    HTTP/1.1 404 Not Found
    ...

But if the client is interested in learning how to create a mugshot at
/~salgado/mugshot, it can use content negotiation to get a WADL
description of the resource-to-be.

    >>> wadl = webservice.get(
    ...     '/~salgado/mugshot',
    ...     'application/vd.sun.wadl+xml').getBody()
    >>> wadl_schema.validate(wadl)
    True
    >>> wadl_schema.error_log
    ''

    >>> tree = etree.fromstring(wadl)

Just like with the WADL description of an entry or collection
resource, the WADL representation of a hosted file resource is not
much more than a reference to a big WADL file at the service root. To
find out about the capabilities of the resource-to-be, the client
needs to fetch the WADL representation of
http://.../ and look for the XML element with the
ID "HostedFile".

    >>> tree.tag
    '...application'

    >>> resources = single_list_value(tree)
    >>> resources.tag
    '...resources'
    >>> resources.attrib['base']
    'http://.../~salgado/mugshot'

    >>> resource = single_list_value(resources)
    >>> resource.tag
    '...resource'
    >>> resource.attrib['path']
    ''
    >>> resource.attrib['type']
    'http://.../#HostedFile'


== The service root ==

All the WADL documents we've seen so far have been very simple,
describing a single resource and describing it by reference to another
WADL document. That other document is the WADL representation of the
service root. It describes the capabilities of every kind of resource
the service offers. It also describes the JSON representations those
resources serve, and any custom methods invokable on those
resources. It's a big document.

Because it is so big, it is cached.  Because it only changes when the
Launchpad software changes, it is cached to a file.  Right now, our
webservice will return a special test file:
canonical/launchpad/apidoc/wadl-testrunner.xml.  It was loaded on module
import using the canonical.config.config.instance_name, so a development
instance will use the file canonical/launchpad/apidoc/wadl-development.xml.

    >>> test_wadl = webservice.get(
    ...     '/', 'application/vd.sun.wadl+xml').getBody()
    >>> print test_wadl
    <?xml version="1.0"?>
    <wadl:application xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                      xmlns="http://research.sun.com/wadl/2006/10"
                      xmlns:wadl="http://research.sun.com/wadl/2006/10"
                      xsi:schemaLocation="http://research.sun.com/wadl/2006/10/wadl.xsd">
    <BLANKLINE>
      <!--This file is for testing purposes only.  See
          canonical/launcpad/pagetests/webservice/xx-wadl.txt -->
    <BLANKLINE>
    </wadl:application>
    <BLANKLINE>

Let's use the real contents, though.  To do this, we need to do what
utilities/create-lp-wadl.py does: clear out the cache on the class.

    >>> from canonical.launchpad.systemhomes import WebServiceApplication
    >>> WebServiceApplication.cached_wadl = None

    >>> wadl = webservice.get(
    ...     '/', 'application/vd.sun.wadl+xml').getBody()
    >>> wadl = wadl.decode('UTF-8')

    >>> len(wadl) > len(test_wadl)
    True

The new output is cached on the class now.  After verifying, we'll reinstate
the testing version so other tests have a clean slate.

    >>> WebServiceApplication.cached_wadl == wadl
    True
    >>> WebServiceApplication.cached_wadl = test_wadl

We can examine the real wadl now.

    # We need to replace the nbsp entity, because the validator
    # doesn't support embedded definition.
    >>> wadl_schema.validate(
    ...     wadl.replace('&nbsp;', '&#160;').encode('UTF-8'))
    True
    >>> wadl_schema.error_log
    ''
    >>> tree = etree.fromstring(wadl)

Like all WADL documents, the WADL representation of the service root
is rooted at an <application> tag.

    >>> tree.tag
    '...application'

As with the WADL descriptions of collection and entry resources, this
<application> tag describes the capabilities of the server root
resource. But that <application> tag also contains all the information
referenced by all the other WADL documents in the system. #PersonEntry
is here, as is #people and #ScopedCollection and
many other targets of a <resource> tag's 'resource_type' attribute. Also
located here are the descriptions of the JSON representations those
resources serve.


-------------


Most <param> tags don't tell the client much beyond where to find a
certain parameter, but some of our parameters take values from a
proscribed vocabulary. These parameters correspond to Choice fields
who take their vocabulary from an EnumeratedValue. For these
parameters, the server provides the client with information about the
possible values.

    >>> status_param = single_list_value(
    ...     [param for param in full_params
    ...      if param.attrib['name'] == 'status'])
    >>> status_options = status_param.getchildren()
    >>> status_options[0].tag
    '...doc'
    >>> status_options[1].tag
    '...option'
    >>> sorted(status.attrib['value'] for status in status_options[1:])
    ['Confirmed', 'Fix Committed', ... "Won't Fix"]


== Hosted binary files ==

One interesting type of parameter not shown above is a link to a
binary file managed by the web service, such as a person's mugshot.

    >>> person_desc = single_list_value(
    ...     [entry for entry in entry_resource_descriptions
    ...      if entry[0].attrib['id'] == 'person'])
    >>> (person_entry_type, person_full_rep, person_diff_rep,
    ...  person_page_collection_type, person_collection_rep) = person_desc
    >>> mugshot_param = single_list_value(
    ...     [param for param in person_full_rep
    ...      if param.attrib['name'] == 'mugshot_link'])
    >>> doc, mugshot_link = mugshot_param
    >>> mugshot_link.attrib['resource_type']
    'http://.../#HostedFile'

What can the client do to this binary file resource?

    >>> get, put, delete = list(hosted_binary_resource_type)

The client can send GET to the resource, and be redirected to a binary
file hosted externally.

    >>> get.tag
    '...method'
    >>> get.attrib['name']
    'GET'
    >>> get_response = single_list_value(get)
    >>> get_representation = single_list_value(get_response)
    >>> get_representation.attrib['status']
    '303'
    >>> redirect_param = single_list_value(get_representation)
    >>> redirect_param.tag
    '...param'
    >>> redirect_param.attrib['style']
    'header'
    >>> redirect_param.attrib['name']
    'Location'

The client can PUT a binary file:

    >>> put.tag
    '...method'
    >>> put.attrib['name']
    'PUT'

The client can DELETE an existing file:

    >>> delete.tag
    '...method'
    >>> delete.attrib['name']
    'DELETE'




