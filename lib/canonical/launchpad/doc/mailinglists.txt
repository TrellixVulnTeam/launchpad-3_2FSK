= Team Mailing Lists =

Teams may have zero or one team mailing list.  Creating a team mailing list
requires several steps, starting with registration of the list by the owner of
an existing team.  This is done through an IMailingListRegistry utility.

    >>> from zope.interface.verify import verifyObject
    >>> from canonical.launchpad.interfaces import (
    ...     IMailingList, IMailingListRegistry)
    >>> from canonical.launchpad.database import MailingListRegistry
    >>> list_registry = MailingListRegistry()
    >>> verifyObject(IMailingListRegistry, list_registry)
    True

In the following description of how to use team mailing lists, we will need
several team.

    >>> from canonical.launchpad.interfaces import IPersonSet
    >>> from canonical.launchpad.ftests import login, ANONYMOUS
    >>> login(ANONYMOUS)
    >>> personset = getUtility(IPersonSet)
    >>> ddaa = personset.getByName('ddaa')
    >>> team_one = personset.newTeam(ddaa, 'team-one', 'Team One')
    >>> team_two = personset.newTeam(ddaa, 'team-two', 'Team Two')
    >>> team_three = personset.newTeam(ddaa, 'team-three', 'Team Three')
    >>> team_four = personset.newTeam(ddaa, 'team-four', 'Team Four')
    >>> from canonical.database.sqlbase import flush_database_updates
    >>> flush_database_updates()

Define a helper function that sorts mailing lists alphabetically based on
their team's name.

    >>> def sorted_lists(lists):
    ...     return sorted(lists, key=lambda L: L.team.name)

None of these teams have mailing lists yet.

    >>> sorted_lists(list_registry.registered_lists)
    []
    >>> sorted_lists(list_registry.approved_lists)
    []
    >>> print list_registry.getTeamMailingList(team_one)
    None
    >>> print list_registry.getTeamMailingList(team_two)
    None
    >>> print list_registry.getTeamMailingList(team_three)
    None
    >>> print list_registry.getTeamMailingList(team_four)
    None


== Registering a team mailing list ==

The team owner starts the process of creating a team mailing list by
registering the list.  By registering the mailing list, the team owner makes a
request to have the list created, but it is not created right away.

    >>> from datetime import datetime
    >>> import pytz
    >>> utc = pytz.timezone('UTC')
    >>> registration_date = datetime.now(utc)
    >>> list_one = list_registry.register(team_one)
    >>> verifyObject(IMailingList, list_one)
    True
    >>> flush_database_updates()
    >>> list_one
    <MailingList for team "team-one"; status=REGISTERED at 0x...>

You may not register a mailing list for a person.

    >>> salgado = personset.getByName('salgado')
    >>> list_registry.register(salgado)
    Traceback (most recent call last):
    ...
    AssertionError: Cannot register a list for a person who is not a team

The newly registered mailing list is linked to its team, and the list's
registrant is the team owner at the time the list was registered.  The list's
registration date is set, and its status is set to REGISTERED.

    >>> list_one.team.displayname
    u'Team One'
    >>> list_one.registrant.name
    u'ddaa'
    >>> registration_date <= list_one.date_registered <= datetime.now(utc)
    True
    >>> list_one.status.name
    'REGISTERED'

The mailing list has no reviewer or review date, nor an activation date or
welcome message text.

    >>> print list_one.reviewer
    None
    >>> print list_one.date_reviewed
    None
    >>> print list_one.date_activated
    None
    >>> print list_one.welcome_message
    None

The mailing list's registrant does not change even if the team's owner
changes.

    >>> login('carlos@canonical.com')
    >>> carlos = personset.getByName('carlos')
    >>> team_one.teamowner = carlos
    >>> flush_database_updates()
    >>> list_one.registrant.name
    u'ddaa'

A mailing list cannot be registered more than once.

    >>> list_registry.register(team_one)
    Traceback (most recent call last):
    ...
    AssertionError: Mailing list for team "team-one" already exists


== Reviewing a registered mailing list ==

A registered mailing list must then be reviewed by a Launchpad administrator
before the request to create it can be made.  Use the registry to find the set
of all currently registered mailing lists.

    >>> list_two = list_registry.register(team_two)
    >>> list_two
    <MailingList for team "team-two"; status=REGISTERED at ...>
    >>> list_three = list_registry.register(team_three)
    >>> list_three
    <MailingList for team "team-three"; status=REGISTERED at ...>
    >>> list_four = list_registry.register(team_four)
    >>> list_four
    <MailingList for team "team-four"; status=REGISTERED at ...>
    >>> flush_database_updates()
    >>> sorted_lists(list_registry.registered_lists)
    [<MailingList for team "team-four"; status=REGISTERED at ...>,
     <MailingList for team "team-one"; status=REGISTERED at ...>,
     <MailingList for team "team-three"; status=REGISTERED at ...>,
     <MailingList for team "team-two"; status=REGISTERED at ...>]

A mailing list's registration cannot be reviewed by a non-administrator.

    >>> from canonical.lp.dbschema import MailingListStatus
    >>> no_priv = personset.getByName('no-priv')
    >>> list_one.review(no_priv, MailingListStatus.APPROVED)
    Traceback (most recent call last):
    ...
    AssertionError: Reviewer must be a Launchpad administrator
    >>> list_one.review(ddaa, MailingListStatus.APPROVED)
    Traceback (most recent call last):
    ...
    AssertionError: Reviewer must be a Launchpad administrator

A Launchpad administer though, may approve the registration.

    >>> list_one.review(carlos, MailingListStatus.APPROVED)
    >>> flush_database_updates()
    >>> list_one.status.name
    'APPROVED'

A mailing list that has already been reviewed, may not be re-reviewed.

    >>> list_one.review(carlos, MailingListStatus.APPROVED)
    Traceback (most recent call last):
    ...
    AssertionError: Only unreviewed mailing lists may be reviewed
    >>> list_one.review(carlos, MailingListStatus.DECLINED)
    Traceback (most recent call last):
    ...
    AssertionError: Only unreviewed mailing lists may be reviewed

A reviewer may also decline a mailing list registration.

    >>> list_two.review(carlos, MailingListStatus.DECLINED)
    >>> flush_database_updates()
    >>> list_two.status.name
    'DECLINED'

A reviewer may not review a mailing list to a state other than approved or
declined.

    >>> list_three.review(carlos, MailingListStatus.ACTIVE)
    Traceback (most recent call last):
    ...
    AssertionError: Reviewed lists may only be approved or declined

Once approved or declined the lists won't be re-considered for review.

    >>> sorted_lists(list_registry.registered_lists)
    [<MailingList for team "team-four"; status=REGISTERED at ...>,
     <MailingList for team "team-three"; status=REGISTERED at ...>]

Approve a couple of other lists to illustrate some additional outcomes later
on.

    >>> list_three.review(carlos, MailingListStatus.APPROVED)
    >>> list_four.review(carlos, MailingListStatus.APPROVED)
    >>> flush_database_updates()
    >>> list(list_registry.registered_lists)
    []


== Constructing mailing lists ==

Once a team mailing list has been approved, it can be constructed by Mailman.
This happens by returning the set of approved mailing lists through the XMLRPC
interface used by Mailman (not shown here).  When Mailman retrieves the set of
mailing lists to construct, the list's statuses are set to the CONSTRUCTING
state.

    >>> sorted_lists(list_registry.approved_lists)
    [<MailingList for team "team-four"; status=APPROVED at ...>,
     <MailingList for team "team-one"; status=APPROVED at ...>,
     <MailingList for team "team-three"; status=APPROVED at ...>]

    >>> list_one.construct()
    >>> flush_database_updates()
    >>> list_one.status.name
    'CONSTRUCTING'

A mailing list that has been declined may not be constructed.

    >>> list_two.construct()
    Traceback (most recent call last):
    ...
    AssertionError: Only approved mailing lists may be constructed

Once in the construction phase, a list is no longer in the approval state.

    >>> sorted_lists(list_registry.approved_lists)
    [<MailingList for team "team-four"; status=APPROVED at ...>,
     <MailingList for team "team-three"; status=APPROVED at ...>]

Lists should never be constructed more than once.

    >>> list_one.construct()
    Traceback (most recent call last):
    ...
    AssertionError: Only approved mailing lists may be constructed

Construct a couple of other lists to illustration some additional outcomes
later.

    >>> list_three.construct()
    >>> list_four.construct()
    >>> flush_database_updates()


== Reporting the results of construction ==

After Mailman has worked at constructing lists for a while, it reports (again
through XMLRPC not shown here) on the status of each list construction.  Most,
if not all will succeed, thus activating the team's mailing list.

    >>> list_one.reportResult(MailingListStatus.ACTIVE)
    >>> list_three.reportResult(MailingListStatus.ACTIVE)
    >>> flush_database_updates()
    >>> list_one.status.name
    'ACTIVE'
    >>> list_three.status.name
    'ACTIVE'

Some list constructions may fail.

    >>> list_four.reportResult(MailingListStatus.FAILED)
    >>> flush_database_updates()
    >>> list_four.status.name
    'FAILED'


== Deactivating lists ==

A list which is active may be deactivated.

    >>> list_three.deactivate()
    >>> flush_database_updates()
    >>> list_three.status.name
    'DEACTIVATING'

This doesn't immediately deactivate the mailing list though.  Mailman still
needs to query for the requested deactivations, take the necessary actions,
and report the deactivation results.

    >>> sorted_lists(list_registry.deactivated_lists)
    [<MailingList for team "team-three"; status=DEACTIVATING at ...>]
    >>> list_three.reportResult(MailingListStatus.INACTIVE)
    >>> list_three.status.name
    'INACTIVE'

But lists which are not active may not be deactivated.

    >>> list_two.deactivate()
    Traceback (most recent call last):
    ...
    AssertionError: Only active mailing lists may be deactivated
    >>> list_four.deactivate()
    Traceback (most recent call last):
    ...
    AssertionError: Only active mailing lists may be deactivated


== Welcome messages ==

Mailing lists have a welcome message text which is sent to new members when
they subscribe to a list.  The welcome message can contain any text.

    >>> print list_one.welcome_message
    None
    >>> list_one.welcome_message = """\
    ... Welcome to the Team One mailing list."""
    >>> flush_database_updates()
    >>> list_one.welcome_message
    u'Welcome to the Team One mailing list.'

After changing the welcome message, the list's status should be MODIFIED.

    >>> list_one.status.name
    'MODIFIED'
    >>> sorted_lists(list_registry.modified_lists)
    [<MailingList for team "team-one"; status=MODIFIED at ...>]

Eventually, Mailman will get around to acting on this modification, and then
it will set the status back to ACTIVE (or FAILED if the update failed for some
reason).

    >>> list_one.reportResult(MailingListStatus.ACTIVE)
    >>> flush_database_updates()
    >>> list_one.status.name
    'ACTIVE'

You cannot change the welcome message text for a mailing list in anything but
ACTIVE status.

    >>> list_two.welcome_message = """\
    ... This list has been declined."""
    Traceback (most recent call last):
    ...
    AssertionError: Only active mailing lists may be modified

    >>> list_four.welcome_message = """\
    ... This list has been deactivated."""
    Traceback (most recent call last):
    ...
    AssertionError: Only active mailing lists may be modified
