Person
======

The Person class is overloaded to represent both people and teams. Let's
log in as Robert Collins to ensure we have the privileges to do what
we're going to demonstrate.

    >>> from zope.component import getUtility
    >>> from zope.interface.verify import verifyObject
    >>> from canonical.database.sqlbase import sqlvalues, flush_database_updates
    >>> from canonical.launchpad.interfaces import (
    ...     IPersonSet, IPerson, IEmailAddressSet)
    >>> from canonical.launchpad.ftests import login, ANONYMOUS
    >>> from canonical.launchpad.helpers import contactEmailAddresses
    >>> from canonical.lp.dbschema import EmailAddressStatus

    >>> login(ANONYMOUS)

    >>> personset = getUtility(IPersonSet)
    >>> emailset = getUtility(IEmailAddressSet)

Verify that foobar (a Person object) correctly implements IPerson.

    >>> foobar = personset.getByName('name16')
    >>> verifyObject(IPerson, foobar)
    True

The IPersonSet component
------------------------

Access to people (Persons or Teams) is done through the IPersonSet
utility:

You can create a new person using the createPersonAndEmail method of
IPersonSet. All you need for that is a valid email address. You can also
hide the user email addresses.

Some of our scripts may create Person entries, and in these cases they must
provide a rationale and a comment (optional) for the creation of that Person
entry. These are displayed on the home pages of unvalidated Launchpad
profiles, to make it clear that those profiles were not created by the
people they represent and why they had to be created. Because the comment
will be displayed verbatim in a web page, it must start with the word "when"
followed by a description of the action that caused the entry to be created.

    >>> from canonical.lp.dbschema import PersonCreationRationale
    >>> p, email = personset.createPersonAndEmail(
    ...     'randomuser@randomhost.com', PersonCreationRationale.POFILEIMPORT,
    ...     comment='when importing the Portuguese translation of firefox',
    ...     hide_email_addresses=True)
    >>> p.teamowner is None
    True
    >>> email.status == EmailAddressStatus.NEW
    True
    >>> p.is_valid_person # Not valid because no preferred email address
    False
    >>> p.hide_email_addresses
    True

When a new sourcepackage is imported and a Person entry has to be created
because we don't know about the maintainer of that package, the code to create
the person should look like this:

    >>> person, emailaddress = personset.createPersonAndEmail(
    ...     'random@random.com', PersonCreationRationale.SOURCEPACKAGEIMPORT,
    ...     comment='when the ed package was imported into Ubuntu Breezy')
    >>> person.is_valid_person
    False
    >>> person.creation_comment
    u'when the ed package was imported into Ubuntu Breezy'


In case of failure of creating a new person or email the method returns
(None, None). Let's demonstrate this trying to create a person with
an invalid email.

    >>> p2, invalid_email = personset.createPersonAndEmail(
    ...     'test#canonical.com', PersonCreationRationale.UNKNOWN)
    >>> p2, invalid_email
    (None, None)

And now with the same name of a existing account

    >>> p3, invalid_email = personset.createPersonAndEmail(
    ...     'randomemail@randomhost.com', PersonCreationRationale.UNKNOWN,
    ...     name='name12')
    >>> p3, invalid_email
    (None, None)

    >>> vcs_imports = personset.getByName('vcs-imports')
    >>> vcs_imports.teamowner is None
    False
    >>> vcs_imports.is_valid_person # Not valid person because it is a team
    False
    >>> lifeless = personset.getByName('lifeless')
    >>> lifeless.teamowner is None
    True

An IPerson has an inTeam method to allow us to easily check if a
person is a member of a team. It accepts an object implementing
IPerson, which is the common use case when checking permissions.

    >>> ddaa = personset.getByName('ddaa')
    >>> ddaa.is_valid_person
    True
    >>> lifeless.inTeam(vcs_imports) and ddaa.inTeam(vcs_imports)
    True

The inTeam method is cached to avoid unnecessary database lookups - this
was a cause of a number of timeouts

    >>> from zope.security.proxy import removeSecurityProxy
    >>> naked_lifeless = removeSecurityProxy(lifeless)
    >>> naked_lifeless._inTeam_cache[vcs_imports.id]
    True
    >>> naked_lifeless._inTeam_cache[vcs_imports.id] = False
    >>> lifeless.inTeam(vcs_imports)
    False
    >>> naked_lifeless._inTeam_cache[vcs_imports.id] = True
    >>> lifeless.inTeam(vcs_imports)
    True

If a Person is not a Team then the Person object will not provide the
ITeam interface.

    >>> from canonical.launchpad.interfaces import ITeam
    >>> ITeam.providedBy(lifeless)
    False

If a Person is a Team then the Person will provide the ITeam interface.

    >>> ITeam.providedBy(vcs_imports)
    True

If a team doesn't have a contact email address, all notifications we send to
the team will go to the preferred email of each member.

    >>> contactEmailAddresses(vcs_imports)
    set(['david.allouche@canonical.com', 'robertc@robertcollins.net',
         'foo.bar@canonical.com'])


Renaming persons
----------------

All persons have a unique name in launchpad, so to allow them to change their
names, we must make sure that name is not already in use by someone else.

    >>> from canonical.launchpad.interfaces.person import PersonNameField
    >>> field = PersonNameField(__name__='name', title=u'Unique name',
    ...                         description=u'', readonly=False, required=True)
    >>> field = field.bind(lifeless)
    >>> field.context == lifeless
    True

You can always use your own name.

    >>> field.validate(lifeless.name)

Or a name that is not already in use.

    >>> field.validate(u'namenotinuse')

But you can't use Mark's name, of course. ;)

    >>> field.validate(u'sabdfl')
    Traceback (most recent call last):
      ...
    LaunchpadValidationError: ...sabdfl is already in use by another
    person or team...


Searching
---------

You can search based on a person's name or displayname, or any of the email
addresses that belongs to a person using the methods provided by IPersonSet.

While we don't have Full Text Indexes in the emailaddress table, we'll be
trying to match the text only against the beginning of an email address:

    >>> results = personset.find('ubuntu')
    >>> for person in results:
    ...     emails = [email.email for email in emailset.getByPerson(person)]
    ...     (person.displayname, person.name, emails)
    (u'Mirror Administrators', u'ubuntu-mirror-admins', [])
    (u'Sigurd Gartmann', u'sigurd-ubuntu', [u'sigurd-ubuntu@brogar.org'])
    (u'Ubuntu Gnome Team', u'name18', [])
    (u'Ubuntu Team', u'ubuntu-team', [u'support@ubuntu.com'])
    (u'Ubuntu Translators', u'ubuntu-translators', [])

    >>> results = personset.find('steve.alexander')
    >>> for person in results:
    ...     emails = [email.email for email in emailset.getByPerson(person)]
    ...     (person.displayname, person.name, emails)
    (u'Steve Alexander', u'stevea', [u'steve.alexander@ubuntulinux.com'])

Searching only for People based on their names or email addresses:

    >>> results = personset.findPerson('james.blackwell')
    >>> for person in results:
    ...     emails = [email.email for email in emailset.getByPerson(person)]
    ...     (person.displayname, person.name, emails)
    (u'James Blackwell', u'jblack', [u'james.blackwell@ubuntulinux.com'])

    >>> results = personset.findPerson('dave')
    >>> for person in results:
    ...     emails = [email.email for email in emailset.getByPerson(person)]
    ...     (person.displayname, person.name, emails)
    (u'Dave Miller', u'justdave', [u'dave.miller@ubuntulinux.com', u'justdave@bugzilla.org'])

Searching only for Teams based on their names or email addresses:

    >>> results = personset.findTeam('support')
    >>> for person in results:
    ...     emails = [email.email for email in emailset.getByPerson(person)]
    ...     (person.displayname, person.name, emails)
    (u'Ubuntu Team', u'ubuntu-team', [u'support@ubuntu.com'])

    >>> results = personset.findTeam('translators')
    >>> for person in results:
    ...     emails = [email.email for email in emailset.getByPerson(person)]
    ...     (person.displayname, person.name, emails)
    (u'Ubuntu Translators', u'ubuntu-translators', [])


Packages related to a person
----------------------------

To obtain the packages a person is related to, we can use the
latestMaintainedPackages() and latestUploadedButNotMaintainedPackages()
methods of IPersonSet. The former will return the latest
SourcePackageReleases a person uploaded in which he is listed as the
Maintainer. The latter will return the latest SourcePackageReleases a
person uploaded (where he isn't the maintainer).

    >>> sabdfl = personset.getByName('sabdfl')
    >>> for sprelease in sabdfl.latestMaintainedPackages():
    ...     print (sprelease.name, sprelease.uploaddistrorelease.fullreleasename,
    ...            sprelease.version)
    (u'alsa-utils', u'Debian Sid', u'1.0.9a-4')
    (u'pmount', u'Ubuntu Hoary', u'0.1-2')
    (u'netapplet', u'Ubuntu Warty', u'0.99.6-1')
    (u'netapplet', u'Ubuntu Hoary', u'1.0-1')
    (u'alsa-utils', u'Ubuntu Warty', u'1.0.8-1ubuntu1')
    (u'mozilla-firefox', u'Ubuntu Hoary', u'0.9')
    (u'evolution', u'Ubuntu Hoary', u'1.0')

    >>> for sprelease in sabdfl.latestUploadedButNotMaintainedPackages():
    ...     print (sprelease.name, sprelease.uploaddistrorelease.fullreleasename,
    ...            sprelease.version)
    (u'foobar', u'Ubuntu Breezy-autotest', u'1.0')
    (u'cdrkit', u'Ubuntu Breezy-autotest', u'1.0')
    (u'cnews', u'Ubuntu Breezy-autotest', u'1.0')
    (u'libstdc++', u'Ubuntu Hoary', u'b8p')
    (u'cnews', u'Ubuntu Hoary', u'cr.g7-37')
    (u'linux-source-2.6.15', u'Ubuntu Hoary', u'2.6.15.3')
    (u'at', u'Ubuntu Hoary', u'0.00')
    (u'alsa-utils', u'Ubuntu Hoary', u'1.0.9a-4ubuntu1')


Translations
------------

The IPerson interface offers a way of returning POFileTranslator records
for a Person:

  >>> carlos = getUtility(IPersonSet).getByName('carlos')
  >>> [pt.pofile.title for pt in carlos.translation_history]
  [u'Spanish (es) translation of man in Ubuntu Hoary package "evolution"',
   u'Spanish (es) translation of evolution-2.2 in Evolution trunk',
   u'Japanese (ja) translation of evolution-2.2 in Ubuntu Hoary package "evolution"',
   u'Spanish (es) translation of evolution-2.2 in Ubuntu Hoary package "evolution"']

The IPersonSet component contains a few convenience methods to return
Person objects that have contributed translations.

  >>> from canonical.launchpad.database import POFile
  >>> pofile = POFile.get(12)
  >>> [p.name for p in personset.getPOFileContributors(pofile)]
  [u'carlos', u'name16', u'tsukimi']

getPOFileContributorsByDistroRelease gives the list of people that did
contributions to templates that are current in the given IDistroRelease
and ILanguage.

  >>> from canonical.launchpad.database import DistroRelease, Language
  >>> hoary = DistroRelease.selectOneBy(name="hoary")
  >>> spanish = Language.selectOneBy(code="es")
  >>> [p.name for p in personset.getPOFileContributorsByDistroRelease(hoary, spanish)]
  [u'jorge-gonzalez-gonzalez', u'carlos', u'valyag', u'danner', u'name16',
   u'name12', u'tsukimi']

  # We can see that there is another translator that doesn't appear in
  # previous list because the template he translated is not current.
  >>> non_current_pofile = POFile.get(31)
  >>> non_current_pofile.potemplate.iscurrent
  False
  >>> [p.name for p in personset.getPOFileContributors(non_current_pofile)]
  [u'jordi']
  >>> non_current_pofile.potemplate.distrorelease == hoary
  True
  >>> non_current_pofile.language == spanish
  True


Specification Lists
-------------------

We should be able to generate lists of specifications for people based on
certain criteria:

First, Carlos does not have any completed specifications assigned to him:

    >>> from canonical.lp.dbschema import SpecificationFilter
    >>> carlos.specifications(filter=[
    ...     SpecificationFilter.ASSIGNEE, SpecificationFilter.COMPLETE]).count()
    0

Next, Carlos has three incomplete specs *related* to him:

    >>> filter = []
    >>> for spec in carlos.specifications(filter=filter):
    ...     print spec.name, spec.is_complete, spec.informational
    svg-support False False
    extension-manager-upgrades False True
    media-integrity-check False False

Carlos has 2 specifications assigned to him:

    >>> filter = [SpecificationFilter.ASSIGNEE]
    >>> for spec in carlos.specifications(filter=filter):
    ...     print spec.name
    svg-support
    extension-manager-upgrades

Just for fun, lets check the SAB. He should have one spec for which he
is the approver.

    >>> sabdfl = getUtility(IPersonSet).getByName('sabdfl')
    >>> filter = [SpecificationFilter.APPROVER]
    >>> for spec in sabdfl.specifications(filter=filter):
    ...     print spec.name
    extension-manager-upgrades

The Foo Bar person has a single spec which has feedback requested:

    >>> filter = [SpecificationFilter.FEEDBACK]
    >>> for spec in foobar.specifications(filter=filter):
    ...     print spec.name
    e4x

But has registered 5 of them:

    >>> filter = [SpecificationFilter.CREATOR]
    >>> print foobar.specifications(filter=filter).count()
    5

Now Celso, on the other hand, has 2 specs related to him:

    >>> cprov = personset.getByName('cprov')
    >>> cprov.specifications().count()
    2

On one of those, he is the approver:

    >>> filter = [SpecificationFilter.APPROVER]
    >>> for spec in cprov.specifications(filter=filter):
    ...     print spec.name
    svg-support

And on another one, he is the drafter

    >>> filter = [SpecificationFilter.DRAFTER]
    >>> for spec in cprov.specifications(filter=filter):
    ...     print spec.name
    e4x

We can filter for specifications that contain specific text:

    >>> for spec in cprov.specifications(filter=['svg']):
    ...     print spec.name
    svg-support

Inactive products are excluded from the listings.

    >>> from canonical.database.sqlbase import flush_database_updates
    >>> from canonical.launchpad.interfaces import IProductSet
    >>> from canonical.launchpad.ftests import login
    >>> firefox = getUtility(IProductSet).getByName('firefox')
    >>> login("foo.bar@canonical.com")
    >>> firefox.active = False
    >>> flush_database_updates()
    >>> cprov.specifications(filter=['svg']).count()
    0

Reset firefox so we don't mess up later tests.

    >>> firefox.active = True
    >>> flush_database_updates()

Ubunteros
---------

To list all Ubunteros, use IPersonSet.getUbunteros():

    >>> [p.name for p in personset.getUbunteros()]
    [u'name16']

To check if a person is an Ubuntero, use IPerson.is_ubuntero:

    >>> foobar.is_ubuntero
    True

Branches
--------

** See branch.txt for API related to branches.

