Things TODO
-----------

* Treat {arch} as a branch boundary

   Some source packages have {arch} in their sub-directories, this is
   a good place to invent a branch boundary if we're not already doing
   that.

   Otherwise we create {arch} in a sub-directory of a branch, which is
   sucky.

   We could also be intelligent and borrow branch names, etc. from
   them.

   These actually needs some thought, because simply adding to the
   manifest isn't enough as the inventory doesn't have it.


* WorkingManifest

   Refactor the manifest code so we have a WorkingManifest class that
   takes an inventory and optionally an existing manifest object and
   builds the new manifest structure, including branches and branch
   relationships.

   We'll pass this to the importer code instead of the
   direct-from-database stuff.

   We'll then have some kind of method that saves this in the database
   or writes it out to an XML file, etc.

   Also need a method to load a WorkingManifest from disk (skipping
   the inventory stage entirely).


* Manifest matching

   Need to make really sure generated manifests don't have equal
   generalised paths (or we have a matching problem).

   This should probably be a final check rather than the matching one
   we use now.


* Children manifest

   Need to copy entire manifests including children elements, not just
   the first element.  Need to work out how to then hide further
   detected children while keeping in mind that .diff.gz has children.

   One way would be to add that manifest to the manifest we match
   against, so children would match or be new.


* Children inventories

   Need to ignore children inventory entries when we ignore their
   parent.


* User interaction

   Need to ask the user to confirm the finished manifest, and whenever
   we have a problem.  If no user present *then* we can raise a
   ManifestError.


* Better repository naming

   Still need to store desired archive, category and version somewhere
   for branch naming purposes.


* Different branch schemes

   Right now we're just doing tracked, need to do versioned and exact
   as well (and any others we think of).


* Versioning

   Need to keep an idea about what version of an object we're looking
   for, this will be important for upstream releases and versioned
   branches, etc.

   This also applies to imports, need to work out what version of
   upstream to sync with, not just the latest.


* Replace getUpstreamRelease with getFile

   We should really be checking the files we have against the Soyuz
   file repository, not the name of upstream releases.  If we check
   md5sums this can match the .orig.tar.gz without hackery.


* Stop abusing objects

   Use dicts instead of item.manifest and abusing item.kind,
   item.product, etc.


* Patch after what?

   For patches, we may need to apply them after another patch (in a
   chain).  Take this into account when testing them out.


* Save manifests properly

   We're not saving a copy of the manifest for SourcePackageRelease
   yet.  We need to do that, remembering the changeset numbers.


* Parse changelog

   Mark came up with the idea of parsing the changelog and finding a
   useful previous release, rather than having a head manifest.  I
   like it.
