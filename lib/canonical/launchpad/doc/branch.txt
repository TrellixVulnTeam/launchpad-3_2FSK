Bazaar Branches
===============

The Branch table holds information about an Bazaar Branch. It describes the
Launchpad user model of a branch, and in particular should be able (in the
future) to support un-committing of revisions.

It has a N-N association to the Revision table through the RevisionNumber
table. An association table is required because the sequence of revisions
listed by "bzr log" is defined by a "revision-history" file which has some
freedom with respect to the ancestry of revisions.

  * Distinct revision histories may point to same revision.

  * Revision histories including the same revision may have different starting
    points, they need not trace history back to the initial import. Therefore a
    given revision may have a different order number in different branches.

  * A revision history is required to follow the ancestry DAG, but two
    different branches may have histories tracing a different path between two
    shared revisions. This is exercised by the "convergence" feature of "bzr
    pull".

A Branch is not tied to an URL, since a branch may change locations over time.
It's not tied to a specific revision history because each new commit appends to
the history, and it's not restricted to appending to the history because the
Bazaar model does not forbid users from replacing the history of a branch.

Actually, the conceptual model of Bazaar does not really have an identifiable
concept of a branch. Branch describes a Launchpad concept.

Creating branches
-----------------

Branches can be created with IBranchSet.new. IBranchSet can be accessed as an
utility.

>>> from zope.component import getUtility
>>> from canonical.launchpad.interfaces import IBranchSet
>>> branchset = getUtility(IBranchSet)

>>> from canonical.launchpad.interfaces import IProductSet
>>> productset = getUtility(IProductSet)
>>> firefox_product = productset.get(4)

>>> from canonical.launchpad.interfaces import IPersonSet
>>> personset = getUtility(IPersonSet)
>>> ddaa = personset.getByName('ddaa')

>>> url = 'http://example.com/~ddaa/firefox.dev'
>>> title = "David Allouche's Main Firefox Branch"
>>> summary = "Main line of development for David Allouche on Firefox."
>>> home_page = "http://example.com/~ddaa/"
>>> firefox_dev = branchset.new('dev', ddaa, firefox_product, url,
...     title, summary=summary, home_page=home_page)
>>> firefox_dev.name
u'dev'
>>> firefox_dev.product == firefox_product
True

Branches must implement the IBranch interface.

>>> from zope.interface.verify import verifyObject
>>> from canonical.launchpad.interfaces import IBranch
>>> verifyObject(IBranch, firefox_dev)
True

Branch may or may not be associated to a product, and may have no home_page

>>> url = 'http://example.com/~ddaa/junkcode'
>>> junkcode = branchset.new('junkcode', ddaa, None, url,
...     title, summary=summary)
>>> junkcode.name
u'junkcode'
>>> junkcode.product is None
True
>>> junkcode.home_page is None
True

Branches and products
---------------------

Branch not associated to a product are called "junk" branch and treated for
navigation purposes as if they were associated to a magic product named
"+junk".

>>> junkcode.product_name
'+junk'
>>> firefox_dev.product_name
u'firefox'

Branches registered and authored
--------------------------------

You can get the list of branches for a given Launchpad owner. These are called
the "registered branches", because the owner is initially set to the current
user by the branch creation forms.

>>> def getName(branch):
...     return branch.name
>>> sorted(ddaa.registered_branches, key=getName) == [firefox_dev, junkcode]
True

Branches are associated to an "author" user, which may be different from the
registrant. You can get the branch authored by a given person. Junk branches
should generally have at least an author, but that is not enforced.

>>> list(ddaa.authored_branches)
[]
>>> junkcode.author = ddaa
>>> list(ddaa.authored_branches) == [junkcode]
True

The list of registered branches does not include branches whose registrant is
also the author. That avoids duplicating the same branch in the registered and
authored branch listings for a person.

>>> list(ddaa.registered_branches) == [firefox_dev]
True

Branch subscriptions
--------------------

Branches can be subscribed to and unsubscribed from by a Person.

>>> from canonical.launchpad.interfaces import IPerson, IBranchSubscription
>>> sabdfl = personset.getByName('sabdfl')
>>> sabdfl.subscribed_branches
[]
>>> subscription = firefox_dev.subscribe(sabdfl)
>>> verifyObject(IBranchSubscription, subscription)
True
>>> subscription.branch == firefox_dev and subscription.person == sabdfl
True
>>> firefox_dev.subscriptions == [subscription]
True
>>> firefox_dev.subscribers == [sabdfl]
True
>>> sabdfl.subscribed_branches == [firefox_dev]
True
>>> firefox_dev.unsubscribe(sabdfl)
>>> firefox_dev.subscribers
[]

Branches related to a person
----------------------------

Finally, you can get the list of related branches for a person, that includes
the branches registered, authored and subscribed to by this person.

>>> lifeless = personset.getByName('lifeless')
>>> lifeless.branches
[]
>>> url = 'http://example.com/~lifeless/mesh-merge'
>>> title = "Experimental mesh merging algorithm."
>>> meshmerge = branchset.new('mesh-merge', lifeless, None, url,
...     title, summary=title)
>>> junkcode.author = lifeless
>>> unused = firefox_dev.subscribe(lifeless)
>>> [getName(b) for b in lifeless.branches]

>>> sorted(lifeless.branches, key=getName) == [firefox_dev, junkcode, meshmerge]
True

Branches and revisions
----------------------

See revision.txt for a doctest covering the creation of revisions and related
objects. Revision data is loaded in the database by a batch job using a
different user, Launchpad code is only concened with using this data.

    TODO: test Branch.revision_history, Branch.revision_count, and
    Branch.latest_revisions from sampledata. Cannot populate the tables from
    here because only the importd user is allowed to do that, and importd works
    in a zopeless environment. -- DavidAllouche 2005-10-21

    TODO: There should be tests for Revision, RevisionNumber and RevisionParent
    as well. -- DavidAllouche 2005-10-25

    TODO: Test Revision.parents_ids and demonstrate usage.
    -- DavidAllouche 2005-10-25

    TODO: Test Branch.revisions_since

    TODO: Test RevisionSet.getByRevisionID
