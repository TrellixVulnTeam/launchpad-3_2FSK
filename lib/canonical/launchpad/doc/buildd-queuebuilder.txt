QueueBuilder Tests
==================

QueueBuilder is a script to sanely initialise new build jobs, it
verifies the available DistroArchReleases, for which we are able to
build packages, repairs broken Builds entries that makes sense,
verifies the packages pending to build, install the jobs in
BuildQueue table and scores the build acording a bunch of
parameters.

  >>> from canonical.launchpad.scripts.builddmaster import BuilddMaster

import the bunch of required database classes:

  >>> from canonical.launchpad.database import (
  ...      SourcePackageRelease, SourcePackageName, DistroRelease,
  ...      SourcePackagePublishingHistory,
  ...      SecureSourcePackagePublishingHistory,
  ...      PocketChroot, DistroArchRelease, Build, BuildQueue,
  ...      SourcePackageReleaseFile)

  >>> from canonical.lp.dbschema import (
  ...      PackagePublishingPocket, PackagePublishingStatus,
  ...      SourcePackageFileType)

  >>> from canonical.database.constants import UTC_NOW


The Master side of Buildd requires access to Launchpad Database, the
user designed for this kind of access is 'fiera', as in all test the
transaction should be retrieved.

  >>> import transaction

The master also requires an 'logging' instance to not compromise the
standard output with noisely output.

  >>> import logging

Now we have satisfied all needs for BuildMaster, let's instantiate it.

  >>> bm = BuilddMaster(logging.getLogger(), transaction)

Emulates a PocketChroot entry to validate the distroarchrelese
Ubuntu/Warty/i386/RELEASE and Debian/Woody/i386/RELEASE:

  >>> warty = DistroRelease.selectOneBy(name='warty')
  >>> warty_dar = DistroArchRelease.selectOneBy(distroreleaseID=warty.id,
  ...                                           architecturetag='i386')

  >>> woody = DistroRelease.selectOneBy(name='woody')
  >>> woody_dar = DistroArchRelease.selectOneBy(distroreleaseID=woody.id,
  ...                                           architecturetag='i386')


Pick up any existent librarian file as chroot.

  >>> pocket = PocketChroot(distroarchreleaseID=warty_dar.id,
  ...                       chroot=1)

  >>> pocket = PocketChroot(distroarchreleaseID=woody_dar.id,
  ...                       chroot=2)

Produce a set of available DistroArchRelease, for which the
build jobs will be created.

  >>> distroreleases = set()
  >>> for dar in DistroArchRelease.select():
  ...     distroreleases.add(dar.distrorelease)
  ...     bm.addDistroArchRelease(dar)
  ...

Only Ubuntu/Warty/i386 and Debian/Woody/i386 have an available CHROOT.

  >>> sorted((arch.distrorelease.name, arch.architecturetag)
  ...        for arch in bm._archreleases)
  [(u'warty', u'i386'), (u'woody', u'i386')]

Adding a new dummy sourcepackagerelease and publish it in Ubuntu/Warty/i386:

  >>> name = SourcePackageName(name="test-buildd")

Note that the magic number "1" is used to pick up an arbitrary required
entity from the existent sampledata, we don't care about
them. (creator=1 is sabdfl, manifest=1 is the first dummy manifest
added by the current sample data and so on)

  >>> srcpkgrel = SourcePackageRelease(creator=1, version='666',
  ...                                  section=1, maintainer=1, component=1,
  ...                                  uploaddistrorelease=1,
  ...                                  sourcepackagename=name.id,
  ...                                  architecturehintlist="all",
  ...                                  builddependsindep='foo (<< 1.0)',
  ...                                  builddepends=None, dsc=None,
  ...                                  changelog=None, manifest=1,
  ...                                  dscsigningkey=None)

  >>> tar = SourcePackageFileType.TARBALL
  >>> srcfile = SourcePackageReleaseFile(sourcepackagerelease=srcpkgrel.id,
  ...                                    libraryfile=1,
  ...                                    filetype=tar)
  >>> srcfile.libraryfile.filename, srcfile.sourcepackagerelease.name
  (u'netapplet-1.0.0.tar.gz', u'test-buildd')

We need to publish the source in order to get it visible to the
createMissingBuilds() method. Additionally if the target is an already
released distrorelease it can only be visible if published in in
special pocket (UPDATES, SECURITY or BACKPORTS)

  >>> published = PackagePublishingStatus.PUBLISHED
  >>> release_pocket = PackagePublishingPocket.UPDATES
  >>> p = SecureSourcePackagePublishingHistory(
  ...                                    sourcepackagerelease=srcpkgrel.id,
  ...                                    distroreleaseID=warty.id,
  ...                                    status=published,
  ...                                    pocket=release_pocket,
  ...                                    component=srcpkgrel.component,
  ...                                    section=srcpkgrel.section,
  ...                                    datecreated=UTC_NOW)


Store how many Build entries we have from sampledata, and
create missing builds (packages w/o build entry) for those distroreleases.
As we just insert a new sourcepackagerelease in run-time we expect to
have a new build for the sane Warty and a warning about the
absence of nominatedarchindep field for Woody:

  >>> build_count = Build.select().count()
  >>> for dr in distroreleases:
  ...      bm.createMissingBuilds(dr)
  WARNING:root:No Nominated Architecture Independent, skipping distrorelease ...
  WARNING:root:No Nominated Architecture Independent, skipping distrorelease ...

Check that we only created a new Build entry for the added sourcepackagerelease:

  >>> Build.select().count() - build_count
  1

  >>> b = Build.selectOneBy(sourcepackagereleaseID=srcpkgrel.id)
  >>> (b.sourcepackagerelease.name, b.distroarchrelease.distrorelease.name)
  (u'test-buildd', u'warty')

Now we have Build table properly set and probably with some entries
marked as NEEDSBUILD we can create BuildQueue entries for it

  >>> bm.addMissingBuildQueueEntries()
  >>> BuildQueue.select().count()
  4

A separate process is responsible for cleaning up the BuildQueue and
scroring the jobs properly.

The default score value is 0 (zero), attempt for the fact we already
have two build queue entries added by the sampledata, that's why the 3rd
element of the result.

  >>> job = BuildQueue.select(orderBy='id')[2]
  >>> job.lastscore
  0

Check the published component name retriever, they might be different,
i.e., the published component can be different than the original component.

  >>> job.component_name
  u'main'
  >>> job.build.sourcepackagerelease.component.name
  u'main'

After sanitising the jobs, only the ones containing
sourcepackagerelease files should remain:

  >>> new_jobs = bm.sanitiseAndScoreCandidates()
  WARNING:root:MISSING DEP: [('foo', '1.0', '<<')] in warty i386

  >>> len(new_jobs)
  1

  >>> job = new_jobs[0]
  >>> job.build.sourcepackagerelease.name
  u'test-buildd'

And we grant some score depending on: time pending on the buildqueue,
component the package belongs to, and the urgency of the upload.
There is still some work to do here, for further information see the
launchpad/scripts/builddmaster.py code. The job presented should won
exactly ** 995 ** points last turn (5 for the default urgency 'LOW'
1000 for the 'Main' component and -10 for one unsatisfied dependency,
further tests for scoring are in buildd-scoring.txt)

  >>> job.lastscore
  995



