
Using EnumCol
=============

*Note:* This document is about canonical.lp.dbschema.EnumCol, not SQLObject's
builtin EnumCol.

Test imports and setup.

    >>> from canonical.database.sqlbase import SQLBase
    >>> from canonical.database.constants import DEFAULT
    >>> from canonical.launchpad.ftests.harness import LaunchpadTestSetup

Let's make a example table to demonstrate EnumCol with.  Enumerations are stored
in the database as integers, and we'll give the column a default value.

    >>> connection = LaunchpadTestSetup().connect()
    >>> cursor = connection.cursor()
    >>> cursor.execute('''
    ...     CREATE TABLE Test (
    ...         id serial NOT NULL,
    ...         foo integer DEFAULT 1 NOT NULL 
    ...     );
    ... ''')
    >>> cursor.execute('GRANT ALL ON TABLE Test TO launchpad;')
    >>> cursor.execute('GRANT ALL ON test_id_seq TO launchpad;')
    >>> connection.commit()

Let's define a schema for that column.

    >>> from canonical.launchpad.webapp.enum import DBSchema, Item
    >>> class FooSchema(DBSchema):
    ...     """Schema for the foo column."""
    ...     ONE = Item(1, """
    ...         One
    ... 
    ...         Number one.
    ...         """)
    ...
    ...     TWO = Item(2, """
    ...         TWO
    ... 
    ...         Number two.
    ...         """)
 
Now let's define an SQLObject for that table, using FooSchema as the schema for
the foo column.  We declare the default value for the foo column to be whatever
the database's default is.

    >>> from canonical.database.enumcol import EnumCol
    >>> class Test(SQLBase):
    ...     foo = EnumCol(schema=FooSchema, default=DEFAULT)

Create a row in the table.
 
    >>> t = Test()

The value of the foo column has been set to the default defined in the database,
because we didn't specify one.

    >>> t.foo == FooSchema.ONE
    True

You cannot use integers or strings as EnumCol values:

    >>> t.foo = 2
    Traceback (most recent call last):
    ...
    TypeError: Need to set a dbschema Enum column to a dbschema Item, not an int

    >>> t.foo = "TWO"
    Traceback (most recent call last):
    ...
    TypeError: Not a DBSchema Item: 'TWO'

You can of course use items from FooSchema.

    >>> t.foo = FooSchema.TWO

But not items from another schema.

    >>> class AnotherSchema(DBSchema):
    ...     ONE = Item(1, """
    ...         One
    ... 
    ...         Number one.
    ...         """)
    >>> t.foo = AnotherSchema.ONE
    Traceback (most recent call last):
    ...
    TypeError: DBSchema Item from wrong class, <class 'AnotherSchema'> != <class 'FooSchema'>

