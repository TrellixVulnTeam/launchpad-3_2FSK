= LAZR config =

The LAZR config system is used to manage process configuration.
Process configuration is for saying how things change when we run
Launchpad on different machines, or under different circumstances.

This system uses ini-like file format of section, keys, and values.
The config file supports inheritance to minimize duplication of
information across files. The format supports schema validation.


== ConfigSchema and ConfigSchemaParser ==

A schema is loaded by instantiating the ConfigSchema class with
the path to a configuration file. The schema is explicitly derived from
the information in the configuration file.

    >>> from os import path
    >>> from canonical.launchpad.webapp.testing import verifyObject
    >>> from canonical.lazr.config import ConfigSchema
    >>> from canonical.lazr.interfaces import IConfigSchema

    >>> base_conf = path.normpath(path.join(
    ...     path.dirname(__file__), '..', 'ftests', 'testfiles', 'base.conf'))

The config file contains sections enclosed in square brackets ([]).
The section name may be divided into major and minor categories using a
dot (.). Beneath each section is a list of key-value pairs, separated
by a colon (:). Multiple sections with the same major category may have
their keys defined in another section that appends the '.template'
suffix to the category name. A section with '.optional' suffix is not
required. Lines that start with a hash (#) are comments.

    >>> schema_file = open(base_conf, 'r')
    >>> raw_schema = schema_file.read()
    >>> schema_file.close()
    >>> print raw_schema
    # This section defines required keys and default values.
    [section-1]
    key1: foo
    key2: bar and baz
    key3: Launchpad&nbsp;rocks
    key4: F&#028c;k yeah!
    key5:
    # This section is required, and it defines all the keys for its category.
    [section-2.app-b]
    key1: True
    # These sections define a common set of required keys and default values.
    [section-3.template]
    key1: 17
    key2: 3.1415
    # This section is optional; it uses the keys defined
    # by section-3.template.
    [section-3.app-a.optional]
    # This is a required section whose keys are defined by section-3.template
    # and it defines a new key.
    [section-3.app-b]
    key2: changed
    key3: unique
    # This section is optional.
    [section-5.optional]
    key1: something

    >>> schema = ConfigSchema(base_conf)
    >>> verifyObject(IConfigSchema, schema)
    True

    >>> schema.name
    'base.conf'
    >>> schema.filename
    '...ftests/testfiles/base.conf'

A schema is made up of multiple SchemaSections. They can be iterated
over in a loop as needed.

    >>> from operator import attrgetter
    >>> for section_schema in sorted(schema, key=attrgetter('name')):
    ...     print section_schema.name
    section-1
    section-2.app-b
    section-3.app-a
    section-3.app-b
    section-5

You can check if the schema contains a section name, and that can be
used to access the SchemaSection as a subscript.

    >>> 'section-1' in schema
    True
    >>> 'section-4' in schema
    False

A SectionSchema can be retrieved from the schema using the []
operator

    >>> section_schema_1 = schema['section-1']
    >>> section_schema_1.name
    'section-1'

A SectionNotFound error is raised if the name does not match any of the
SectionSchemas.

    >>> section_schema_app_a = schema['section-3.app-a']
    >>> schema['section-4']
    Traceback (most recent call last):
      ...
    NoSectionError: ...

Processes often require resources like databases or vhosts that have a
common category of keys. The list of all category names can be retrieved
via the categories attribute.

    >>> schema.category_names
    ['section-3', 'section-2']

The list of SchemaSections that share common category can be retrieved
using getByCategory().

    >>> all_section_3 = schema.getByCategory('section-3')
    >>> for section_schema in sorted(all_section_3, key=attrgetter('name')):
    ...     print section_schema.name
    section-3.app-a
    section-3.app-b

An error is raised when accessing a category does not exist.

    >>> schema.getByCategory('non-section')
    Traceback (most recent call last):
      ...
    NoCategoryError: ...


== SchemaSection ==

A SchemaSection behaves similar to a dictionary. It has keys and
values. Each SchemaSection has a name.

    >>> from canonical.lazr.interfaces import ISectionSchema
    >>> section_schema_1 = schema['section-1']
    >>> verifyObject(ISectionSchema, section_schema_1)
    True

    >>> section_schema_1.name
    'section-1'

Optional sections have the optional attribute set to True:

    >>> section_schema_1.optional
    False
    >>> schema['section-3.app-a'].optional
    True

A key can be verified to be in a section.

    >>> 'key1' in section_schema_1
    True
    >>> 'nonkey' in section_schema_1
    False

A key can be accessed directly using as a subscript of the SchemaSection.
The value is always a string.

    >>> section_schema_1['key3']
    'Launchpad&nbsp;rocks'
    >>> section_schema_1['key5']
    ''

An error is raised if a non-existent key is accessed.

    >>> section_schema_1['not-exist']
    Traceback (most recent call last):
      ...
    KeyError: ...

In the conf file, '[section-1]' is a default section that defines keys
and values. The values specified in the section schema will be used as
default values if not overriden in the configuration. In the case of
key5, the key had no explicit value, so the value is an empty string.

    >>> for key in sorted(section_schema_1):
    ...     print key, ':', section_schema_1[key]
    key1 : foo
    key2 : bar and baz
    key3 : Launchpad&nbsp;rocks
    key4 : F&#028c;k yeah!
    key5 :

In the conf file '[section-3.template]' defines a common set of keys and
default values for '[section-3.app-a]' and '[section-3.app-b]'. When a
section defines different keys and default values s from the template,
the new data overlays the template data. This is the case for section
'[section-3.app-b]'.

    >>> for section_schema in sorted(all_section_3, key=attrgetter('name')):
    ...     print section_schema.name
    ...     for key in sorted(section_schema):
    ...         print key, ':', section_schema[key]
    section-3.app-a
    key1 : 17
    key2 : 3.1415
    section-3.app-b
    key1 : 17
    key2 : changed
    key3 : unique


== ConfigSchema validation ==

ConfigSchema will raise an error if the schema file cannot be opened.

    >>> ConfigSchema("no-such-file")
    Traceback (most recent call last):
      ...
    IOError: [Errno 2] No such file or directory: ...

The schema parser is self-validating. It will check that the character
encoding is ascii. It will check that the data is not ambiguous or
self-contradicting.

Schema files that contain non-ASCII characters raise a
UnicodeDecodeError.

    >>> testfiles_dir = path.normpath(path.join(
    ...     path.dirname(__file__), '..', 'ftests', 'testfiles'))
    >>> ConfigSchema('%s/%s' % (testfiles_dir, 'bad-nonascii.conf'))
    Traceback (most recent call last):
      ...
    UnicodeDecodeError: ...

Keys without sections raise MissingSectionHeaderError.

    >>> ConfigSchema('%s/%s' % (testfiles_dir, 'bad-sectionless.conf'))
    Traceback (most recent call last):
      ...
    MissingSectionHeaderError: File contains no section headers. ...

Redefining a section in a config file will raise a RedefinedSectionError.

    >>> ConfigSchema('%s/%s' % (testfiles_dir, 'bad-redefined-section.conf'))
    Traceback (most recent call last):
      ...
    RedefinedSectionError: ...

# XXX sinzui 2007-12-13:
# ConfigSchema should raise RedefinedKeyError when a section redefines
# a key.

Defining a section that belongs to many categories will raise
a InvalidSectionNameError.

    >>> ConfigSchema('%s/%s' % (
    ...     testfiles_dir, 'bad-invalid-name.conf'))
    Traceback (most recent call last):
      ...
    InvalidSectionNameError: [category.other_category.name.optional] ...

As does using non word characters other than a dot or dash in the
section name.

    >>> ConfigSchema('%s/%s' % (
    ...     testfiles_dir, 'bad-invalid-name-chars.conf'))
    Traceback (most recent call last):
      ...
    InvalidSectionNameError: [$category.name_part.optional] ...
