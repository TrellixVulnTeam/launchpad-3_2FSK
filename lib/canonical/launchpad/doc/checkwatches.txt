== checkwatches.py ==

The updating and syncing of bug watches is done by a cronscript. We
can't test it properly, since we don't yet have a mock HTTP server we
can use for testing, so let's just make sure that it doesn't try to
contact any external servers.

    >>> from canonical.database.sqlbase import cursor
    >>> from canonical.database.constants import UTC_NOW
    >>> cur = cursor()
    >>> cur.execute("UPDATE BugWatch SET lastchecked=%s" % UTC_NOW)
    >>> import transaction
    >>> transaction.commit()

    >>> import subprocess
    >>> process = subprocess.Popen(
    ...     'cronscripts/checkwatches.py', shell=True,
    ...     stdin=subprocess.PIPE, stdout=subprocess.PIPE,
    ...     stderr=subprocess.PIPE)
    >>> (out, err) = process.communicate()
    >>> out
    ''
    >>> process.returncode
    0

    >>> print err
    INFO    creating lockfile
    INFO    No watches to update on http://bugs.debian.org
    WARNING ExternalBugtracker for BugTrackerType 'EMAILADDRESS' is not
            known.
    WARNING ExternalBugtracker for BugTrackerType 'SAVANNAH' is not known.
    INFO    No watches to update on http://bugzilla.gnome.org/bugs
    INFO    No watches to update on http://sourceforge.net/
    INFO    No watches to update on https://bugzilla.mozilla.org/
    INFO    Skipping updating Ubuntu Bugzilla watches.
    INFO    Time for this run: ... seconds.
    <BLANKLINE>

We set a default timeout on checkwatches to 30 seconds. In order to test
this, we can monkey-patch urllib2.urlopen so that it always raises a
timeout and call the checkwatches cronscript machinery directly.

First, we create some bug watches to test with:

    >>> from canonical.launchpad.database import BugTracker
    >>> from canonical.launchpad.interfaces import (
    ...     BugTrackerType, IBugSet)
    >>> from canonical.launchpad.scripts.checkwatches import (
    ...     BugWatchUpdater)
    >>> from canonical.launchpad.interfaces import (
    ...     IPersonSet)
    >>> sample_person = getUtility(IPersonSet).getByEmail(
    ...     'test@canonical.com')

    >>> example_bug_tracker = BugTracker(
    ...     name="example-bugs",
    ...     title="Example.com Roundup",
    ...     bugtrackertype=BugTrackerType.ROUNDUP,
    ...     baseurl="http://bugs.example.com",
    ...     summary="Contains bugs for Example.com",
    ...     contactdetails="foo.bar@example.com",
    ...     owner=sample_person)

    >>> login('test@canonical.com')

    >>> example_bug = getUtility(IBugSet).get(10)
    >>> example_bugwatch = example_bug.addWatch(
    ...     example_bug_tracker, 1, sample_person)

    >>> login('no-priv@canonical.com')

Next, we monkey-patch urllib2.urlopen so that it always times out.

The timeout will also produce an OOPS report.

    >>> from canonical.launchpad.ftests.externalbugtracker import oops_hook
    >>> oops_hook.install()

    >>> import socket
    >>> import urllib2
    >>> urlopen = urllib2.urlopen

    >>> transaction.commit()
    >>> def do_not_urlopen(url=None, data=None):
    ...     raise socket.timeout("Connection timed out.")
    >>> try:
    ...     urllib2.urlopen = do_not_urlopen
    ...     updater = BugWatchUpdater(transaction)
    ...     updater._login()
    ...     updater.updateBugTrackers(
    ...         bug_tracker_names=[example_bug_tracker.name])
    ...     print oops_hook.formatted_oops_info
    ... finally:
    ...     urllib2.urlopen = urlopen
    ERROR:root:Connection timed out when updating http://bugs.example.com
    OOPS-...
    baseurl=u'http://bugs.example.com'
    bugtracker=u'example-bugs'
    error-explanation=u'Connection timed out when updating...

    >>> oops_hook.uninstall()

Errors that occur when updating a bug watch are recorded against that
bug watch. The timeout will be recorded against the bug watch we just
created in its last_error_type field.

    >>> from canonical.launchpad.interfaces import BugWatchErrorType
    >>> example_bugwatch.last_error_type == BugWatchErrorType.TIMEOUT
    True

Another error which may occur and which checkwatches is responsible for
handling is UnknownBugTrackerTypeError, which is raised when
checkwatches attempts to instantiate the ExternalBugtracker descendant
for a bugtracker which Launchpad doesn't support.

We can demonstrate this by altering the get_external_bugtracker method
of the externalbugtracker module to ensure that it raises this error.

    >>> from canonical.launchpad.components import externalbugtracker
    >>> real_get_external_bugtracker = (
    ...     externalbugtracker.get_external_bugtracker)

    >>> def broken_get_external_bugtracker(bugtracker):
    ...     bugtrackertype = bugtracker.bugtrackertype
    ...     raise externalbugtracker.UnknownBugTrackerTypeError(
    ...         bugtrackertype.name, bugtracker.name)

    >>> login(ANONYMOUS)
    >>> try:
    ...     externalbugtracker.get_external_bugtracker = (
    ...         broken_get_external_bugtracker)
    ...     updater = BugWatchUpdater(transaction)
    ...     updater._login()
    ...     updater.updateBugTracker(example_bug_tracker)
    ... finally:
    ...     externalbugtracker.get_external_bugtracker = (
    ...         real_get_external_bugtracker)
    WARNING:...:ExternalBugtracker for BugTrackerType 'ROUNDUP' is not
    known.

The bug watch's last error type field will have been updated to reflect
the error that was raised:

    >>> example_bugwatch.last_error_type.title
    'Unsupported Bugtracker'


== Converting Remote Statuses ==

The BugWatchUpdater class places a wrapper, _convertRemoteStatus()
around ExternalBugTracker.convertRemoteStatus(). This allows it to
handle unknown remote statuses correctly and also means that
ExternalBugTracker implementations don't have to care about handling
the UNKNOWN_REMOTE_STATUS constant correctly.

This can be demonstrating using an example externalbugtracker class.

    >>> from canonical.launchpad.components.externalbugtracker import (
    ...     ExternalBugTracker, UnknownRemoteStatusError)
    >>> from canonical.launchpad.interfaces import BugTaskStatus
    >>> class ExampleExternalBugTracker(ExternalBugTracker):
    ...     def convertRemoteStatus(self, remote_status):
    ...         """Convert a remote status to a `BugTaskStatus`."""
    ...         status_map = {
    ...             'open': BugTaskStatus.NEW,
    ...             'closed': BugTaskStatus.FIXRELEASED}
    ...
    ...         try:
    ...             return status_map[remote_status]
    ...         except KeyError:
    ...             raise UnknownRemoteStatusError()

    >>> example_bugtracker = ExampleExternalBugTracker('http://example.com')
    >>> launchpad_status = updater._convertRemoteStatus(
    ...     example_bugtracker, 'open')
    >>> print launchpad_status.title
    New

If an unknown remote status is passed to the ExternalBugTracker's own
convertRemoteStatus() method an UnknownRemoteStatusError will be raised.

    >>> example_bugtracker.convertRemoteStatus('spoon')
    Traceback (most recent call last):
      ...
    UnknownRemoteStatusError

However, _convertRemoteStatus() wraps error handling around this.
It will catch the error, log a warning and return BugTaskStatus.UNKNOWN,
allowing checkwatches to continue its run.

    >>> status = updater._convertRemoteStatus(example_bugtracker, 'spoon')
    WARNING...Unknown remote status 'spoon'.

    >>> print status.title
    Unknown


== Batched Bugwatch Updating ==

checkwatches.py will only update those bugs that need updating, but
there is a further limit on the amount of bugs which will be updated for
a given ExternalBugTracker in each checkwatches run: the batch size.

We need to add some bug watches again since
BugWatchUpdate.updateBugTracker() automatically rolls back the
transaction if something goes wrong.

    >>> login('test@canonical.com')
    >>> for bug_id in range(1, 10):
    ...     example_bugwatch = example_bug.addWatch(
    ...         example_bug_tracker, bug_id, sample_person)

Since we know how many bugwatches example_bug has we will be able to see
when checkwatches only updates a subset of them.

    >>> example_bug.watches.count()
    9

Since our example bug tracker is a Roundup bug tracker we can
monkey-patch the Roundup ExternalBugTrackerClass in order to set its
batch size. We will also monkey-patch urllib2.urlopen again so that no
requests are actually made.

    >>> from canonical.launchpad.components import externalbugtracker
    >>> from canonical.launchpad.scripts import FakeLogger
    >>> original_log = externalbugtracker.log
    >>> batch_size = externalbugtracker.Roundup.batch_size
    >>> transaction.commit()
    >>> try:
    ...     updater = BugWatchUpdater(transaction)
    ...     updater._login()
    ...     urllib2.urlopen = do_not_urlopen
    ...     externalbugtracker.Roundup.batch_size = 5
    ...     updater.log = FakeLogger()
    ...     updater.updateBugTrackers([example_bug_tracker.name])
    ... finally:
    ...     externalbugtracker.log = original_log
    ...     externalbugtracker.Roundup.batch_size = batch_size
    ...     urllib2.urlopen = urlopen
    INFO Updating 5 watches on http://bugs.example.com
    ERROR Connection timed out when updating http://bugs.example.com

