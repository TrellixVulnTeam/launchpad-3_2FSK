Person
======

The Person class is overloaded to represent both people and teams. Let's
log in as Robert Collins to ensure we have the privileges to do what
we're going to demonstrate.

>>> from zope.component import getUtility
>>> from zope.interface.verify import verifyObject
>>> from canonical.database.sqlbase import sqlvalues, flush_database_updates
>>> from canonical.launchpad.interfaces import (
...     IPersonSet, IPerson, IEmailAddressSet)
>>> from canonical.launchpad.ftests import login
>>> from canonical.launchpad.helpers import contactEmailAddresses

>>> login("robertc@robertcollins.net")

>>> personset = getUtility(IPersonSet)
>>> emailset = getUtility(IEmailAddressSet)


Verify that foobar (a Person object) correctly implements IPerson.

>>> foobar = personset.getByName('name16')
>>> verifyObject(IPerson, foobar)
True


Access to people (Persons or Teams) is done through the IPersonSet
utility:

You can create a new person using the createPersonAndEmail method of
IPersonSet. All you need for that is a valid email address.
>>> p, email = personset.createPersonAndEmail('randomuser@randomhost.com')
>>> p.teamowner is None
True

>>> vcs_imports = personset.getByName('vcs-imports')
>>> vcs_imports.teamowner is None
False
>>> lifeless = personset.getByName('lifeless')
>>> lifeless.teamowner is None
True

An IPerson has an inTeam method to allow us to easily check if a
person is a member of a team. It accepts an object implementing
IPerson, which is the common use case when checking permissions.

>>> ddaa = personset.getByName('ddaa')
>>> lifeless.inTeam(vcs_imports) and ddaa.inTeam(vcs_imports)
True

If a Person is not a Team then the Person object will not provide the
ITeam interface.

>>> from canonical.launchpad.interfaces import ITeam
>>> ITeam.providedBy(lifeless)
False

If a Person is a Team then the Person will provide the ITeam interface.

>>> ITeam.providedBy(vcs_imports)
True

If a team doesn't have a contact email address, all notifications we send to
the team will go to the preferred email of each member.

>>> contactEmailAddresses(vcs_imports)
set(['david.allouche@canonical.com', 'robertc@robertcollins.net',
     'foo.bar@canonical.com'])

We don't support changing a Person into a Team or a Team into a Person.

>>> vcs_imports.teamowner = None
>>> ITeam.providedBy(vcs_imports)
True


Renaming
--------

All persons have a unique name in launchpad, so to allow them to change their
names, we must make sure that name is not already in use by someone else.

>>> from canonical.launchpad.fields import StrippingTextLine
>>> from canonical.launchpad.interfaces.person import PersonNameField
>>> field = PersonNameField(__name__='name', title=u'Unique name',
...                         description=u'', readonly=False, required=True)
>>> field = field.bind(lifeless)
>>> field.context == lifeless
True

You can always use your own name.
>>> field.validate(lifeless.name)

Or a name that is not already in use.
>>> field.validate(u'namenotinuse')

But you can't use Mark's name, of course. ;)
>>> field.validate(u'sabdfl')
Traceback (most recent call last):
  ...
LaunchpadValidationError: ...sabdfl is already in use by another person/team...


In the case of your displayname, the only constraint is that it can't contain
only spaces. To ensure that, we use a StrippingTextLine in the displayname,
which is a class that always strips the unicode string before applying any
validation or constraints.
>>> field = StrippingTextLine(__name__='displayname', title=u'Displayname',
...                           description=u'', readonly=False, required=True,
...                           missing_value=u'')
>>> field.fromUnicode(u' foo ')
u'foo'

>>> field.fromUnicode(u'  ')
Traceback (most recent call last):
...
RequiredMissing


Merging
-------

The method to perform the low level merging of two Persons
should only be used by the one true account merge workflow.

>>> foo = personset.getByName('name16')
>>> sample = personset.getByName('name12')
>>> admins = personset.getByName('admins')

We can't merge teams

>>> personset.merge(admins, foo)
Traceback (most recent call last):
...
TypeError: ...

>>> personset.merge(foo, admins)
Traceback (most recent call last):
...
TypeError: ...

Nor can we merge an account that still has email addresses attached to it

>>> nonempty, email = personset.createPersonAndEmail('empty@somehost.com')
>>> rosetta_admins = personset.getByName('rosetta-admins')
>>> rosetta_admins.addMember(nonempty)
>>> personset.merge(nonempty, sample)
Traceback (most recent call last):
...
ValueError: ...

Now we remove the only email address nonempty had.

>>> email.destroySelf()
>>> empty = nonempty

Must login as 'sabdfl' cause he's the owner of the Ubuntu Team.
>>> login('mark@hbd.com')
>>> ubuntu_team = personset.getByName('ubuntu-team')
>>> ubuntu_translators = personset.getByName('ubuntu-translators')
>>> ubuntu_translators.addMember(empty)
>>> ubuntu_team.teamowner = empty
>>> foo = empty.assignKarma('bugfixed')
>>> flush_database_updates()

'Sample Person' is a deactivated member of the 'Ubuntu Translators' team,
while empty is an active member. After the merge, 'Sample Person' will be an
active member of that team.
>>> sample in ubuntu_translators.inactivemembers
True
>>> empty in ubuntu_translators.activemembers
True
>>> empty.karma
0
>>> sample.karma
91

>>> personset.merge(empty, sample)

>>> sample in ubuntu_translators.activemembers
True
>>> sample.inTeam(ubuntu_translators)
True

Note that we don't bother migrating karma - it will just be reset next
time the caches are rebuilt

>>> empty.karma
0
>>> sample.karma
91

>>> from canonical.launchpad.database import Person
>>> cur = Person._connection._connection.cursor()

A merged account gets a -merged suffix on its name.
>>> cur.execute("SELECT id FROM Person WHERE name='empty-merged'")
>>> cur.fetchone()[0] == empty.id
True


>>> cur.execute("select person, team, status from teammembership where "
...             "person = %s and team = %s"
...             % sqlvalues(sample.id, rosetta_admins.id))
>>> cur.fetchone()
[12, 30, 2]

>>> sample.inTeam(rosetta_admins)
True

>>> cur.execute("select p1.name from person as p1, person as p2 where "
...             "p1.id = p2.teamowner and p2.name = 'ubuntu-team'")
>>> cur.fetchone()[0]
u'name12'

The account that has been merged is flagged. We can use this to eliminate
merged accounts from lists etc.

>>> cur.execute("SELECT merged FROM Person WHERE name='empty-merged'")
>>> cur.fetchone()[0]
12

>>> cur.execute("SELECT merged FROM Person WHERE name='name12'")
>>> cur.fetchone()[0] is None
True

After the merging we could test the topPeople() method of the PersonSet
class. This methods returns a sliced list of 5 valid person accounts,
ordered by karma. A valid person account is any non-merged person with a
preferred email address.

>>> [(person.name, person.karma) for person in personset.topPeople()]
[(u'name12', 91), (u'name16', 40), (u'launchpad', 0), (u'jordi', 0), (u'marilize', 0)]


People can have karma in Launchpad
----------------------------------

Depending on the action a given person performs in Launchpad, that person can
earn some karma points. This is useful to know how active a user is in
Launchpad.

Salgado wrote the karma framework. Let's give him some karma points.

>>> salgado = personset.getByName('salgado')
>>> foo = salgado.assignKarma('bugfixed')
>>> salgado.karma
0

The value that you get through IPerson.karma is a cached value that's
calculated daily. That's why it still 0.


Searching
---------

You can search based on a person's name or displayname, or any of the email
addresses that belongs to a person using the methods provided by IPersonSet.

While we don't have Full Text Indexes in the emailaddress table, we'll be
trying to match the text only against the beginning of an email address:

>>> results = personset.find('ubuntu')
>>> for person in results:
...     emails = [email.email for email in emailset.getByPerson(person)]
...     (person.displayname, person.name, emails)
(u'Sigurd Gartmann', u'sigurd-ubuntu', [u'sigurd-ubuntu@brogar.org'])
(u'Ubuntu Gnome Team', u'name18', [])
(u'Ubuntu Team', u'ubuntu-team', [u'support@ubuntu.com'])
(u'Ubuntu Translators', u'ubuntu-translators', [])

>>> results = personset.find('steve.alexander')
>>> for person in results:
...     emails = [email.email for email in emailset.getByPerson(person)]
...     (person.displayname, person.name, emails)
(u'Steve Alexander', u'stevea', [u'steve.alexander@ubuntulinux.com'])


Searching only for People based on their names or email addresses:

>>> results = personset.findPerson('james.blackwell')
>>> for person in results:
...     emails = [email.email for email in emailset.getByPerson(person)]
...     (person.displayname, person.name, emails)
(u'James Blackwell', u'jblack', [u'james.blackwell@ubuntulinux.com'])

>>> results = personset.findPerson('dave')
>>> for person in results:
...     emails = [email.email for email in emailset.getByPerson(person)]
...     (person.displayname, person.name, emails)
(u'Dave Miller', u'justdave', [u'dave.miller@ubuntulinux.com', u'justdave@bugzilla.org'])


Searching only for Teams based on their names or email addresses:

>>> results = personset.findTeam('support')
>>> for person in results:
...     emails = [email.email for email in emailset.getByPerson(person)]
...     (person.displayname, person.name, emails)
(u'Ubuntu Team', u'ubuntu-team', [u'support@ubuntu.com'])

>>> results = personset.findTeam('translators')
>>> for person in results:
...     emails = [email.email for email in emailset.getByPerson(person)]
...     (person.displayname, person.name, emails)
(u'Ubuntu Translators', u'ubuntu-translators', [])


Packages related to a person
----------------------------

To obtain the packages a person is related to, we can use the
latestMaintainedPackages() and latestUploadedButNotMaintainedPackages()
methods of IPersonSet. The former will return the latest
SourcePackageReleases a person uploaded in which he is listed as the
Maintainer. The latter will return the latest SourcePackageReleases a
person uploaded (where he isn't the maintainer).

>>> sabdfl = personset.getByName('sabdfl')
>>> for sprelease in sabdfl.latestMaintainedPackages():
...     print (sprelease.name, sprelease.uploaddistrorelease.fullreleasename,
...            sprelease.version)
(u'alsa-utils', u'Debian Sid', u'1.0.9a-4')
(u'pmount', u'Ubuntu Hoary', u'0.1-2')
(u'netapplet', u'Ubuntu Warty', u'0.99.6-1')
(u'netapplet', u'Ubuntu Hoary', u'1.0-1')
(u'alsa-utils', u'Ubuntu Warty', u'1.0.8-1ubuntu1')
(u'mozilla-firefox', u'Ubuntu Hoary', u'0.9')
(u'evolution', u'Ubuntu Hoary', u'1.0')

>>> for sprelease in sabdfl.latestUploadedButNotMaintainedPackages():
...     print (sprelease.name, sprelease.uploaddistrorelease.fullreleasename,
...            sprelease.version)
(u'libstdc++', u'Ubuntu Hoary', u'b8p')
(u'cnews', u'Ubuntu Hoary', u'cr.g7-37')
(u'linux-source-2.6.15', u'Ubuntu Hoary', u'2.6.15.3')
(u'alsa-utils', u'Ubuntu Hoary', u'1.0.9a-4ubuntu1')


Bug contact packages
--------------------

A person who chooses to receive all bugmail for a package is said to be
a "bug contact" for that package. A package may have zero, one, or more
bug contacts.

IPerson.getBugContactPackages returns this list of packages, sorted
alphabetically (A to Z) by package name.

>>> [package.name for package in foobar.getBugContactPackages()]
[u'mozilla-firefox', u'pmount']

