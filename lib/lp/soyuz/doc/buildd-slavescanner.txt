= Buildd Slave Scanner =

The Buildd Slave scanner is able to run over the build jobs being
processed in the current BuildFarm and collect information about the
status of the process, collect the results of finished jobs and
automatically dispatch new jobs to idle slaves.

The Master side of Buildd requires access to Launchpad Database, the
user designed for this kind of access is 'fiera', as in all test the
transaction should be retrieved.

    >>> from canonical.database.sqlbase import ZopelessTransactionManager
    >>> local_transaction = ZopelessTransactionManager._installed

We check for sent mails in some places, so load the stub mailer:

    >>> from lp.services.mail import stub
    >>> from canonical.database.sqlbase import commit

And create a utility function to make tests easier to read.

    >>> def check_mail_sent(last_stub_mail_count):
    ...    commit()
    ...    return len(stub.test_emails) == last_stub_mail_count + 3

The master also requires an 'logging' instance to not compromise the
standard output with noisily output.

    >>> import logging
    >>> logger = logging.getLogger()

Import MockBuilder and a series of MockSlaves to be used in this test.

    >>> from lp.buildmaster.tests.mock_slaves import (
    ...    AbortedSlave, AbortingSlave, BuildingSlave,
    ...    MockBuilder, OkSlave, WaitingSlave)



The Builddmaster should crash when collecting builds which are denied in
the given distroseries/pocket. Anytime it happens we need to manually
investigate why this build end up built. (should never happen in real
cases, and even so should be refused when we try to upload it.)

    >>> bqItem12 = getUtility(IBinaryPackageBuildSet).getByBuildID(
    ...     2).queueBuild()
    >>> setupBuildQueue(bqItem12, a_builder)
    >>> last_stub_mail_count = len(stub.test_emails)

Create a mock slave so the builder gets the right responses for this test.

    >>> bqItem12.builder.setSlaveForTesting(WaitingSlave('BuildStatus.OK'))
    >>> a_builder.updateBuild(bqItem12)
    Traceback (most recent call last):
    ...
    AssertionError: i386 build of mozilla-firefox 0.9 in ubuntu warty RELEASE (2) can not be built for pocket RELEASE: illegal status

We need 'a_builder' released (from 'bqItem12') so it can be associated with
'bqItem10' below.

    >>> bqItem12.builder = None


== Setup chroots ==

Retrieve a known DistroArchSeries

    >>> from canonical.launchpad.interfaces import IDistributionSet
    >>> hoary_i386 = getUtility(IDistributionSet)['ubuntu']['hoary']['i386']
    >>> warty_i386 = getUtility(IDistributionSet)['ubuntu']['warty']['i386']

Create a totally bogus CHROOT

    >>> from canonical.launchpad.database import LibraryFileAlias
    >>> fake_chroot = LibraryFileAlias.get(1)
    >>> unused = hoary_i386.addOrUpdateChroot(fake_chroot)
    >>> unused = warty_i386.addOrUpdateChroot(fake_chroot)


== Build Dispatching ==

Build dispatching can be entirely done via IBuilder content class
using the findAndStartJob method.

We will use SoyuzTestPublisher to simulate the required context in the
next tests. Let's initialise it.

    >>> from lp.soyuz.tests.test_publishing import (
    ...     SoyuzTestPublisher)
    >>> from canonical.testing.layers import LaunchpadZopelessLayer

    >>> test_publisher = SoyuzTestPublisher()

    >>> commit()
    >>> LaunchpadZopelessLayer.switchDbUser('launchpad')

    >>> test_publisher.prepareBreezyAutotest()

    >>> commit()
    >>> LaunchpadZopelessLayer.switchDbUser(config.builddmaster.dbuser)

Helper function to create binary publications in this test.

    >>> def create_binary_publication_for(archive, distroseries, status):
    ...     commit()
    ...     LaunchpadZopelessLayer.switchDbUser('launchpad')
    ...     login('foo.bar@canonical.com')
    ...     pub_binaries = test_publisher.getPubBinaries(
    ...         archive=archive, distroseries=distroseries,
    ...         status=status)
    ...     commit()
    ...     LaunchpadZopelessLayer.switchDbUser(config.builddmaster.dbuser)
    ...     login(ANONYMOUS)

We will reset the sampledata building job before continue with the
tests.

    >>> current_job = a_builder.currentjob
    >>> resurrect_build = getUtility(IBinaryPackageBuildSet).getByQueueEntry(
    ...     current_job)
    >>> resurrect_build.status = BuildStatus.NEEDSBUILD
    >>> current_job.builder = None
    >>> current_job.setDateStarted(None)
    >>> current_job.lastscore = 0


Partner archive builds will set up the 'archives' argument such that it
references all the required pockets/components in the primary archive, in
addition to a reference to the release pocket in the partner archive itself.

    >>> ubuntu = getUtility(IDistributionSet)['ubuntu']
    >>> partner_archive = ubuntu.getArchiveByComponent('partner')
    >>> removeSecurityProxy(a_build).archive = partner_archive
    >>> commit()
    >>> a_builder.setSlaveForTesting(OkSlave())

The partner archive won't be passed to the builder unless it has at
least one published binary availble in the target distroarchseries.
This feature fixes bug #196782, when archive/suites got passed to
builders before they get published on disk, i.e. the first build on
any PPA/suite will fail during the first 20 minutes because no empty
indexes are published.

A PPA can depend on another PPA. We can make Celso's PPA depend on
Mark's PPA:

    >>> commit()
    >>> LaunchpadZopelessLayer.switchDbUser('launchpad')
    >>> login('foo.bar@canonical.com')


Clean up before continuing:

    >>> a_builder.virtualized = False
    >>> removeSecurityProxy(a_build).archive = ubuntu.main_archive
    >>> commit()


