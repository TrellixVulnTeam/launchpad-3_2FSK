TestBugzillaAPIXMLRPCTransport
==============================

The TestBugzillaAPIXMLRPCTransport is an XML-RPC transport that behaves
in the same way as the XML-RPC endpoint of a Bugzilla 3.4 installation.
It implements the parts of the Bugzilla API which Launchpad uses to
communicate with those instances. The TestBugzillaAPIXMLRPCTransport is
very similar to the TestBugzillaXMLRPCTransport, which it subclasses.
Only the parts of TestBugzillaAPIXMLRPCTransport that are different from
its ancestor will be tested here.

    >>> import xmlrpclib
    >>> from lp.bugs.tests.externalbugtracker import (
    ...     TestBugzillaAPIXMLRPCTransport)
    >>> bugzilla_transport = TestBugzillaAPIXMLRPCTransport(
    ...     'http://example.com/xmlrpc.cgi')
    >>> server = xmlrpclib.ServerProxy(
    ...     'http://example.com/xmlrpc.cgi', transport=bugzilla_transport)


Version discovery
-----------------

The TestBugzillaAPIXMLRPCTransport provides a method, Bugzilla.version(),
which returns the version of the Bugzilla instance to which the client
is currently connected.

    >>> server.Bugzilla.version()
    {'version': '3.4.1+'}


Logging in
----------

Unlike TestBugzillaXMLRPCTransport, TestBugzillaAPIXMLRPCTransport uses
the standard Bugzilla username and password system for authentication.
Users can log in to the Bugzilla instance by calling User.login(). This
method will return the user's user ID in a dict.

    >>> server.User.login(
    ...     {'login': 'foo.bar@canonical.com', 'password': 'test'})
    {'id': 0}

The Bugzilla_logincookie will now have been set for the transport, too.

    >>> print bugzilla_transport.cookie_processor.cookiejar
    <cookielib.CookieJar[<Cookie Bugzilla_login=...>,
        <Cookie Bugzilla_logincookie=...>]>

Trying to log in with an incorrect username or password will result in
an error being raised.

    >>> server.User.login(
    ...     {'login': 'test@canonical.com', 'password': 'test'})
    Traceback (most recent call last):
      ...
    Fault: <Fault 300: 'The username or password you entered is not valid.'>


Getting the current time
------------------------

The Bugzilla.time() method allows us to retrieve a dict of the time on
the remote server.

    >>> time_dict = server.Bugzilla.time()
    >>> for key in sorted(time_dict):
    ...     print "%s: %s" % (key, time_dict[key])
    db_time: 20080501T01:01:01
    tz_name: UTC
    tz_offset: +0000
    tz_short_name: UTC
    web_time: 20080501T01:01:01
    web_time_utc: 20080501T01:01:01

If the remote server is in a different timezone, the db_time and
web_time items will be in the server's local timezone whilst
web_time_utc will be in UTC.

    >>> bugzilla_transport.utc_offset = 60**2
    >>> bugzilla_transport.timezone = 'CET'
    >>> time_dict = server.Bugzilla.time()
    >>> for key in sorted(time_dict):
    ...     print "%s: %s" % (key, time_dict[key])
    db_time: 20080501T01:01:01
    tz_name: CET
    tz_offset: +0100
    tz_short_name: CET
    web_time: 20080501T01:01:01
    web_time_utc: 20080501T00:01:01


Getting bugs from the server
----------------------------

The Bugzilla API method Bug.get() allows us to get one or more bugs from
the remote server. It takes a list of bug IDs to return and returns a
list of dicts containing those bugs' data.

    >>> return_value = server.Bug.get(
    ...     {'ids': [1], 'permissive': True})
    >>> [bug_dict] = return_value['bugs']
    >>> for key in sorted(bug_dict):
    ...     print "%s: %s" % (key, bug_dict[key])
    alias: 
    assigned_to: test@canonical.com
    component: GPPSystems
    creation_time: 20080610T16:19:53
    id: 1
    internals:...
    is_open: True
    last_change_time: 20080610T16:19:53
    priority: P1
    product: Marvin
    resolution: FIXED
    severity: normal
    status: RESOLVED
    summary: That bloody robot still exists.

Note that further tests for this functionality can be found in the
"Bug.get()" section, above. This is because these two methods
are synonymous.


Searching for bugs
------------------

The Bugzilla API offers a Bug.search() method which, somewhat
unsurprisingly, can be used to search for Bugs on the Bugzilla instance.
It accepts a number of arguments on which to search.

Specifying a 'last_change_time' parameter when calling Launchpad.get_bugs()
will cause the method to only return bugs that have changed since that
date / time.

    >>> from datetime import datetime
    >>> from xmlrpclib import DateTime
    >>> last_change_time = datetime(2008, 6, 11, 9, 0, 0)

    # XXX 2009-08-21 gmb (bug 254999):
    #     We can remove this once we upgrade to python 2.5. We encode
    #     last_change_time into an XML-RPC DateTime manually. This is
    #     because xmlrpclib can't handle DateTime encoding within a
    #     dict.
    >>> last_change_time = DateTime(last_change_time.timetuple())

    >>> return_value = server.Bug.search({
    ...     'last_change_time': last_change_time,
    ...     })

    >>> bug_dicts = return_value['bugs']
    >>> assert len(bug_dicts) == 1, "There should only be one bug dict."

    >>> bug_dict = bug_dicts[0]
    >>> for key in sorted(bug_dict):
    ...     print "%s: %s" % (key, bug_dict[key])
    alias: bug-two
    assigned_to: marvin@heartofgold.ship
    component: Crew
    creation_time: 20080611T09:23:12
    id: 2
    internals:...
    is_open: True
    last_change_time: 20080611T09:24:29
    priority: P1
    product: HeartOfGold
    resolution: 
    severity: high
    status: NEW
    summary: Collect unknown persons in docking bay 2.

Specifying a range of IDs when calling Bug.search() will limit the
results to those IDs.

    >>> last_change_time = datetime(2007, 6, 10, 1, 1, 1)
    >>> last_change_time = DateTime(last_change_time.timetuple())
    >>> return_value = server.Bug.search({
    ...     'id': [1],
    ...     'last_change_time': last_change_time,
    ...     })

    >>> bug_dicts = return_value['bugs']
    >>> for bug_dict in bug_dicts:
    ...     for key in sorted(bug_dict):
    ...         print "%s: %s" % (key, bug_dict[key])
    alias: 
    assigned_to: test@canonical.com
    component: GPPSystems
    creation_time: 20080610T16:19:53
    id: 1
    internals:...
    is_open: True
    last_change_time: 20080610T16:19:53
    priority: P1
    product: Marvin
    resolution: FIXED
    severity: normal
    status: RESOLVED
    summary: That bloody robot still exists.

Setting last_change_time to a date in the future will mean that no bugs are
returned.

    >>> from datetime import timedelta
    >>> last_change_time = datetime.now() + timedelta(days=42)

    >>> # XXX 2008-08-05 gmb (bug 254999):
    >>> #     We can remove this once we upgrade to python 2.5.
    >>> last_change_time = DateTime(last_change_time.timetuple())

    >>> return_value = server.Bug.search({
    ...     'last_change_time': last_change_time,
    ...     })

    >>> bug_dicts = return_value['bugs']
    >>> len(bug_dicts)
    0

It's possible to search for bugs filed on a particular product.

    >>> return_value = server.Bug.search({
    ...     'product': ['HeartOfGold'],
    ...     })

    >>> bug_dicts = return_value['bugs']
    >>> for bug_dict in bug_dicts:
    ...     for key in sorted(bug_dict):
    ...         print "%s: %s" % (key, bug_dict[key])
    alias: bug-two
    assigned_to: marvin@heartofgold.ship
    component: Crew
    creation_time: 20080611T09:23:12
    id: 2
    internals:...
    is_open: True
    last_change_time: 20080611T09:24:29
    priority: P1
    product: HeartOfGold
    resolution: 
    severity: high
    status: NEW
    summary: Collect unknown persons in docking bay 2.

You can search for more than one product.

    >>> return_value = server.Bug.search({
    ...     'product': ['HeartOfGold', 'Marvin'],
    ...     })
    >>> bug_dicts = return_value['bugs']
    >>> for bug_dict in bug_dicts:
    ...     for key in sorted(bug_dict):
    ...         print "%s: %s" % (key, bug_dict[key])
    alias: 
    assigned_to: test@canonical.com
    component: GPPSystems
    creation_time: 20080610T16:19:53
    id: 1
    internals:...
    is_open: True
    last_change_time: 20080610T16:19:53
    priority: P1
    product: Marvin
    resolution: FIXED
    severity: normal
    status: RESOLVED
    summary: That bloody robot still exists.
    alias: bug-two
    assigned_to: marvin@heartofgold.ship
    component: Crew
    creation_time: 20080611T09:23:12
    id: 2
    internals:...
    is_open: True
    last_change_time: 20080611T09:24:29
    priority: P1
    product: HeartOfGold
    resolution: 
    severity: high
    status: NEW
    summary: Collect unknown persons in docking bay 2.
