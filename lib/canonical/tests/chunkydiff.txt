============
Chunky diffs
============

  run this using

    python test.py -u canonical.tests.test_chunkydiff

Consider this desired output

  nnnnnnABCxyzDEFnnnnnn

and this actual output

  nnnnnnABClmnopDEFnnnnnn

the test says this

  ...ABCxyzDEF...

useful output would be

  ...ABClmnopDEF...
        ^^^^^

and not

  nnnnnnABClmnopDEFnnnnnn
           ^^^^^

How do we do this?

If the comparison has failed, we take the first character after the
ellipsis in the test, and look for that in the actual output.  If it occurs
only once, then fine.  If it does not occur at all, then print out the whole
diff.  If it occurs more than once, take the next character from the test,
and look for those two characters in the actual output. Repeat until
there is no occurence, or there is just one occurence.

The same goes for the characters before the trailing ellipsis.

The search can be narrowed because the characters at the end must follow
those at the start.

    >>> from canonical.chunkydiff import elided_source

    >>> actual = "nnnnnnABClmnopDEFnnnnnn"
    >>> tested = "...ABCxyzDEF..."
    >>> elided_source(tested, actual)
    '...ABClmnopDEF...'

Trivial modification, so that the code needs to take the input into account
and not just parrot out a hard-coded return value.

    >>> actual = "nnnnnnABClmnopzDEFnnnnnn"
    >>> tested = "...ABCxyzDEF..."
    >>> elided_source(tested, actual)
    '...ABClmnopzDEF...'

No interesting output between the arbitrary markers.  This is really no
different from the above, as far as the system is concerned.

    >>> actual = "nnnnnnABCDEFnnnnnn"
    >>> tested = "...ABCxyzDEF..."
    >>> elided_source(tested, actual)
    '...ABCDEF...'

If there are two chunks that differ by the second or third characters in,
choose the one that matches best.

    >>> actual = "nnnnnnABClmnopzDEFnnnnnABXuuuuXEFnnnn"
    >>> tested = "...ABCxyzDEF..."
    >>> elided_source(tested, actual)
    '...ABClmnopzDEF...'

What happens when there is no ellipsis at the start?

    >>> actual = "ABClmnopzDEFnnnn"
    >>> tested = "ABCxyzDEF..."
    >>> elided_source(tested, actual)
    'ABClmnopzDEF...'

What happens when there is no ellipsis at the end, but extra data at the end?

    >>> actual = "ABClmnopzDEFnnnn"
    >>> tested = "...ABCxyzDEF"
    >>> elided_source(tested, actual)
    '...ABClmnopzDEFnnnn'

What happens when there is no ellipsis at the end?

    >>> actual = "nnnnABClmnopzDEF"
    >>> tested = "...ABCxyzDEF"
    >>> elided_source(tested, actual)
    '...ABClmnopzDEF'

What happens when there is no ellipsis at all?

    >>> actual = "ABClmnopzDEF"
    >>> tested = "ABCxyzDEF"
    >>> elided_source(tested, actual)
    'ABClmnopzDEF'

What happens when there is more than one chunk?

    >>> actual = "nnnnnnABClmnopzDEFnnnnnGHIzponmJKLnnnn"
    >>> tested = "...ABCxyzDEF...GHIxyzJKL..."
    >>> elided_source(tested, actual)
    '...ABClmnopzDEF...GHIzponmJKL...'

What about when the chunks are presented in the wrong order?

The first chunk from "tested" will have been found, but the second chunk
will be absent.  We want to keep the "nnnn" at the end of 'actual' because
it is not matched by anything.  We want to elide the start as it matches the
elision, but not the end, as there is unmatched stuff in tested that we may
want to compare.

We may want to choose from among the following possible output in this case:

'...GHIzponmJKLnnnn'
'...GHIzponmJKL...'
'...ABCmnopzDEF...GHIzponmJKL...'

We'll use the first case for now, and see how it works in practice.

Implementing this involves recognising how much of the actual string has
been consumed by matching each chunk, and using only that remainder for the
next chunks.

    >>> actual = "nnnnnnABClmnopzDEFnnnnnGHIzponmJKLnnnn"
    >>> tested = "...GHIzponmJKL...ABClmnopzDEF..."
    >>> elided_source(tested, actual)
    '...GHIzponmJKLnnnn'

Where there is more than one option for the end match, choose the closest
one.

    >>> actual = "nnnnnnABClmnopzDEFnnnnnGHIzponmDEFnnnn"
    >>> tested = "...ABCxxxxDEF..."
    >>> elided_source(tested, actual)
    '...ABClmnopzDEF...'

Check anchoring to the start with elided junk after the first matched chunk.

    >>> actual = "ABClmnopznnnDEFzponmGHInnnn"
    >>> tested = "ABC...DEFxxxGHI..."
    >>> elided_source(tested, actual)
    'ABC...DEFzponmGHI...'

Check anchoring to the end with elided junk immediately before.

    >>> actual = "ABCDEzxcvbX"
    >>> tested = "ABCDE...X"
    >>> elided_source(tested, actual)
    'ABCDE...X'

Test single character within ellipses.

    >>> actual = "abcdeXfghij"
    >>> tested = "...X..."
    >>> elided_source(tested, actual)
    '...X...'

Multiple single characters.

    >>> actual = "ABCDEnnXnnXnnX"
    >>> tested = "ABCDE...X"
    >>> elided_source(tested, actual)
    'ABCDE...X'


    >>> actual = "ABCDEnnXnn"
    >>> tested = "ABCDE...X..."
    >>> elided_source(tested, actual)
    'ABCDE...X...'

Test with differences in whitespace.

    >>> actual = "ABC\nxxx DEF"
    >>> tested = "ABC ... DEF"
    >>> elided_source(tested, actual)
    'ABC\nxxx DEF'

    >>> actual = "ABC xxx DEF"
    >>> tested = "ABC\n... DEF"
    >>> elided_source(tested, actual, normalize_whitespace=True)
    'ABC\n... DEF'

Test with multiple whitespace characters.

    >>> actual = "ABC xxx DEF"
    >>> tested = "ABC\n\n... DEF"
    >>> elided_source(tested, actual, normalize_whitespace=True)
    'ABC\n\n... DEF'
