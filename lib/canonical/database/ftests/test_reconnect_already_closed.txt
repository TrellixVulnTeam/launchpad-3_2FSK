

Create a connection, wrap it in a ConnectionWrapper, and get a cursor from it.

    >>> from canonical.database import reconnect
    >>> import psycopg
    >>> import canonical.lp
    >>> reconnecting_conn = reconnect.ConnectionWrapper(
    ...     psycopg.connect, 
    ...     'dbname=%s user=%s' % (canonical.lp.dbname, canonical.lp.dbuser)
    ... )
    >>> reconnecting_cursor = reconnecting_conn.cursor()

Execute a query with the cursor, to show that it works.

    >>> reconnecting_cursor.execute('select 1;')
    >>> list(reconnecting_cursor.fetchone())
    [1]

Close the real connection, to simulate certain error conditions.

    >>> reconnecting_conn.orig.close()

Now execute a query again.  The reconnection wrapper deals with with the
closed connection transparently, rather than raising
psycopg.InterfaceError('already closed').

    >>> reconnecting_cursor.execute('select 1;')
    >>> list(reconnecting_cursor.fetchone())
    [1]
    
Close explicitly, to tidy up.

    >>> reconnecting_conn.close()

Now any queries will fail.  The reconnection wrapper won't catch the exception
this time.

    >>> reconnecting_cursor.execute('select 1;')
    Traceback (most recent call last):
    ...
    InterfaceError: already closed


