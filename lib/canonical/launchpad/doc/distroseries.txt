= Distro Releases =

From the DerivationOverview spec
<https://launchpad.canonical.com/DerivationOverview>:

    A distribution of GNU/Linux comprises a set of packages, an installer,
    possibly a live-CD, some amount of metadata associated with the arrangement
    of those elements and also a lot of information on managing it.

A distro series is a given version of a distribution. So, for Ubuntu, there
are releases (or planned releases) like "warty", "hoary" and "bendy".

Distro releases are retrieved with the IDistroSeriesSet utility, much like
people are retrieved with the IPersonSet utility, or bug tasks are retrieved
with the IBugTaskSet utility.

The IDistroSeriesSet utility is accessed in the usual fashion:


    >>> from zope.component import getUtility
    >>> from canonical.launchpad.webapp.testing import verifyObject
    >>> from canonical.launchpad.interfaces import (
    ...     IDistroSeries, IDistroSeriesSet, IDistributionSet,
    ...     IHasTranslationImports)
    >>> distroseriesset = getUtility(IDistroSeriesSet)

To retrieve a specific release of a distribution, use IDistroSeriesSet.get:

    >>> warty = distroseriesset.get(1)
    >>> print warty.name
    warty
    >>> print warty.fullseriesname
    Ubuntu Warty

Or IDistroSeriesSet.findByName:

    >>> for distroseries in distroseriesset.findByName("warty"):
    ...     print distroseries.name
    warty

To get one specific release by name, use queryByName:

    >>> ubuntu = getUtility(IDistributionSet).getByName("ubuntu")

    >>> warty = distroseriesset.queryByName(ubuntu, "warty")
    >>> warty.name
    u'warty'

If the release by that name doesn't exist, None will be returned:

    >>> foobar = distroseriesset.queryByName(ubuntu, "foobar")
    >>> print foobar
    None

Or IDistroSeriesSet.findByVersion:

    >>> for distroseries in distroseriesset.findByVersion("5.04"):
    ...     print distroseries.name
    hoary

We verify that a distroseries does in fact fully provide IDistroSeries:

    >>> verifyObject(IDistroSeries, warty)
    True
    >>> IDistroSeries.providedBy(warty)
    True

And IHasTranslationImports:

    >>> verifyObject(IHasTranslationImports, warty)
    True
    >>> IHasTranslationImports.providedBy(warty)
    True

To search the set of IDistroSeriess, use IDistroSeriesSet.search:

    >>> ubuntu_releases = distroseriesset.search(
    ...     distribution=ubuntu, isreleased=True, orderBy="-datereleased")
    >>> [release.name for release in ubuntu_releases]
    [u'warty']

    >>> all_ubuntu_releases = distroseriesset.search(distribution=ubuntu)
    >>> all_ubuntu_releases.count()
    4

DistroSeries.getPublishedReleases:

    >>> from canonical.launchpad.database import SourcePackageName, DistroSeries
    >>> warty2 = DistroSeries.get(1)

Passing a ISourcePackageName as argument:

    >>> prs = warty2.getPublishedReleases(
    ...       SourcePackageName.byName('mozilla-firefox'))
    >>> print len(prs)
    1
    >>> print prs[0].sourcepackagerelease.sourcepackagename.name
    mozilla-firefox

Passing a string name:

    >>> print len(warty2.getPublishedReleases('mozilla-firefox'))
    1

Including pending publication records in the result:

    >>> print len(warty2.getPublishedReleases('mozilla-firefox',
    ...           include_pending=True))
    2

Not found as empty list:

    >>> print len(warty2.getPublishedReleases('nosuchpackage'))
    0

canUploadToPocket method helps us to decide if an upload is allowed or
not, according the distroseries status and the upload target pocket.

   >>> from canonical.launchpad.interfaces import IDistributionSet
   >>> ubuntu = getUtility(IDistributionSet)['ubuntu']
   >>> breezy_autotest = ubuntu['breezy-autotest']
   >>> hoary = ubuntu['hoary']

   >>> from canonical.launchpad.interfaces import PackagePublishingPocket
   >>> from canonical.launchpad.interfaces import DistroSeriesStatus

   >>> warty.status.name
   'CURRENT'
   >>> warty.canUploadToPocket(PackagePublishingPocket.RELEASE)
   False
   >>> warty.canUploadToPocket(PackagePublishingPocket.SECURITY)
   True

   >>> breezy_autotest.status.name
   'EXPERIMENTAL'
   >>> breezy_autotest.canUploadToPocket(PackagePublishingPocket.RELEASE)
   True
   >>> breezy_autotest.canUploadToPocket(PackagePublishingPocket.SECURITY)
   False

The FROZEN status is special.  Uploads are allowed for all pockets as
the upload will have to wait for manual approval anyway:

   >>> from zope.security.proxy import removeSecurityProxy
   >>> removeSecurityProxy(hoary).status = DistroSeriesStatus.FROZEN

   >>> hoary.status.name
   'FROZEN'
   >>> hoary.canUploadToPocket(PackagePublishingPocket.RELEASE)
   True
   >>> hoary.canUploadToPocket(PackagePublishingPocket.SECURITY)
   True


== Package searching ==

You can search through binary packages publishing in a distribution
release by using the searchPackages method, which uses magical fti:

    >>> len(warty.searchPackages("pmount"))
    1

This also works for small or weirdly named packages that don't work
through fti, and even for substrings:

    >>> len(warty.searchPackages("linux-2.6.12"))
    1
    >>> len(warty.searchPackages("at"))
    1
    >>> len(warty.searchPackages("inux-2"))
    1


== DistroSeriess have components and sections ==

A distroseries has some number of components and/or sections which
are valid for that distroseries. These selections are used by (among
other things) the uploader for validating incoming uploads.

   >>> hoary = distroseriesset.get(3)
   >>> for c in hoary.components:
   ...     print c.name
   main
   restricted
   >>> for s in hoary.sections:
   ...     print s.name
   base
   web
   editors
   admin
   devel
   translations

   >>> from canonical.launchpad.interfaces import (
   ...    IComponentSet, ISectionSet)
   >>> python = getUtility(ISectionSet).ensure('python')

   >>> hoary.addSection(python)

   >>> for c in hoary.components:
   ...     print c.name
   main
   restricted

   >>> for s in hoary.sections:
   ...     print s.name
   base
   web
   editors
   admin
   devel
   python
   translations

Breezy-autotest has got a partner component, which is not reported:

    >>> breezyautotest = distroseriesset.queryByName(ubuntu, "breezy-autotest")
    >>> for c in breezyautotest.components:
    ...     print c.name
    main
    restricted
    universe
    multiverse

The upload_components property, however, reports all the available
components since partner is allowed for upload:

    >>> for c in breezyautotest.upload_components:
    ...     print c.name
    main
    restricted
    universe
    multiverse
    partner


== DistroSeries can be initialised from their parents ==

When a distroseries is derived from another distroseries (be it a
derivative distribution, or simply the next release in a sequence from
Ubuntu) we need to initialise the new release with quite a lot of
information. Not least of which is the section and component
selections and the publishing information for the distroseries.

DistroSeries provides us with a method for doing this which carefully
goes behind the back of sqlobject to copy potentially tens of
thousands of rows around in order to set up a distroseries.

IDistroSeries lists a series of preconditions for performing an
initialisation. In particular the initialiser won't overwrite
publishing records etc. Essentially this is a "Do not push this button
again" type set of assertions.

   >>> login("foo.bar@canonical.com")
   >>> humpy = distroseriesset.new(ubuntu, 'humpy', 'Humpy Hippo',
   ...                              'The Humpy Hippo', 'Fat', 'Yo Momma',
   ...                              '99.2',hoary, hoary.owner)
   >>> humpy_i386 = humpy.newArch('i386', hoary['i386'].processorfamily,
   ...                            True, humpy.owner)
   >>> humpy.nominatedarchindep = humpy_i386
   >>> humpy.initialiseFromParent()
   >>> len(hoary.getPublishedReleases('pmount'))
   1
   >>> len(humpy.getPublishedReleases('pmount'))
   1
   >>> len(hoary['i386'].getReleasedPackages('pmount'))
   1
   >>> len(humpy_i386.getReleasedPackages('pmount'))
   1

Check if the attributes of an DRSPR instance for the just initialised
distroseries are sane. A DRSPR instance should filter attributes of
a SPR according the distroseries in question (practically according
what is published in this distrorelelase)

Since the initialise-from-parent procedure copies the latest
publications from the parent IDRSPR.builds should be empty, reflecting
that there are no builds for this SPR in this DistroSeries.
IDRSPR.builds will be non-empty after a developer submits a new SPR
for the  DistroSeries.

In other hand IDRSPR.binaries should return the binaries resulted of
the SPRs inheritance by joining BPP->BPR->BUILD->SPR, i.e, binaries
published in this distroseries (in fact, in one of its architectures)
resulted of the sourcepackagerelease in question, but built anywhere.
(fix bug #52938)

Initialise a new distroseries based on warty (since it has, at least
one coherent published source + binary, mozilla-firefox)

   >>> bumpy = distroseriesset.new(ubuntu, 'bumpy', 'Bumpy',
   ...                              'The Bumpy', 'Fat', 'Boom',
   ...                              '99.3', warty, warty.owner)

   >>> bumpy_i386 = bumpy.newArch('i386', warty['i386'].processorfamily,
   ...                            True, bumpy.owner)
   >>> bumpy.nominatedarchindep = bumpy_i386
   >>> bumpy.initialiseFromParent()

Build a new ISourcePackage based in the new distroseries:

   >>> bumpy_firefox_sp = bumpy.getSourcePackage('mozilla-firefox')

Check the content IDRSPR binaries & builds attributes:

'binaries' should be inherited from parent release.

   >>> bumpy_firefox_sp.currentrelease.binaries.count()
   2

   >>> for bin in bumpy_firefox_sp.currentrelease.binaries:
   ...     print bin.id, bin.title, bin.build.distroarchseries.title
   12 mozilla-firefox-0.9 The Warty Warthog Release for i386 (x86)
   27 mozilla-firefox-data-0.9 The Warty Warthog Release for i386 (x86)

'builds' should be empty since it was built in parent (warty), not in this
distroseries (bumby.

   >>> bumpy_firefox_sp.currentrelease.builds.count()
   0

the SPR returns all build records for it.

   >>> bumpy_firefox_sp.currentrelease.sourcepackagerelease.builds.count()
   4

== Translatable Packages and Packaging ==

You can easily find out what packages are translatable in a
distribution release:

   >>> translatables = hoary.getTranslatableSourcePackages()
   >>> for translatable in translatables:
   ...    print translatable.name
   evolution
   mozilla
   pmount

Packages can be linked to upstream productseries in specific
distribution releases. IDistroSeries offers a way to query translatable
packages that are linked to upstream productseries.

   >>> unlinked_translatables = hoary.getUnlinkedTranslatableSourcePackages()
   >>> for translatable in unlinked_translatables:
   ...    print translatable.name
   pmount
   mozilla

The links to upstream product series can be verified using the
packagings property:

    >>> packagings = hoary.packagings
    >>> for packaging in packagings:
    ...     print packaging.sourcepackagename.name, \
    ...           packaging.productseries.product.displayname
    evolution Evolution
    mozilla-firefox Mozilla Firefox
    netapplet NetApplet

From the results above you can notice that neither mozilla-firefox nor
netapplet are translatable in Hoary.


== DistroSeries can build meta objects for packages ==

   >>> from canonical.launchpad.interfaces import (
   ...     ISourcePackage,
   ...     IDistroSeriesBinaryPackage,
   ...     IDistroSeriesSourcePackageRelease,
   ...     ISourcePackagePublishingHistory)


   >>> pmount_src_name =  SourcePackageName.byName('pmount')
   >>> pmount_source = hoary.getSourcePackage(pmount_src_name)
   >>> ISourcePackage.providedBy(pmount_source)
   True

   >>> from canonical.launchpad.database.binarypackagename import (
   ...                                       BinaryPackageName)
   >>> pmount_bin_name =  BinaryPackageName.byName('pmount')
   >>> pmount_drbp = hoary.getBinaryPackage(pmount_bin_name)
   >>> IDistroSeriesBinaryPackage.providedBy(pmount_drbp)
   True
   >>> len(pmount_drbp.current_publishings)
   3

   >>> from canonical.launchpad.database.sourcepackagerelease import (
   ...                                           SourcePackageRelease)
   >>> pmount_rel = SourcePackageRelease.selectOneBy(
   ...     sourcepackagenameID=pmount_src_name.id, version='0.1-1')
   >>> pmount_rel.sourcepackagename.name
   u'pmount'

   >>> pmount_srcrel = hoary.getSourcePackageRelease(pmount_rel)
   >>> IDistroSeriesSourcePackageRelease.providedBy(pmount_srcrel)
   True

Check some properties of DRSPR meta class

Entire publishing history:

   >>> pmount_srcrel.publishing_history.count()
   1

Most recent published history row:

   >>> pmount_srcrel.current_published is None
   True

   >>> netapplet_srcrel =  hoary.getSourcePackage('netapplet').currentrelease
   >>> spph = netapplet_srcrel.current_published
   >>> verifyObject(ISourcePackagePublishingHistory, spph)
   True

   >>> spph.section.name
   u'web'

The changesfile attribute contains the package changelog. It is provided as
an ILibraryFileAlias:

   >>> firefox_srcrel =  warty.getSourcePackage(
   ...    'mozilla-firefox').currentrelease
   >>> firefox_srcrel.title
   u'mozilla-firefox 0.9 (source) in ubuntu warty'

   >>> firefox_srcrel.changesfile
   <LibraryFileAlias at ...>

If the package changelog is not available, that attribute is None:

   >>> netapplet_srcrel.changesfile is None
   True

Perform `post publication` override:

   >>> new_section = getUtility(ISectionSet)['base']

   >>> netapplet_srcrel.current_published.changeOverride(
   ...     new_section=new_section)
   >>> pub_hist = netapplet_srcrel.publishing_history
   >>> pub_hist.count()
   2

Override information about 'pmount' is pending publication:

   >>> pub_hist[0].status.name, pub_hist[0].section.name
   ('PENDING', u'base')

Supersede current publication:

   >>> superseded_netapplet = netapplet_srcrel.current_published.supersede()
   >>> netapplet_srcrel.publishing_history.count()
   2

We need to flush cached values.

   >>> from canonical.database.sqlbase import flush_database_updates
   >>> flush_database_updates()

   >>> superseded_netapplet.status.name, superseded_netapplet.datesuperseded
   ('SUPERSEDED', CURRENT_TIMESTAMP AT TIME ZONE 'UTC')


== DistroSeries Translations migration ==

We have several ways to copy translations between distro series.  We bring a
transaction manager (in this case a fake one) to make these work.

    >>> class FakeTransactionManager:
    ...     """Mock transaction manager for test."""
    ...     # The translations-copying code does not want its connection reset
    ...     # after every transaction.  Give it a field to change.
    ...     reset_after_transaction = True
    ...     def begin(self):
    ...         pass
    ...     def commit(self):
    ...         pass
    >>> transaction_stub = FakeTransactionManager()

=== Preconditions for migrating translations between distro series ===

Before we are able to migrate translations, there are a set of preconditions
that should be met:

First one is that we should keep the new distroseries's translations hidden
from the public, so the copying procedure is not confused by concurrent
updates:

    >>> humpy.hide_all_translations = False
    >>> humpy.copyMissingTranslationsFromParent(transaction_stub)
    Traceback (most recent call last):
    ...
    AssertionError: hide_all_translations not set!...

    # Set the field to TRUE so we meet this precondition for following
    # tests.
    >>> humpy.hide_all_translations = True

The other one is that, for the same reason, the import queue should not be
accepting uploads for this distroseries.

    >>> humpy.defer_translation_imports = False
    >>> humpy.copyMissingTranslationsFromParent(transaction_stub)
    Traceback (most recent call last):
    ...
    AssertionError: defer_translation_imports not set!...

    # Set the field to TRUE so we meet this precondition for following
    # tests.
    >>> humpy.defer_translation_imports = True


=== Translation Migration taks ===

The main way to migrate translations is to clone what we have in its parent
distribution.

   >>> humpy.copyMissingTranslationsFromParent(transaction_stub)

Only current PO templates are copied from the distribution parent:

   >>> len(hoary.getTranslationTemplates()) > len(
   ...     hoary.getCurrentTranslationTemplates())
   True
   >>> len(humpy.getTranslationTemplates()) == len(
   ...     humpy.getCurrentTranslationTemplates())
   True
   >>> len(humpy.getTranslationTemplates()) == len(
   ...     hoary.getCurrentTranslationTemplates())
   True
   >>> humpy.getObsoleteTranslationTemplates()
   []

Define a couple of functions we will need to compare the files from the parent
and child distro series.

   >>> def get_diffable_lines(file):
   ...     """Get lines in file worth diffing (but omit date)."""
   ...     return [
   ...         line for line in file.splitlines()
   ...         if not line.startswith('"X-Launchpad-Export-Date:')]

   >>> def get_diff(old_file, new_file):
   ...     from canonical.launchpad.helpers import test_diff
   ...     # Get content as list of lines, removing X-Launchpad-Export-Date
   ...     # lines to prevent time bombs in tests.
   ...     old_file_lines = get_diffable_lines(old_file)
   ...     new_file_lines = get_diffable_lines(new_file)
   ...
   ...     if old_file_lines != new_file_lines:
   ...         # The old and new files differ.
   ...         return u"Output doesn't match:\n\n %s\n" % test_diff(
   ...             old_file_lines, new_file_lines)
   ...     return ''

   >>> def compare_translations(orig_distroseries, dest_distroseries):
   ...
   ...     sortkey = lambda template: (
   ...         template.potemplatename.name, template.sourcepackagename.name)
   ...
   ...     orig_templates = sorted(
   ...         orig_distroseries.getCurrentTranslationTemplates(),
   ...         key=sortkey)
   ...     dest_templates = sorted(
   ...         dest_distroseries.getCurrentTranslationTemplates(),
   ...         key=sortkey)
   ...
   ...     output_text = ''
   ...     for i in range(len(orig_templates)):
   ...         old_template = orig_templates[i]
   ...         new_template = dest_templates[i]
   ...         if old_template.priority != new_template.priority:
   ...             output_text += 'Priority of %s is different from %s\n' % (
   ...                 old_template.title, new_template.title)
   ...         output = get_diff(old_template.export(), new_template.export())
   ...         if output != '':
   ...            output_text += output
   ...         for old_pofile in old_template.pofiles:
   ...             new_pofile = new_template.getPOFileByLang(
   ...                 old_pofile.language.code, old_pofile.variant)
   ...             old_pofile_data = old_pofile.uncachedExport(
   ...                 ignore_obsolete=True,force_utf8=True)
   ...             new_pofile_data = new_pofile.uncachedExport(
   ...                 ignore_obsolete=True, force_utf8=True)
   ...             output = get_diff(old_pofile_data, new_pofile_data)
   ...             if output is not None:
   ...                 output_text += output
   ...     return output_text

Comparing the current translations for the parent distro series to those of the
distro series we just created, we see that there are no differences at all.
Translation-wise, humpy is a perfect copy of hoary.

   >>> print compare_translations(hoary, humpy)
   <BLANKLINE>

Since people may continue to translate Hoary (and in fact we usually encourage
them to do so as a matter of policy), we will also periodically update Humpy's
translations based on changes made in Hoary.

To illustrate this, we will add some new translations to Hoary, migrate them
to Humpy, and check that the changes are copied where appropriate.

In practice the updates need not be entirely complete.  The database and the
Translations application remain "live" during the process, so there may be some
interference from changes made through the UI.  In those cases the copying
mechanism will drop a few updates rather than risk overwriting newer changes.
Any dropped updates from Hoary will still appear as suggestions to translators
working on Humpy, as long as they're still translating the same messages.

Get the needed objects to prepare this test.

    >>> import datetime
    >>> import pytz
    >>> from canonical.launchpad.interfaces import (
    ...     ISourcePackageNameSet, IPOTemplateSet, IPersonSet)
    >>> evolution = getUtility(ISourcePackageNameSet)['evolution']
    >>> potemplateset = getUtility(IPOTemplateSet)
    >>> potemplatesubset_hoary = potemplateset.getSubset(distroseries=hoary,
    ...     sourcepackagename=evolution)
    >>> potemplate_hoary = potemplatesubset_hoary.getPOTemplateByName(
    ...     'evolution-2.2')
    >>> pofile_es_hoary = potemplate_hoary.getPOFileByLang('es')
    >>> potemplatesubset_humpy = potemplateset.getSubset(distroseries=humpy,
    ...     sourcepackagename=evolution)
    >>> potemplate_humpy = potemplatesubset_humpy.getPOTemplateByName(
    ...     'evolution-2.2')
    >>> pofile_es_humpy = potemplate_humpy.getPOFileByLang('es')

The one submitting the string will be Carlos.  He's an editor for this POFile.

    >>> carlos = getUtility(IPersonSet).getByName('carlos')

    >>> from canonical.launchpad.ftests import time_counter
    >>> # "Clock" that's guaranteed always to progress between calls.
    >>> now = time_counter(delta=datetime.datetime.resolution).next

As it happens, our templates have some messages with the same msgids but
different contexts.  These exist in both Hoary and Humpy, but one is
translated only in Hoary; another only in Humpy; another in both, with the one
in Humpy the most recent; and yet another in both but with the one in Hoary
the most recent.

    >>> from zope.security.proxy import removeSecurityProxy

    >>> def add_messageset_to_template(potemplate, sequence, msgid, context):
    ...     """Add a message set to the given `POTemplate`."""
    ...     context_msg = potemplate.createMessageSetFromText(
    ...         msgid, context)
    ...     context_msg = removeSecurityProxy(context_msg)
    ...     context_msg.sequence = sequence
    ...     potemplate.invalidateCache()
    ...     return context_msg

    >>> def add_translation(pofile, potmsgset, translation):
    ...     """Set translation for given message set in given `POFile`."""
    ...     pomsgset = pofile.createMessageSetFromMessageSet(potmsgset)
    ...     pomsgset.updateTranslationSet(
    ...         carlos, { 0: translation }, fuzzy=False, published=False,
    ...         lock_timestamp=now())

    >>> context_msg = add_messageset_to_template(
    ...     potemplate_hoary, 100, u"A contexted message", None)
    >>> add_translation(pofile_es_hoary, context_msg, "Hoary0")
    >>> context_msg = add_messageset_to_template(
    ...     potemplate_humpy, 100, u"A contexted message", None)
    >>> context_msg = add_messageset_to_template(
    ...     potemplate_hoary, 101, u"A contexted message", u"context1")
    >>> context_msg = add_messageset_to_template(
    ...     potemplate_humpy, 101, u"A contexted message", u"context1")
    >>> add_translation(pofile_es_humpy, context_msg, "Humpy1")
    >>> context_msg = add_messageset_to_template(
    ...     potemplate_hoary, 102, u"A contexted message", u"context2")
    >>> add_translation(pofile_es_hoary, context_msg, "Hoary2")
    >>> context_msg = add_messageset_to_template(
    ...     potemplate_humpy, 102, u"A contexted message", u"context2")
    >>> add_translation(pofile_es_humpy, context_msg, "Humpy2")
    >>> context_msg_hoary = add_messageset_to_template(
    ...     potemplate_hoary, 103, u"A contexted message", u"context3")
    >>> context_msg_humpy = add_messageset_to_template(
    ...     potemplate_humpy, 103, u"A contexted message", u"context3")
    >>> add_translation(pofile_es_humpy, context_msg_humpy, "Humpy3")
    >>> add_translation(pofile_es_hoary, context_msg_hoary, "Hoary3")

Carlos also updates a regular string in the parent release.

    >>> pomsgset_hoary = pofile_es_hoary.getPOMsgSet(u'evolution addressbook')
    >>> pomsgset_hoary.updateTranslationSet(
    ...     carlos, { 0: u'hoary updated string' }, fuzzy=False,
    ...     published=False, lock_timestamp=now())

And another update in a string that was previously untranslated.

    >>> pomsgset_hoary = pofile_es_hoary.getPOMsgSet(u'has ')
    >>> pomsgset_hoary.updateTranslationSet(
    ...     carlos, { 0: u'empty string translated' }, fuzzy=False,
    ...     published=False, lock_timestamp=now())

Update a string in the child release.

    >>> pomsgset_humpy = pofile_es_humpy.getPOMsgSet(
    ...     u'current addressbook folder')
    >>> pomsgset_humpy.updateTranslationSet(
    ...     carlos, { 0: u'humpy updated string' }, fuzzy=False,
    ...     published=False, lock_timestamp=now())

These are the respective expected numbers of translated messages, messages
whose translations have changed in Launchpad, ones that are newly translated
in Launchpad, and ones with unreviewed suggestions.

We update these statistics first, since we have not gone through the regular
UI for updating translations, and receive the current numbers as a byproduct.

    >>> pofile_es_hoary.updateStatistics()
    (7, 2, 4, 1)
    >>> pofile_es_humpy.updateStatistics()
    (7, 2, 3, 0)

The statistics for messages translated in Launchpad reflect the fact that we
translated one previously untranslated string in Hoary.  The number for this
category of message is called rosettaCount.

    >>> pofile_es_hoary.currentCount()
    7
    >>> pofile_es_humpy.currentCount()
    7

    >>> pofile_es_hoary.updatesCount()
    2
    >>> pofile_es_humpy.updatesCount()
    2

    >>> pofile_es_hoary.rosettaCount()
    4
    >>> pofile_es_humpy.rosettaCount()
    3

When we compare the full translations for hoary and humpy, we see the changes
we just made, as well as the differences between the messages-with-context.

    >>> print compare_translations(hoary, humpy)
    Output doesn't match:
    <BLANKLINE>
    --- expected
    +++ actual
    <BLANKLINE>
    @@ -30,11 +30,11 @@
    <BLANKLINE>
     #: a11y/addressbook/ea-addressbook-view.c:103
     #: a11y/addressbook/ea-minicard-view.c:119
     msgid "evolution addressbook"
    -msgstr "hoary updated string"
    +msgstr "libreta de direcciones de Evolution"
    <BLANKLINE>
     #: a11y/addressbook/ea-minicard-view.c:101
     msgid "current addressbook folder"
    -msgstr "carpeta de libretas de direcciones actual"
    +msgstr "humpy updated string"
    <BLANKLINE>
     #: a11y/addressbook/ea-minicard-view.c:102
     #, fuzzy
    @@ -43,7 +43,7 @@
    <BLANKLINE>
    <BLANKLINE>
     #: a11y/addressbook/ea-minicard-view.c:102
     msgid "has "
    -msgstr "empty string translated "
    +msgstr ""
    <BLANKLINE>
     #: a11y/addressbook/ea-minicard-view.c:104
     msgid " cards"
    @@ -277,16 +277,16 @@
     msgstr ""
    <BLANKLINE>
     msgid "A contexted message"
    -msgstr "Hoary0"
    +msgstr ""
    <BLANKLINE>
     msgctxt "context1"
     msgid "A contexted message"
    -msgstr ""
    +msgstr "Humpy1"
    <BLANKLINE>
     msgctxt "context2"
     msgid "A contexted message"
    -msgstr "Hoary2"
    +msgstr "Humpy2"
    <BLANKLINE>
     msgctxt "context3"
     msgid "A contexted message"
    -msgstr "Hoary3"
    +msgstr "Humpy3"

Now we migrate the updates from Hoary to Humpy.

    >>> humpy.copyMissingTranslationsFromParent(transaction_stub)

Our updates are copied to Humpy.  The remaining differences between Hoary and
Humpy are the messages that were translated in Humpy more recently than they
were in Hoary, or were translated in Humpy but not at all in Hoary.

    >>> print compare_translations(hoary, humpy)
    Output doesn't match:
    <BLANKLINE>
    --- expected
    +++ actual
    <BLANKLINE>
    @@ -34,7 +34,7 @@
    <BLANKLINE>
     #: a11y/addressbook/ea-minicard-view.c:101
     msgid "current addressbook folder"
    -msgstr "carpeta de libretas de direcciones actual"
    +msgstr "humpy updated string"
    <BLANKLINE>
     #: a11y/addressbook/ea-minicard-view.c:102
     #, fuzzy
    @@ -281,12 +281,12 @@
    <BLANKLINE>
     msgctxt "context1"
     msgid "A contexted message"
    -msgstr ""
    +msgstr "Humpy1"
    <BLANKLINE>
     msgctxt "context2"
     msgid "A contexted message"
    -msgstr "Hoary2"
    +msgstr "Humpy2"
    <BLANKLINE>
     msgctxt "context3"
     msgid "A contexted message"
    -msgstr "Hoary3"
    +msgstr "Humpy3"

Changes in Humpy supersede any translation changes that may be made in its
parent distroseries for that same message.  So even if someone now translates
the same messages in Hoary as well, Humpy will retain its own translations
of those string when we next migrate updates.

    >>> pomsgset_hoary = pofile_es_hoary.getPOMsgSet(
    ...     u'current addressbook folder')
    >>> pomsgset_hoary.updateTranslationSet(
    ...     carlos, { 0: u'second hoary updated string' }, fuzzy=False,
    ...     published=False, lock_timestamp=now())
    >>> humpy.copyMissingTranslationsFromParent(transaction_stub)

    >>> print compare_translations(hoary, humpy)
    Output doesn't match:
    <BLANKLINE>
    --- expected
    +++ actual
    <BLANKLINE>
    @@ -34,7 +34,7 @@
    <BLANKLINE>
     #: a11y/addressbook/ea-minicard-view.c:101
     msgid "current addressbook folder"
    -msgstr "second hoary updated string"
    +msgstr "humpy updated string"
    <BLANKLINE>
     #: a11y/addressbook/ea-minicard-view.c:102
     #, fuzzy
    @@ -281,12 +281,12 @@
    ...

The Hoary message is updated, but even though the Humpy version is older, it
is not overwritten by the copy.  (The differences in the part where we had
messages with contexts remain as they were.)

We can also see that the statistics are updated and both distributions show
mostly the same numbers (though some messages in the rosettaCount actually
differ between the two distro series).  The only difference is that 1 message
that was untranslated in Humpy got copied from Hoary, whereas another that was
translated in Humpy but not in Hoary, wasn't.

    >>> pofile_es_hoary.currentCount() == pofile_es_humpy.currentCount()
    True
    >>> pofile_es_hoary.updatesCount() == pofile_es_humpy.updatesCount()
    True
    >>> pofile_es_hoary.rosettaCount() == pofile_es_humpy.rosettaCount() - 1
    True

Finally, prepare a new distro series to do the copy using an external script
to do the translation migration to this new distro series.

    >>> testing_series = distroseriesset.new(
    ...     ubuntu, 'testing', 'Testing Test', 'The Testing Test', 'Fat',
    ...     'Yo Momma', '99.4',hoary, hoary.owner)
    >>> testing_series.getTranslationTemplates()
    []

The script starts its own transactions, so we need to commit here to be sure
the new series will be available in the script.

    >>> import subprocess
    >>> import sys
    >>> import transaction
    >>> transaction.commit()

Now, we execute the script that will migrate/copy all current templates and
translations from testing_series' parent distro series (hoary)

    >>> process = subprocess.Popen([
    ...     sys.executable, 'scripts/copy-missing-translations-from-parent.py',
    ...     '--distribution=ubuntu', '--series=testing', '-v'],
    ...     stdin=subprocess.PIPE, stdout=subprocess.PIPE,
    ...     stderr=subprocess.STDOUT)
    >>> (output, empty) = process.communicate()
    >>> print output
    INFO    creating lockfile
    INFO    Starting...
    INFO    Done...
    DEBUG   Removing lock file: /var/lock/launchpad-copy-missing-translations-ubuntu-testing.lock

Once the script finished, new distro series does have templates.

    >>> len(testing_series.getCurrentTranslationTemplates()) > 0
    True

And all current templates were copied.

    >>> len(hoary.getCurrentTranslationTemplates()) == len(
    ...     testing_series.getCurrentTranslationTemplates())
    True


== SourcePackagePublishingHistory ==

IDistroSeries.getSourcePackagePublishing returns all the ISPPH
records for a given status in a given pocket. It makes easy to
generate a list of currently published sources for override-check, for
instance. it can also be used to generate the archive packages list in
the future.

   >>> ubuntu = getUtility(IDistributionSet)['ubuntu']
   >>> hoary = ubuntu['hoary']

   >>> from canonical.launchpad.interfaces import (
   ...    PackagePublishingPocket, PackagePublishingStatus)

   >>> hoary_pub_sources = hoary.getSourcePackagePublishing(
   ...     PackagePublishingStatus.PUBLISHED,
   ...     PackagePublishingPocket.RELEASE)

   >>> hoary_pub_sources.count()
   6

   >>> hoary_pub_source = hoary_pub_sources[0]

   >>> from canonical.launchpad.interfaces import (
   ...     ISourcePackagePublishingHistory)
   >>> verifyObject(ISourcePackagePublishingHistory, hoary_pub_source)
   True

   >>> hoary_pub_source.sourcepackagerelease.name
   u'alsa-utils'

   >>> hoary_pub_source.sourcepackagerelease.version
   u'1.0.9a-4ubuntu1'

   >>> hoary_pub_source.component.name
   u'main'

   >>> hoary_pub_source.section.name
   u'base'

   >>> hoary.getSourcePackagePublishing(
   ...     PackagePublishingStatus.PUBLISHED,
   ...     PackagePublishingPocket.UPDATES).count()
   0

This method also allow us to restrict the results to a given
component:

   >>> component_main = getUtility(IComponentSet)['main']
   >>> hoary.getSourcePackagePublishing(
   ...     PackagePublishingStatus.PUBLISHED,
   ...     PackagePublishingPocket.RELEASE,
   ...     component=component_main).count()
   5

   >>> component_multiverse = getUtility(IComponentSet)['multiverse']
   >>> hoary.getSourcePackagePublishing(
   ...     PackagePublishingStatus.PUBLISHED,
   ...     PackagePublishingPocket.RELEASE,
   ...     component=component_multiverse).count()
   0

By default the IDistribution 'main_archive' is considered, but It also
allows the callsite to specify one and then the result will be
restricted to it.

   >>> debian_archive = getUtility(IDistributionSet)['debian'].main_archive
   >>> print debian_archive.purpose.title
   Primary Archive

   >>> hoary.getSourcePackagePublishing(
   ...     PackagePublishingStatus.PUBLISHED,
   ...     PackagePublishingPocket.RELEASE,
   ...     component=component_main, archive=debian_archive).count()
   0

ISPP.publishedBinaries returns all the binaries generated by the
publication in question:

   >>> warty = ubuntu['warty']
   >>> warty_pub_sources = warty.getSourcePackagePublishing(
   ...     PackagePublishingStatus.PUBLISHED,
   ...     PackagePublishingPocket.RELEASE)

   >>> warty_pub_source = warty_pub_sources[4]
   >>> warty_pub_source.sourcepackagerelease.name
   u'mozilla-firefox'
   >>> warty_pub_source.sourcepackagerelease.version
   u'0.9'
   >>> warty_pub_source.component.name
   u'main'
   >>> warty_pub_source.section.name
   u'web'

   >>> warty_mozilla_pub_binaries = warty_pub_source.publishedBinaries()
   >>> warty_mozilla_pub_binaries.count()
   4
   >>> warty_mozilla_pub_bin = warty_mozilla_pub_binaries[0]

   >>> from canonical.launchpad.interfaces import (
   ...    IBinaryPackagePublishingHistory)
   >>> verifyObject(IBinaryPackagePublishingHistory, warty_mozilla_pub_bin)
   True

   >>> warty_mozilla_pub_bin.binarypackagerelease.name
   u'mozilla-firefox'
   >>> warty_mozilla_pub_bin.binarypackagerelease.version
   u'0.9'
   >>> warty_mozilla_pub_bin.component.name
   u'main'
   >>> warty_mozilla_pub_bin.section.name
   u'base'

DistroSeries.getBinaryPackagePublishing will return
BinaryPackagePublishingHistory objects for the DistroSeries:

    >>> warty = ubuntu['warty']
    >>> bpphs = warty.getBinaryPackagePublishing()
    >>> bpphs.count()
    10
    >>> 'mozilla-firefox' in set(
    ...     pkgpub.binarypackagerelease.binarypackagename.name
    ...     for pkgpub in bpphs)
    True

It also allows us to pass wanted strings like: name, version, archtag and
sourcename.

    >>> warty.getBinaryPackagePublishing(
    ...     name="nosuchpackage").count()
    0
    >>> warty.getBinaryPackagePublishing(
    ...     version="nosuchversion").count()
    0
    >>> warty.getBinaryPackagePublishing(
    ...     archtag="nosucharch").count()
    0
    >>> warty.getBinaryPackagePublishing(
    ...     sourcename="nosuchsource").count()
    0

We can restrict the results by component:

    >>> warty.getBinaryPackagePublishing(
    ...     component=component_main).count()
    10
    >>> warty.getBinaryPackagePublishing(
    ...     component=component_multiverse).count()
    0

By pocket:

    >>> warty.getBinaryPackagePublishing(
    ...     pocket=PackagePublishingPocket.RELEASE).count()
    10
    >>> warty.getBinaryPackagePublishing(
    ...     pocket=PackagePublishingPocket.BACKPORTS).count()
    0

Or any combination of them:

    >>> warty.getBinaryPackagePublishing(
    ...     sourcename="alsa", pocket=PackagePublishingPocket.RELEASE,
    ...     component=component_main).count()
    0

    >>> warty.getBinaryPackagePublishing(
    ...     name="mozilla-firefox", archtag='i386',
    ...     component=component_main).count()
    2

As getSourcePackagePublishing, getBinaryPublishing accepts 'archive'
parameter for result restriction:

    >>> warty.getBinaryPackagePublishing(
    ...     name="mozilla-firefox", archtag='i386',
    ...     component=component_main, archive=debian_archive).count()
    0



= Specification Listings =

We should be able to get lists of specifications in different states
related to a distroseries.

Basically, we can filter by completeness, and by whether or not the spec is
informational.

    >>> distroset = getUtility(IDistributionSet)
    >>> kubuntu = distroset.getByName("kubuntu")
    >>> krunch = kubuntu.getSeries("krunch")
    >>> from canonical.launchpad.interfaces import SpecificationFilter

First, there should be one informational specs for krunch:

    >>> filter = [SpecificationFilter.INFORMATIONAL]
    >>> krunch.specifications(filter=filter).count()
    1


There are 2 completed specs for Krunch:

    >>> filter = [SpecificationFilter.COMPLETE]
    >>> for spec in kubuntu.specifications(filter=filter):
    ...    print spec.name, spec.is_complete
    thinclient-local-devices True
    usplash-on-hibernation True


And there are 2 incomplete specs:

    >>> filter = [SpecificationFilter.INCOMPLETE]
    >>> for spec in krunch.specifications(filter=filter):
    ...     print spec.name, spec.is_complete
    cluster-installation False
    revu False


If we ask for all specs, we get them in the order of priority.

    >>> filter = [SpecificationFilter.ALL]
    >>> for spec in krunch.specifications(filter=filter):
    ...    print spec.priority.title, spec.name
    Essential cluster-installation
    High revu
    Medium thinclient-local-devices
    Low usplash-on-hibernation
    Undefined kde-desktopfile-langpacks
    Not krunch-desktop-plan


With a distroseries, we can ask for ACCEPTED, PROPOSED and DECLINED specs:

    >>> filter=[SpecificationFilter.ACCEPTED]
    >>> for spec in krunch.specifications(filter=filter):
    ...     print spec.name, spec.goalstatus.title
    cluster-installation Accepted
    revu Accepted
    thinclient-local-devices Accepted
    usplash-on-hibernation Accepted

    >>> filter=[SpecificationFilter.PROPOSED]
    >>> for spec in krunch.specifications(filter=filter):
    ...     print spec.name, spec.goalstatus.title
    kde-desktopfile-langpacks Proposed

    >>> filter=[SpecificationFilter.DECLINED]
    >>> for spec in krunch.specifications(filter=filter):
    ...     print spec.name, spec.goalstatus.title
    krunch-desktop-plan Declined


And if we ask just for specs, we get BOTH the incomplete and the complete
ones that have been accepted.

    >>> for spec in krunch.specifications():
    ...     print spec.name, spec.is_complete, spec.goalstatus.title
    cluster-installation False Accepted
    revu False Accepted
    thinclient-local-devices True Accepted
    usplash-on-hibernation True Accepted

We can filter for specifications that contain specific text:

    >>> for spec in krunch.specifications(filter=['usb']):
    ...     print spec.name
    thinclient-local-devices


= Drivers =

Distributions have drivers, who are people that have permission to approve
bugs and features for specific releases. The rules are that:

 1. a "driver" can be set on either Distribution or DistroSeries
 2. drivers are only actually relevant on a DistroSeries, because thats the
    granularity at which we track spec/bug targeting
 3. the important attribute is ".drivers" on a distroseries, it is
    calculated based on the combination of owners and drivers in the
    distribution and the distroseries. It is a LIST of drivers, which might
    be empty, or have one or two people/teams in it.
 4. If the release has a driver, then that driver is in the list.
 5. If the distribution has a driver then that is in the list too, otherwise
 6. If neither the release nor the distribution has a driver, then the
    distribution registrant is the driver.

We test these rules below.


First, we look at a release where both the distribution and release have
drivers. Kubuntu should be a good example.

    >>> kubuntu.driver.name
    u'jblack'
    >>> krunch.driver.name
    u'edgar'
    >>> for d in krunch.drivers:
    ...     print d.name
    edgar
    jblack


Now, we look at a release where there is a driver on the release but not on
the distribution.

    >>> debian = distroset.getByName('debian')
    >>> print debian.driver
    None
    >>> print debian.owner.name
    sabdfl
    >>> sarge = debian.getSeries('sarge')
    >>> print sarge.driver.name
    jdub
    >>> for d in sarge.drivers:
    ...     print d.name
    jdub
    sabdfl


Now, a release where there is no driver on the release but there is a driver
on the distribution.

    >>> redhat = distroset.getByName('redhat')
    >>> print redhat.driver.name
    jblack
    >>> six = redhat.getSeries('six')
    >>> print six.driver
    None
    >>> for d in six.drivers:
    ...     print d.name
    jblack


Finally, on a release where neither the distribution nor the release have a
driver. Here, we expect the driver to be the owner of the distribution
(because this is the "commonest fallback").

    >>> sid = debian.getSeries('sid')
    >>> print debian.driver
    None
    >>> print debian.owner.name
    sabdfl
    >>> print sid.driver
    None
    >>> print sid.owner.name
    jdub

    >>> for d in sid.drivers:
    ...     print d.name
    sabdfl

== Lastest Uploads ==

IDistroSeries provides the 'getLatestUpload' method which returns a
list of the last 5 (five) IDistroSeriesSourcePackageRelease (IDRSPR)
uploaded and published in its context.

    >>> warty = ubuntu['warty']
    >>> latest_uploads = warty.getLatestUploads()

Each element is an IDistroSeriesSourcePackageRelease instance:

    >>> for upload in latest_uploads:
    ...     print upload.name, upload.version
    mozilla-firefox 0.9

Also, empty results (caused obviously by lack of sample data or very
earlier development state of a distroseries) are possible:

    >>> ubuntutest = getUtility(IDistributionSet)['ubuntutest']
    >>> breezy_autotest = ubuntutest['breezy-autotest']
    >>> latest_uploads = breezy_autotest.getLatestUploads()

    >>> len(latest_uploads)
    0
