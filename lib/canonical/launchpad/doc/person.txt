= Person =

The Person class is what we use to represent Launchpad users, teams and
some people which have done work on the free software community but are not
Launchpad users.

    >>> from zope.component import getUtility
    >>> from canonical.launchpad.webapp.testing import verifyObject
    >>> from canonical.database.sqlbase import sqlvalues, flush_database_updates
    >>> from canonical.launchpad.interfaces import (
    ...     IPersonSet, IPerson, IEmailAddressSet, IHasTranslationImports)
    >>> from canonical.launchpad.ftests import login, ANONYMOUS
    >>> login(ANONYMOUS)

Any Person object (either a person or a team) implements IPerson.

    >>> personset = getUtility(IPersonSet)
    >>> foobar = personset.getByName('name16')
    >>> foobar.isTeam()
    False
    >>> verifyObject(IPerson, foobar)
    True
    >>> ubuntu_team = personset.getByName('ubuntu-team')
    >>> ubuntu_team.isTeam()
    True
    >>> verifyObject(IPerson, ubuntu_team)
    True

and IHasTranslationImports:

    >>> IHasTranslationImports.providedBy(foobar)
    True
    >>> verifyObject(IHasTranslationImports, foobar)
    True
    >>> IHasTranslationImports.providedBy(ubuntu_team)
    True
    >>> verifyObject(IHasTranslationImports, ubuntu_team)
    True

== The IPersonSet utility ==

Access to people (Persons or Teams) is done through the IPersonSet
utility:

You can create a new person using the createPersonAndEmail method of
IPersonSet. All you need for that is a valid email address. You can also
hide the user email addresses.

Some of our scripts may create Person entries, and in these cases they must
provide a rationale and a comment (optional) for the creation of that Person
entry. These are displayed on the home pages of unvalidated Launchpad
profiles, to make it clear that those profiles were not created by the
people they represent and why they had to be created. Because the comment
will be displayed verbatim in a web page, it must start with the word "when"
followed by a description of the action that caused the entry to be created.

    >>> from canonical.launchpad.interfaces import (
    ...     EmailAddressStatus, PersonCreationRationale)
    >>> p, email = personset.createPersonAndEmail(
    ...     'randomuser@randomhost.com', PersonCreationRationale.POFILEIMPORT,
    ...     comment='when importing the Portuguese translation of firefox',
    ...     hide_email_addresses=True)
    >>> p.teamowner is None
    True
    >>> email.status == EmailAddressStatus.NEW
    True
    >>> p.is_valid_person # Not valid because no preferred email address
    False
    >>> p.hide_email_addresses
    True

By default, newly created Person entries will have AccountStatus.NOACCOUNT as
their account_status.  This is only changed if/when we turn that entry into an
actual user account. (Currently, we assume that a Person entry is turned into
a user account when its first email address is confirmed)

    >>> p.account_status
    <DBItem AccountStatus.NOACCOUNT...
    >>> p.setPreferredEmail(email)
    >>> email.status
    <DBItem EmailAddressStatus.PREFERRED...
    >>> p.account_status
    <DBItem AccountStatus.ACTIVE...

In the case of teams, though, the account_status is not changed as their
account_status must always be set to NOACCOUNT. (Notice how we use
setContactAddress() rather than setPreferredEmail() here, since the latter
can be used only for people and the former only for teams)

    >>> shipit_admins = personset.getByName('shipit-admins')
    >>> shipit_admins.account_status
    <DBItem AccountStatus.NOACCOUNT...

    >>> emailset = getUtility(IEmailAddressSet)
    >>> email = emailset.new('foo@baz.com', shipit_admins)
    >>> shipit_admins.setContactAddress(email)
    >>> email.status
    <DBItem EmailAddressStatus.PREFERRED...
    >>> shipit_admins.account_status
    <DBItem AccountStatus.NOACCOUNT...

When a new sourcepackage is imported and a Person entry has to be created
because we don't know about the maintainer of that package, the code to create
the person should look like this:

    >>> person, emailaddress = personset.createPersonAndEmail(
    ...     'random@random.com', PersonCreationRationale.SOURCEPACKAGEIMPORT,
    ...     comment='when the ed package was imported into Ubuntu Breezy')
    >>> person.is_valid_person
    False
    >>> person.creation_comment
    u'when the ed package was imported into Ubuntu Breezy'


In case of failure of creating a new person or email the method returns
(None, None). Let's demonstrate this trying to create a person with
an invalid email.

    >>> p2, invalid_email = personset.createPersonAndEmail(
    ...     'test#canonical.com', PersonCreationRationale.UNKNOWN)
    >>> p2, invalid_email
    (None, None)

And now with the same name of a existing account

    >>> p3, invalid_email = personset.createPersonAndEmail(
    ...     'randomemail@randomhost.com', PersonCreationRationale.UNKNOWN,
    ...     name='name12')
    >>> p3, invalid_email
    (None, None)

    >>> vcs_imports = personset.getByName('vcs-imports')
    >>> vcs_imports.teamowner is None
    False
    >>> vcs_imports.is_valid_person # Not valid person because it is a team
    False
    >>> lifeless = personset.getByName('lifeless')
    >>> lifeless.teamowner is None
    True

=== Ubunteros ===

Anybody who signed the last version of Ubuntu's Code of Conduct is considered
an Ubuntero.  To list all Ubunteros, use IPersonSet.getUbunteros():

    >>> [p.name for p in personset.getUbunteros()]
    [u'name16']

To check if a person is an Ubuntero, use IPerson.is_ubuntero:

    >>> foobar.is_ubuntero
    True

== Teams ==

As we said above, the Person class is overloaded to represent teams so
we may have Person objects which are, in fact, teams. To find out
whether a given object is a person or a team we can use the isTeam()
method of IPerson or check if the object provides the ITeam interface.

    >>> from canonical.launchpad.interfaces import ITeam
    >>> ddaa = personset.getByName('ddaa')
    >>> ddaa.isTeam()
    False
    >>> ITeam.providedBy(ddaa)
    False

    >>> landscape_devs = personset.getByName('landscape-developers')
    >>> landscape_devs.isTeam()
    True
    >>> ITeam.providedBy(landscape_devs)
    True
    >>> verifyObject(ITeam, landscape_devs)
    True

Also note that a team will never have a Launchpad account, so its
account_status will always be NOACCOUNT.

    >>> landscape_devs.account_status
    <DBItem AccountStatus.NOACCOUNT...

=== Team members ===

The relationship between a person and a team is stored in TeamMemberships
table. TeamMemberships have a status (which can be any item of
TeamMembershipStatus) and represent the current state of the relationship
between that person and that team. Only TeamMembershipStatus with an ADMIN
or APPROVED status are considered active.

    >>> [member.displayname for member in landscape_devs.approvedmembers]
    [u'Guilherme Salgado']
    >>> [member.displayname for member in landscape_devs.adminmembers]
    [u'Sample Person']

The IPerson.activemembers property will always include all approved and admin
members of that team.

    >>> [member.displayname for member in landscape_devs.activemembers]
    [u'Guilherme Salgado', u'Sample Person']

TeamMemberships with a PROPOSED or INVITED status represent a person/team
which has proposed himself as a member or which has been invited to join
the team.

    >>> [member.displayname for member in landscape_devs.proposedmembers]
    [u'Foo Bar']
    >>> [member.displayname for member in landscape_devs.invited_members]
    [u'Launchpad Developers']

Similarly, we have IPerson.pendingmembers which includes both invited and
proposed members.

    >>> [member.displayname for member in landscape_devs.pendingmembers]
    [u'Foo Bar', u'Launchpad Developers']

Finally, we have EXPIRED and DEACTIVATED TeamMemberships, which represent
former (inactive) members of a team.

    >>> [member.displayname for member in landscape_devs.expiredmembers]
    [u'Karl Tilbury']
    >>> [member.displayname for member in landscape_devs.deactivatedmembers]
    [u'No Privileges Person']

We can get a list of all inactive members of a team with the
IPerson.inactivemembers property.

    >>> [member.displayname for member in landscape_devs.inactivemembers]
    [u'Karl Tilbury', u'No Privileges Person']

We can also iterate over the TeamMemberships themselves, which is useful
when we want to display details about them rather than just the member.

    >>> [(membership.person.displayname, membership.status.name)
    ...  for membership in landscape_devs.getActiveMemberships()]
    [(u'Guilherme Salgado', 'APPROVED'), (u'Sample Person', 'ADMIN')]
    >>> [(membership.person.displayname, membership.status.name)
    ...  for membership in landscape_devs.getInvitedMemberships()]
    [(u'Launchpad Developers', 'INVITED')]
    >>> [(membership.person.displayname, membership.status.name)
    ...  for membership in landscape_devs.getProposedMemberships()]
    [(u'Foo Bar', 'PROPOSED')]
    >>> [(membership.person.displayname, membership.status.name)
    ...  for membership in landscape_devs.getInactiveMemberships()]
    [(u'Karl Tilbury', 'EXPIRED'), (u'No Privileges Person', 'DEACTIVATED')]

An IPerson has an inTeam method to allow us to easily check if a
person is a member (directly or through other teams) of a team. It
accepts an object implementing IPerson, which is the common use case
when checking permissions.

    >>> ddaa.is_valid_person
    True
    >>> lifeless.inTeam(vcs_imports) and ddaa.inTeam(vcs_imports)
    True

That method can also be used to check that a given IPerson is a member of
itself. We can do that because people and teams have TeamParticipation
entries for themselves.

    >>> ddaa.inTeam(ddaa)
    True
    >>> ddaa.hasParticipationEntryFor(ddaa)
    True

    >>> vcs_imports.inTeam(vcs_imports)
    True
    >>> vcs_imports.hasParticipationEntryFor(vcs_imports)
    True

The inTeam method is cached to avoid unnecessary database lookups - this
was a cause of a number of timeouts

    >>> from zope.security.proxy import removeSecurityProxy
    >>> naked_lifeless = removeSecurityProxy(lifeless)
    >>> naked_lifeless._inTeam_cache[vcs_imports.id]
    True
    >>> naked_lifeless._inTeam_cache[vcs_imports.id] = False
    >>> lifeless.inTeam(vcs_imports)
    False
    >>> naked_lifeless._inTeam_cache[vcs_imports.id] = True
    >>> lifeless.inTeam(vcs_imports)
    True

** See lib/canonical/launchpad/doc/teammembership.txt for more information
   about team membership/participation.


=== Email notifications to teams ===

If a team has a contact email address, all notifications we send to the
team will go to that address.

    >>> ubuntu_team = personset.getByName('ubuntu-team')
    >>> ubuntu_team.preferredemail.email
    u'support@ubuntu.com'
    >>> from canonical.launchpad.helpers import contactEmailAddresses
    >>> contactEmailAddresses(ubuntu_team)
    set(['support@ubuntu.com'])

On the other hand, if a team doesn't have a contact email address, all
notifications we send to the team will go to the preferred email of
each direct member of that team.

    >>> vcs_imports.preferredemail is None
    True
    >>> sorted(member.preferredemail.email
    ...        for member in vcs_imports.activemembers)
    [u'david.allouche@canonical.com', u'foo.bar@canonical.com',
     u'robertc@robertcollins.net']
    >>> sorted(contactEmailAddresses(vcs_imports))
    ['david.allouche@canonical.com', 'foo.bar@canonical.com',
     'robertc@robertcollins.net']


== Deactivating user accounts ==

Any user can deactivate his own account, in case they don't want it anymore
or they don't want to be shown as Launchpad users.

As seen below, Foo Bar has a bunch of stuff assigned/owned to/by him in
Launchpad which we'll want to be reassigned/unassigned if his account is
deactivated.  Unfortunatel, Foo Bar has no specifications assigned to him, so
we'll assign one just to prove that deactivating his account will cause this
spec to be reassigned.

    >>> foobar.specifications().count() > 0
    True
    >>> from canonical.launchpad.database import Person, Specification
    >>> spec = Specification.selectFirst("assignee IS NULL", orderBy='id')
    >>> spec.assignee = foobar
    >>> flush_database_updates()

    >>> [membership.team.name for membership in foobar.myactivememberships]
    [u'guadamen', u'admins', u'launchpad-buildd-admins', u'launchpad',
     u'testing-spanish-team', u'name18', u'ubuntu-team', u'vcs-imports']
    >>> [email.email for email in foobar.validatedemails]
    []
    >>> foobar.name
    u'name16'
    >>> foobar.preferredemail.email
    u'foo.bar@canonical.com'
    >>> [coc.active for coc in foobar.signedcocs]
    [True]
    >>> from canonical.launchpad.interfaces import BugTaskSearchParams
    >>> params = BugTaskSearchParams(foobar, assignee=foobar)
    >>> foobar.searchTasks(params).count() > 0
    True
    >>> len(foobar.assigned_specs) > 0
    True
    >>> foobar_pillars = []
    >>> for pillar_name in foobar.getOwnedOrDrivenPillars():
    ...     pillar = pillar_name.pillar
    ...     if pillar.owner == foobar or pillar.driver == foobar:
    ...         foobar_pillars.append(pillar_name)
    >>> len(foobar_pillars) > 0
    True
    >>> foobar_teams = list(Person.selectBy(teamowner=foobar))
    >>> len(foobar_teams) > 0
    True
    >>> foobar.is_valid_person
    True

    >>> comment = ("I'm a silly person who doesn't want to be listed "
    ...            "as a Launchpad user.")

The deactivateAccount method is restricted to the user himself --not even
launchpad admins can use it.

    >>> login('mark@hbd.com')
    >>> foobar.deactivateAccount(comment)
    Traceback (most recent call last):
    ...
    Unauthorized: ...'launchpad.Special')

    >>> login('foo.bar@canonical.com')
    >>> foobar.deactivateAccount(comment)
    >>> flush_database_updates()
    >>> from canonical.database.sqlbase import flush_database_caches
    >>> flush_database_caches()

Deactivating an account changes many of the person's attributes.  It adds a
'-deactivatedaccount' suffix to the person's name...

    >>> foobar.name
    u'name16-deactivatedaccount'

...an account status of DEACTIVATED...

    >>> foobar.account_status
    <DBItem AccountStatus.DEACTIVATED...
    >>> foobar.account_status_comment
    u"I'm a silly person who doesn't want to be listed as a Launchpad user."

...to have no team memberships...

    >>> [membership.team.name for membership in foobar.myactivememberships]
    []

...and no validated/preferred email addresses...

    >>> [email.email for email in foobar.validatedemails]
    []
    >>> print getattr(foobar.preferredemail, 'email', None)
    None

...no signed codes of conduct...

    >>> [coc.active for coc in foobar.signedcocs]
    [False]

...no assigned bug tasks...

    >>> foobar.searchTasks(params).count()
    0

...no assigned specs...

    >>> len(foobar.assigned_specs)
    0

...no owned teams...

    >>> Person.selectBy(teamowner=foobar).count()
    0

...no owned or driven pillars...
    >>> foobar.getOwnedOrDrivenPillars().count()
    0

...and, finally, to not be considered a valid person in Launchpad.

    >>> foobar.is_valid_person
    False

It's also important to note that the teams/pillars owned/driven by Foo Bar
are now owned/driven by the registry admins team.

    >>> from canonical.launchpad.interfaces import ILaunchpadCelebrities
    >>> registry = getUtility(ILaunchpadCelebrities).registry
    >>> registry_pillars = set(registry.getOwnedOrDrivenPillars())
    >>> registry_pillars.issuperset(foobar_pillars)
    True

    >>> registry_teams = set(Person.selectBy(teamowner=registry))
    >>> registry_teams.issuperset(foobar_teams)
    True

    # We need to restore Foo Bar's name because some of our further tests rely
    # on that name existing in the database and it'd be a lot more painful
    # to update them. :/
    >>> foobar.name = 'name16'
    >>> flush_database_updates()

== Searching ==

You can search based on a person's name or displayname, or any of the email
addresses that belongs to a person using the methods provided by IPersonSet.

While we don't have Full Text Indexes in the emailaddress table, we'll be
trying to match the text only against the beginning of an email address:

    # First we'll define a utility function to help us displaying the results.
    >>> emailset = getUtility(IEmailAddressSet)
    >>> def print_people(results):
    ...     for person in results:
    ...         emails = [email.email for email in emailset.getByPerson(person)]
    ...         print (
    ...             "%s (%s): %s" % (person.displayname, person.name, emails))

    >>> print_people(personset.find('ubuntu'))
    Mirror Administrators (ubuntu-mirror-admins): []
    Sigurd Gartmann (sigurd-ubuntu): [u'sigurd-ubuntu@brogar.org']
    Ubuntu Gnome Team (name18): []
    Ubuntu Team (ubuntu-team): [u'support@ubuntu.com']
    Ubuntu Translators (ubuntu-translators): []

    >>> print_people(personset.find('steve.alexander'))
    Steve Alexander (stevea): [u'steve.alexander@ubuntulinux.com']

Searching only for People based on their names or email addresses:

    >>> print_people(personset.findPerson('james.blackwell'))
    James Blackwell (jblack): [u'james.blackwell@ubuntulinux.com']

    >>> print_people(personset.findPerson('dave'))
    Dave Miller (justdave): [u'dave.miller@ubuntulinux.com',
                             u'justdave@bugzilla.org']

By default, when searching only for people, any person whose account is
inactive is not included in the list, but we can tell findPerson to include
them as well.
    
    >>> from canonical.launchpad.interfaces import AccountStatus
    >>> dave = personset.getByName('justdave')
    >>> login('dave.miller@ubuntulinux.com')
    >>> dave.account_status = AccountStatus.DEACTIVATED
    >>> flush_database_updates()
    >>> list(personset.findPerson('dave'))
    []

    >>> print_people(
    ...     personset.findPerson('dave', exclude_inactive_accounts=False))
    Dave Miller (justdave): [u'dave.miller@ubuntulinux.com',
                             u'justdave@bugzilla.org']

    >>> dave.account_status = AccountStatus.ACTIVE
    >>> flush_database_updates()
    >>> login(ANONYMOUS)

Searching only for Teams based on their names or email addresses:

    >>> print_people(personset.findTeam('support'))
    Ubuntu Team (ubuntu-team): [u'support@ubuntu.com']

    >>> print_people(personset.findTeam('translators'))
    Ubuntu Translators (ubuntu-translators): []

== Packages related to a person ==

To obtain the packages a person is related to, we can use:

 1. getLatestMaintainedPackages(),
 2. getLatestUploadedButNotMaintainedPackages(),
 3. getLatestUploadedPPAPackages

The 1st will return the latest SourcePackageReleases related to a
person in which he is listed as the Maintainer. The second will return
the latest SourcePackageReleases a person uploaded (and where he isn't
the maintainer).

Both, 1st and 2nd methods, only consider sources upload to primary archives.

The 3rd method returns SourcePackageReleases uploaded by the person in
question to any PPA.

    >>> sabdfl = personset.getByName('sabdfl')
    >>> for sprelease in sabdfl.getLatestMaintainedPackages():
    ...     print (sprelease.name, sprelease.upload_distroseries.fullseriesname,
    ...            sprelease.version)
    (u'alsa-utils', u'Debian Sid', u'1.0.9a-4')
    (u'pmount', u'Ubuntu Hoary', u'0.1-2')
    (u'netapplet', u'Ubuntu Warty', u'0.99.6-1')
    (u'netapplet', u'Ubuntu Hoary', u'1.0-1')
    (u'alsa-utils', u'Ubuntu Warty', u'1.0.8-1ubuntu1')
    (u'mozilla-firefox', u'Ubuntu Hoary', u'0.9')
    (u'evolution', u'Ubuntu Hoary', u'1.0')

    >>> for sprelease in sabdfl.getLatestUploadedButNotMaintainedPackages():
    ...     print (sprelease.name, sprelease.upload_distroseries.fullseriesname,
    ...            sprelease.version)
    (u'language-pack-de', u'Ubuntu Breezy-autotest', u'1.0')
    (u'foobar', u'Ubuntu Breezy-autotest', u'1.0')
    (u'cdrkit', u'Ubuntu Breezy-autotest', u'1.0')
    (u'cnews', u'Ubuntu Breezy-autotest', u'1.0')
    (u'libstdc++', u'Ubuntu Hoary', u'b8p')
    (u'cnews', u'Ubuntu Hoary', u'cr.g7-37')
    (u'linux-source-2.6.15', u'Ubuntu Hoary', u'2.6.15.3')
    (u'at', u'Ubuntu Hoary', u'0.00')
    (u'alsa-utils', u'Ubuntu Hoary', u'1.0.9a-4ubuntu1')


    >>> sabdfl_spreleases = sabdfl.getLatestUploadedPPAPackages()
    >>> for sprelease in sabdfl_spreleases:
    ...     print (sprelease.name,
    ...            sprelease.version,
    ...            sprelease.creator.name,
    ...            sprelease.maintainer.name,
    ...            sprelease.upload_archive.owner.name,
    ...            sprelease.upload_distroseries.fullseriesname)
    (u'iceweasel', u'1.0', u'sabdfl', u'name16', u'sabdfl', u'Ubuntu Warty')
    (u'iceweasel', u'1.0', u'sabdfl', u'name16', u'no-priv', u'Ubuntu Warty')

We will change modify the first SourcePackageRelease to reproduce the
issue mentioned in bug 157303, where source with same creator and
maintainer got omitted from the results:

    >>> any_spr = sabdfl_spreleases[0]
    >>> naked_spr = removeSecurityProxy(any_spr)
    >>> naked_spr.maintainer = sabdfl
    >>> flush_database_updates()

    >>> sabdfl_spreleases = sabdfl.getLatestUploadedPPAPackages()
    >>> for sprelease in sabdfl_spreleases:
    ...     print (sprelease.name,
    ...            sprelease.version,
    ...            sprelease.creator.name,
    ...            sprelease.maintainer.name,
    ...            sprelease.upload_archive.owner.name,
    ...            sprelease.upload_distroseries.fullseriesname)
    (u'iceweasel', u'1.0', u'sabdfl', u'sabdfl', u'sabdfl', u'Ubuntu Warty')
    (u'iceweasel', u'1.0', u'sabdfl', u'name16', u'no-priv', u'Ubuntu Warty')


== Pillars owned or driven by a person or team ==

To obtain all distributions, project groups and projects owned or driven by a
person or team, we can use the getOwnedOrDrivenPillars() method of IPerson.
This method returns PillarNames ordered by distribution, project groups and
projects.

    >>> from canonical.launchpad.interfaces import (IDistribution, IProject,
    ...     IProduct)

    >>> def print_pillar(pillarname):
    ...     pillar = pillarname.pillar
    ...     if IDistribution.providedBy(pillar):
    ...         pillar_type = 'distribution'
    ...     elif IProject.providedBy(pillar):
    ...         pillar_type = 'project group'
    ...     elif IProduct.providedBy(pillar):
    ...         pillar_type = 'project'
    ...     print "%s: %s (%s)" % (
    ...         pillar_type, pillar.title, pillar.name)

    >>> for pillarname in sabdfl.getOwnedOrDrivenPillars():
    ...     print_pillar(pillarname)
    distribution: Ubuntu Linux (ubuntu)
    distribution: Redhat Advanced Server (redhat)
    distribution: Debian GNU/Linux (debian)
    distribution: The Gentoo Linux (gentoo)
    distribution: Kubuntu - Free KDE-based Linux (kubuntu)
    distribution: Ubuntu Test (ubuntutest)
    project group: Apache (apache)
    project group: The Test Project (aaa)
    project group: The GIMP Project (gimp)
    project: Tomcat (tomcat)
    project: The Gnome Panel Applets (applets)
    project: Liba52 Test Decoder (a52dec)
    project: Gnome Baker (gnomebaker)
    project: ALSA utilities (alsa-utils)
    project: Derby - Java Database (derby)

    >>> for pillarname in ubuntu_team.getOwnedOrDrivenPillars():
    ...     print_pillar(pillarname)
    distribution: Ubuntu Linux (ubuntu)
    distribution: Ubuntu Test (ubuntutest)
    project: Tomcat (tomcat)


== Translations ==

Users can set their preferred languages, retrievable as Person.languages.

    >>> daf = personset.getByName('daf')
    >>> carlos = personset.getByName('carlos')

    >>> for language in carlos.languages:
    ...     print language.code, language.englishname
    ca     Catalan
    en     English
    es     Spanish

The Person.languages list is ordered alphabetically by the languages' English
names.

    >>> for language in daf.languages:
    ...     print language.code, language.englishname
    en_GB  English (United Kingdom)
    ja     Japanese
    cy     Welsh

Person.translatable_languages yields the same list, except it leaves out US
English and languages marked as non-visible such as 'zh' or 'de_DE'.

    >>> for language in daf.translatable_languages:
    ...     print language.code, language.englishname
    en_GB  English (United Kingdom)
    ja     Japanese
    cy     Welsh

    >>> for language in carlos.translatable_languages:
    ...     print language.code, language.englishname
    ca     Catalan
    es     Spanish

The IPerson interface offers a way of returning POFileTranslator records
for a Person:

    >>> for pt in carlos.translation_history:
    ...     print pt.pofile.title
    Spanish (es) translation of alsa-utils in alsa-utils trunk
    Spanish (es) translation of man in Ubuntu Hoary package "evolution"
    Spanish (es) translation of evolution-2.2 in Evolution trunk
    Japanese (ja) translation of evolution-2.2 in Ubuntu Hoary package "evolution"
    Spanish (es) translation of evolution-2.2 in Ubuntu Hoary package "evolution"

The IPersonSet component contains a few convenience methods to return
Person objects that have contributed translations.

    >>> from canonical.launchpad.database import POFile
    >>> pofile = POFile.get(12)
    >>> [p.name for p in personset.getPOFileContributors(pofile)]
    [u'carlos', u'name16', u'tsukimi']

getPOFileContributorsByDistroSeries gives the list of people that did
contributions to templates that are current in the given IDistroSeries
and ILanguage.

    >>> from canonical.launchpad.database import DistroSeries, Language
    >>> hoary = DistroSeries.selectOneBy(name="hoary")
    >>> spanish = Language.selectOneBy(code="es")
    >>> [p.name for p in personset.getPOFileContributorsByDistroSeries(hoary, spanish)]
    [u'jorge-gonzalez-gonzalez', u'carlos', u'valyag', u'danner', u'name16',
     u'name12', u'tsukimi']

    # We can see that there is another translator that doesn't appear in
    # previous list because the template he translated is not current.
    >>> non_current_pofile = POFile.get(31)
    >>> non_current_pofile.potemplate.iscurrent
    False
    >>> [p.name for p in personset.getPOFileContributors(non_current_pofile)]
    [u'jordi']
    >>> non_current_pofile.potemplate.distroseries == hoary
    True
    >>> non_current_pofile.language == spanish
    True

=== Translators for a given language ===

We can get the list of translators that did some translation in Launchpad and
expressed their interest for a concrete language.

    >>> from canonical.launchpad.interfaces import (
    ...     ILanguageSet, IPersonSet, IKarmaCacheManager)
 
    # Sample data is not complete for this test, so we need to note that another
    # Spanish translator expressed its interest on doing Spanish translations.
    # That other person is Foo Bar (name16).
    >>> personset = getUtility(IPersonSet)
    >>> foo_bar = personset.getByName('name16')
    >>> print foo_bar.displayname
    Foo Bar
    >>> languageset = getUtility(ILanguageSet)
    >>> spanish = languageset.getLanguageByCode('es')
    >>> foo_bar.addLanguage(spanish)
    >>> translators = personset.getTranslatorsByLanguage(spanish)
    >>> for translator in translators:
    ...     karma = 0
    ...     for karma_category_cache in translator.karma_category_caches:
    ...         if (karma_category_cache.category.name == 'translations'):
    ...             karma = karma_category_cache.karmavalue
    ...     print (translator.displayname, karma)
    (u'Foo Bar', 164)
    (u'Carlos Perell\xf3 Mar\xedn', 9)


== Specification Lists ==

We should be able to generate lists of specifications for people based on
certain criteria:

First, Carlos does not have any completed specifications assigned to him:

    >>> from canonical.launchpad.interfaces import SpecificationFilter
    >>> carlos.specifications(filter=[
    ...     SpecificationFilter.ASSIGNEE,
    ...     SpecificationFilter.COMPLETE]).count()
    0

Next, Carlos has three incomplete specs *related* to him:

    >>> filter = []
    >>> for spec in carlos.specifications(filter=filter):
    ...     print spec.name, spec.is_complete, spec.informational
    svg-support False False
    extension-manager-upgrades False True
    media-integrity-check False False

Carlos has 2 specifications assigned to him:

    >>> for spec in carlos.assigned_specs:
    ...     print spec.name
    svg-support
    extension-manager-upgrades

But from these two, only one has started.

    >>> [(spec.name, spec.is_started)
    ...  for spec in carlos.assigned_specs_in_progress]
    [(u'svg-support', True)]

Just for fun, lets check the SAB. He should have one spec for which he
is the approver.

    >>> sabdfl = getUtility(IPersonSet).getByName('sabdfl')
    >>> filter = [SpecificationFilter.APPROVER]
    >>> for spec in sabdfl.specifications(filter=filter):
    ...     print spec.name
    extension-manager-upgrades

The Foo Bar person has a single spec which has feedback requested:

    >>> filter = [SpecificationFilter.FEEDBACK]
    >>> for spec in foobar.specifications(filter=filter):
    ...     print spec.name
    e4x

But has registered 5 of them:

    >>> filter = [SpecificationFilter.CREATOR]
    >>> print foobar.specifications(filter=filter).count()
    5

Now Celso, on the other hand, has 2 specs related to him:

    >>> cprov = personset.getByName('cprov')
    >>> cprov.specifications().count()
    2

On one of those, he is the approver:

    >>> filter = [SpecificationFilter.APPROVER]
    >>> for spec in cprov.specifications(filter=filter):
    ...     print spec.name
    svg-support

And on another one, he is the drafter

    >>> filter = [SpecificationFilter.DRAFTER]
    >>> for spec in cprov.specifications(filter=filter):
    ...     print spec.name
    e4x

We can filter for specifications that contain specific text:

    >>> for spec in cprov.specifications(filter=['svg']):
    ...     print spec.name
    svg-support

Inactive products are excluded from the listings.

    >>> from canonical.database.sqlbase import flush_database_updates
    >>> from canonical.launchpad.interfaces import IProductSet
    >>> from canonical.launchpad.ftests import login
    >>> firefox = getUtility(IProductSet).getByName('firefox')
    >>> login("mark@hbd.com")
    >>> firefox.active = False
    >>> flush_database_updates()
    >>> cprov.specifications(filter=['svg']).count()
    0

Reset firefox so we don't mess up later tests.

    >>> firefox.active = True
    >>> flush_database_updates()


== Branches ==

** See branch.txt for API related to branches.


== Distribution uploaders ==

We can ascertain whether a person has uploader rights to a distribution
or not.

    >>> from canonical.launchpad.interfaces import IDistributionSet
    >>> cprov = getUtility(IPersonSet).getByName('cprov')
    >>> ubuntu = getUtility(IDistributionSet)['ubuntu']
    >>> cprov.isUploader(ubuntu)
    True

'kiko' is not an uploader to Ubuntu:

    >>> kiko = getUtility(IPersonSet).getByName('kiko')
    >>> kiko.isUploader(ubuntu)
    False

