= Launchpad Single-Signon Workflow: Authorize =

If a user has logged into Launchpad and then wants to log in to a
Launchpad-SSO web site, they are not prompted for a password.

First we will set up the helper view that lets us test the final
portion of the authentication process:

    >>> from openid.consumer.consumer import Consumer
    >>> from openid.fetchers import setDefaultFetcher
    >>> from openid.store.memstore import MemoryStore
    >>> from canonical.launchpad.testing.openidhelpers import (
    ...     complete_from_browser, make_identifier_select_endpoint,
    ...     PublisherFetcher)
    >>> setDefaultFetcher(PublisherFetcher())

The authentication process is started by the relying party issuing a
checkid_setup request, sending the user to Launchpad.  We will
authenticate before starting the login procedure:

    >>> browser.addHeader('Authorization', 'Basic mark@hbd.com:test')

    >>> openid_store = MemoryStore()
    >>> consumer = Consumer(session={}, store=openid_store)
    >>> request = consumer.beginWithoutDiscovery(
    ...     make_identifier_select_endpoint(PROTOCOL_URI))

    # Use localhost instead of launchpad.dev because Launchpad is not
    # recorded as an OpenIDRPSummary.
    >>> browser.open(request.redirectURL(
    ...     'http://localhost/', 'http://localhost/+openid-consumer'))

Each OpenID authentication is recorded as an OpenIDRPSummary. This user
has not ever used Launchpad to authenticate with a relying party.

    >>> from zope.component import getUtility
    >>> from canonical.launchpad.interfaces import IOpenIDRPSummarySet

    >>> login('foo.bar@canonical.com')

    >>> from canonical.launchpad.webapp.dbpolicy import SSODatabasePolicy
    >>> policy = SSODatabasePolicy(LaunchpadTestRequest())
    >>> policy.beforeTraverse()

    >>> rp_summary_set = getUtility(IOpenIDRPSummarySet)
    >>> summaries = rp_summary_set.getByIdentifier(
    ...     'http://openid.launchpad.dev/+id/sabdfl_oid')
    >>> summaries.count()
    0

    >>> policy.afterCall()

    >>> logout()

At this point, the user is presented with a form asking if they want
to authenticate to the relying party

    >>> print browser.title
    Authenticate to http://localhost/

By clicking the "Sign In" button, the user is returned to the relying
party with their identity URL:

    >>> browser.getControl('Sign In', index=0).click()
    >>> print browser.url
    http://localhost/+openid-consumer?...
    >>> info = complete_from_browser(
    ...     consumer, browser, 'http://openid.launchpad.dev/+id/sabdfl_oid')
    >>> print info.status
    success
    >>> print info.endpoint.claimed_id
    http://openid.launchpad.dev/+id/sabdfl_oid

The authentication was recorded. There is a summary showing that the
user has used the replying part once.

    >>> login('foo.bar@canonical.com')

    >>> summaries = rp_summary_set.getByIdentifier(
    ...     'http://openid.launchpad.dev/+id/sabdfl_oid')
    >>> for summary in summaries:
    ...     summary.openid_identifier
    ...     summary.trust_root
    ...     summary.total_logins
    u'http://openid.launchpad.dev/+id/sabdfl_oid'
    u'http://localhost/'
    1

    >>> logout()


== Declining to Authenticate ==

Alternatively, the user could have declined to authenticate.  This
time, we will cancel the authentication request:

    >>> request = consumer.beginWithoutDiscovery(
    ...     make_identifier_select_endpoint(PROTOCOL_URI))
    >>> browser.open(request.redirectURL(
    ...     'http://launchpad.dev/', 'http://launchpad.dev/+openid-consumer'))

    >>> print browser.title
    Authenticate to http://launchpad.dev/
    >>> browser.getControl("Not Now").click()
    >>> print browser.url
    http://launchpad.dev/+openid-consumer?...
    >>> info = complete_from_browser(
    ...     consumer, browser, 'http://openid.launchpad.dev/+id/sabdfl_oid')
    >>> print info.status
    cancel


== Cleanup ==

    >>> setDefaultFetcher(None)
