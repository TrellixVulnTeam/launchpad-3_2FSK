= An example of EnumCol with EnumeratedTypes =

EnumCol is a type of column that is used in SQLBase classes where the
database representation is an integer and the code uses an enumerated
type.

Firstly we need an example table.

    >>> from canonical.database.sqlbase import cursor
    >>> cur = cursor()
    >>> cur.execute('''
    ...     CREATE TABLE FooTest (
    ...         id serial NOT NULL,
    ...         foo integer DEFAULT 1 NOT NULL
    ...     );
    ... ''')
    >>> cur.execute('GRANT ALL ON TABLE FooTest TO launchpad;')
    >>> cur.execute('GRANT ALL ON footest_id_seq TO launchpad;')
    >>> import transaction
    >>> transaction.commit()

The enumerated type that is used with the EnumCol must be a
DBEnumeratedType, with items that are instances of DBItem.

    >>> from canonical.launchpad.webapp.enum import (
    ...     EnumeratedType, DBEnumeratedType, DBItem, Item, extends)
    >>> class FooType(DBEnumeratedType):
    ...     """Enumerated type for the foo column."""
    ...     ONE = DBItem(1, """
    ...         One
    ...
    ...         Number one.
    ...         """)
    ...
    ...     TWO = DBItem(2, """
    ...         Two
    ...
    ...         Number two.
    ...         """)

The database implementation class then refers to the enumerated type.

    >>> from canonical.database.constants import DEFAULT
    >>> from canonical.database.enumcol import EnumCol
    >>> from canonical.database.sqlbase import SQLBase
    >>> class FooTest(SQLBase):
    ...     foo = EnumCol(enum=FooType, default=DEFAULT)

Create a row in the table.

    >>> t = FooTest()

The value of the foo column has been set to the default defined in the
database, because we didn't specify one in the constructor.

    >>> t.foo == FooType.ONE
    True

You cannot use integers or strings as EnumCol values:

    >>> t.foo = 2
    Traceback (most recent call last):
    ...
    TypeError: Need to set an EnumeratedType Enum column to an Item, not an int

    >>> t.foo = "TWO"
    Traceback (most recent call last):
    ...
    TypeError: Not a DBItem: 'TWO'

You can of course use items from FooType.

    >>> t.foo = FooType.TWO
    >>> t.foo
    <DBItem FooType.TWO, (2) Two>

But not items from another schema.

    >>> class AnotherType(DBEnumeratedType):
    ...     ONE = DBItem(1, """
    ...         One
    ...
    ...         Number one.
    ...         """)
    >>> t.foo = AnotherType.ONE
    Traceback (most recent call last):
    ...
    TypeError: DBItem from wrong type, 'FooType' not in ['AnotherType']

XXX: thumper 2007-06-14
Need to think of a cleaner way to implement the extending assignment
problem.

But it will allow setting from an item from an enumerated type that
inherits or extends the original enumerated type where the item was in
that original type.

    >>> class FooBarType(FooType):
    ...     THREE = DBItem(3, "Three")

    >>> t.foo = FooBarType.ONE

Even though the assignment is from a derived enumeration, the value
that is available through the EnumCol is the item from the assigned
enumeration.

    >>> t.foo
    <DBItem FooType.ONE, (1) One>
    >>> t.foo = FooBarType.THREE
    Traceback (most recent call last):
    ...
    TypeError: DBItem from wrong type, 'FooType' not in ['FooBarType']

    >>> class FooBazType(EnumeratedType):
    ...     extends(FooType)
    ...     THREE = DBItem(3, "Three")
    ...     FOUR = Item("Four")

    >>> t.foo = FooBazType.ONE
    >>> t.foo
    <DBItem FooType.ONE, (1) One>

    >>> t.foo = FooBazType.THREE
    Traceback (most recent call last):
    ...
    TypeError: DBItem from wrong type, 'FooType' not in ['FooBazType']

    >>> t.foo = FooBazType.FOUR
    Traceback (most recent call last):
    ...
    TypeError: Not a DBItem: <Item FooBazType.FOUR, Four>

