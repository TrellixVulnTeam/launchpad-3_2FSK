= ShipIt Pages =

    >>> from canonical.launchpad.database import ShippingRequest
    >>> from canonical.launchpad.layers import (
    ...     ShipItKUbuntuLayer, ShipItUbuntuLayer)
    >>> jordis_request = ShippingRequest.get(16)


== /shipit/myrequest ==

This is the only page that normal users have access to. Here they can make new
requests, change/cancel existing ones and see the previous one that were
shipped already.

When making a new request, users have to chose the number of CDs from a set of
predefined options. These options are stored on the StandardShipItRequest
table, and if we don't have a single option in the database, it doesn't make
sense to allow people to use shipit to make new requests, so we'll say that
shipit is closed, in case we don't find any StandardShipItRequest. This can
also be overused to close shipit through the web UI, by simply removing all
StandardShipItRequests.

    >>> from canonical.launchpad.ftests import login
    >>> login('test@canonical.com')
    >>> from canonical.launchpad.systemhomes import ShipItApplication
    >>> shipit = ShipItApplication()
    >>> myrequest_view = create_view(
    ...     shipit, 'myrequest', layer=ShipItUbuntuLayer)
    >>> myrequest_view.is_open = False
    >>> html = myrequest_view.renderStandardrequestForm()
    >>> from BeautifulSoup import BeautifulSoup
    >>> print BeautifulSoup(html).findAll('h1')[-1].renderContents()
    ShipIt is currently closed

    >>> myrequest_view.is_open = True
    >>> html = myrequest_view.renderStandardrequestForm()
    >>> headers = BeautifulSoup(html).findAll('h1')
    >>> 'ShipIt is currently closed' in headers
    False


== /shipit/requests/$request.id ==

This is the page where shipit admins go to approve, deny or change an existing
request.

In this page we display a table of Flavours X Architectures, containing the
widgets for the quantities of requested CDs of a given flavour and arch. These
widgets must always be ordered according to the order we use in the table
headers, or we'll start shipping wrong CDs to people. This order is specified
by the ordered_flavours and ordered_architectures attributes of the view
class.

    >>> review_request_view = create_view(
    ...     jordis_request, '+edit', layer=ShipItUbuntuLayer)
    >>> [flavour.title for flavour in review_request_view.ordered_flavours]
    ['Ubuntu', 'Kubuntu', 'Edubuntu', 'Ubuntu Server Edition']

    >>> [arch.title for arch in review_request_view.ordered_architectures]
    ['PC', '64-bit PC']

And this is the order we use when generating the widgets matrix.

    >>> matrix = review_request_view.widgetsMatrixWithFlavours()
    >>> for row in matrix:
    ...     newrow = []
    ...     for cell in row:
    ...         if isinstance(cell, basestring) or cell is None:
    ...             newrow.append(cell)
    ...         else:
    ...             newrow.append(cell.label)
    ...     print newrow
    ['Ubuntu', u'PC', u'64-bit PC']
    ['Kubuntu', u'PC', u'64-bit PC']
    ['Edubuntu', u'PC', None]
    ['Ubuntu Server Edition', u'PC', u'64-bit PC']

Similarly to the quantity widgets, we use a table to display the quantities
requested by the user. But in this case, the shipit admins are not supposed to
change these values, so we don't need widgets.

    >>> for row in review_request_view.quantities_matrix:
    ...     print row
    ['Kubuntu', 5, 0]
    ['Edubuntu', 5, 0]


If the request we're looking at is already approved, we use the approved
quantities as initial values for the widgets. Otherwise we use the requested
quantities as initial values, so that the shipit admin approving the request
don't have to type all the requested quantities in the approved quantities
widgets.

    >>> review_request_view.context.isApproved()
    True
    >>> review_request_view.initial_values
    {'highpriority': True, 'kubuntu_quantityamd64approved': 0,
     'ubuntu_quantityx86approved': 0, 'kubuntu_quantityx86approved': 5,
     'edubuntu_quantityx86approved': 5, 'ubuntu_quantityamd64approved': 0,
     'server_quantityamd64approved': 0, 'server_quantityx86approved': 0}

    >>> pending_approval_request = ShippingRequest.get(12)
    >>> review_request_view = create_view(
    ...     pending_approval_request, '+edit', layer=ShipItUbuntuLayer)
    >>> review_request_view.context.isApproved()
    False

    >>> for row in review_request_view.quantities_matrix:
    ...     print row
    ['Ubuntu', 10, 0]

    >>> review_request_view.initial_values
    {'highpriority': False, 'kubuntu_quantityamd64approved': 0,
     'ubuntu_quantityx86approved': 10, 'kubuntu_quantityx86approved': 0,
     'edubuntu_quantityx86approved': 0, 'ubuntu_quantityamd64approved': 0,
     'server_quantityamd64approved': 0, 'server_quantityx86approved': 0}


== Hardy-specific changes ==

Although Hardy is an LTS release it has been decided that Kubuntu Hardy
will not be LTS, so we need a small hack to make sure we don't say
"8.04 LTS" when talking about Kubuntu in the same way we do when talking
about Ubuntu/Edubuntu.

The simplest way to do so is by storing a modified HARDY item from
ShipItDistroSeries in the views that render public pages.

    >>> view = create_view(shipit, '+index', layer=ShipItUbuntuLayer)
    >>> view.initialize()
    >>> view.series.title
    '8.04 LTS (Hardy Heron)'
    >>> create_view(shipit, 'login', layer=ShipItUbuntuLayer).series.title
    '8.04 LTS (Hardy Heron)'
    >>> create_view(
    ...     shipit, 'myrequest', layer=ShipItUbuntuLayer).series.title
    '8.04 LTS (Hardy Heron)'

    >>> view = create_view(shipit, '+index', layer=ShipItKUbuntuLayer)
    >>> view.initialize()
    >>> view.series.title
    '8.04 (Hardy Heron)'
    >>> create_view(shipit, 'login', layer=ShipItKUbuntuLayer).series.title
    '8.04 (Hardy Heron)'
    >>> create_view(
    ...     shipit, 'myrequest', layer=ShipItKUbuntuLayer).series.title
    '8.04 (Hardy Heron)'

