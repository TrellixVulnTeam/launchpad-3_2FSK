TranslationImportQueueEntry
===========================

The TranslationImportQueueEntry is an entry of the queue that will be imported
into Rosetta.

getGuessedPOFile
------------------

This property gives us the IPOFile where we think we should import this entry.

To test it, we need to add an entry to the queue.

Here we have some imports and utility fetch.

    >>> import transaction
    >>> from zope.component import getUtility
    >>> from canonical.database.sqlbase import flush_database_updates
    >>> from canonical.launchpad.interfaces import ITranslationImportQueue
    >>> from canonical.launchpad.interfaces import ILaunchpadCelebrities
    >>> from canonical.launchpad.database import ProductSeries
    >>> from canonical.launchpad.database import DistroRelease
    >>> from canonical.launchpad.database import SourcePackageName
    >>> from canonical.launchpad.ftests import login
    >>> from canonical.lp.dbschema import RosettaImportStatus
    >>> translationimportqueue = getUtility(ITranslationImportQueue)
    >>> rosetta_expert = getUtility(ILaunchpadCelebrities).rosetta_expert

First, we are going to try to do the guess against the Evolution product. That
means that we are going to use the ProductSeries.id = 3

    >>> evolution_productseries = ProductSeries.get(3)

Attach the file to the product series, without associate it with any potemplate.

    >>> entry = translationimportqueue.addOrUpdateEntry(
    ...     'po/sr.po', 'foo', True, rosetta_expert,
    ...      productseries=evolution_productseries)

This entry has no information about the IPOFile where it should be attached to:

    >>> entry.import_into == None
    True

And the guessing algorithm will not be able to guess anything as there is no
IPOFiles on the same path and we have two IPOTemplates on the same path where
this IPOFile is located ('po/')

    >>> entry.getGuessedPOFile() == None
    True

Now let's try the same against the evolution sourcepackage that only has an
IPOTemplate.

    >>> hoary_distrorelease = DistroRelease.get(3)
    >>> evolution_sourcepackagename = SourcePackageName.get(9)
    >>> entry = translationimportqueue.addOrUpdateEntry(
    ...     'po/sr.po', 'foo', True, rosetta_expert,
    ...      distrorelease=hoary_distrorelease,
    ...      sourcepackagename=evolution_sourcepackagename)
    >>> transaction.commit()

This entry has no information about the IPOFile where it should be attached to:

    >>> entry.import_into == None
    True

And the guessing algorithm is able to give us an IPOFile where it should be
imported.

    >>> entry.getGuessedPOFile() == None
    False

    >>> entry.getGuessedPOFile().title
    u'Serbian (sr) translation of evolution-2.2 in Ubuntu Hoary package "evolution"'


Let's try now to update the entries.

We need to know the status that the entry has.

    >>> entry.status.title
    'Needs Review'

And store current creation and status change date:

    >>> previous_dateimported = entry.dateimported
    >>> previous_date_status_changed = entry.date_status_changed

Now, we do a new upload.

    >>> entry = translationimportqueue.addOrUpdateEntry(
    ...     'po/sr.po', 'foo', True, rosetta_expert,
    ...      distrorelease=hoary_distrorelease,
    ...      sourcepackagename=evolution_sourcepackagename)
    >>> transaction.commit()

And the new status is

    >>> entry.status.title
    'Needs Review'

The dateimported remains the same as it was already waiting to be imported.

    >>> entry.dateimported == previous_dateimported
    True

And the date_status_changed is newer

    >>> entry.date_status_changed > previous_date_status_changed
    True

Let's change now its status to imported and see what happens. To do it,
we need to be logged in as an admin.

    >>> login('carlos@canonical.com')
    >>> entry.status = RosettaImportStatus.IMPORTED

Need to update our saved date_status_changed to detect if it changes now.

    >>> previous_date_status_changed = entry.date_status_changed

Do the new upload.

    >>> po_sr_entry = translationimportqueue.addOrUpdateEntry(
    ...     'po/sr.po', 'foo', True, rosetta_expert,
    ...      distrorelease=hoary_distrorelease,
    ...      sourcepackagename=evolution_sourcepackagename)

And the new status is

    >>> po_sr_entry.status.title
    'Needs Review'

The dateimported remains the same as it was already waiting to be imported.

    >>> po_sr_entry.dateimported > previous_dateimported
    True

And the date_status_changed is newer

    >>> po_sr_entry.date_status_changed > previous_date_status_changed
    True

First, we import a new .pot file.

    >>> pot_entry = translationimportqueue.addOrUpdateEntry(
    ...     'po/evolution-2.2.pot', 'foo', True, rosetta_expert,
    ...      distrorelease=hoary_distrorelease,
    ...      sourcepackagename=evolution_sourcepackagename)

Reset any pofile/potemplate information we have for the po_sr_entry.

    >>> po_sr_entry.potemplate = None

Change the pofile.path value

    >>> pofile = po_sr_entry.getGuessedPOFile()
    >>> if pofile is not None:
    ...     pofile.path = u'po/sr-old.po'

XXX: CarlosPerelloMarin 20060331 If flush_database_updates is removed from
here we don't see the pofile.path change and the internal code path that we
want to check here doesn't work. For more information, see bug #3989

    >>> flush_database_updates()
    >>> transaction.commit()

Now, let's check that we cannot find the pot_entry as a POTemplate because
the way our code works, we cannot guess it while we have a .pot file pending
to be imported.

    >>> pot_entry.status.title
    'Needs Review'
    >>> po_sr_entry.getGuessedPOFile() is not None
    False

But if that entry is imported, the guessing algorithm works.

    >>> pot_entry.status = RosettaImportStatus.IMPORTED
    >>> po_sr_entry.getGuessedPOFile() is not None
    True

getGuessedPOFile with KDE
-------------------------

Official KDE packages have a non standard layout where the .pot files are
stored inside the sourcepackage with the binaries that will use it and the
translations are stored in external packages following the same language pack
ideas that we use with Ubuntu. This layout breaks completely Rosetta because
we don't have a way to link the .po and .pot files coming from different
packages. For this case, we use some extra information to get that link
between different sourcepackages.

The info we use is:
    - The sourcepackagename: All KDE language packs have
      the sourcepackagename following this pattern:
      kde-i18n-LANGCODE. We get from here the language where the .po
      files belong.
    - The .po filename: All .po files are stored using the translation
      domain as its filename. This information helps us to get the
      IPOTemplate where we should associate this .po file.

To do this test, we are going to do all in a single transaction and will
rollback it when it's finished.

First, we are going to add three new sourcepackagenames for this test,
kdebase, kde-i18n-es and kde-i18n-srlatn. The first is from where the .pot
file come and the others have .po files.

    >>> from canonical.launchpad.interfaces import ISourcePackageNameSet
    >>> sourcepackagenameset = getUtility(ISourcePackageNameSet)
    >>> kdebase = sourcepackagenameset.new('kdebase')
    >>> kde_i18n_es = sourcepackagenameset.new('kde-i18n-es')
    >>> kde_i18n_srlatn = sourcepackagenameset.new('kde-i18n-srlatn')

Let's attach the .pot file

    >>> kde_pot_entry = translationimportqueue.addOrUpdateEntry(
    ...     'po/kdebugdialog.pot', 'foo content', True, rosetta_expert,
    ...      distrorelease=hoary_distrorelease,
    ...      sourcepackagename=kdebase)

Create the template name and attach this new import to it.

    >>> from canonical.launchpad.interfaces import IPOTemplateNameSet
    >>> from canonical.launchpad.interfaces import IPOTemplateSet
    >>> potemplatenameset = getUtility(IPOTemplateNameSet)
    >>> kdebugdialog_template_name = potemplatenameset.new(
    ...     'kdebugdialog', 'kdebugdialog')
    >>> potemplateset = getUtility(IPOTemplateSet)
    >>> subset = potemplateset.getSubset(
    ...     distrorelease=hoary_distrorelease, sourcepackagename=kdebase)
    >>> kde_pot_entry.potemplate = subset.new(
    ...     kdebugdialog_template_name, 'po/kdebugdialog.pot', rosetta_expert)
    >>> kde_pot_entry.potemplate.title
    u'Template "kdebugdialog" in Ubuntu Hoary package "kdebase"'

And set this entry as already imported.

    >>> kde_pot_entry.status = RosettaImportStatus.IMPORTED
    >>> flush_database_updates()

Let's attach a .po file from kde-i18n-es

    >>> es_entry = translationimportqueue.addOrUpdateEntry(
    ...     'messages/kdebase/kdebugdialog.po', 'foo content', True,
    ...     rosetta_expert, distrorelease=hoary_distrorelease,
    ...      sourcepackagename=kde_i18n_es)

And we will get the right IPOFile.

    >>> es_entry.getGuessedPOFile().title
    u'Spanish (es) translation of kdebugdialog in Ubuntu Hoary package "kdebase"'

The kde-i18n-srlatn is a bit special, the language is sr@Latn and we should be
able to know that.

    >>> srlatn_entry = translationimportqueue.addOrUpdateEntry(
    ...     'messages/kdebase/kdebugdialog.po', 'foo content', True,
    ...     rosetta_expert, distrorelease=hoary_distrorelease,
    ...      sourcepackagename=kde_i18n_srlatn)

And we will get the right IPOFile.

    >>> srlatn_entry.getGuessedPOFile().title
    u'Serbian (sr) translation of kdebugdialog in Ubuntu Hoary package "kdebase"'
    >>> srlatn_entry.getGuessedPOFile().variant
    u'Latn'

Now, we are going to see what happens if we get a .po file for a template
that is not yet imported.

    >>> es_without_potemplate_entry = translationimportqueue.addOrUpdateEntry(
    ...     'messages/kdebase/konqueror.po', 'foo content', True,
    ...     rosetta_expert, distrorelease=hoary_distrorelease,
    ...      sourcepackagename=kde_i18n_es)

We don't know the IPOFile where it should be imported.

    >>> es_without_potemplate_entry.getGuessedPOFile() is None
    True

Sometimes, a translation domain is not following the restrictions we have for
name fields, and thus, we need to be sure that we look for KDE .pot files
using the translation domain instead the name.

We will see it working here with this example:

    >>> kde_pot_entry = translationimportqueue.addOrUpdateEntry(
    ...     'po/kio_sftp.pot', 'foo content', True, rosetta_expert,
    ...      distrorelease=hoary_distrorelease,
    ...      sourcepackagename=kdebase)

Create the template name and attach this new import to it.

    >>> from canonical.launchpad.interfaces import IPOTemplateNameSet
    >>> from canonical.launchpad.interfaces import IPOTemplateSet
    >>> potemplatenameset = getUtility(IPOTemplateNameSet)
    >>> kdebugdialog_template_name = potemplatenameset.new(
    ...     'kio_sftp', 'kio_sftp')
    >>> potemplateset = getUtility(IPOTemplateSet)
    >>> subset = potemplateset.getSubset(
    ...     distrorelease=hoary_distrorelease, sourcepackagename=kdebase)
    >>> kde_pot_entry.potemplate = subset.new(
    ...     kdebugdialog_template_name, 'po/kio_sftp.pot', rosetta_expert)
    >>> kde_pot_entry.potemplate.title
    u'Template "kio-sftp" in Ubuntu Hoary package "kdebase"'

And set this entry as already imported.

    >>> kde_pot_entry.status = RosettaImportStatus.IMPORTED
    >>> flush_database_updates()

Let's attach a .po file from kde-i18n-es

    >>> es_entry = translationimportqueue.addOrUpdateEntry(
    ...     'messages/kdebase/kio_sftp.po', 'foo content', True,
    ...     rosetta_expert, distrorelease=hoary_distrorelease,
    ...      sourcepackagename=kde_i18n_es)

And we will get the right IPOFile.

    >>> es_entry.getGuessedPOFile().title
    u'Spanish (es) translation of kio-sftp in Ubuntu Hoary package "kdebase"'

Finally, we abort the transaction to undo all changes done.

    >>> transaction.abort()


getGuessedPOFile with KOffice
-----------------------------

Like official KDE packages, KOffice stores the .pot and .po files in different
packages, the only difference it has is that there is just one source package
and the language information is stored as part of the path, but hidden with
more text. The source package with translations is koffice-l10n, and
the layout is:

koffice-i18n-LANGCODE-VERSION/messages/koffice/TRANSLATIONDOMAIN.po

To do this test, we are going to do all in a single transaction and will
rollback it when it's finished.

First, we are going to add two new sourcepackagenames for this test,
koffice and koffice-l10n. The first is from where the .pot
file come and the other for the .po files.

    >>> from canonical.launchpad.interfaces import ISourcePackageNameSet
    >>> sourcepackagenameset = getUtility(ISourcePackageNameSet)
    >>> koffice = sourcepackagenameset.new('koffice')
    >>> koffice_l10n = sourcepackagenameset.new('koffice-l10n')

Let's attach the .pot file

    >>> koffice_pot_entry = translationimportqueue.addOrUpdateEntry(
    ...     'po/koffice.pot', 'foo content', True, rosetta_expert,
    ...      distrorelease=hoary_distrorelease,
    ...      sourcepackagename=koffice)

Create the template name and attach this new import to it.

    >>> koffice_template_name = potemplatenameset.new(
    ...     'koffice', 'koffice')
    >>> potemplateset = getUtility(IPOTemplateSet)
    >>> subset = potemplateset.getSubset(
    ...     distrorelease=hoary_distrorelease, sourcepackagename=koffice)
    >>> koffice_pot_entry.potemplate = subset.new(
    ...     koffice_template_name, 'po/koffice.pot', rosetta_expert)
    >>> koffice_pot_entry.potemplate.title
    u'Template "koffice" in Ubuntu Hoary package "koffice"'

And set this entry as already imported.

    >>> koffice_pot_entry.status = RosettaImportStatus.IMPORTED
    >>> flush_database_updates()

Let's attach a .po file from koffice-l10n

    >>> es_entry = translationimportqueue.addOrUpdateEntry(
    ...     'koffice-i18n-es-1.5.2/messages/koffice/koffice.po',
    ...     'foo content', True, rosetta_expert,
    ...     distrorelease=hoary_distrorelease, sourcepackagename=koffice_l10n)

And we will get the right IPOFile.

    >>> es_entry.getGuessedPOFile().title
    u'Spanish (es) translation of koffice in Ubuntu Hoary package "koffice"'

Let's try now a language with variant information like sr@Latn.

    >>> srlatn_entry = translationimportqueue.addOrUpdateEntry(
    ...     'koffice-i18n-sr@Latn-1.5.2/messages/koffice/koffice.po',
    ...     'foo content', True, rosetta_expert,
    ...     distrorelease=hoary_distrorelease, sourcepackagename=koffice_l10n)

And we will get the right IPOFile.

    >>> srlatn_entry.getGuessedPOFile().title
    u'Serbian (sr) translation of koffice in Ubuntu Hoary package "koffice"'
    >>> srlatn_entry.getGuessedPOFile().variant
    u'Latn'

Now, we are going to see what happens if we get a .po file for a template
that is not yet imported.

    >>> es_without_potemplate_entry = translationimportqueue.addOrUpdateEntry(
    ...     'koffice-i18n-es-1.5.2/messages/koffice/kchart.po',
    ...     'foo content', True, rosetta_expert,
    ...     distrorelease=hoary_distrorelease, sourcepackagename=koffice_l10n)

We don't know the IPOFile where it should be imported.

    >>> es_without_potemplate_entry.getGuessedPOFile() is None
    True

Finally, we abort the transaction to undo all changes done.

    >>> transaction.abort()


getGuessedPOFile with .po files in different directories
--------------------------------------------------------

Some packages have translations and templates inside the same package, but
they don't have them inside the same directory. The layout is:

DIRECTORY/TRANSLATION_DOMAIN.pot
DIRECTORY/LANG_CODE/TRANSLATION_DOMAIN.po

sometimes the layout changes a bit, for instance in ktorrent, and looks like:

DIRECTORY/TRANSLATION_DOMAIN.pot
DIRECTORY/LANG_CODE/messages/TRANSLATION_DOMAIN.po

Or in the zope packages:

DIRECTORY/TRANSLATION_DOMAIN.pot
DIRECTORY/LANG_CODE/LC_MESSAGES/TRANSLATION_DOMAIN.po

We have also packages like k3b that has its translations in its own k3b-i18n
package, but with a layout quite similar to the ones here:

LANG_CODE/messages/TRANSLATION_DOMAIN.po

Also, there is the layout used with GNOME documentation:

DIRECTORY/help/TRANSLATION_DOMAIN.pot
DIRECTORY/help/LANG_CODE/LANG_CODE.po

Let's test every know layout. For the first one, we create an adept
sourcepackagename to test that layout.

    >>> adept = sourcepackagenameset.new('adept')

Let's attach the .pot file

    >>> adept_pot_entry = translationimportqueue.addOrUpdateEntry(
    ...     'po/adept.pot', 'foo content', True, rosetta_expert,
    ...      distrorelease=hoary_distrorelease,
    ...      sourcepackagename=adept)

Create the template name and attach this new import to it.

    >>> adept_template_name = potemplatenameset.new(
    ...     'adept', 'adept')
    >>> subset = potemplateset.getSubset(
    ...     distrorelease=hoary_distrorelease, sourcepackagename=adept)
    >>> adept_pot_entry.potemplate = subset.new(
    ...     adept_template_name, 'po/adept.pot', rosetta_expert)
    >>> adept_pot_entry.potemplate.title
    u'Template "adept" in Ubuntu Hoary package "adept"'

And set this entry as already imported.

    >>> adept_pot_entry.status = RosettaImportStatus.IMPORTED
    >>> flush_database_updates()

Let's attach a .po file now.

    >>> es_entry = translationimportqueue.addOrUpdateEntry(
    ...     'po/es/adept.po', 'foo content', True,
    ...     rosetta_expert, distrorelease=hoary_distrorelease,
    ...      sourcepackagename=adept)

And we will get the right IPOFile.

    >>> es_entry.getGuessedPOFile().title
    u'Spanish (es) translation of adept in Ubuntu Hoary package "adept"'

Now, we are going to see what happens if we get a .po file for a template
that is not yet imported.

    >>> es_without_potemplate_entry = translationimportqueue.addOrUpdateEntry(
    ...     'po/es/adept-foo.po', 'foo content', True,
    ...     rosetta_expert, distrorelease=hoary_distrorelease,
    ...      sourcepackagename=adept)

We don't know the IPOFile where it should be imported.

    >>> es_without_potemplate_entry.getGuessedPOFile() is None
    True

Let's move to the second case, to test it, we create a ktorrent
sourcepackagename and test that layout.

    >>> ktorrent = sourcepackagenameset.new('ktorrent')

Let's attach the .pot file

    >>> ktorrent_pot_entry = translationimportqueue.addOrUpdateEntry(
    ...     'po/ktorrent.pot', 'foo content', True, rosetta_expert,
    ...      distrorelease=hoary_distrorelease,
    ...      sourcepackagename=ktorrent)

Create the template name and attach this new import to it.

    >>> ktorrent_template_name = potemplatenameset.new(
    ...     'ktorrent', 'ktorrent')
    >>> subset = potemplateset.getSubset(
    ...     distrorelease=hoary_distrorelease, sourcepackagename=ktorrent)
    >>> ktorrent_pot_entry.potemplate = subset.new(
    ...     ktorrent_template_name, 'po/ktorrent.pot', rosetta_expert)
    >>> ktorrent_pot_entry.potemplate.title
    u'Template "ktorrent" in Ubuntu Hoary package "ktorrent"'

And set this entry as already imported.

    >>> ktorrent_pot_entry.status = RosettaImportStatus.IMPORTED
    >>> flush_database_updates()

Let's attach a .po file now.

    >>> es_entry = translationimportqueue.addOrUpdateEntry(
    ...     'translations/es/messages/ktorrent.po', 'foo content', True,
    ...     rosetta_expert, distrorelease=hoary_distrorelease,
    ...      sourcepackagename=ktorrent)

And we will get the right IPOFile.

    >>> es_entry.getGuessedPOFile().title
    u'Spanish (es) translation of ktorrent in Ubuntu Hoary package "ktorrent"'

Now, we are going to see what happens if we get a .po file for a template
that is not yet imported.

    >>> es_without_potemplate_entry = translationimportqueue.addOrUpdateEntry(
    ...     'translations/es/messages/ktorrent-foo.po', 'foo content', True,
    ...     rosetta_expert, distrorelease=hoary_distrorelease,
    ...      sourcepackagename=ktorrent)

We don't know the IPOFile where it should be imported.

    >>> es_without_potemplate_entry.getGuessedPOFile() is None
    True

Now, let's move to the third case, to test it, we create a zope
sourcepackagename and test that layout.

    >>> zope = sourcepackagenameset.new('zope')

Let's attach the .pot file

    >>> zope_pot_entry = translationimportqueue.addOrUpdateEntry(
    ...     'debian/zope3/usr/lib/python2.4/site-packages/zope/app/locales/zope.pot',
    ...     'foo content', True, rosetta_expert,
    ...     distrorelease=hoary_distrorelease, sourcepackagename=zope)

Create the template name and attach this new import to it.

    >>> zope_template_name = potemplatenameset.new(
    ...     'zope', 'zope')
    >>> subset = potemplateset.getSubset(
    ...     distrorelease=hoary_distrorelease, sourcepackagename=zope)
    >>> zope_pot_entry.potemplate = subset.new(
    ...     zope_template_name,
    ...     'debian/zope3/usr/lib/python2.4/site-packages/zope/app/locales/zope.pot',
    ...     rosetta_expert)
    >>> zope_pot_entry.potemplate.title
    u'Template "zope" in Ubuntu Hoary package "zope"'

And set this entry as already imported.

    >>> zope_pot_entry.status = RosettaImportStatus.IMPORTED
    >>> flush_database_updates()

Let's attach a .po file now.

    >>> es_entry = translationimportqueue.addOrUpdateEntry(
    ...     'debian/zope3/usr/lib/python2.4/site-packages/zope/app/locales/es/LC_MESSAGES/zope.po',
    ...     'foo content', True, rosetta_expert,
    ...     distrorelease=hoary_distrorelease, sourcepackagename=zope)

And we will get the right IPOFile.

    >>> es_entry.getGuessedPOFile().title
    u'Spanish (es) translation of zope in Ubuntu Hoary package "zope"'

Now, we are going to see what happens if we get a .po file for a template
that is not yet imported.

    >>> es_without_potemplate_entry = translationimportqueue.addOrUpdateEntry(
    ...     'debian/zope3/usr/lib/python2.4/site-packages/zope/app/locales/es/LC_MESSAGES/zope-test.po',
    ...     'foo content', True, rosetta_expert,
    ...     distrorelease=hoary_distrorelease, sourcepackagename=zope)

We don't know the IPOFile where it should be imported.

    >>> es_without_potemplate_entry.getGuessedPOFile() is None
    True

Now, let's move to the fourth case, to test it, we create a k3b
sourcepackagename from where the .pot file comes and a k3b-i18n one
from where the translations come.

    >>> k3b = sourcepackagenameset.new('k3b')
    >>> k3b_i18n = sourcepackagenameset.new('k3b-i18n')

Let's attach the .pot file

    >>> k3b_pot_entry = translationimportqueue.addOrUpdateEntry(
    ...     'po/k3b.pot', 'foo content', True, rosetta_expert,
    ...     distrorelease=hoary_distrorelease, sourcepackagename=k3b)

Create the template name and attach this new import to it.

    >>> k3b_template_name = potemplatenameset.new(
    ...     'k3b', 'k3b')
    >>> subset = potemplateset.getSubset(
    ...     distrorelease=hoary_distrorelease, sourcepackagename=k3b)
    >>> k3b_pot_entry.potemplate = subset.new(
    ...     k3b_template_name, 'po/k3b.pot', rosetta_expert)
    >>> k3b_pot_entry.potemplate.title
    u'Template "k3b" in Ubuntu Hoary package "k3b"'

And set this entry as already imported.

    >>> k3b_pot_entry.status = RosettaImportStatus.IMPORTED
    >>> flush_database_updates()

Let's attach a .po file now.

    >>> es_entry = translationimportqueue.addOrUpdateEntry(
    ...     'es/messages/k3b.po', 'foo content', True, rosetta_expert,
    ...     distrorelease=hoary_distrorelease, sourcepackagename=k3b_i18n)

And we will get the right IPOFile.

    >>> es_entry.getGuessedPOFile().title
    u'Spanish (es) translation of k3b in Ubuntu Hoary package "k3b"'

Now, we are going to see what happens if we get a .po file for a template
that is not yet imported.

    >>> es_without_potemplate_entry = translationimportqueue.addOrUpdateEntry(
    ...     'es/messages/libk3b.po', 'foo content', True, rosetta_expert,
    ...     distrorelease=hoary_distrorelease, sourcepackagename=k3b_i18n)

We don't know the IPOFile where it should be imported.

    >>> es_without_potemplate_entry.getGuessedPOFile() is None
    True

Finally, let's move to the last case, to test it, we create a gnome-terminal
sourcepackagename that will host the .pot and .po files.

    >>> gnome_terminal = sourcepackagenameset.new('gnome-terminal')

Let's attach the .pot file

    >>> terminal_pot_entry = translationimportqueue.addOrUpdateEntry(
    ...     'drivemount/help/drivemount.pot', 'foo content', True,
    ...     rosetta_expert, distrorelease=hoary_distrorelease,
    ...     sourcepackagename=gnome_terminal)

Create the template name and attach this new import to it.

    >>> gnome_terminal_template_name = potemplatenameset.new(
    ...     'help', 'help')
    >>> subset = potemplateset.getSubset(
    ...     distrorelease=hoary_distrorelease,
    ...     sourcepackagename=gnome_terminal)
    >>> terminal_pot_entry.potemplate = subset.new(
    ...     gnome_terminal_template_name,
    ...     'drivemount/help/drivemount.pot', rosetta_expert)
    >>> terminal_pot_entry.potemplate.title
    u'Template "help" in Ubuntu Hoary package "gnome-terminal"'

And set this entry as already imported.

    >>> k3b_pot_entry.status = RosettaImportStatus.IMPORTED
    >>> flush_database_updates()

Let's attach a .po file now.

    >>> es_entry = translationimportqueue.addOrUpdateEntry(
    ...     'drivemount/help/es/es.po', 'foo content', True, rosetta_expert,
    ...     distrorelease=hoary_distrorelease,
    ...     sourcepackagename=gnome_terminal)

And we will get the right IPOFile.

    >>> es_entry.getGuessedPOFile().title
    u'Spanish (es) translation of help in Ubuntu Hoary package "gnome-terminal"'

Now, we are going to see what happens if we get a .po file for a template
that is not yet imported.

    >>> es_without_potemplate_entry = translationimportqueue.addOrUpdateEntry(
    ...     'wanda/help/es/es.po', 'foo content', True, rosetta_expert,
    ...     distrorelease=hoary_distrorelease, sourcepackagename=gnome_terminal)

We don't know the IPOFile where it should be imported.

    >>> es_without_potemplate_entry.getGuessedPOFile() is None
    True


Finally, we abort the transaction to undo all changes done.

    >>> transaction.abort()


executeOptimisticBlock
---------------------

This method looks on the queue to find entries to block based on other .pot
entries that are stored on the same directory and are already blocked.

Check the number of entries on the queue.

    >>> translationimportqueue.entryCount()
    3

First, let's check the status of the existing entries.

    >>> entry1 = translationimportqueue.get(1)
    >>> entry1.path
    u'po/sr.po'
    >>> entry1.status == RosettaImportStatus.NEEDS_REVIEW
    True

    >>> entry2 = translationimportqueue.get(2)
    >>> entry2.path
    u'po/sr.po'
    >>> entry2.status == RosettaImportStatus.NEEDS_REVIEW
    True

    >>> entry3 = translationimportqueue.get(3)
    >>> entry3.path
    u'po/evolution-2.2.pot'

We need it blocked for this test.

    >>> entry3.status = RosettaImportStatus.BLOCKED

Let's see how many entries are blocked.

    >>> translationimportqueue.executeOptimisticBlock()
    1

Now is time to check that we only have one item on the NeedsReview status.

    >>> entry1 = translationimportqueue.get(1)
    >>> entry1.path
    u'po/sr.po'

This entry is form a productseries, and it's not blocked because the blocked
.pot entry is for a distrorelease-sourcepackagename.

    >>> entry1.status == RosettaImportStatus.NEEDS_REVIEW
    True

On the other hand, this other one is for the same
distrorelease/sourcepackagename than the .pot file we have so it's also blocked.

    >>> entry2 = translationimportqueue.get(2)
    >>> entry2.path
    u'po/sr.po'
    >>> entry2.status == RosettaImportStatus.BLOCKED
    True

And the .pot entry is still blocked.

    >>> entry3 = translationimportqueue.get(3)
    >>> entry3.path
    u'po/evolution-2.2.pot'
    >>> entry3.status == RosettaImportStatus.BLOCKED
    True


TranslationImportQueue
======================

The translation import queue is the place where the new translation imports
end before being imported into Rosetta.


getTemplatesOnSameDirectory
---------------------------

This method allows us to get the set of .pot files we have on the same
directory that a given entry.

For the first entry, we don't have any .pot file on that directory.

    >>> entry1.status = RosettaImportStatus.NEEDS_REVIEW
    >>> entries = entry1.getTemplatesOnSameDirectory()
    >>> entries.count()
    0

For the second entry, we have one.

    >>> entry2.status = RosettaImportStatus.NEEDS_REVIEW
    >>> entries = entry2.getTemplatesOnSameDirectory()
    >>> entries.count()
    1

Which is blocked.

    >>> entries[0].status == RosettaImportStatus.BLOCKED
    True

And finally, the .pot entry doesn't have other .pot in the same directory and
obviously, we are not returning it as being at the same directory as it makes
no sense at all.

    >>> entry3.status = RosettaImportStatus.NEEDS_REVIEW
    >>> entries = entry3.getTemplatesOnSameDirectory()
    >>> entries.count()
    0
