== SpecificationDepCandidatesVocabulary ==

All blueprints that can be added as a dependency of the context
blueprint.

First, we set up a product with three blueprints.

    >>> from canonical.launchpad.interfaces import (
    ...     ISpecificationSet, SpecificationDefinitionStatus)
    >>> from lp.registry.interfaces.product import IProductSet
    >>> product_set = getUtility(IProductSet)
    >>> evolution = product_set.getByName('evolution')
    >>> from zope.schema.vocabulary import getVocabularyRegistry
    >>> vocabulary_registry = getVocabularyRegistry()
    >>> from zope.security.proxy import removeSecurityProxy
    >>> vocabulary_registry = getVocabularyRegistry()
    >>> def get_naked_vocab(context, name):
    ...     return removeSecurityProxy(
    ...         vocabulary_registry.get(context, name))
    >>> foobar_person = factory.makePerson()
    >>> specset = getUtility(ISpecificationSet)
    >>> spec_a = factory.makeSpecification(
    ...     name='spec-a', summary='The first spec',
    ...     status=SpecificationDefinitionStatus.APPROVED, product=evolution)
    >>> spec_b = factory.makeSpecification(
    ...     name='spec-b', summary='The second spec',
    ...     status=SpecificationDefinitionStatus.APPROVED, product=evolution)
    >>> spec_c = factory.makeSpecification(
    ...     name='spec-c', summary='The third spec',
    ...     status=SpecificationDefinitionStatus.APPROVED, product=evolution)
    >>> sorted([spec.name for spec in evolution.specifications()])
    [u'spec-a', u'spec-b', u'spec-c']

The dependency candidates for spec_a are all blueprints for evolution
except for spec_a itself.

    >>> vocab = vocabulary_registry.get(
    ...     spec_a, "SpecificationDepCandidates")
    >>> sorted([term.value.name for term in vocab])
    [u'spec-b', u'spec-c']

Dependency candidate come only from the same product of the blueprint
they depend on.

    >>> unrelated_spec = factory.makeSpecification(
    ...     name='spec-c', summary='The third spec',
    ...     status=SpecificationDefinitionStatus.APPROVED, product=product_set.getByName('firefox'))
    >>> vocab = vocabulary_registry.get(
    ...     spec_a, "SpecificationDepCandidates")
    >>> unrelated_spec in vocab
    False
    >>> [term.value.product for term in vocab
    ...  if term.value.product != evolution]
    []

We mark spec_b as a dependency of spec_a and spec_c as a dependency of
spec_b.

    >>> spec_a.createDependency(spec_b)
    <SpecificationDependency at ...>
    >>> [spec.name for spec in spec_a.dependencies]
    [u'spec-b']

    >>> spec_b.createDependency(spec_c)
    <SpecificationDependency at ...>
    >>> [spec.name for spec in spec_b.dependencies]
    [u'spec-c']

No circular dependencies - the vocabulary excludes specifications that
are a dependency of the context spec.

    >>> spec_a in spec_b.all_blocked
    True
    >>> spec_b in spec_c.all_blocked
    True
    >>> vocab = vocabulary_registry.get(
    ...     spec_c, "SpecificationDepCandidates")
    >>> spec_a in [term.value for term in vocab]
    False

This vocabulary provides the IHugeVocabulary interface.

    >>> from canonical.launchpad.webapp.testing import verifyObject
    >>> from canonical.launchpad.webapp.vocabulary import IHugeVocabulary
    >>> verifyObject(IHugeVocabulary, vocab)
    True

The search() method returns specifications within the vocabulary that
matches the search string. The string is matched against the name, or
fallbacks to a full text search.

    >>> vocab = get_naked_vocab(spec_a, "SpecificationDepCandidates")
    >>> list(vocab.search('spec-b')) == [spec_b]
    True
    >>> list(vocab.search('third')) == [spec_c]
    True

The search method uses the SQL `LIKE` operator, with the values quoted
appropriately. Queries conataining regual expression operators, for
example, will simply look for the respective characters within the
vocabulary's item (this used to be the cause of an OOPS, see
https://bugs.edge.launchpad.net/blueprint/+bug/139385 for more
details).

    >>> list(vocab.search('*'))
    []
