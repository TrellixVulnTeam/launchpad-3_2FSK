= Filebug Data Parser =

An application like Apport can upload data to Launchpad, and have the
information added to the bug report that the user will file. The
information is uploaded as a MIME multipart message, where the different
headers tells Launchpad what kind of information it is.

== FileBugDataParser Internals ==

FileBugDataParser is used to parse the MIME message with the information
to be added to the bug report. The information is passed as a file
object to the constructor.

    >>> from StringIO import StringIO
    >>> from canonical.launchpad.browser.bugtarget import FileBugDataParser
    >>> parser = FileBugDataParser(StringIO('123456789'))

To make parsing easier and more efficient, it has a buffer where it
stores the next few bytes of the file. To begin with, it's empty.

    >>> parser._buffer
    ''

Whenever it needs to read some bytes of the file, it will read a fixed
number of bytes into the buffer. The number of bytes is specified by the
BUFFER_SIZE variable.

    >>> parser.BUFFER_SIZE = 3

There a helper method, _consumeBytes(), which will read from the file
until a certain delimiter string is encountered.

    >>> parser._consumeBytes('4')
    '123'

In order to find the delimiter string, it had to read '123456' into
the buffer. The delimiter string is discarded, but the rest of the
string is kept in the buffer.

    >>> parser._buffer
    '56'

The delimiter string isn't limited to one character.

    >>> parser._consumeBytes('67')
    '5'

    >>> parser._buffer
    '89'

If the delimiter isn't found in the file, the rest of the file is
returned.

    >>> parser._consumeBytes('0')
    '89'
    >>> parser._buffer
    ''


=== readLine() ===

readLine() is a helper method to read a single line of the file. It
makes sure that the returned line ends with \n.

    >>> parser = FileBugDataParser(StringIO('123\n456\n789'))
    >>> parser.readLine()
    '123\n'
    >>> parser.readLine()
    '456\n'
    >>> parser.readLine()
    '789\n'


=== readHeaders() ====

readHeaders() reads the headers of a MIME message. It reads all the
headers, untils it sees a blank line.

    >>> msg = """Header: value
    ... Space-Folded-Header: this header
    ...  is folded with a space.
    ... Tab-Folded-Header: this header
    ... \tis folded with a tab.
    ... Another-header: another-value
    ...
    ... Not-A-Header: not-a-value
    ... """
    >>> parser = FileBugDataParser(StringIO(msg))
    >>> headers = parser.readHeaders()
    >>> headers['Header']
    'value'
    >>> headers['Space-Folded-Header']
    'this header\n is folded with a space.'
    >>> headers['Tab-Folded-Header']
    'this header\n\tis folded with a tab.'
    >>> headers['Another-Header']
    'another-value'
    >>> 'Not-A-Header' in headers
    False


== Parsing the data ==

The parse() method returns a FileBugData object, with the information
from the message as attributes.


=== Headers ===

The headers are processed by the _setDataFromHeaders() method. It
accepts a FileBugData object and a dictionary of the headers.


==== Subject ====

The Subject header is available in the initial_summary attribute.

    >>> from canonical.launchpad.browser.bugtarget import FileBugData
    >>> data = FileBugData()
    >>> parser = FileBugDataParser(None)
    >>> parser._setDataFromHeaders(data, {'Subject': 'Bug Subject'})
    >>> data.initial_summary
    u'Bug Subject'


==== Tags ====

The Tags headers is translated into a list of strings as the
initial_tags attributes. The tags are translated to lower case
automatically.

    >>> data = FileBugData()
    >>> parser._setDataFromHeaders(data, {'Tags': 'Tag-One Tag-Two'})
    >>> sorted(data.initial_tags)
    [u'tag-one', u'tag-two']


==== Private ====

The Private header gets translated into a boolean, as the private
attribute. The values "yes" and "no" are accepted, which get translated
into True and False.

    >>> data = FileBugData()
    >>> parser._setDataFromHeaders(data, {'Private': 'yes'})
    >>> data.private
    True
    >>> data = FileBugData()
    >>> parser._setDataFromHeaders(data, {'Private': 'no'})
    >>> data.private
    False

We're in no position of presenting a good error message to the user at
this point, so invalid values get ignored.

    >>> data = FileBugData()
    >>> parser._setDataFromHeaders(data, {'Private': 'not-valid'})
    >>> print data.private
    None


==== Subscribers ====

The Subscribers header is turned into a list of strings, available
through the subscribers attribute. The strings get lowercased
automatically.

    >>> data = FileBugData()
    >>> parser._setDataFromHeaders(data, {'Subscribers': 'sub-one SUB-TWO'})
    >>> sorted(data.subscribers)
    [u'sub-one', u'sub-two']


=== Message Parts ===

Different parts of the message gets treated differently. In short, we
look at the Content-Disposition header. If it's inline, it's a comment,
if it's attachment, it's an attachment.


==== Inline parts ====

The first inline part is special. Instead of being treated as a comment,
it gets appended to the bug description. It's available through the
extra_description attribute.

    >>> debug_data = """MIME-Version: 1.0 
    ... Content-type: multipart/mixed; boundary=boundary
    ...
    ... --boundary
    ... Content-disposition: inline
    ... Content-type: text/plain; charset=utf-8
    ...
    ... This should be added to the description.
    ...
    ... Another line.
    ...
    ... --boundary--
    ... """
    >>> parser = FileBugDataParser(StringIO(debug_data))
    >>> data = parser.parse()
    >>> data.extra_description
    u'This should be added to the description.\n\nAnother line.'



=== Other inline parts ===

If there are more than one inline part, those will be added as comments
to the bug.

    >>> debug_data = """MIME-Version: 1.0 
    ... Content-type: multipart/mixed; boundary=boundary
    ...
    ... --boundary
    ... Content-disposition: inline
    ... Content-type: text/plain; charset=utf-8
    ...
    ... This should be added to the description.
    ...
    ... --boundary
    ... Content-disposition: inline
    ... Content-type: text/plain; charset=utf-8
    ...
    ... This should be added as a comment.
    ...
    ... --boundary
    ... Content-disposition: inline
    ... Content-type: text/plain; charset=utf-8
    ...
    ... This should be added as another comment.
    ...
    ... --boundary--
    ... """
    >>> token = getUtility(ITemporaryStorageManager).new(debug_data)
    >>> transaction.commit()

    >>> request = LaunchpadTestRequest()
    >>> filebug_view = create_view(ubuntu_firefox, request)
    >>> filebug_view.publishTraverse(request, token) is filebug_view
    True
    >>> filebug_view.validate(bug_data) is None
    True
    >>> filebug_view.submit_bug_action.success(bug_data)

    >>> filebug_view.added_bug.title
    u'Test Title'
    >>> print filebug_view.added_bug.description #doctest: -NORMALIZE_WHITESPACE
    Test description.
    <BLANKLINE>
    This should be added to the description.

    >>> for comment in filebug_view.added_bug.messages[1:]:
    ...     print "Comment by %s: %s" % (
    ...         comment.owner.displayname, comment.text_contents)
    Comment by No Privileges Person: This should be added as a comment.
    Comment by No Privileges Person: This should be added as another comment.

Notifications were added to inform the user about what happened.

    >>> for notification in filebug_view.request.response.notifications:
    ...     print notification.message
    Thank you for your bug report.
    Additional information was added to the bug description.
    A comment with additional information was added to the bug report.
    A comment with additional information was added to the bug report.

=== Attachments ===

All the parts that have a 'Content-disposition: attachment' header
will get added as attachments to the bug. The attachment description can
be specified using a Content-description header, but it's not required.

    >>> debug_data = """MIME-Version: 1.0 
    ... Content-type: multipart/mixed; boundary=boundary
    ...
    ... --boundary
    ... Content-disposition: attachment; filename='attachment1'
    ... Content-type: text/plain; charset=utf-8
    ...
    ... This is an attachment.
    ...
    ... --boundary
    ... Content-disposition: attachment; filename='attachment2'
    ... Content-description: Attachment description.
    ... Content-type: text/plain; charset=ISO-8859-1
    ...
    ... This is another attachment, with a description.
    ...
    ... --boundary--
    ... """
    >>> token = getUtility(ITemporaryStorageManager).new(debug_data)
    >>> transaction.commit()

    >>> request = LaunchpadTestRequest()
    >>> filebug_view = create_view(ubuntu_firefox, request)
    >>> filebug_view.publishTraverse(request, token) is filebug_view
    True
    >>> filebug_view.validate(bug_data) is None
    True
    >>> filebug_view.submit_bug_action.success(bug_data)

Since the attachments are stored in the Librarian, we need to commit the
transaction in order to access them.

    >>> transaction.commit()

    >>> filebug_view.added_bug.title
    u'Test Title'
    >>> print filebug_view.added_bug.description
    Test description.

The attachments got added, with the charsets preserved, and the one that
didn't specify a description got an autogenerated one.

    >>> for attachment in filebug_view.added_bug.attachments:
    ...     print "Filename: %s" % attachment.libraryfile.filename
    ...     print "Content type: %s" % attachment.libraryfile.mimetype
    ...     print "Description: %s" % attachment.title
    ...     print "Contents:\n%s" % attachment.libraryfile.read()
    ...     print
    Filename: attachment1
    Content type: text/plain; charset=utf-8
    Description: attachment1
    Contents:
    This is an attachment.
    <BLANKLINE>
    Filename: attachment2
    Content type: text/plain; charset=ISO-8859-1
    Description: Attachment description.
    Contents:
    This is another attachment, with a description.
    <BLANKLINE>

Notifications were added to inform the user about what happened.

    >>> for notification in filebug_view.request.response.notifications:
    ...     print notification.message
    Thank you for your bug report.
    The file "attachment1" was attached to the bug report.
    The file "attachment2" was attached to the bug report.

The attachments are all added to the same comment.

    >>> for comment in filebug_view.added_bug.messages[1:]:
    ...     print "Comment by %s: %s attachment(s)" % (
    ...         comment.owner.displayname, comment.bugattachments.count())
    Comment by No Privileges Person: 2 attachment(s)

=== Private Bugs ===

We can specify whether a bug is private by providing Private field in the
message.

    >>> debug_data = """MIME-Version: 1.0 
    ... Content-type: multipart/mixed; boundary=boundary
    ... Private: yes
    ...
    ... --boundary
    ... Content-disposition: inline
    ... Content-type: text/plain; charset=utf-8
    ...
    ... This bug should be private.
    ...
    ... --boundary--
    ... """
    >>> token = getUtility(ITemporaryStorageManager).new(debug_data)
    >>> transaction.commit()

    >>> request = LaunchpadTestRequest()
    >>> filebug_view = create_view(ubuntu_firefox, request)
    >>> filebug_view.publishTraverse(request, token) is filebug_view
    True
    >>> filebug_view.extra_data.extra_description
    u'This bug should be private.'
    >>> filebug_view.extra_data.private
    True

    >>> filebug_view.validate(bug_data) is None
    True
    >>> filebug_view.submit_bug_action.success(bug_data)
    >>> filebug_view.added_bug.title
    u'Test Title'
    >>> print filebug_view.added_bug.description #doctest: -NORMALIZE_WHITESPACE
    Test description.
    <BLANKLINE>
    This bug should be private.
    >>> filebug_view.added_bug.private
    True
    >>> filebug_view.added_bug.security_related
    False

Since the bug was marked private before it was filed, only the bug reporter has
been subscribed to the bug and there should be no indirect subscribers.

    >>> for subscriber in filebug_view.added_bug.getDirectSubscribers():
    ...     print subscriber.displayname
    No Privileges Person

    >>> filebug_view.added_bug.getIndirectSubscribers()
    []

The user will be notified that the bug has been marked as private.

    >>> print filebug_view.request.response.notifications[2].message
    This bug report has been marked private...

We can also specify that a bug is public via the same field.

    >>> debug_data = """MIME-Version: 1.0 
    ... Content-type: multipart/mixed; boundary=boundary
    ... Private: no
    ...
    ... --boundary
    ... Content-disposition: inline
    ... Content-type: text/plain; charset=utf-8
    ...
    ... This bug should be public.
    ...
    ... --boundary--
    ... """
    >>> token = getUtility(ITemporaryStorageManager).new(debug_data)
    >>> transaction.commit()

    >>> request = LaunchpadTestRequest()
    >>> filebug_view = create_view(ubuntu_firefox, request)
    >>> filebug_view.publishTraverse(request, token) is filebug_view
    True
    >>> filebug_view.extra_data.extra_description
    u'This bug should be public.'
    >>> filebug_view.extra_data.private
    False

    >>> filebug_view.validate(bug_data) is None
    True
    >>> filebug_view.submit_bug_action.success(bug_data)
    >>> filebug_view.added_bug.title
    u'Test Title'
    >>> print filebug_view.added_bug.description #doctest: -NORMALIZE_WHITESPACE
    Test description.
    <BLANKLINE>
    This bug should be public.
    >>> filebug_view.added_bug.private
    False

Since this bug is public, both the reporter and the bug supervisor have been
subscribed.

    >>> for subscriber in filebug_view.added_bug.getDirectSubscribers():
    ...     print subscriber.displayname
    No Privileges Person

    >>> for subscriber in filebug_view.added_bug.getIndirectSubscribers():
    ...     print subscriber.displayname
    Foo Bar
    Ubuntu Team

=== Subscriptions ===

We can also subscribe someone to this bug when we file it by using a Subscribe
field in the message. Multiple people can be specified and they can be
identified by their Launchpad name or their e-mail address.

    >>> debug_data = """MIME-Version: 1.0 
    ... Content-type: multipart/mixed; boundary=boundary
    ... Subscribers: ddaa test@canonical.com
    ...
    ... --boundary
    ... Content-disposition: inline
    ... Content-type: text/plain; charset=utf-8
    ...
    ... Other people are interested in this bug.
    ...
    ... --boundary--
    ... """
    >>> token = getUtility(ITemporaryStorageManager).new(debug_data)
    >>> transaction.commit()

    >>> request = LaunchpadTestRequest()
    >>> filebug_view = create_view(ubuntu_firefox, request)
    >>> filebug_view.publishTraverse(request, token) is filebug_view
    True

    >>> filebug_view.extra_data.extra_description
    u'Other people are interested in this bug.'

    >>> for subscriber in filebug_view.extra_data.subscribers:
    ...     print subscriber
    ddaa
    test@canonical.com

    >>> filebug_view.validate(bug_data) is None
    True
    >>> filebug_view.submit_bug_action.success(bug_data)
    >>> filebug_view.added_bug.title
    u'Test Title'
    >>> print filebug_view.added_bug.description #doctest: -NORMALIZE_WHITESPACE
    Test description.
    <BLANKLINE>
    Other people are interested in this bug.

As well as the reporter, both Sample Person and David Allouche have been
subscribed to the bug.

    >>> for subscriber in filebug_view.added_bug.getDirectSubscribers():
    ...     print subscriber.displayname
    David Allouche
    No Privileges Person
    Sample Person

The user will be notified that Sample Person and David Allouche has been
subscribed to this bug.

    >>> for notification in filebug_view.request.response.notifications:
    ...     print notification.message
    Thank you for your bug report.
    Additional information was added to the bug description.
    David Allouche has been subscribed to this bug.
    Sample Person has been subscribed to this bug.

=== Subscribers to Private bugs ===

The Private and Subscriber fields are intended to be used together to subscribe
certain people and teams to bugs when they are filed.

    >>> debug_data = """MIME-Version: 1.0 
    ... Content-type: multipart/mixed; boundary=boundary
    ... Private: yes
    ... Subscribers: sabdfl
    ...
    ... --boundary
    ... Content-disposition: inline
    ... Content-type: text/plain; charset=utf-8
    ...
    ... This bug should be private, and Mark Shuttleworth subscribed.
    ...
    ... --boundary--
    ... """
    >>> token = getUtility(ITemporaryStorageManager).new(debug_data)
    >>> transaction.commit()

    >>> request = LaunchpadTestRequest()
    >>> filebug_view = create_view(ubuntu_firefox, request)
    >>> filebug_view.publishTraverse(request, token) is filebug_view
    True

    >>> filebug_view.extra_data.extra_description
    u'This bug should be private, and Mark Shuttleworth subscribed.'

    >>> filebug_view.extra_data.private
    True

    >>> for subscriber in filebug_view.extra_data.subscribers:
    ...     print subscriber
    sabdfl

    >>> filebug_view.validate(bug_data) is None
    True

    >>> filebug_view.submit_bug_action.success(bug_data)
    >>> filebug_view.added_bug.title
    u'Test Title'

    >>> print filebug_view.added_bug.description #doctest: -NORMALIZE_WHITESPACE
    Test description.
    <BLANKLINE>
    This bug should be private, and Mark Shuttleworth subscribed.

    >>> filebug_view.added_bug.private
    True
    >>> filebug_view.added_bug.security_related
    False

As well as the reporter, Mark Shuttleworth should have been subscribed to the
bug.

    >>> for subscriber in filebug_view.added_bug.getDirectSubscribers():
    ...     print subscriber.displayname
    Mark Shuttleworth
    No Privileges Person

Since the bug is private, there should be no indirect subscribers.

    >>> filebug_view.added_bug.getIndirectSubscribers()
    []

The user will be notified that Mark Shuttleworth has been subscribed to this
bug and that the bug has been marked as private.

    >>> for notification in filebug_view.request.response.notifications:
    ...     print notification.message
    Thank you for your bug report.
    Additional information was added to the bug description.
    Mark Shuttleworth has been subscribed to this bug.
    This bug report has been marked private...

== publishTraverse() ==

As already seen above, it's the FileBugViewBase's publishTraverse that
finds the right blob to use.

    >>> request = LaunchpadTestRequest()
    >>> filebug_view = create_view(ubuntu_firefox, request)
    >>> filebug_view.publishTraverse(request, token) is filebug_view
    True
    >>> filebug_view.extra_data_token == token
    True
    >>> filebug_view.extra_data is not None
    True

Since the view itself is returned, it will handle further traversals as
well, so if we call the method again, it represents a URL like
'.../+filebug/token/foo', which should raise a NotFound error.

    >>> filebug_view.publishTraverse(request, token)
    Traceback (most recent call last):
    ...
    NotFound:...

=== Not found tokens ===

If publishTraverse is called with a token that can't be found, a
NotFound error is raised.

    >>> request = LaunchpadTestRequest()
    >>> filebug_view = create_view(ubuntu_firefox, request)
    >>> filebug_view.publishTraverse(request, 'no-such-token')
    Traceback (most recent call last):
    ...
    NotFound:...

== Adding tags to filed bugs ==

    >>> bug_data = dict(
    ...     title=u'Test Title', comment=u'Test description.',
    ...     tags=[u'foo', u'bar'])

The validate and action don't use the request when filing the bug, so we
can pass an empty request and pass the data dict to the methods
directly.

    >>> login('no-priv@canonical.com')
    >>> filebug_view = create_view(ubuntu_firefox, LaunchpadTestRequest())
    >>> filebug_view.validate(bug_data) is None
    True
    >>> filebug_view.submit_bug_action.success(bug_data)
    >>> filebug_view.added_bug.title
    u'Test Title'
    >>> filebug_view.added_bug.description
    u'Test description.'
    >>> for tag in filebug_view.added_bug.tags:
    ...     print tag
    bar
    foo

== Filing security bugs ==

The base class allows security bugs to be filed.

    >>> bug_data = dict(
    ...     title=u'Security bug', comment=u'Test description.',
    ...     security_related=True)

    >>> filebug_view = create_view(ubuntu_firefox, LaunchpadTestRequest())
    >>> filebug_view.validate(bug_data) is None
    True
    >>> filebug_view.submit_bug_action.success(bug_data)
    >>> filebug_view.added_bug.title
    u'Security bug'
    >>> filebug_view.added_bug.security_related
    True

== Validation ==

=== The comment field ===

When filing a bug, supplying an empty comment causes a validation error:

    >>> from canonical.launchpad.browser import FileBugGuidedView
    >>> request = LaunchpadTestRequest(
    ...     form={'field.actions.submit_bug': 'Submit Bug Request'})
    >>> filebug_view = FileBugGuidedView(ubuntu, request)
    >>> filebug_view.submit_bug_action.submitted()
    True
    >>> bug_data = dict(title='Test Title', comment='')
    >>> filebug_view.setUpFields()
    >>> filebug_view.setUpWidgets()
    >>> filebug_view.validate(bug_data)
    >>> print filebug_view.getFieldError('comment')
    Required input is missing.

Comments can be up to 50000 characters in length:

    >>> comment = 'x' * 50000
    >>> bug_data = dict(title='Test Title', comment=comment)
    >>> filebug_view = FileBugGuidedView(ubuntu, request)
    >>> filebug_view.setUpFields()
    >>> filebug_view.setUpWidgets()
    >>> filebug_view.validate(bug_data)
    >>> print filebug_view.getFieldError('comment')
    <BLANKLINE>

Supplying a comment that is too long causes a validation error:

    >>> comment = 'x' * 50001
    >>> bug_data = dict(title='Test Title', comment=comment)
    >>> filebug_view = FileBugGuidedView(ubuntu, request)
    >>> filebug_view.setUpFields()
    >>> filebug_view.setUpWidgets()
    >>> filebug_view.validate(bug_data)
    >>> print filebug_view.getFieldError('comment')
    The description is too long...
    
