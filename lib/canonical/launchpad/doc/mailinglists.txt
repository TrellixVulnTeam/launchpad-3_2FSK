= Team Mailing Lists =

Teams may have zero or one team mailing list.  Creating a team mailing list
requires several steps, starting with registration of the list by the owner of
an existing team.  This is done through an IMailingListRegistry utility.

    >>> from zope.interface.verify import verifyObject
    >>> from canonical.launchpad.interfaces import (
    ...     IMailingList, IMailingListRegistry)
    >>> list_registry = getUtility(IMailingListRegistry)
    >>> verifyObject(IMailingListRegistry, list_registry)
    True

In the following description of how to use team mailing lists, we will need
several team.

    >>> from canonical.launchpad.interfaces import IPersonSet
    >>> from canonical.launchpad.ftests import login, ANONYMOUS
    >>> login(ANONYMOUS)
    >>> personset = getUtility(IPersonSet)
    >>> team_owner = personset.getByName('ddaa')
    >>> team_one = personset.newTeam(team_owner, 'team_one', 'Team One')
    >>> team_two = personset.newTeam(team_owner, 'team_two', 'Team Two')
    >>> team_three = personset.newTeam(team_owner, 'team_three', 'Team Three')
    >>> team_four = personset.newTeam(team_owner, 'team_four', 'Team Four')
    >>> from canonical.database.sqlbase import flush_database_updates
    >>> flush_database_updates()

None of these teams have mailing lists yet.

    >>> sorted(list_registry.registered_lists)
    []
    >>> sorted(list_registry.approved_lists)
    []
    >>> print list_registry.getTeamMailingList(team_one)
    None
    >>> print list_registry.getTeamMailingList(team_two)
    None
    >>> print list_registry.getTeamMailingList(team_three)
    None
    >>> print list_registry.getTeamMailingList(team_four)


== Registering a team mailing list ==

The team owner starts the process of creating a team mailing list by
registering the list.  By registering the mailing list, the team owner makes a
request to have the list created, but it is not created right away.

    >>> from datetime import datetime
    >>> registration_date = datetime.now()
    >>> list_one = list_registry.register(team_one)
    >>> flush_database_updates()
    >>> list_one
    '<MailingList for ubuntu_team; status=REGISTERED>'

The newly registered mailing list is linked to its team, and the list's
registrant is the team owner at the time the list was registered.  The list's
registration date is set, and its status is set to REGISTERED.

    >>> list_one.team
    'Team One team'
    >>> list_one.team is ubuntu_team
    True
    >>> list_one.registrant
    'ddaa@canonical.com'
    >>> list_one.registrant is ubuntu_team.teamowner
    True
    >>> registration_date <= list_one.date_registered >= datetime.now()
    True
    >>> list_one.status
    REGISTERED

The mailing list's registrant does not change if the team's owner changes.

    >>> carlos = personset.getByName('carlos')
    >>> ubuntu_team.owner = carlos
    >>> flush_database_updates()
    >>> list_one.registrant
    'ddaa@canonical.com'

A mailing list cannot be registered more than once.

    >>> list_registry.register(team_one)
    Assertion Error


== Reviewing a registered mailing list ==

A registered mailing list must then be reviewed by a Launchpad administrator
before the request to create it can be made.  Use the registry to find the set
of all currently registered mailing lists.

    >>> list_registry.register(team_two)
    >>> list_registry.register(team_three)
    >>> list_registry.register(team_four)
    >>> sorted(list_registry.registered_lists)
    ['Team One mailing list',
     'Team Two mailing list',
     'Team Three mailing list',
     'Team Four mailing list']

A mailing list's registration cannot be reviewed by a non-administrator.

    >>> from canonical.lp.dbschema import MailingListStatus
    >>> no_priv = personset.getByName('no-priv')
    >>> list_one.review(no_priv, MailingListStatus.APPROVED)
    Assertion Error
    >>> list_one.review(carlos, MailingListStatus.APPROVED)
    Assertion Error
    >>> list_one.review(ddaa, MailingListStatus.APPROVED)
    Assertion Error

A Launchpad administer though, may approve the registration.

    >>> sabdfl = personset.getByName('sabdfl')
    >>> list_one.review(sabdfl, MailingListStatus.APPROVED)
    >>> list_one.status
    APPROVED

A mailing list that has already been reviewed, may not be re-reviewed.

    >>> list_one.review(sabdfl, MailingListStatus.APPROVED)
    Assertion Error
    >>> list_one.review(sabdfl, MailingListStatus.DECLINED)
    Assertion Error

A reviewer may  also decline a mailing list registration.

    >>> team_two.review(sabdfl, MailingListStatus.DECLINED)
    >>> flush_database_updates()
    >>> python_list.status
    DECLINED

Once approved or declined the lists won't be re-considered for review.

    >>> sorted(list_registry.registered_lists)
    ['Team Three mailing list',
     'Team Four mailing list']

Approve a couple of other lists to illustrate some additional outcomes later
on.

    >>> team_three.review(sabdfl, MailingListStatus.APPROVED)
    >>> team_four.review(sabdfl, MailingListStatus.APPROVED)
    >>> flush_database_updates()
    >>> list(list_registry.registered_lists)
    []


== Constructing mailing lists ==

Once a team mailing list has been approved, it can be constructed by Mailman.
This happens by returning the set of approved mailing lists through the XMLRPC
interface used by Mailman (not shown here).  When Mailman retrieves the set of
mailing lists to construct, the list's statuses are set to the CONSTRUCTING
state.

    >>> sorted(list_registry.approved_lists)
    ['Team One mailing list',
     'Team Three mailing list',
     'Team Four mailing list']
    >>> list_one.construct()
    >>> list_one.status
    MailingListStatus.CONSTRUCTING

A mailing list that has been declined may not be constructed.

    >>> list_two.construct()
    Assertion Error

Once in the construction phase, a list is no longer in the approval state.

    >>> list(list_registry.approved_lists)
    ['Team Three mailing list',
     'Team Four mailing list']

Lists should never be constructed more than once.

    >>> list_one.construct()
    Assertion Error

Construct a couple of other lists to illustration some additional outcomes
later.

    >>> list_three.construct()
    >>> list_four.construct()
    >>> flush_database_updates()


== Reporting the results of construction ==

After Mailman has worked at constructing lists for a while, it reports (again
through XMLRPC not shown here) on the status of each list construction.  Most,
if not all will succeed, thus activating the team's mailing list.

    >>> list_one.reportConstructionResult(MailingListStatus.ACTIVE)
    >>> list_three.reportConstructionResult(MailingListStatus.ACTIVE)
    >>> flush_database_updates()
    >>> list_one.status
    ACTIVE
    >>> list_three.status
    ACTIVE

Some list constructions may fail.

    >>> list_four.reportConstructionResult(MailingListStatus.FAILED)
    >>> flush_database_updates()
    >>> list_four.status
    FAILED


== Deactivating lists ==

A list which is active may be deactivated.

    >>> list_four.deactivate()
    >>> flush_database_updates()
    >>> list_four.status
    INACTIVE

But lists which are not active may not be deactivated.

    >>> list_two.deactivate()
    Assertion Error
    >>> list_three.deactivate()
    Assertion Error
    >>> list_four.deactivate()
    Assertion Error


== Welcome messages ==

Mailing lists have a welcome message text which is sent to new members when
they subscribe to a list.  The welcome message text can contain anything.

    >>> list_one.welcome_message_text = """\
    ... Welcome to the Team One mailing list."""
    >>> flush_database_updates()
    >>> list_one.welcome_message_text
    'Welcome to the Team One mailing list.'
    >>> print list_two.welcome_message_text
    None


== XXX ==

 * How do we coordinate deactivation of lists with Mailman?  Should we be able
   to re-activate lists once they are deactivated, and if so, is approval
   necessary?
 * How do we handle changes to welcome_message_text with Mailman?
 * Should we use specific exceptions rather than assertions to deal with
   failure cases?
