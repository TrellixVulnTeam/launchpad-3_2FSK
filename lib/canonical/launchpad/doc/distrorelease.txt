Distro Releases
===============

From the DerivationOverview spec[1]:

    A distribution of GNU/Linux comprises a set of packages, an installer,
    possibly a live-CD, some amount of metadata associated with the arrangement
    of those elements and also a lot of information on managing it.

A distro release is a given version of a distribution. So, for Ubuntu, there
are releases (or planned releases) like "warty", "hoary" and "bendy".

Distro releases are retrieved with the IDistroReleaseSet utility, much like
people are retrieved with the IPersonSet utility, or bug tasks are retrieved
with the IBugTaskSet utility.

The IDistroReleaseSet utility is accessed in the usual fashion:

    >>> from zope.component import getUtility
    >>> from canonical.launchpad.interfaces import (
    ...     IDistroReleaseSet, IDistributionSet)
    >>> distroreleaseset = getUtility(IDistroReleaseSet)

To retrieve a specific release of a distribution, use IDistroReleaseSet.get:

    >>> warty = distroreleaseset.get(1)
    >>> print warty.name
    warty
    >>> print warty.fullreleasename
    Ubuntu Warty

Or IDistroReleaseSet.findByName:

    >>> for distrorelease in distroreleaseset.findByName("warty"):
    ...     print distrorelease.name
    warty

To get one specific release by name, use queryByName:

    >>> ubuntu = getUtility(IDistributionSet).getByName("ubuntu")

    >>> warty = distroreleaseset.queryByName(ubuntu, "warty")
    >>> warty.name
    u'warty'

If the release by that name doesn't exist, None will be returned:

    >>> foobar = distroreleaseset.queryByName(ubuntu, "foobar")
    >>> print foobar
    None

Or IDistroReleaseSet.findByVersion:

    >>> for distrorelease in distroreleaseset.findByVersion("5.04"):
    ...     print distrorelease.name
    hoary

To search the set of IDistroReleases, use IDistroReleaseSet.search:

    >>> ubuntu_releases = distroreleaseset.search(
    ...     distribution=ubuntu, isreleased=True, orderBy="-datereleased")
    >>> [release.name for release in ubuntu_releases]
    [u'warty']

    >>> all_ubuntu_releases = distroreleaseset.search(distribution=ubuntu)
    >>> all_ubuntu_releases.count()
    4

DistroRelease.getPublishedReleases:

    >>> from canonical.launchpad.database import SourcePackageName, DistroRelease
    >>> warty2 = DistroRelease.get(1)

Passing a ISourcePackageName as argument:

    >>> prs = warty2.getPublishedReleases(
    ...       SourcePackageName.byName('mozilla-firefox'))
    >>> print len(prs)
    1
    >>> print prs[0].sourcepackagerelease.sourcepackagename.name
    mozilla-firefox

Passing a string name:

    >>> print len(warty2.getPublishedReleases('mozilla-firefox'))
    1

Including pending publication records in the result:

    >>> print len(warty2.getPublishedReleases('mozilla-firefox',
    ...           include_pending=True))
    2

Not found as empty list:

    >>> print len(warty2.getPublishedReleases('nosuchpackage'))
    0


DistroRelease.getBinaryPackagePublishing will return
BinaryPackagePublishing objects for the DistroRelease:

    >>> from canonical.launchpad.database import DistroRelease
    >>> warty = DistroRelease.get(1)
    >>> bpp = warty.getBinaryPackagePublishing()
    >>> print bpp.count()
    3
    >>> print list(bpp)[0].binarypackagerelease.binarypackagename.name
    mozilla-firefox
    >>> bpp = warty.getBinaryPackagePublishing(name="nosuchpackage")
    >>> print bpp.count()
    0
    >>> bpp = warty.getBinaryPackagePublishing(version="nosuchversion")
    >>> print bpp.count()
    0
    >>> bpp = warty.getBinaryPackagePublishing(archtag="nosucharch")
    >>> print bpp.count()
    0
    >>> bpp = warty.getBinaryPackagePublishing(sourcename="nosuchsource")
    >>> print bpp.count()
    0

Package searching
-----------------

You can search through binary packages publishing in a distribution
release by using the searchPackages method, which uses magical fti:

    >>> len(warty.searchPackages("pmount"))
    1

This also works for small or weirdly named packages that don't work
through fti, and even for substrings:

    >>> len(warty.searchPackages("linux-2.6.12"))
    1
    >>> len(warty.searchPackages("at"))
    1
    >>> len(warty.searchPackages("inux-2"))
    1

CVE BugTasks on a Distro Release
--------------------------------

A distro release should know what CVE-related bug tasks exist on it, and
what state they are in. We should be able to find open, and closed,
bugtasks, using this API. Based on the sample data we know the following
about Debian:

    >>> woody = distroreleaseset.get(6)
    >>> tasks = woody.open_cve_bugtasks
    >>> for task in tasks:
    ...     print task.id
    20

There should be NO resolved CVE tasks:

    >>> tasks = woody.resolved_cve_bugtasks
    >>> print tasks.count()
    0

DistroReleases have components and sections
-------------------------------------------

A distrorelease has some number of components and/or sections which
are valid for that distrorelease. These selections are used by (among
other things) the uploader for validating incoming uploads.

   >>> hoary = distroreleaseset.get(3)
   >>> for c in hoary.components:
   ...     print c.name
   main
   restricted
   >>> for s in hoary.sections:
   ...     print s.name
   editors

   >>> from canonical.launchpad.interfaces import (
   ...    IComponentSet, ISectionSet)
   >>> univ = getUtility(IComponentSet).ensure('universe')
   >>> web = getUtility(ISectionSet).ensure('web')

   >>> hoary.addComponent(univ)
   >>> hoary.addSection(web)

   >>> for c in hoary.components:
   ...     print c.name
   main
   restricted
   universe

   >>> for s in hoary.sections:
   ...     print s.name
   web
   editors


[1] https://wiki.launchpad.canonical.com/DerivationOverview

DistroReleases can be initialised from their parents
----------------------------------------------------

When a distrorelease is derived from another distrorelease (be it a
derivative distribution, or simply the next release in a sequence from
Ubuntu) we need to initialise the new release with quite a lot of
information. Not least of which is the section and component
selections and the publishing information for the distrorelease.

DistroRelease provides us with a method for doing this which carefully
goes behind the back of sqlobject to copy potentially tens of
thousands of rows around in order to set up a distrorelease.

IDistroRelease lists a series of preconditions for performing an
initialisation. In particular the initialiser won't overwrite
publishing records etc. Essentially this is a "Do not push this button
again" type set of assertions.

   >>> login("foo.bar@canonical.com")
   >>> humpy = distroreleaseset.new(ubuntu, 'humpy', 'Humpy Hippo',
   ...                              'The Humpy Hippo', 'Fat', 'Yo Momma',
   ...                              '99.2',hoary, hoary.owner)
   >>> humpy_i386 = humpy.newArch('i386', hoary['i386'].processorfamily,
   ...                            True, humpy.owner)
   >>> humpy.nominatedarchindep = humpy_i386
   >>> humpy.initialiseFromParent()
   >>> len(hoary.getPublishedReleases('pmount'))
   1
   >>> len(humpy.getPublishedReleases('pmount'))
   1
   >>> len(hoary['i386'].getReleasedPackages('pmount'))
   1
   >>> len(humpy_i386.getReleasedPackages('pmount'))
   1

DistroRelease can build meta objects for packages
-------------------------------------------------

   >>> from zope.interface.verify import verifyObject
   >>> from canonical.launchpad.interfaces import (
   ...     ISourcePackage,
   ...     IDistroReleaseBinaryPackage,
   ...     IDistroReleaseSourcePackageRelease,
   ...     ISourcePackagePublishingHistory)


   >>> pmount_src_name =  SourcePackageName.byName('pmount')
   >>> pmount_source = hoary.getSourcePackage(pmount_src_name)
   >>> ISourcePackage.providedBy(pmount_source)
   True

   >>> from canonical.launchpad.database.binarypackagename import (
   ...                                       BinaryPackageName)
   >>> pmount_bin_name =  BinaryPackageName.byName('pmount')
   >>> pmount_binary = hoary.getBinaryPackage(pmount_bin_name)
   >>> IDistroReleaseBinaryPackage.providedBy(pmount_binary)
   True

   >>> from canonical.launchpad.database.sourcepackagerelease import (
   ...                                           SourcePackageRelease)
   >>> pmount_rel = SourcePackageRelease.selectOneBy(
   ...     sourcepackagenameID=pmount_src_name.id, version='0.1-1')
   >>> pmount_rel.sourcepackagename.name
   u'pmount'

   >>> pmount_srcrel = hoary.getSourcePackageRelease(pmount_rel)
   >>> IDistroReleaseSourcePackageRelease.providedBy(pmount_srcrel)
   True

Check some properties of DRSPR meta class

Entire publishing history:

   >>> pmount_srcrel.publishing_history.count()
   1

Most recent published history row:

   >>> spph = pmount_srcrel.current_published
   Traceback (most recent call last):
   ...
   NotFoundError: u'Source package pmount not published in hoary'

   >>> netapplet_srcrel =  hoary.getSourcePackage('netapplet').currentrelease
   >>> spph = netapplet_srcrel.current_published
   >>> verifyObject(ISourcePackagePublishingHistory, spph)
   True

   >>> spph.section.name
   u'web'

Perform `post publication` override:

   >>> new_section = getUtility(ISectionSet)['base']

   >>> netapplet_srcrel.changeOverride(new_section=new_section)
   >>> pub_hist = netapplet_srcrel.publishing_history
   >>> pub_hist.count()
   2

Override information about 'pmount' is pending publication:

   >>> pub_hist[0].status.name, pub_hist[0].section.name
   ('PENDING', u'base')

Supersede current publication:

   >>> superseded_netapplet = netapplet_srcrel.supersede()
   >>> netapplet_srcrel.publishing_history.count()
   2

   XXX cprov 20060322: Misteriously we cannot direct access attributes
   of a SSPPH objects within the tests, but we do this for SBPPH in
   distroarchrelease.txt. wth ?

   >>> superseded_netapplet.status.name, superseded_netapplet.datesuperseded
   Traceback (most recent call last):
   ...
   ForbiddenAttribute: ('status', <SecureSourcePackagePublishingHistory...)

   >>> from zope.security.proxy import removeSecurityProxy
   >>> naked_hist = removeSecurityProxy(superseded_netapplet)

   >>> naked_hist.status.name, naked_hist.datesuperseded
   ('SUPERSEDED', CURRENT_TIMESTAMP AT TIME ZONE 'UTC')



