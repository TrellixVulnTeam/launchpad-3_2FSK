= Bazaar Branches =

The Branch table holds information about an Bazaar Branch. It describes the
Launchpad user model of a branch, and in particular should be able (in the
future) to support un-committing of revisions.

It has a N-N association to the Revision table through the RevisionNumber
table. An association table is required because the sequence of revisions
listed by "bzr log" is defined by a "revision-history" file which has some
freedom with respect to the ancestry of revisions.

  * Distinct revision histories may point to same revision.

  * Revision histories including the same revision may have different starting
    points, they need not trace history back to the initial import. Therefore a
    given revision may have a different order number in different branches.

  * A revision history is required to follow the ancestry DAG, but two
    different branches may have histories tracing a different path between two
    shared revisions. This is exercised by the "convergence" feature of "bzr
    pull".

A Branch is not tied to an URL, since a branch may change locations over time.
It's not tied to a specific revision history because each new commit appends to
the history, and it's not restricted to appending to the history because the
Bazaar model does not forbid users from replacing the history of a branch.

== Creating branches ==

Branches can be created with IBranchSet.new. IBranchSet can be accessed as an
utility.

>>> from zope.component import getUtility
>>> from canonical.launchpad.interfaces import IBranchSet, NotFoundError
>>> from canonical.launchpad.ftests import syncUpdate
>>> branchset = getUtility(IBranchSet)

It must define the IBranchSet interface.

>>> from zope.interface.verify import verifyObject
>>> verifyObject(IBranchSet, branchset)
True

>>> from canonical.launchpad.interfaces import IProductSet
>>> productset = getUtility(IProductSet)
>>> gterm_product = productset.get(6)

>>> print branchset.get(-1)
None

A branch is retrievable via BranchSet's __getitem__ 

>>> branchset[24].name
u'launchpad'

If it doesn't exist an exception NotFoundError is raised

>>> try:
...     branchset[-1]
... except NotFoundError:
...     pass

>>> from canonical.launchpad.interfaces import IPersonSet
>>> personset = getUtility(IPersonSet)
>>> ddaa = personset.getByName('ddaa')

>>> from datetime import datetime, timedelta
>>> from pytz import UTC
>>> def timegenerator(origin):
...     now = origin
...     while True:
...         now += timedelta(seconds=5)
...         yield now
>>> now = timegenerator(datetime.now(UTC))

The timegenerator is used to create nicely ordered 'fake' date_created
times for the branches.  This avoids using transaction.commit to get the
date_created values from the database.

>>> gterm_dev_url = 'http://example.com/~ddaa/gterm.dev'
>>> title = "David Allouche's Main GNOME Terminal Branch"
>>> summary = "Main line of development for David Allouche on GNOME Terminal."
>>> home_page = "http://example.com/~ddaa/"
>>> gterm_dev = branchset.new('dev', ddaa, gterm_product, gterm_dev_url,
...     title, summary=summary, home_page=home_page, date_created=now.next())

>>> gterm_dev.name
u'dev'
>>> gterm_dev.product == gterm_product
True
>>> gterm_dev.url
u'http://example.com/~ddaa/gterm.dev'

Branches must implement the IBranch interface.

>>> from zope.interface.verify import verifyObject
>>> from canonical.launchpad.interfaces import IBranch
>>> verifyObject(IBranch, gterm_dev)
True

Branch may or may not be associated to a product, and may have no home_page,
no title, and no summary, and even no URL.

Branches with no URL are primarily hosted on the supermirror.

>>> url = 'http://example.com/~ddaa/junkcode'
>>> junkcode = branchset.new('junkcode', ddaa, None, None,
...                          date_created=now.next())

>>> junkcode.name
u'junkcode'
>>> print repr(junkcode.product)
None
>>> print repr(junkcode.home_page)
None
>>> print repr(junkcode.title)
None
>>> print repr(junkcode.summary)
None
>>> print repr(junkcode.url)
None


== Determing the number of branches ==

The IBranchSet can tell us how many branches there are registered.

>>> branchset.count()
27

(25 in the sample data, and two added above.)

== Determing the number of branches with bugs ==

The count of branches that have bugs associated with them is another
useful piece of summary information that is supplied on one of the initial
pages to show that there can be a relationship created between
branches and bugs.

>>> branchset.countBranchesWithAssociatedBugs()
2

== Determining the recently changed, registered and imported branches ==

The IBranchSet methods getRecentlyChangedBranches, getRecentlyImportedBranches,
and getRecentlyRegisteredBranches are used to give summary information that
is to be displayed on the code.launchpad.net page to entice the 
user to click through.

Changed branches are branches that are owned by real people or groups (as
opposed to vcs-imports), and have recently had new revisions detected by
the branch scanner, either through the branch being pushed to the supermirror
or the branch puller script mirroring a remote branch.

Imported branches are those branches owned by vcs-imports, and are "imported"
from other VCS hosted code bases.  Again recently imported branches are
identified by new revisions detected by the branch scanner.

Branches that have been recently registered have either been created by a user
using the web UI, or by pushing a new branch directly to the supermirror.

In order to determine changes in the branches the last_scanned timestamp
is used.  This is set by the branch scanner when it has finished
scanning the branches and recording the branch data in the launchpad
database.  The sample data doesn't have this value set, so we'll fake
it here to get some interesting results instead of nothing.

>>> list(branchset.getRecentlyChangedBranches(5))
[]
>>> list(branchset.getRecentlyImportedBranches(5))
[]

>>> from datetime import datetime, timedelta
>>> import pytz
>>> today = datetime.now(pytz.timezone('UTC'))
>>> branch = branchset.getByUniqueName('~ddaa/gnome-terminal/dev')
>>> branch.last_scanned = today - timedelta(3)
>>> syncUpdate(branch)
>>> branch = branchset.getByUniqueName('~ddaa/+junk/junkcode')
>>> branch.last_scanned = today - timedelta(2)
>>> syncUpdate(branch)
>>> branch = branchset.getByUniqueName('~vcs-imports/evolution/main')
>>> branch.last_scanned = today - timedelta(1)
>>> syncUpdate(branch)

>>> for branch in branchset.getRecentlyChangedBranches(5):
...   print branch.unique_name
~ddaa/+junk/junkcode
~ddaa/gnome-terminal/dev

>>> for branch in branchset.getRecentlyImportedBranches(5):
...   print branch.unique_name
~vcs-imports/evolution/main

>>> for branch in branchset.getRecentlyRegisteredBranches(2):
...   print branch.unique_name
~ddaa/+junk/junkcode
~ddaa/gnome-terminal/dev


== Finding a branch by URL ==

It is possible to find a branch by URL. Either using the pull URL:

>>> branchset.getByUrl(gterm_dev_url) == gterm_dev
True

Or using the Supermirror URL of the same branch:

>>> gterm_dev_supermirror = \
...     u'http://bazaar.launchpad.net/~ddaa/gnome-terminal/dev'
>>> branchset.getByUrl(gterm_dev_supermirror) == gterm_dev
True
>>> junkcode_supermirror = \
...     u'http://bazaar.launchpad.net/~ddaa/+junk/junkcode'
>>> branchset.getByUrl(junkcode_supermirror) == junkcode or \
...     ('failed', branchset.getByUrl(junkcode_supermirror))
True

The provided URL must not have any trailing slash:

>>> try: branchset.getByUrl(gterm_dev_url + '/')
... except AssertionError: print 'trailing slash not allowed'
trailing slash not allowed

If no branch is found for the specified URL, the specified default value is
returned.

>>> not_there_url = 'http//example.com/not-in-the-sample-data'
>>> print branchset.getByUrl(not_there_url)
None
>>> print branchset.getByUrl(not_there_url, 123)
123

== Branches and products ==

Branch not associated to a product are called "junk" branch and treated for
navigation purposes as if they were associated to a magic product named
"+junk".

>>> junkcode.product_name
'+junk'
>>> gterm_dev.product_name
u'gnome-terminal'

== Branch names ==

Branches have a unique name, that is based on the names of the owner, product
and branch.

>>> pushed = branchset[25]
>>> pushed.unique_name
u'~name12/gnome-terminal/pushed'
>>> junkcode.unique_name
u'~ddaa/+junk/junkcode'

Branches have a display name that is the Branch.title if it's provided, and the
unique_name otherwise.

>>> assert gterm_dev.title is not None
>>> gterm_dev.displayname == gterm_dev.title
True
>>> assert pushed.title is None
>>> pushed.displayname == pushed.unique_name
True

== Branches registered and authored ==

You can get the list of branches for a given Launchpad owner. These are called
the "registered branches", because the owner is initially set to the current
user by the branch creation forms.

>>> def getName(branch):
...     return branch.name
>>> sorted(ddaa.registered_branches, key=getName) == [gterm_dev, junkcode]
True

Branches are associated to an "author" user, which may be different from the
registrant. You can get the branch authored by a given person. Junk branches
should generally have at least an author, but that is not enforced.

>>> list(ddaa.authored_branches)
[]
>>> junkcode.author = ddaa
>>> syncUpdate(junkcode)

>>> list(ddaa.authored_branches) == [junkcode]
True

The list of registered branches does not include branches whose registrant is
also the author. That avoids duplicating the same branch in the registered and
authored branch listings for a person.

>>> list(ddaa.registered_branches) == [gterm_dev]
True

== Branch sort key ==

Branches have a sort_key attribute which is used through Launchpad to order
branch listings in a consistent and predictable way.

The sort key is made of:

  * product name (if applicable)
  * lifecycle status sort key
  * author's browser name (if applicable)
  * branch name
  * owner's nickname

The owner's name is usually not displayed in branch listings, but it is used in
the sort key to guarantee a predictable sort order. This relies on the fact
that (owner, product, name) is unique for all branches.

>>> from canonical.lp.dbschema import BranchLifecycleStatus
>>> gterm_slowness = branchset[19]
>>> gterm_slowness.sort_key
(u'gnome-terminal', ..., u'Sample Person', u'slowness', u'name12')
>>> gterm_slowness.sort_key[1] == BranchLifecycleStatus.MERGED.sortkey
True

If the product or author of a branch is NULL, the corresponding item in the
sort key is None.

Let's demonstrate that on a branch with a NULL product.

>>> junk_dev = branchset[20]
>>> print junk_dev.product
None
>>> junk_dev.sort_key
(None, ..., u'Ubuntu Team', u'junk.dev', u'name12')
>>> junk_dev.sort_key[1] == BranchLifecycleStatus.EXPERIMENTAL.sortkey
True

And on a branch with a NULL author.

>>> gterm_24 = branchset[17]
>>> print gterm_24.author
None
>>> gterm_24.sort_key
(u'gnome-terminal', ..., None, u'2.4', u'name12')
>>> gterm_24.sort_key[1] == BranchLifecycleStatus.ABANDONED.sortkey
True

== Branch subscriptions ==

Branches can be subscribed to and unsubscribed from by a Person.

>>> from canonical.launchpad.interfaces import IPerson, IBranchSubscription
>>> sabdfl = personset.getByName('sabdfl')
>>> sabdfl.subscribed_branches.count()
0
>>> subscription = gterm_dev.subscribe(sabdfl)
>>> verifyObject(IBranchSubscription, subscription)
True
>>> subscription.branch == gterm_dev and subscription.person == sabdfl
True
>>> gterm_dev.subscriptions[0] == subscription
True
>>> list(gterm_dev.subscribers) == [sabdfl]
True
>>> list(sabdfl.subscribed_branches) == [gterm_dev]
True
>>> gterm_dev.unsubscribe(sabdfl)
>>> gterm_dev.subscribers.count()
0

== Branches related to a person ==

Finally, you can get the list of related branches for a person, that includes
the branches registered, authored and subscribed to by this person.

>>> lifeless = personset.getByName('lifeless')
>>> lifeless.branches.count()
0
>>> url = 'http://example.com/~lifeless/mesh-merge'
>>> title = "Experimental mesh merging algorithm."
>>> meshmerge = branchset.new('mesh-merge', lifeless, None, url,
...     title, summary=title, date_created=now.next())
>>> junkcode.author = lifeless
>>> syncUpdate(junkcode)
>>> unused = gterm_dev.subscribe(lifeless)
>>> sorted(lifeless.branches, key=getName) == [gterm_dev, junkcode, meshmerge]
True

== Branches and revisions ==

See revision.txt for a doctest covering the creation of revisions and related
objects. Revision data is loaded in the database by a batch job using a
different user, Launchpad code is only concened with using this data.

Let's get a branch with some revisions in it.

>>> sample_person = personset.getByName('name12')
>>> junk = sample_person.getBranch('+junk', 'junk.dev')
>>> print junk.unique_name
~name12/+junk/junk.dev

== Revision history of Branch ==

Branch.revision_history gives the sequence of revisions in this branch's
history, latest revisions first. All revision history items must implement the
IRevisionNumber interface. The Branch.revision_count attribute gives the length
of the revision_history attribute but without building the list.

>>> from canonical.launchpad.interfaces import IRevisionNumber
>>> count = junk.revision_count
>>> count
6
>>> [verifyObject(IRevisionNumber, a) for a in junk.revision_history]
[True, True, True, True, True, True]
>>> [revno.sequence for revno in junk.revision_history]
[6, 5, 4, 3, 2, 1]

There are two methods for getting only the the latest items of the revision
history.

Branch.latest_revisions give a specific count of RevisionNumbers at the end of
the history.

>>> three_latest = list(junk.revision_history)[:3]
>>> list(junk.latest_revisions(3)) == three_latest
True

Branch.revisions_since gives all the RevisionNumbers for revisions comitted
since a given timestamp. It may give suprising results if some committers had a
skewed clock.

>>> from datetime import datetime
>>> timestamp = datetime(2005, 10, 31, 12, 00, 00)
>>> two_latest = list(junk.revision_history)[:2]
>>> list(junk.revisions_since(timestamp)) == two_latest
True

== Ancestry of Revision ==

The revision-history of a given branch, is only one possible ancestry path in
the ancestry graph. It is also possible to examine the ancestry graph directly.

A Bazaar branch may contains references (by revision_id) to revisions for which
no data is available. Such revisions are called "ghosts".

Initial commits (after a "bzr init") revisions have no parent.

>>> history = list(junk.revision_history)
>>> initial = history[-1].revision
>>> initial.parent_ids
[]

Normal commits (as opposed to merges) have exactly one parent. The first parent
of a revision is always the revision that was current when committing.

>>> commit = history[-2].revision
>>> [type(a) for a in commit.parent_ids] == [unicode]
True

Merges usually have two parents, but they may have more. Though the bzr user
interface discourage such complex merges.

>>> merge = history[-4].revision
>>> len(merge.parent_ids)
2

Parent revisions are identified by their globally unique id, and not by a
foreign key, so existing parents and ghosts can be modelled in the same way.

To try and retrieve a Revision given its globally unique id, you can use the
RevisionSet utility.

>>> from canonical.launchpad.interfaces import IRevisionSet
>>> revisionset = getUtility(IRevisionSet)
>>> [parent_id] = commit.parent_ids
>>> parent = revisionset.getByRevisionId(parent_id)
>>> parent == initial
True

If the parent was a ghost at import time and is not currently available in the
database. getByRevisionId returns None.

>>> revisionset.getByRevisionId('missing-revision-id') is None
True

== Getting the tip revision for a Branch ==

The last revision that we have stored in the database for any given branch
is identified by the branch attribute "last_scanned_id".  This is the textual
revision_id for the bzr revision.  The reason that it is a text id rather than
an integer foreign key is so it can easily be compared to the
"last_mirrored_id".  The "last_mirrored_id" is set by the branch puller, and is
used to identify when a scan is needed for a branch.

>>> branch = branchset.get(1)
>>> branch.last_scanned_id
>>> branch.getTipRevision() is None
True

>>> branch.last_scanned_id = 'null:'
>>> branch.getTipRevision() is None
True

>>> branch.last_scanned_id = 'test@canonical.com-20051031165248-6f1bb97973c2b4f4'
>>> rev = branch.getTipRevision()
>>> print rev.owner.name
admins
>>> print rev.date_created
2005-10-31 17:21:47.381770+00:00
>>> print rev.log_body
initial import (empty)


== Branch Scan List ==

To speed up the branch scanning process, we only want to scan those
branches that have new information available to be scanned.

This accomplished by making the branch puller and branch scanner
record the last revision IDs in the branch that they saw.

If the last mirrored and last scanned revision IDs differ for a
branch, then they will be included in the scan list:

  >>> branch = branchset.get(1)
  >>> branch.last_mirrored_id = 'rev-2'
  >>> branch.last_scanned_id = 'rev-1'
  >>> syncUpdate(branch)
  >>> branch in branchset.getBranchesToScan()
  True

When the branch is scanned, the scanned ID will be updated, and the
branch will no longer appear in the list:

  >>> branch.last_scanned_id = 'rev-2'
  >>> syncUpdate(branch)
  >>> branch in branchset.getBranchesToScan()
  False

If a branch has not been scanned yet, it will have a null scanned ID,
so is included in the branch pull list:

  >>> branch.last_scanned_id = None
  >>> syncUpdate(branch)
  >>> branch in branchset.getBranchesToScan()
  True

If a branch has not been mirrored, it will have a null mirrored ID.
There is no point in mirroring such branches, whatever the last
scanned ID is.

  >>> branch.last_mirrored_id = None
  >>> branch.last_scanned_id = None
  >>> syncUpdate(branch)
  >>> branch in branchset.getBranchesToScan()
  False

  >>> branch.last_scanned_id = 'rev-1'
  >>> syncUpdate(branch)
  >>> branch in branchset.getBranchesToScan()
  False

== Getting last commit time for branches ==

There is not sufficient correct data in the sample code to make this
right, but we still want to test the corner cases.

  >>> branchset.getLastCommitForBranches([])
  {}
  >>> branch = branchset.get(1)
  >>> branchset.getLastCommitForBranches([branch])
  {<Branch ...>: None}
  >>> another = branchset.get(2)
  >>> branchset.getLastCommitForBranches([branch, another])
  {<Branch ...>: None, <Branch ...>: None}

== Getting branches by owner ==

In order to facilitate getting the branches for all the teams that a 
person is a member of, we need to be able to get branches owned by
arbitrary people.

  >>> branchset.getBranchesForOwners([])
  []
  >>> owners = [personset.getByName('launchpad')]
  >>> branches = branchset.getBranchesForOwners(owners)
  >>> import operator
  >>> for branch in sorted(branches, key=operator.attrgetter('unique_name')):
  ...     print branch.unique_name
  ~launchpad/gnome-terminal/launchpad

  >>> owners.append(personset.getByName('ddaa'))
  >>> branches = branchset.getBranchesForOwners(owners)
  >>> for branch in sorted(branches, key=operator.attrgetter('unique_name')):
  ...     print branch.unique_name
  ~ddaa/+junk/junkcode
  ~ddaa/gnome-terminal/dev
  ~launchpad/gnome-terminal/launchpad
 
