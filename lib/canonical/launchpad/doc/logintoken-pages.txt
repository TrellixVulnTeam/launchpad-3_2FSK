= LoginToken pages =

Users interact with login tokens for operations that require the user to
prove he has access to a resource that is external to Launchpad. For
example, claiming an email address or resetting a password require the
user to use the login token sent to him in an email.


== Reset password view ==

A user can reset his password if he forgets it. A link for a LoginToken
is sent to the email address that the user claims is his. The view
displays a form asking the user to confirm his email address and provide
a new password.

    >>> from zope.component import getMultiAdapter, getUtility
    >>> from zope.security.proxy import removeSecurityProxy
    >>> from canonical.launchpad.interfaces.logintoken import (
    ...     ILoginTokenSet, LoginTokenType)
    >>> from canonical.launchpad.interfaces.person import IPersonSet
    >>> from canonical.launchpad.webapp.servers import LaunchpadTestRequest

    >>> person_set = getUtility(IPersonSet)
    >>> no_priv = person_set.getByEmail('no-priv@canonical.com')
    >>> no_priv_account = removeSecurityProxy(no_priv.account)
    >>> old_password = no_priv_account.password

    >>> login_token_set = getUtility(ILoginTokenSet)
    >>> login_token = login_token_set.new(
    ...     no_priv, 'no-priv@canonical.com',
    ...     'no-priv@canonical.com', LoginTokenType.PASSWORDRECOVERY)
    >>> request = LaunchpadTestRequest(
    ...     SERVER_URL='http://launchpad.dev',
    ...     PATH_INFO='/token/%s/+resetpassword' % login_token.token,
    ...     method='POST',
    ...     form={
    ...         'field.email': 'no-priv@canonical.com',
    ...         'field.password': 'test1',
    ...         'field.password_dupe': 'test1',
    ...         'field.actions.continue': 'Continue',
    ...         })
    >>> resetpassword_view = getMultiAdapter(
    ...     (login_token, request), name="+resetpassword")
    >>> resetpassword_view.initialize()
    >>> old_password == no_priv_account.password
    False

If the user submits the wrong email address for the token, an error is
stored. The password is not reset.

    >>> login_token = login_token_set.new(
    ...     no_priv, 'no-priv@canonical.com',
    ...     'no-priv@canonical.com', LoginTokenType.PASSWORDRECOVERY)
    >>> request = LaunchpadTestRequest(
    ...     SERVER_URL='http://launchpad.dev',
    ...     PATH_INFO='/token/%s/+resetpassword' % login_token.token,
    ...     method='POST',
    ...     form={
    ...         'field.email': 'wrong@canonical.com',
    ...         'field.password': 'test2',
    ...         'field.password_dupe': 'test2',
    ...         'field.actions.continue': 'Continue',
    ...         })
    >>> resetpassword_view = getMultiAdapter(
    ...     (login_token, request), name="+resetpassword")
    >>> resetpassword_view.initialize()
    >>> resetpassword_view.errors
    [u"The email address ... didn't match ... the password reset."]

    >>> old_password == no_priv_account.password
    True


=== Reactivating an account using reset password ===

A user with a DEACTIVATED account does not have a password--he must use
the +resetpassword view to set his account to ACTIVE and add a password.

    >>> former_user = person_set.getByEmail('former-user@canonical.com')
    >>> former_user.name
    u'former-user-deactivatedaccount'

    >>> former_user_account = removeSecurityProxy(former_user.account)
    >>> former_user_account.status
    <DBItem AccountStatus.DEACTIVATED, ...>
    >>> print former_user_account.password
    None

    >>> login_token = login_token_set.new(
    ...     former_user, 'former-user@canonical.com',
    ...     'former-user@canonical.com', LoginTokenType.PASSWORDRECOVERY)

If the user provides the correct email address for the token, the
password is reset, and the account status is set ACTIVE.

    >>> request = LaunchpadTestRequest(
    ...     SERVER_URL='http://launchpad.dev',
    ...     PATH_INFO='/token/%s/+resetpassword' % login_token.token,
    ...     method='POST',
    ...     form={
    ...         'field.email': 'former-user@canonical.com',
    ...         'field.password': 'test3',
    ...         'field.password_dupe': 'test3',
    ...         'field.actions.continue': 'Continue',
    ...         })
    >>> resetpassword_view = getMultiAdapter(
    ...     (login_token, request), name="+resetpassword")
    >>> resetpassword_view.initialize()

    >>> former_user.name
    u'former-user'
    >>> former_user_account.status
    <DBItem AccountStatus.ACTIVE, ...>
    >>> former_user.is_valid_person
    True


== Claiming a profile ==

The ClaimProfileView allows users to claim accounts created by Launchpad
processes. The user profile for Alexander Limi was created during an
import. The user profile does not have a preferred email address or a
password.

    >>> limi = person_set.getByEmail('limi@plone.org')
    >>> limi.name
    u'limi'
    >>> limi.displayname
    u'Alexander Limi'
    >>> print limi.preferredemail
    None

    >>> limi_account = removeSecurityProxy(limi.account)
    >>> limi_account.status
    <DBItem AccountStatus.NOACCOUNT, ...>
    >>> print limi_account.password
    None
    >>> limi.is_valid_person
    False

The user can claim his profile by providing the email address that
is associated with the profile. If the correct address is provided,
the user is sent an email with a link to a LoginToken.

    >>> login_token = login_token_set.new(
    ...     limi, 'limi@plone.org',
    ...     'limi@plone.org', LoginTokenType.PROFILECLAIM)

The user is asked to provide a display name and password, and to
indicate if his email address can be shown to other Launchpad users.

    >>> request = LaunchpadTestRequest(
    ...     SERVER_URL='http://launchpad.dev',
    ...     PATH_INFO='/token/%s/+claimprofile' % login_token.token,
    ...     method='POST',
    ...     form={
    ...         'field.displayname': 'A. Limi',
    ...         'field.hide_email_addresses': 'on',
    ...         'field.password': 'test4',
    ...         'field.password_dupe': 'test4',
    ...         'field.actions.confirm': 'Continue',
    ...         })
    >>> claimprofile_view = getMultiAdapter(
    ...     (login_token, request), name="+claimprofile")
    >>> claimprofile_view.initialize()
    >>> claimprofile_view.errors
    []

The user's Person, EmailAddress, and Account objects are updated.

    >>> limi.displayname
    u'A. Limi'
    >>> limi.hide_email_addresses
    True
    >>> removeSecurityProxy(limi.preferredemail).email
    u'limi@plone.org'

    >>> limi_account.status
    <DBItem AccountStatus.ACTIVE, ...>
    >>> limi_account.status_comment
    u'Activated by claim profile.'
    >>> limi.is_valid_person
    True


== Creating a new account from an existing profile ==

If a user's email address matches the email address of an unclaimed
account, the existing profile is activated and given to the user.
David Miller (justdave) has an account created via an automated process.

    >>> justdave = person_set.getByEmail('justdave@bugzilla.org')
    >>> justdave.name
    u'justdave'
    >>> justdave.displayname
    u'Dave Miller'
    >>> print justdave.preferredemail
    None

    >>> justdave_account = removeSecurityProxy(justdave.account)
    >>> justdave_account.status
    <DBItem AccountStatus.NOACCOUNT, ...>
    >>> print justdave_account.password
    None
    >>> justdave.is_valid_person
    False

Dave would normally create a new account by claiming a LoginToken
that verifies his access to the email address his provided.

    >>> login_token = login_token_set.new(
    ...     justdave, 'justdave@bugzilla.org',
    ...     'justdave@bugzilla.org', LoginTokenType.NEWACCOUNT)

The NewAccountView will activate the existing account and update
the Person object.

    >>> request = LaunchpadTestRequest(
    ...     SERVER_URL='http://launchpad.dev',
    ...     PATH_INFO='/token/%s/+newaccount' % login_token.token,
    ...     method='POST',
    ...     form={
    ...         'field.displayname': 'Dave (justdave) Miller',
    ...         'field.hide_email_addresses.used': '',
    ...         'field.password': 'test5',
    ...         'field.password_dupe': 'test5',
    ...         'field.actions.continue': 'Continue',
    ...         })
    >>> claimprofile_view = getMultiAdapter(
    ...     (login_token, request), name="+newaccount")
    >>> claimprofile_view.initialize()
    >>> claimprofile_view.errors
    []

The existing Account, Person and EmailAddress are updated.

    >>> justdave.displayname
    u'Dave (justdave) Miller'
    >>> justdave.hide_email_addresses
    False
    >>> removeSecurityProxy(justdave.preferredemail).email
    u'justdave@bugzilla.org'

    >>> justdave_account.status
    <DBItem AccountStatus.ACTIVE, ...>
    >>> justdave_account.status_comment
    u'Activated by new account.'
    >>> justdave.is_valid_person
    True


== Validating GPG keys ==

In order to add a GPG key to Launchpad we require that the person
registering it decrypt an email and follow the instructions in it.
The last step in that workflow is the +validategpg page, which can
be accessed by non-logged-in users. That page will attempt to access
all email addresses of the requester but that may fail when the user
is not logged in and the requester has chosen to hide his email
addresses, so here we'll make sure that even non-logged-in users can
perform the last step of the workflow for adding a GPG key.

    >>> sample_person = person_set.getByEmail('test@canonical.com')
    >>> sample_person.hide_email_addresses
    True

    >>> login_token = login_token_set.new(
    ...     sample_person, 'test@canonical.com', 'test@canonical.com',
    ...     LoginTokenType.VALIDATEGPG,
    ...     fingerprint='A419AE861E88BC9E04B9C26FBA2B9389DFD20543')

    # Start our stub GPG keyserver so that the key can be fetched by the page.
    >>> from canonical.zeca.ftests.harness import ZecaTestSetup
    >>> z = ZecaTestSetup()
    >>> z.setUp()

    >>> request = LaunchpadTestRequest(
    ...     SERVER_URL='http://launchpad.dev',
    ...     PATH_INFO='/token/%s/+validategpg' % login_token.token,
    ...     method='POST', form={'field.actions.continue': 'Continue'})
    >>> validategpg_view = getMultiAdapter(
    ...     (login_token, request), name="+validategpg")
    >>> print validategpg_view.user
    None
    >>> validategpg_view.initialize()
    >>> print "\n".join(
    ...     notification.message
    ...     for notification in validategpg_view.request.notifications)
    The key 1024D/DFD20543 was successfully validated...

    # Tear down the stub keyserver.
    >>> z.tearDown()
