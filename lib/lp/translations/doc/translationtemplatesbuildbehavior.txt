= TranslationTemplatesBuildJobBehavior =

== Setup ==

Set up build environment.  Clear out the build queue.

    >>> import transaction
    >>> import logging
    >>> logger = logging.getLogger()
    >>> logger.setLevel(logging.CRITICAL)

    >>> from canonical.database.sqlbase import quote
    >>> from canonical.launchpad.interfaces.lpstorm import IMasterStore
    >>> from lp.services.job.interfaces.job import JobStatus
    >>> from lp.services.job.model.job import Job
    >>> store = IMasterStore(Job)
    >>> query = store.execute("UPDATE Job SET status = %s" % quote(
    ...     JobStatus.FAILED))

    >>> from canonical.buildd.tests import BuilddSlaveTestSetup
    >>> BuilddSlaveTestSetup().setUp()

    >>> from canonical.librarian.interfaces import ILibrarianClient
    >>> from StringIO import StringIO
    >>> from canonical.launchpad.interfaces.librarian import (
    ...     ILibraryFileAliasSet)
    >>> from canonical.launchpad.interfaces.launchpad import (
    ...     ILaunchpadCelebrities)

Choose an arbitrary file as the chroot tarball for the build slave.  It
won't actually build, so it doesn't matter what's in there.

The build slave uses the nominated architecture for the current Ubuntu
release.

    >>> ubuntu = getUtility(ILaunchpadCelebrities).ubuntu
    >>> librarian_client = getUtility(ILibrarianClient)
    >>> content = 'arbitrary chroot file content'
    >>> alias_id = librarian_client.addFile(
    ...    'foo.tar.gz', len(content), StringIO(content), 'text/plain')
    >>> archdistroseries = ubuntu.currentseries.nominatedarchindep
    >>> chroot = getUtility(ILibraryFileAliasSet)[alias_id]
    >>> pc = archdistroseries.addOrUpdateChroot(chroot=chroot)

    >>> from lp.buildmaster.interfaces.builder import IBuilderSet
    >>> getUtility(IBuilderSet).checkBuilders(logger, transaction)

    >>> processor = archdistroseries.processorfamily.processors[0]

Make a builder to process our build request.

    >>> builder = factory.makeBuilder(
    ...     virtualized=True, processor=processor, vm_host='hostname')

The builder doesn't talk to a real slave.  We don't have those in our
test suite.  But we give it a fake one.

    >>> from lp.testing.fakemethod import FakeMethod
    >>> class FakeSlave:
    ...     build = FakeMethod()
    ...     cacheFile = FakeMethod()
    ...     resume = FakeMethod(result=('Output here', 'Errors here', 0))

    >>> from zope.security.proxy import removeSecurityProxy
    >>> slave = FakeSlave()
    >>> removeSecurityProxy(builder).slave = slave


== Get a job! ==

Use the ITranslationTemplatesBuildJobSource to create a
TranslationTemplatesBuildJob.

    >>> from lp.buildmaster.interfaces.buildqueue import IBuildQueueSet
    >>> from lp.translations.interfaces.translationtemplatesbuildjob import (
    ...     ITranslationTemplatesBuildJobSource)
    >>> branch = factory.makeBranch()
    >>> specific_job_source = getUtility(ITranslationTemplatesBuildJobSource)
    >>> specific_job = specific_job_source.create(branch)
    >>> buildqueue = getUtility(IBuildQueueSet).getByJob(specific_job.job)

The build has no start date yet.

    >>> print buildqueue.date_started
    None

Our job is now first in line to be executed.

    >>> removeSecurityProxy(builder)._findBuildCandidate() == buildqueue
    True

Dispatch the first job in line (ours!) to the build slave.

    >>> activated_job = builder.findAndStartJob()
    >>> activated_job == buildqueue
    True

Our build is now marked as started.

    >>> buildqueue.date_started is None
    False

The slave's build method has been called.

    >>> slave.build.call_count
    1


== Teardown ==

Clean up after this test.

    >>> BuilddSlaveTestSetup().tearDown()
