= launchpadlib =

launchpadlib is the standalone Python language bindings to Launchpad's web
services API.  It is officially supported by Canonical, although third party
packages may be available to provide bindings to other programming languages.

launchpadlib is currently in pre-alpha release.

    >>> import launchpadlib
    >>> launchpadlib.__version__
    '0.1'

launchpadlib talks to Launchpad's API facet, but anonymous users are not
allowed to access even the root service.

    >>> from urllib import urlopen
    >>> import lxml.objectify
    >>> def parse(url):
    ...     connection = urlopen(url)
    ...     try:
    ...         tree = lxml.objectify.parse(connection)
    ...     finally:
    ...         connection.close()
    ...     return tree.getroot()

    >>> root = parse('http://api.launchpad.dev')
    >>> root.head.title
    'Forbidden'
    >>> root.body.div[1].table.tr.td.div.text.strip()
    u'Not logged in \u2014'

Anonymous users cannot even access the beta service.

    >>> root = parse('http://api.launchpad.dev/beta')
    >>> root.head.title
    'Forbidden'
    >>> root.body.div[1].table.tr.td.div.text.strip()
    u'Not logged in \u2014'


== OAuth authentication ==

XXX REMOVE ME
 * 'qQ7dw1fXCR5hhJRN7ztj' is salgado with public read access only
 * '3SdVlTlVKcgXSJHbsSSk' is no-priv with public read access only

The Launchpad API requires user authentication via OAuth, and launchpadlib
provides a high level interface to OAuth for the most common use cases.
Several pieces of information are necessary to complete the OAuth request:

 * A consumer key, which is unique to the application using the API
 * An access token, which represents the user to the web service

Consumer keys are hard-baked into the application.  They are generated by the
application developer and registered with Launchpad independently of the use
of the application.  Since consumer keys are arbitrary, a registered consumer
key usually comes with a secret, but most open source applications will forgo
this since it's not really a secret anyway.

The access token cannot be provided directly.  Instead, the application
generates an unauthenticated request token, exchanging this for an access
token and a secret after obtaining approval to so from the user.  This
permission is typically gained by redirecting the user through their trusted
web browser, then back to the application.

This entire exchange is managed by the Credentials class and a few OAuth
classes.  There are several subclasses of Credentials, depending on whether
the application wants to store the access token on the file system or not.  In
the simplest case, the application will request a new access token every time.

    >>> from launchpadlib.credentials import Consumer
    >>> consumer = Consumer('launchpad-library')
    >>> consumer.key
    'launchpad-library'
    >>> consumer.secret
    ''

Salgado has full access to the Launchpad API.  In the simplest case, the
application itself will now obtain Salgado's approval to access the Launchpad
API on his behalf.  How the application does this is up to the application,
provided it conforms to the OAuth protocol.  Let's assume the application has
done this dance, and retrieved Salgado's access token and secret.

    >>> from launchpadlib.credentials import AccessToken
    >>> access_token = AccessToken(
    ...     'hgm2VK35vXD6rLg5pxWw',
    ...     'QzsKbdk2Fr8RsJX3j89VVq5mWVGVQ84Hpwdrg0Cw'
    ...     + '8VVwW4ClNnPHDPJ7vm3xjDRn5hLpKc3r6WfznFVz')

And now the root service can be accessed, using these credentials.

    >>> from launchpadlib.credentials import Credentials
    >>> credentials = Credentials(consumer, access_token)

    >>> from launchpadlib.launchpad import Launchpad as _Launchpad
    >>> class Launchpad(_Launchpad):
    ...     """A testable Launchpad proxy accessing the demo service root."""
    ...     SERVICE_ROOT = 'http://api.launchpad.dev:8085/beta'

    >>> launchpad = Launchpad(credentials=credentials)
    >>> sorted(launchpad.people)
    [...]
    >>> sorted(launchpad.bugs)
    [...]

It can be convenient to store the credentials on the file system, so that the
next time the user interacts with the application, he won't have to go through
the whole OAuth request dance.  This isn't secure (since it stores the token
and secret in plain text on the file system), but it's convenient.
Applications are, of course, welcome to subclass Credentials to provide more
secure storage.

    >>> import os
    >>> import tempfile
    >>> tempdir = tempfile.mkdtemp()
    >>> credentials_file = os.path.join(tempdir, '.credentials')
    >>> os.path.exists(credentials_file)
    False

Because the credentials file does not yet exist, there will be no credentials
available.

    >>> from launchpadlib.credentials import StorableCredentials
    >>> credentials = StorableCredentials(credentials_file)
    >>> print credentials.consumer
    None
    >>> print credentials.access_token
    None
    >>> os.path.splitext(credentials.filename)[1]
    '.credentials'
    >>> os.path.exists(credentials.filename)
    False

To use this the first time, just set the appropriate instance variables and
use the save() method.

    >>> credentials.consumer = consumer
    >>> credentials.access_token = access_token
    >>> credentials.save()

First, the credentials file now exists.

    >>> os.path.exists(credentials_file)
    True

And the credentials are perfectly valid for accessing Launchpad.

    >>> launchpad = Launchpad(credentials=credentials)
    >>> sorted(launchpad.people)
    [...]
    >>> sorted(launchpad.bugs)
    [...]

The credentials can also be retrieved from the file, so that the OAuth request
dance can be avoided.

    >>> credentials = StorableCredentials(credentials_file)
    >>> credentials.consumer.key
    'launchpad-library'
    >>> credentials.consumer.secret
    ''
    >>> credentials.access_token.key
    'hgm2VK35vXD6rLg5pxWw'
    >>> credentials.access_token.secret
    'QzsKbdk2Fr8RsJX3j89VVq5mWVGVQ84Hpwdrg0Cw...

These credentials too, are perfectly usable to access Launchpad.

    >>> launchpad = Launchpad(credentials=credentials)
    >>> sorted(launchpad.people)
    [...]
    >>> sorted(launchpad.bugs)
    [...]

It is an error to save a credentials file when no consumer or access token is
available.

    >>> credentials = StorableCredentials(credentials_file)
    >>> credentials.consumer = None
    >>> credentials.save()
    Traceback (most recent call last):
    ...
    CredentialsFileError: No consumer

    >>> credentials = StorableCredentials(credentials_file)
    >>> credentials.consumer = consumer
    >>> credentials.access_token = None
    >>> credentials.save()
    Traceback (most recent call last):
    ...
    CredentialsFileError: No access token


== Bad credentials ==

If you use the wrong access token, you also get an exception.

    >>> access_token = AccessToken('bad', 'no-secret')
    >>> credentials = Credentials(consumer, access_token)
    >>> launchpad = Launchpad(credentials=credentials)
    Traceback (most recent call last):
    ...
    HTTPError: HTTP Error 403: Forbidden

Also, if you use the wrong access secret, you get an exception.

    >>> access_token = AccessToken('hgm2VK35vXD6rLg5pxWw', 'bad-secret')
    >>> credentials = Credentials(consumer, access_token)
    >>> launchpad = Launchpad(credentials=credentials)
    Traceback (most recent call last):
    ...
    HTTPError: HTTP Error 403: Forbidden


== Clean up ==

    >>> import shutil
    >>> shutil.rmtree(tempdir)
