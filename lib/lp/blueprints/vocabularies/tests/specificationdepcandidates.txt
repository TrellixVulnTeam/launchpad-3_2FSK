== SpecificationDepCandidatesVocabulary ==

All blueprints that can be added as a dependency of the
context blueprint.

First, we set up a product with three blueprints.

    >>> from canonical.launchpad.interfaces import (
    ...     ISpecificationSet, SpecificationDefinitionStatus)
    >>> evolution = product_set.getByName('evolution')
    >>> foobar_person = person_set.getByName('name16')
    >>> foobar_person.displayname
    u'Foo Bar'
    >>> specset = getUtility(ISpecificationSet)
    >>> spec_a = specset.new('spec-a', 'Spec A',
    ...     'http://www.example.org/SpecA', 'The first spec',
    ...     SpecificationDefinitionStatus.APPROVED, foobar_person,
    ...     product=evolution)
    >>> spec_b = specset.new('spec-b', 'Spec B',
    ...     'http://www.example.org/SpecB', 'The second spec',
    ...     SpecificationDefinitionStatus.APPROVED, foobar_person,
    ...     product=evolution)
    >>> spec_c = specset.new('spec-c', 'Spec C',
    ...     'http://www.example.org/SpecC', 'The third spec',
    ...     SpecificationDefinitionStatus.APPROVED, foobar_person,
    ...     product=evolution)
    >>> sorted([spec.name for spec in evolution.specifications()])
    [u'spec-a', u'spec-b', u'spec-c']

The dependency candidates for spec_a are all blueprints for evolution
except for spec_a itself.

    >>> vocab = vocabulary_registry.get(
    ...     spec_a, "SpecificationDepCandidates")
    >>> sorted([term.value.name for term in vocab])
    [u'spec-b', u'spec-c']

Dependency candidate come only from the same product of the blueprint
they depend on.

    >>> unrelated_spec = specset.new('unrelated-spec', 'Unrelated Spec',
    ...     'http://example.com/SpecU', 'A spec unrelated to Evolution',
    ...     SpecificationDefinitionStatus.APPROVED, foobar_person,
    ...     product=firefox)
    >>> vocab = vocabulary_registry.get(
    ...     spec_a, "SpecificationDepCandidates")
    >>> unrelated_spec in vocab
    False
    >>> [term.value.product for term in vocab
    ...  if term.value.product != evolution]
    []

We mark spec_b as a dependency of spec_a and spec_c as a dependency
of spec_b.

    >>> spec_a.createDependency(spec_b)
    <SpecificationDependency at ...>
    >>> [spec.name for spec in spec_a.dependencies]
    [u'spec-b']

    >>> spec_b.createDependency(spec_c)
    <SpecificationDependency at ...>
    >>> [spec.name for spec in spec_b.dependencies]
    [u'spec-c']

No circular dependencies - the vocabulary excludes specifications that
are a dependency of the context spec.

    >>> spec_a in spec_b.all_blocked
    True
    >>> spec_b in spec_c.all_blocked
    True
    >>> vocab = vocabulary_registry.get(
    ...     spec_c, "SpecificationDepCandidates")
    >>> spec_a in [term.value for term in vocab]
    False

This vocabulary provides the IHugeVocabulary interface.

    >>> from canonical.launchpad.webapp.testing import verifyObject
    >>> from canonical.launchpad.webapp.vocabulary import IHugeVocabulary
    >>> verifyObject(IHugeVocabulary, vocab)
    True

The search() method returns specifications within the vocabulary
that matches the search string. The string is matched against the name,
or fallbacks to a full text search.

    >>> vocab = get_naked_vocab(spec_a, "SpecificationDepCandidates")
    >>> list(vocab.search('spec-b')) == [spec_b]
    True
    >>> list(vocab.search('third')) == [spec_c]
    True

The search method uses the SQL `LIKE` operator, with the values quoted
appropriately. Queries conataining regual expression operators, for
example, will simply look for the respective characters within the
vocabulary's item (this used to be the cause of an OOPS, see
https://bugs.edge.launchpad.net/blueprint/+bug/139385 for more details).

    >>> list(vocab.search('*'))
    []
