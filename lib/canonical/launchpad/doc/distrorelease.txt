Distro Releases
===============

From the DerivationOverview spec[1]:

    A distribution of GNU/Linux comprises a set of packages, an installer,
    possibly a live-CD, some amount of metadata associated with the arrangement
    of those elements and also a lot of information on managing it.

A distro release is a given version of a distribution. So, for Ubuntu, there
are releases (or planned releases) like "warty", "hoary" and "bendy".

Distro releases are retrieved with the IDistroReleaseSet utility, much like
people are retrieved with the IPersonSet utility, or bug tasks are retrieved
with the IBugTaskSet utility.

The IDistroReleaseSet utility is accessed in the usual fashion:

    >>> from zope.component import getUtility
    >>> from canonical.launchpad.interfaces import (
    ...     IDistroReleaseSet, IDistributionSet)
    >>> distroreleaseset = getUtility(IDistroReleaseSet)

To retrieve a specific release of a distribution, use IDistroReleaseSet.get:

    >>> warty = distroreleaseset.get(1)
    >>> print warty.name
    warty
    >>> print warty.fullreleasename
    Ubuntu Warty

Or IDistroReleaseSet.findByName:

    >>> for distrorelease in distroreleaseset.findByName("warty"):
    ...     print distrorelease.name
    warty

To get one specific release by name, use queryByName:

    >>> ubuntu = getUtility(IDistributionSet).getByName("ubuntu")

    >>> warty = distroreleaseset.queryByName(ubuntu, "warty")
    >>> warty.name
    u'warty'

If the release by that name doesn't exist, None will be returned:

    >>> foobar = distroreleaseset.queryByName(ubuntu, "foobar")
    >>> print foobar
    None

Or IDistroReleaseSet.findByVersion:

    >>> for distrorelease in distroreleaseset.findByVersion("5.04"):
    ...     print distrorelease.name
    hoary

To search the set of IDistroReleases, use IDistroReleaseSet.search:

    >>> ubuntu_releases = distroreleaseset.search(
    ...     distribution=ubuntu, isreleased=True, orderBy="-datereleased")
    >>> [release.name for release in ubuntu_releases]
    [u'warty']

    >>> all_ubuntu_releases = distroreleaseset.search(distribution=ubuntu)
    >>> all_ubuntu_releases.count()
    4

DistroRelease.getPublishedReleases:

    >>> from canonical.launchpad.database import SourcePackageName, DistroRelease
    >>> warty2 = DistroRelease.get(1)

Passing a ISourcePackageName as argument:

    >>> prs = warty2.getPublishedReleases(
    ...       SourcePackageName.byName('mozilla-firefox'))
    >>> print len(prs)
    1
    >>> print prs[0].sourcepackagerelease.sourcepackagename.name
    mozilla-firefox

Passing a string name:

    >>> print len(warty2.getPublishedReleases('mozilla-firefox'))
    1

Including pending publication records in the result:

    >>> print len(warty2.getPublishedReleases('mozilla-firefox',
    ...           include_pending=True))
    2

Not found as empty list:

    >>> print len(warty2.getPublishedReleases('nosuchpackage'))
    0


DistroRelease.getBinaryPackagePublishing will return
BinaryPackagePublishing objects for the DistroRelease:

    >>> from canonical.launchpad.database import DistroRelease
    >>> warty = DistroRelease.get(1)
    >>> bpp = warty.getBinaryPackagePublishing()
    >>> print bpp.count()
    4
    >>> print list(bpp)[0].binarypackagerelease.binarypackagename.name
    mozilla-firefox
    >>> bpp = warty.getBinaryPackagePublishing(name="nosuchpackage")
    >>> print bpp.count()
    0
    >>> bpp = warty.getBinaryPackagePublishing(version="nosuchversion")
    >>> print bpp.count()
    0
    >>> bpp = warty.getBinaryPackagePublishing(archtag="nosucharch")
    >>> print bpp.count()
    0
    >>> bpp = warty.getBinaryPackagePublishing(sourcename="nosuchsource")
    >>> print bpp.count()
    0

Package searching
-----------------

You can search through binary packages publishing in a distribution
release by using the searchPackages method, which uses magical fti:

    >>> len(warty.searchPackages("pmount"))
    1

This also works for small or weirdly named packages that don't work
through fti, and even for substrings:

    >>> len(warty.searchPackages("linux-2.6.12"))
    1
    >>> len(warty.searchPackages("at"))
    1
    >>> len(warty.searchPackages("inux-2"))
    1

CVE BugTasks on a Distro Release
--------------------------------

A distro release should know what CVE-related bug tasks exist on it, and
what state they are in. We should be able to find open, and closed,
bugtasks, using this API. Based on the sample data we know the following
about Debian:

    >>> woody = distroreleaseset.get(6)
    >>> tasks = woody.open_cve_bugtasks
    >>> for task in tasks:
    ...     print task.id
    20

There should be NO resolved CVE tasks:

    >>> tasks = woody.resolved_cve_bugtasks
    >>> print tasks.count()
    0

DistroReleases have components and sections
-------------------------------------------

A distrorelease has some number of components and/or sections which
are valid for that distrorelease. These selections are used by (among
other things) the uploader for validating incoming uploads.

   >>> hoary = distroreleaseset.get(3)
   >>> for c in hoary.components:
   ...     print c.name
   main
   restricted
   >>> for s in hoary.sections:
   ...     print s.name
   editors

   >>> from canonical.launchpad.interfaces import (
   ...    IComponentSet, ISectionSet)
   >>> univ = getUtility(IComponentSet).ensure('universe')
   >>> web = getUtility(ISectionSet).ensure('web')

   >>> hoary.addComponent(univ)
   >>> hoary.addSection(web)

   >>> for c in hoary.components:
   ...     print c.name
   main
   restricted
   universe

   >>> for s in hoary.sections:
   ...     print s.name
   web
   editors


[1] https://wiki.launchpad.canonical.com/DerivationOverview

DistroReleases can be initialised from their parents
----------------------------------------------------

When a distrorelease is derived from another distrorelease (be it a
derivative distribution, or simply the next release in a sequence from
Ubuntu) we need to initialise the new release with quite a lot of
information. Not least of which is the section and component
selections and the publishing information for the distrorelease.

DistroRelease provides us with a method for doing this which carefully
goes behind the back of sqlobject to copy potentially tens of
thousands of rows around in order to set up a distrorelease.

IDistroRelease lists a series of preconditions for performing an
initialisation. In particular the initialiser won't overwrite
publishing records etc. Essentially this is a "Do not push this button
again" type set of assertions.

   >>> login("foo.bar@canonical.com")
   >>> humpy = distroreleaseset.new(ubuntu, 'humpy', 'Humpy Hippo',
   ...                              'The Humpy Hippo', 'Fat', 'Yo Momma',
   ...                              '99.2',hoary, hoary.owner)
   >>> humpy_i386 = humpy.newArch('i386', hoary['i386'].processorfamily,
   ...                            True, humpy.owner)
   >>> humpy.nominatedarchindep = humpy_i386
   >>> humpy.initialiseFromParent()
   >>> len(hoary.getPublishedReleases('pmount'))
   1
   >>> len(humpy.getPublishedReleases('pmount'))
   1
   >>> len(hoary['i386'].getReleasedPackages('pmount'))
   1
   >>> len(humpy_i386.getReleasedPackages('pmount'))
   1

DistroRelease can build meta objects for packages
-------------------------------------------------

   >>> from zope.interface.verify import verifyObject
   >>> from canonical.launchpad.interfaces import (
   ...     ISourcePackage,
   ...     IDistroReleaseBinaryPackage,
   ...     IDistroReleaseSourcePackageRelease,
   ...     ISourcePackagePublishingHistory)


   >>> pmount_src_name =  SourcePackageName.byName('pmount')
   >>> pmount_source = hoary.getSourcePackage(pmount_src_name)
   >>> ISourcePackage.providedBy(pmount_source)
   True

   >>> from canonical.launchpad.database.binarypackagename import (
   ...                                       BinaryPackageName)
   >>> pmount_bin_name =  BinaryPackageName.byName('pmount')
   >>> pmount_binary = hoary.getBinaryPackage(pmount_bin_name)
   >>> IDistroReleaseBinaryPackage.providedBy(pmount_binary)
   True

   >>> from canonical.launchpad.database.sourcepackagerelease import (
   ...                                           SourcePackageRelease)
   >>> pmount_rel = SourcePackageRelease.selectOneBy(
   ...     sourcepackagenameID=pmount_src_name.id, version='0.1-1')
   >>> pmount_rel.sourcepackagename.name
   u'pmount'

   >>> pmount_srcrel = hoary.getSourcePackageRelease(pmount_rel)
   >>> IDistroReleaseSourcePackageRelease.providedBy(pmount_srcrel)
   True

Check some properties of DRSPR meta class

Entire publishing history:

   >>> pmount_srcrel.publishing_history.count()
   1

Most recent published history row:

   >>> spph = pmount_srcrel.current_published
   Traceback (most recent call last):
   ...
   NotFoundError: u'Source package pmount not published in hoary'

   >>> netapplet_srcrel =  hoary.getSourcePackage('netapplet').currentrelease
   >>> spph = netapplet_srcrel.current_published
   >>> verifyObject(ISourcePackagePublishingHistory, spph)
   True

   >>> spph.section.name
   u'web'

Perform `post publication` override:

   >>> new_section = getUtility(ISectionSet)['base']

   >>> netapplet_srcrel.changeOverride(new_section=new_section)
   >>> pub_hist = netapplet_srcrel.publishing_history
   >>> pub_hist.count()
   2

Override information about 'pmount' is pending publication:

   >>> pub_hist[0].status.name, pub_hist[0].section.name
   ('PENDING', u'base')

Supersede current publication:

   >>> superseded_netapplet = netapplet_srcrel.supersede()
   >>> netapplet_srcrel.publishing_history.count()
   2

   XXX cprov 20060322: Misteriously we cannot direct access attributes
   of a SSPPH objects within the tests, but we do this for SBPPH in
   distroarchrelease.txt. wth ?

   >>> superseded_netapplet.status.name, superseded_netapplet.datesuperseded
   Traceback (most recent call last):
   ...
   ForbiddenAttribute: ('status', <SecureSourcePackagePublishingHistory...)

   >>> from zope.security.proxy import removeSecurityProxy
   >>> naked_hist = removeSecurityProxy(superseded_netapplet)

   >>> naked_hist.status.name, naked_hist.datesuperseded
   ('SUPERSEDED', CURRENT_TIMESTAMP AT TIME ZONE 'UTC')




Specification Listings
======================

We should be able to get lists of specifications in different states
related to a distrorelease.

Basically, we can filter by completeness, and by whether or not the spec is
informational.

 >>> distroset = getUtility(IDistributionSet)
 >>> kubuntu = distroset.getByName("kubuntu")
 >>> krunch = kubuntu.getRelease("krunch")
 >>> from canonical.lp.dbschema import SpecificationFilter

First, there should be one informational specs for krunch:

 >>> filter = [SpecificationFilter.INFORMATIONAL]
 >>> krunch.specifications(filter=filter).count()
 1


There are 2 completed specs for Krunch:

 >>> filter = [SpecificationFilter.COMPLETE]
 >>> for spec in kubuntu.specifications(filter=filter):
 ...    print spec.name, spec.is_complete
 thinclient-local-devices True
 usplash-on-hibernation True


And there are 2 incomplete specs:

 >>> filter = [SpecificationFilter.INCOMPLETE]
 >>> for spec in krunch.specifications(filter=filter):
 ...     print spec.name, spec.is_complete
 cluster-installation False
 revu False


If we ask for all specs, we get them in the order of priority.

 >>> filter = [SpecificationFilter.ALL]
 >>> for spec in krunch.specifications(filter=filter):
 ...    print spec.priority.title, spec.name
 Essential cluster-installation
 High revu
 Medium thinclient-local-devices
 Low usplash-on-hibernation
 Proposed kde-desktopfile-langpacks
 Not krunch-desktop-plan


With a distrorelease, we can ask for ACCEPTED, PROPOSED and DECLINED specs:

 >>> filter=[SpecificationFilter.ACCEPTED]
 >>> for spec in kubuntu.specifications(filter=filter):
 ...     print spec.name, spec.goalstatus.title
 cluster-installation Accepted
 revu Accepted
 thinclient-local-devices Accepted
 usplash-on-hibernation Accepted

 >>> filter=[SpecificationFilter.PROPOSED]
 >>> for spec in kubuntu.specifications(filter=filter):
 ...     print spec.name, spec.goalstatus.title
 kde-desktopfile-langpacks Proposed
 
 >>> filter=[SpecificationFilter.DECLINED]
 >>> for spec in kubuntu.specifications(filter=filter):
 ...     print spec.name, spec.goalstatus.title
 krunch-desktop-plan Declined
 

And if we ask just for specs, we get BOTH the incomplete and the complete
ones that have been accepted.

 >>> for spec in krunch.specifications():
 ...     print spec.name, spec.is_complete, spec.goalstatus.title
 cluster-installation False Accepted
 revu False Accepted
 thinclient-local-devices True Accepted
 usplash-on-hibernation True Accepted


Drivers
=======

Distributions have drivers, who are people that have permission to approve
bugs and features for specific releases. The rules are that:

 1. a "driver" can be set on either Distribution or DistroRelease
 2. drivers are only actually relevant on a DistroRelease, because thats the
    granularity at which we track spec/bug targeting
 3. the important attribute is ".drivers" on a distrorelease, it is
    calculated based on the combination of owners and drivers in the
    distribution and the distrorelease. It is a LIST of drivers, which might
    be empty, or have one or two people/teams in it.
 4. If the release has a driver, then that driver is in the list.
 5. If the distribution has a driver then that is in the list too, otherwise
 6. If neither the release nor the distribution has a driver, then the
    distribution registrant is the driver.

We test these rules below.


First, we look at a release where both the distribution and release have
drivers. Kubuntu should be a good example.

 >>> kubuntu.driver.name
 u'jblack'
 >>> krunch.driver.name
 u'edgar'
 >>> for d in krunch.drivers:
 ...     print d.name
 edgar
 jblack


Now, we look at a release where there is a driver on the release but not on
the distribution.

 >>> debian = distroset.getByName('debian')
 >>> print debian.driver
 None
 >>> sarge = debian.getRelease('sarge')
 >>> print sarge.driver.name
 jdub
 >>> for d in sarge.drivers:
 ...     print d.name
 jdub


Now, a release where there is no driver on the release but there is a driver
on the distribution.

 >>> redhat = distroset.getByName('redhat')
 >>> print redhat.driver.name
 jblack
 >>> six = redhat.getRelease('six')
 >>> print six.driver
 None
 >>> for d in six.drivers:
 ...     print d.name
 jblack


Finally, on a release where neither the distribution nor the release have a
driver. Here, we expect the driver to be the owner of the distribution
(because this is the "commonest fallback").

 >>> sid = debian.getRelease('sid')
 >>> print debian.driver
 None
 >>> print debian.owner.name
 sabdfl
 >>> print sid.driver
 None
 >>> print sid.owner.name
 jdub

 >>> for d in sid.drivers:
 ...     print d.name
 sabdfl


