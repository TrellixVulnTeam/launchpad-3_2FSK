= Entries =

Most objects published by a lazr.restful web service are entries:
self-contained data structures with an independent existence from any
other entry. Entries are distinguished from collections, which are
groupings of entries.

All entries in a web service work pretty much the same way. This
document illustrates the general features of entries, using the
example web service's dishes and recipes as examples.

  >>> from canonical.lazr.testing.webservice import CookbookWebServiceCaller
  >>> webservice = CookbookWebServiceCaller()


== Reading ==

It's possible to get a JSON 'representation' of an entry by sending a
GET request to the entry's URL.

Here we see that the cookbook 'Everyday Greens' is a vegetarian cookbook.

  >>> from urllib import quote
  >>> greens_url = quote("/cookbooks/Everyday Greens")
  >>> webservice.get(greens_url).jsonBody()['cuisine']
  u'Vegetarian'

Data is served encoded in UTF-8, and a good client will automatically
convert it into Unicode.

  >>> construsions_url = quote("/cookbooks/Construsions un repas")
  >>> webservice.get(construsions_url).jsonBody()['cuisine']
  u'Fran\xe7ais'


== Redirects ==

TBA.


== Content negotiation ==

By varying the 'Accept' header, the client can request either a JSON
or XHTML representation of an entry, or a WADL description of the
entry's capabilities.

  >>> def negotiated_type(accept_header, uri='/cookbooks/Everyday%20Greens'):
  ...     return webservice.get(uri, accept_header).getHeader('Content-Type')

  >>> negotiated_type('application/json')
  'application/json'

  >>> negotiated_type('application/xhtml+xml')
  'application/xhtml+xml'

  >>> negotiated_type('application/vd.sun.wadl+xml')
  'application/vd.sun.wadl+xml'

  >>> negotiated_type(None)
  'application/json'

  >>> negotiated_type('text/html')
  'application/json'

  >>> negotiated_type('application/json, application/vd.sun.wadl+xml')
  'application/json'

  >>> negotiated_type('application/json, application/xhtml+xml')
  'application/json'

  >>> negotiated_type('application/vd.sun.wadl+xml, text/html, '
  ...                 'application/json')
  'application/vd.sun.wadl+xml'

  >>> negotiated_type('application/json;q=0.5, application/vd.sun.wadl+xml')
  'application/vd.sun.wadl+xml'

  >>> negotiated_type('application/json;q=0, application/xhtml+xml;q=0.05,'
  ...                 'application/vd.sun.wadl+xml;q=0.1')
  'application/vd.sun.wadl+xml'

The client can also set the 'ws.accept' query string variable, which
will take precedence over any value set for the Accept header.

  >>> def qs_negotiated_type(query_string, header):
  ...     uri = '/cookbooks/Everyday%20Greens?ws.accept=' + query_string
  ...     return negotiated_type(header, uri)

  >>> qs_negotiated_type('application/json', None)
  'application/json'

  >>> qs_negotiated_type('application/json', 'application/xhtml+xml')
  'application/json'

  >>> negotiated_type('application/json;q=0, application/xhtml+xml;q=0.5,'
  ...                 'application/json;q=0.5, application/xhtml+xml;q=0,')
  'application/xhtml+xml'


== XHTML representations ==

Every entry has an XHTML representation. The default representation is
a simple definition list.

  >>> print webservice.get(greens_url, 'application/xhtml+xml')
  HTTP/1.1 200 Ok
  ...
  <dl ...>
  ...
  </dl>

But it's possible to define a custom HTML view for a particular object
type. Here's a simple view that serves some hard-coded HTML.

  >>> class DummyView:
  ...
  ...     def __init__(*args):
  ...         pass
  ...
  ...     def __call__(*args):
  ...         return "<html>foo</html>"

Register the view as the IWebServiceClientRequest view for an ICookbook entry...

  >>> from canonical.lazr.interfaces.rest import IWebServiceClientRequest
  >>> from canonical.lazr.rest.example.interfaces import ICookbook
  >>> from zope.interface.interfaces import IInterface
  >>> view_name = "canonical.lazr.rest.resource.EntryResource"
  >>> from zope.component import getGlobalSiteManager
  >>> manager = getGlobalSiteManager()
  >>> manager.registerAdapter(
  ...      factory=DummyView, required=[ICookbook, IWebServiceClientRequest],
  ...      provided=IInterface, name=view_name)

...and the XHTML representation of an ICookbook will be the result of
calling a DummyView object.

  >>> print webservice.get(greens_url, 'application/xhtml+xml')
  HTTP/1.1 200 Ok
  ...
  <html>foo</html>

Before we continue, here's some cleanup code to remove the custom view
we just defined.

  >>> from zope.component import getGlobalSiteManager
  >>> ignored = getGlobalSiteManager().unregisterAdapter(
  ...      factory=DummyView, required=[ICookbook, IWebServiceClientRequest],
  ...      provided=IInterface, name=view_name)

  >>> print webservice.get(greens_url, 'application/xhtml+xml')
  HTTP/1.1 200 Ok
  ...
  <dl ...>
  ...
  </dl>


== Named operations ==

Some entries support custom operations through GET. The custom
operation to be invoked is named in the query string's 'ws.op'
argument. You can search a cookbook's recipes by specifying
the 'find_recipes' operation.

  >>> joy_url = quote("/cookbooks/The Joy of Cooking")
  >>> recipes = webservice.get(
  ...     "%s?ws.op=find_recipes&search=e" % joy_url).jsonBody()
  >>> sorted([r['self_link'] for r in recipes['entries']])
  [u'...Baked%20beans', u'...Roast%20chicken']

Some entries support custom operations through POST. You can invoke a
custom operation to modify a cookbook's cuisine, making it seem more
interesting.

  >>> print webservice.get(joy_url).jsonBody()['cuisine']
  General

  >>> print webservice.named_post(joy_url, 'make_more_interesting', {})
  HTTP/1.1 200 Ok
  ...

  >>> print webservice.get(joy_url).jsonBody()['cuisine']
  Nouvelle General

Custom operations may have error handling.

  >>> print webservice.named_post(joy_url, 'make_more_interesting', {})
  HTTP/1.1 400 Bad Request
  ...
  The 'Nouvelle' trick can't be used on this cookbook because its
  cuisine is already 'Nouvelle'.
  ...

Trying to invoke a nonexistent custom operation yields an error.

  >>> print webservice.get("%s?ws.op=no_such_operation" % joy_url)
  HTTP/1.1 400 Bad Request
  ...
  No such operation: no_such_operation


== Modification ==

It's possible to modify an entry by sending to the server a document
asserting what the entry should look like. The document may only
describe part of the entry's new state, in which case the client
should use the PATCH HTTP method. Or it may completely describe the
entry's state, in which case the client should use PUT.

  >>> import simplejson
  >>> def modify_cookbook(cookbook, representation, method, headers=None):
  ...     "A helper function to send a PUT or PATCH request to a cookbook."
  ...     new_headers = {'Content-type': 'application/json'}
  ...     if headers is not None:
  ...         new_headers.update(headers)
  ...     return webservice('/cookbooks/' + quote(cookbook), method,
  ...                       simplejson.dumps(representation),
  ...                       headers)

Here we use the web service to change the "Everyday Greens" cookbook
so that its cuisine is in uppercase. The data returned is the new JSON
representation of the object.

  >>> print modify_cookbook('Everyday Greens', {'cuisine' : 'VEGETARIAN'},
  ...                       'PATCH')
  HTTP/1.1 209 Content Returned
  ...
  Content-Type: application/json
  <BLANKLINE>
  {...}

  >>> print webservice.get(greens_url).jsonBody()['cuisine']
  VEGETARIAN

A modification might cause an entry's address to change. Here we use
the web service to change the cookbook's name to 'Everyday Greens 2'.

  >>> print modify_cookbook('Everyday Greens',
  ...                       {'name' : 'Everyday Greens 2'}, 'PATCH')
  HTTP/1.1 301 Moved Permanently
  ...
  Location: http://.../Everyday%20Greens%202
  <BLANKLINE>

At this point we can no longer manipulate this cookbook by sending
HTTP requests to http://cookbooks.dev/1.0/cookbooks/Everyday%20Greens,
because that cookbook now 'lives' at
http://cookbooks.dev/1.0/cookbooks/Everyday%20Greens%202. To change
the cookbook name back, we need to send a PATCH request to the new
address.

  >>> print modify_cookbook('Everyday Greens 2',
  ...                       {'name' : 'Everyday Greens'}, 'PATCH')
  HTTP/1.1 301 Moved Permanently
  ...
  Location: http://.../cookbooks/Everyday%20Greens
  <BLANKLINE>

The PATCH HTTP method is useful for simple changes, but not all HTTP
clients support PATCH. It's possible to fake a PATCH request with
POST, by setting the X-HTTP-Method-Override header to "PATCH". Because
Firefox 3 mangles the Content-Type header for POST requests, you may
also set the X-Content-Type-Override header, which will override the
value of Content-Type.

  >>> print modify_cookbook('Everyday Greens',
  ...     {'cuisine' : 'VEGETARIAN/VEGAN'}, 'POST',
  ...     {'X-HTTP-Method-Override' : 'PATCH',
  ...      'Content-Type': 'not-a-valid-content/type',
  ...      'X-Content-Type-Override': 'application/json'})
  HTTP/1.1 209 Content Returned
  ...

If you try to use X-HTTP-Method-Override when the underlying HTTP
method is not POST, you'll get an error.

  >>> print modify_cookbook('Everyday Greens',
  ...     {}, 'GET', {'X-HTTP-Method-Override' : 'PATCH'})
  HTTP/1.1 400 Bad Request
  ...
  X-HTTP-Method-Override can only be used with a POST request.

Even if a client supports PATCH, sometimes it's easier to GET a
document, modify it, and send it back. If you have the full document
at hand, you can use the PUT method.

We happen to have a full document from when we sent a GET request to
the 'Everday Greens' cookbook. Modifying that document and PUTting it
back is less work than constructing a new document and sending it with
PATCH. As with PATCH, a successful PUT serve the new representation of
the object that was modified.

  >>> greens = webservice.get(greens_url).jsonBody()
  >>> print greens['cuisine']
  VEGETARIAN/VEGAN

  >>> greens['cuisine'] = 'Vegetarian'
  >>> print modify_cookbook('Everyday Greens', greens, 'PUT')
  HTTP/1.1 209 Content Returned
  ...
  <BLANKLINE>
  {...}

  >>> greens = webservice.get(greens_url).jsonBody()
  >>> print greens['cuisine']
  Vegetarian

Because our patch format is the same as our representation format (a
JSON hash), any document that works with a PUT request will also work
with a PATCH request.

  >>> print modify_cookbook('Everyday Greens', greens, 'PATCH')
  HTTP/1.1 209 Content Returned
  ...


=== Content negotiation during modification ===

When making a PATCH, you don't have to get a JSON representation
back. You can also get an HTML representation.

  >>> print modify_cookbook('Everyday Greens', greens, 'PATCH',
  ...                       headers={'Accept': 'application/xhtml+xml'})
  HTTP/1.1 209 Content Returned
  ...
  Content-Type: application/xhtml+xml
  <BLANKLINE>
  <?xml version="1.0"?>
  ...

You can even get a WADL representation, though that's pretty useless.

  >>> headers = {'Accept':'application/vd.sun.wadl+xml'}
  >>> print modify_cookbook('Everyday Greens', greens, 'PATCH',
  ...                       headers=headers)
  HTTP/1.1 209 Content Returned
  ...
  Content-Type: application/vd.sun.wadl+xml
  <BLANKLINE>
  ...


=== Server-side modification ===

Sometimes the server will transparently modify a value sent by the
client, to clean it up or put it into a canonical form. For this
purpose, the response to a PUT or PATCH request includes a brand new
JSON representation of the object, so that the client can know whether
and which changes were made.

Here's an example. If a cookbook's name contains leading or trailing
whitespace, the whitespace will be stripped.

  >>> greens = webservice.get(greens_url).jsonBody()
  >>> greens['cuisine']
  u'Vegetarian'
  >>> first_etag = greens['http_etag']

Send in a cuisine with leading or trailing whitespace and it'll be
transparently trimmed. The document returned from the POST request
will be the new representation, modified by both client and server.

  >>> greens = webservice(greens_url, "PATCH",
  ...                     simplejson.dumps({'cuisine' : '  Veg '}),
  ...                     {'Content-type': 'application/json'}).jsonBody()
  >>> greens['cuisine']
  u'Veg'
  >>> greens['http_etag'] == first_etag
  False

The canonicalization works for PUT requests as well.

  >>> greens['cuisine'] = "    Vegetarian "
  >>> greens = webservice(greens_url, "PUT", simplejson.dumps(greens),
  ...                     {'Content-type': 'application/json'}).jsonBody()
  >>> greens['cuisine']
  u'Vegetarian'
