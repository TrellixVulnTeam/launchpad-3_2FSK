Adding BugTasks
===============

If a bug occurs in more than one place, you can request a fix in some
other software. You can request a fix in either a product or a
distribution. Let's start with a product, this is done using
+upstreamtask.

    >>> login('test@canonical.com')
    >>> from zope.component import getView
    >>> from canonical.launchpad.interfaces import IBugSet
    >>> bug_four = getUtility(IBugSet).get(4)
    >>> len(bug_four.bugtasks)
    1
    >>> firefox_task = bug_four.bugtasks[0]
    >>> from canonical.launchpad.webapp.servers import LaunchpadTestRequest

Some of the setup is done just before the view is rendered. Let's
create a helper function that makes sure the view is set up properly.
We don't care about the actual rendering of the page, so we override
the index template.

    >>> def get_and_setup_view(context, name, form):
    ...     view = getView(context, name, LaunchpadTestRequest(form=form))
    ...     view.index = lambda: ''
    ...     return view
    >>> add_task_view = get_and_setup_view(
    ...     firefox_task, '+upstreamtask', form={})

We haven't posted the form, so we'll see one button. In order to set
everything up correctly, we have to call render_upstreamtask().

    >>> add_task_view.render_upstreamtask()
    ''
    >>> [action.label for action in add_task_view.actions]
    [u'Continue']

If we POST the form without entering any information, it will complain
that product is required:

    >>> form = {
    ...     'field.actions.request_fix': '', 'field.product': '',
    ...     'field.bug_url': ''}
    >>> add_task_view = get_and_setup_view(firefox_task, '+upstreamtask', form)
    >>> add_task_view.render_upstreamtask()
    ''
    >>> add_task_view.getWidgetError('product')
    u'Required input is missing.'

In order to show that all the events get fired off, let's create an
event listener and register it:

    >>> from zope.interface import Interface
    >>> from canonical.launchpad.event.interfaces import ISQLObjectCreatedEvent
    >>> from canonical.launchpad.ftests.event import TestEventListener

    >>> def on_created_event(object, event):
    ...     print "SQLObjectCreatedEvent: %r" % object

    >>> on_created_listener = TestEventListener(
    ...     Interface, ISQLObjectCreatedEvent, on_created_event)


If we specify a valid product, no errors will occur, and a bugtask will
be created:

    >>> form['field.product'] = u'evolution'
    >>> add_task_view = get_and_setup_view(firefox_task, '+upstreamtask', form)
    >>> add_task_view.render_upstreamtask()
    SQLObjectCreatedEvent: <BugTask at ...>
    ''

    >>> for bugtask in bug_four.bugtasks:
    ...     print bugtask.targetname
    evolution (upstream)
    firefox (upstream)

This worked without any problems since Evolution does use Malone as its
offical bug tracker.

    >>> evolution_task = bug_four.bugtasks[0]
    >>> evolution_task.target.official_malone
    True

If we try to add a task for ALSA, which doesn't use Malone, it won't go
as smoothly as above.

    >>> form['field.product'] = u'alsa-utils'
    >>> request = LaunchpadTestRequest(
    ...     form={'FORM_SUBMIT': '', 'field.product': 'alsa-utils',
    ...           'field.bug_url': ''})
    >>> add_task_view = get_and_setup_view(firefox_task, '+upstreamtask', form)
    >>> add_task_view.render_upstreamtask()
    ''

    >>> for bugtask in bug_four.bugtasks:
    ...     print bugtask.targetname
    evolution (upstream)
    firefox (upstream)

As you can see no ALSA was added to the bug. In order to add such a
task, a user has to confirm that he indeed wants to add the task. A
notification is displayed asking the user for confirmation.

    >>> len(add_task_view.errors)
    0
    >>> add_task_view._confirm_new_task
    True
    >>> len(add_task_view.notifications)
    1
    >>> add_task_view.next_url is None
    True

If the user confirms, a bugtask will be added to the bug.

    >>> del form['field.actions.request_fix']
    >>> form['field.actions.confirm'] = u''
    >>> add_task_view = get_and_setup_view(firefox_task, '+upstreamtask', form)
    >>> add_task_view.render_upstreamtask()
    SQLObjectCreatedEvent: <BugTask at ...>
    ''
    >>> add_task_view._confirm_new_task
    False
    >>> add_task_view.next_url is not None
    True

    >>> for bugtask in bug_four.bugtasks:
    ...     print bugtask.targetname
    alsa-utils (upstream)
    evolution (upstream)
    firefox (upstream)

But since no bug watch was specified, the status and importance
are set to the default values.

    >>> alsa_task = bug_four.bugtasks[0]
    >>> alsa_task.target.official_malone
    False
    >>> alsa_task.status.title
    'Unconfirmed'
    >>> alsa_task.importance.title
    'Undecided'

On the same form, we can add a bug watch, by specifying the remote bug
URL. If we don't enter a valid URL, we get an error message.

    >>> del form['field.actions.confirm']
    >>> form['field.product'] = u'alsa-utils'
    >>> form['field.actions.request_fix'] = u''
    >>> form['field.bug_url'] = u'not-a-url'
    >>> add_task_view = get_and_setup_view(firefox_task, '+upstreamtask', form)
    >>> add_task_view.render_upstreamtask()
    ''
    >>> print add_task_view.getWidgetError('bug_url')
    Launchpad doesn't know what kind of bug tracker this URL is pointing at.

Note that this caused the transaction to be aborted, thus the bugtasks
that got added earlier are now gone:

    >>> len(bug_four.bugtasks)
    1

If we specify a valid URL, both the task and the bug watch will be added
without any confirmation needee:

    >>> form['field.bug_url'] = (
    ...     u'http://bugzilla.gnome.org/bugs/show_bug.cgi?id=84')
    >>> add_task_view = get_and_setup_view(firefox_task, '+upstreamtask', form)
    >>> add_task_view.render_upstreamtask()
    SQLObjectCreatedEvent: <BugWatch at ...>
    SQLObjectCreatedEvent: <BugTask at ...>
    ''

    >>> add_task_view._confirm_new_task
    False

    >>> for bugtask in bug_four.bugtasks:
    ...     print bugtask.targetname
    alsa-utils (upstream)
    firefox (upstream)

    >>> for bugwatch in bug_four.watches:
    ...     print "%s: %s" % (bugwatch.bugtracker.title, bugwatch.remotebug)
    GnomeGBug GTracker: 84

The bug watch got linked to the create task, and all the bug task's
attribute got initialised to Unknown. The bugtask will be synced with
the bug watch's status later.

    >>> alsa_task = bug_four.bugtasks[0]
    >>> alsa_task.targetname
    u'alsa-utils (upstream)'
    >>> alsa_task.product.official_malone
    False
    >>> alsa_task.bugwatch == bug_four.watches[0]
    True

    >>> alsa_task.status.title
    'Unknown'
    >>> alsa_task.importance.title
    'Unknown'


If we try to add a bug watch together with a product which does use
Malone, an error will occur.

    >>> form['field.product'] = u'evolution'
    >>> form['field.bugtracker'] = u'1'
    >>> form['field.bug_url'] = (
    ...     u'http://bugzilla.gnome.org/bugs/show_bug.cgi?id=168')
    >>> add_task_view = get_and_setup_view(firefox_task, '+upstreamtask', form)
    >>> add_task_view.render_upstreamtask()
    ''
    >>> add_task_view.form_wide_errors
    [u'Bug watches can not be added for Evolution, as it uses Malone as
       its official bug tracker. Alternatives are to add a watch for
       another product, or a comment containing a URL to the related bug
       report.']

There's a method for easily retrieving the target display name for use
on the confirmation page. If we request a fix in an upstream product,
its display name is returned:

    >>> form['field.bug_url'] = u''
    >>> form['field.product'] = u'alsa-utils'
    >>> add_task_view = get_and_setup_view(firefox_task, '+upstreamtask', form)
    >>> add_task_view.render_upstreamtask()
    ''
    >>> add_task_view.getBugTargetName()
    u'alsa-utils'

If we request a fix in a source package, the distribution's display
name is returned.

    >>> del form['field.product']
    >>> form['field.distribution'] = u'debian'
    >>> form['field.sourcepackagename'] = u'evolution'
    >>> add_task_view = get_and_setup_view(firefox_task, '+distrotask', form)
    >>> add_task_view.render_distrotask()
    ''
    >>> add_task_view.getBugTargetName()
    u'Debian'

    >>> on_created_listener.unregister()
