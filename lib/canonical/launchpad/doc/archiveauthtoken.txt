= ArchiveAuthToken =

This content class represents an authorisation token associated with
an IPerson and an IArchive.  The tokens are used to permit Launchpad
users access to a published private archive and are written out to
.htaccess files in the archive's filesystem by the publisher.

See also ArchiveSubscriber.txt.


== Creating new tokens ==

New tokens are created using IArchive.newAuthToken()

Operations with tokens are security protected, so to start with we'll log
in as an unprivileged user.

    >>> login("no-priv@canonical.com")

We can create a new token for name12 to access cprov's PPA like this:

    >>> from canonical.launchpad.interfaces.person import IPersonSet
    >>> cprov = getUtility(IPersonSet).getByName("cprov")
    >>> name12 = getUtility(IPersonSet).getByName("name12")

    >>> new_token = cprov.archive.newAuthToken(name12, "testtoken")
    Traceback (most recent call last):
    ...
    Unauthorized:...

That failed because only people who have launchpad.Append (basically, upload
access) on the context archive are allowed to create tokens.

Users cannot create their own access tokens either.  Log in as name12:

    >>> login("test@canonical.com")
    >>> new_token = cprov.archive.newAuthToken(name12, "testtoken")
    Traceback (most recent call last):
    ...
    Unauthorized:...

If we log in as cprov it will work:

    >>> login("celso.providelo@canonical.com")
    >>> token_with_random_string = cprov.archive.newAuthToken(name12)

By default the tokens are 20 characters long.

    >>> print len(token_with_random_string.token)
    20

We can also specify our own token for testing purposes:

    >>> new_token = cprov.archive.newAuthToken(name12, "testtoken")

The new token is returned and reflects the data:

    >>> print new_token.archive.title
    PPA for Celso Providelo

    >>> print new_token.person.name
    name12

    >>> print new_token.token
    testtoken

Commit the new token to the database.

    >>> from storm.store import Store
    >>> Store.of(new_token).commit()

Tokens also contain some date information:

    >>> new_token.date_created is not None
    True

    >>> print new_token.date_deactivated
    None


== Retrieving existing tokens ==

The ArchiveAuthTokenSet utility allows you to retrieve tokens by ID and by
the token text itself.  To access tokens you need launchpad.View privilege
which applies to the person in the token and launchpad admins.

    >>> from canonical.launchpad.interfaces.archiveauthtoken import (
    ...     IArchiveAuthTokenSet)
    >>> token_set = getUtility(IArchiveAuthTokenSet)

    >>> login("no-priv@canonical.com")

    >>> token =  token_set.get(new_token.id)
    Traceback (most recent call last):
    ...
    Unauthorized:...

Log in as name12, who is the person in the token.

    >>> login("test@canonical.com")

And retrieve the token by id and by token data:

    >>> print token_set.get(new_token.id).token
    testtoken

    >>> print token_set.getByToken(u"testtoken").person.name
    name12


== Amending Tokens ==

Tokens can only be de-activated after they are created.  The calling user
also needs launchpad.Edit on the token, which means either someone with
IArchive launchpad.Append (as for creating new tokens) or an admin.

    >>> login("no-priv@canonical.com")
    >>> new_token.deactivate()
    Traceback (most recent call last):
    ...
    Unauthorized:...

    >>> login("celso.providelo@canonical.com")
    >>> new_token.deactivate()

Deactivating sets the date_deactivated value.

    >>> new_token.date_deactivated is not None
    True

We can do this as an admin too:

    >>> login("admin@canonical.com")
    >>> new_token.deactivate()
