= Code Imports =

CodeImport objects model the process surrounding the code import service
of Launchpad. A CodeImport object is created by a user requesting an
import, the import source is then reviewed by privileged users. Then
importd, the code import daemon, performs the initial import that
populates the import branch, and updates it regularly.

We can import code from CVS or Subversion.

CodeImports are hidden from regular users currently.  David Allouche is
a member of the vcs-imports team and can access the objects freely.

    >>> login('david.allouche@canonical.com')


== Code import set utility ==

CodeImports are created and found using the ICodeImportSet interface,
which is registered as a utility.

    >>> from canonical.launchpad.interfaces import ICodeImport, ICodeImportSet
    >>> from canonical.launchpad.webapp.testing import verifyObject
    >>> from zope.component import getUtility
    >>> from zope.security.proxy import removeSecurityProxy
    >>> code_import_set = getUtility(ICodeImportSet)
    >>> verifyObject(ICodeImportSet, removeSecurityProxy(code_import_set))
    True

CodeImports record who created them, and we're going to pretend that
this is done by 'No Privileges Person'.

    >>> from canonical.launchpad.interfaces import IPersonSet
    >>> nopriv = getUtility(IPersonSet).getByName('no-priv')


== CodeImport events ==

Most mutating operations affecting code imports should create
CodeImportEvent objects in the database to provide an audit trail.

    >>> from canonical.launchpad.interfaces import ICodeImportEventSet
    >>> event_set = getUtility(ICodeImportEventSet)


== Supported source systems ==

The rcs_type field, which indicates whether the import is from CVS or
Subversion, takes values from the 'RevisionControlSystems' vocabulary.

    >>> from canonical.launchpad.interfaces import RevisionControlSystems
    >>> for item in RevisionControlSystems:
    ...     print item.title
    Concurrent Versions System
    Subversion


=== Import from CVS ===

Code imports from CVS specify the CVSROOT value, and the path to import
in the repository, known as the "module".

    >>> cvs = RevisionControlSystems.CVS
    >>> cvs_root = ':pserver:anonymous@cvs.example.com:/cvsroot'
    >>> cvs_module = 'hello'
    >>> from canonical.launchpad.interfaces import IProductSet
    >>> product = getUtility(IProductSet).getByName('firefox')
    >>> cvs_import = code_import_set.new(
    ...     registrant=nopriv, product=product, branch_name='trunk-cvs',
    ...     rcs_type=cvs, cvs_root=cvs_root, cvs_module=cvs_module)
    >>> verifyObject(ICodeImport, removeSecurityProxy(cvs_import))
    True

When a new code import is created, an email is sent to the each of the
three members of the vcs-imports team.

    >>> import transaction
    >>> transaction.commit()
    >>> from canonical.launchpad.mail import stub
    >>> len(stub.test_emails)
    3
    >>> from canonical.launchpad.helpers import contactEmailAddresses
    >>> from canonical.launchpad.interfaces import ILaunchpadCelebrities
    >>> vcs_imports = getUtility(ILaunchpadCelebrities).vcs_imports
    >>> len(contactEmailAddresses(vcs_imports))
    3
    >>> import email
    >>> message = email.message_from_string(stub.test_emails[0][2])
    >>> print message['subject']
    New code import: firefox/trunk-cvs
    >>> print message['X-Launchpad-Message-Rationale']
    Operator @vcs-imports
    >>> print message.get_payload()
    A new code import has been requested by No Privileges Person:
        http://code.launchpad.dev/~vcs-imports/firefox/trunk-cvs
    -- =
    You are getting this email because you are a member of the vcs-imports team.

Creating a CodeImport object creates a corresponding CodeImportEvent.

    >>> cvs_events = event_set.getEventsForCodeImport(cvs_import)
    >>> [event.event_type.name for event in cvs_events]
    ['CREATE']

The CodeImportSet is also able to retrieve the code imports with the
specified root and module.

    >>> existing_import = code_import_set.getByCVSDetails(
    ...     cvs_root=cvs_root, cvs_module=cvs_module)
    >>> cvs_import == existing_import
    True


=== Import from Subversion ===

Code imports from Subversion specify the URL used with "svn checkout" to
retrieve the tree to import.

    >>> svn = RevisionControlSystems.SVN
    >>> svn_url = 'svn://svn.example.com/trunk'
    >>> svn_import = code_import_set.new(
    ...     registrant=nopriv, product=product, branch_name='trunk-svn',
    ...     rcs_type=svn, svn_branch_url=svn_url)
    >>> verifyObject(ICodeImport, removeSecurityProxy(svn_import))
    True

Creating a CodeImport object creates a corresponding CodeImportEvent.

    >>> svn_events = event_set.getEventsForCodeImport(svn_import)
    >>> [event.event_type.name for event in svn_events]
    ['CREATE']

The CodeImportSet is also able to retrieve the code imports with the
specified subversion branch url.

    >>> existing_import = code_import_set.getBySVNDetails(
    ...     svn_branch_url=svn_url)
    >>> svn_import == existing_import
    True


== Creating a CodeImport from existing data ==

The first production code that creates CodeImports will be a sync
script that creates CodeImports from the existing information in the
ProductSeries table.  The only ProductSeries with such information in
the sample data is evolution/trunk.

    >>> from canonical.launchpad.interfaces import (
    ...     IProductSeriesSet, ImportStatus)
    >>> [series] = getUtility(IProductSeriesSet).searchImports(
    ...     importstatus=ImportStatus.PROCESSING)
    >>> series.product.name
    u'evolution'
    >>> series.name
    u'trunk'
    >>> series.cvsroot
    u':pserver:anonymous@anoncvs.gnome.org:/cvs/gnome'
    >>> series.cvsmodule
    u'evolution'

Once we've found the series, creating a new CodeImport with the same
source details is a fairly simple matter.

    >>> from canonical.launchpad.database.codeimport import CodeImport
    >>> from canonical.launchpad.interfaces import CodeImportReviewStatus
    >>> if series.importstatus in (ImportStatus.SYNCING,
    ...                            ImportStatus.PROCESSING):
    ...     review_status = CodeImportReviewStatus.REVIEWED
    ... else:
    ...     review_status = CodeImportReviewStatus.NEW
    >>> from_existing_import = CodeImport(
    ...     registrant=vcs_imports,
    ...     owner=vcs_imports,
    ...     branch=series.import_branch,
    ...     rcs_type=series.rcstype,
    ...     cvs_root=series.cvsroot,
    ...     cvs_module=series.cvsmodule,
    ...     svn_branch_url=series.svnrepository,
    ...     review_status=review_status)

This CodeImport is associated to the evolution/main ProductSeries
(because the series' import_branch is the branch of the CodeImport):

    >>> from_existing_import.series.name
    u'trunk'


== Updating code import details ==

Members of the VCS Imports team (import operators), or Launchpad
administrators can update the details of the code import, including
the review status.  This is done using the code import methods:
approve; suspend; invalidate and markFailing update the review status
and the other details, and changeDetails just updates the other
details.  All of these methods return a boolean indicating if they
made a change.

    >>> from canonical.launchpad.testing import LaunchpadObjectFactory
    >>> factory = LaunchpadObjectFactory()
    >>> code_import = factory.makeCodeImport(
    ...     svn_branch_url='http://svn.example.com/project')
    >>> print code_import.review_status.title
    Pending Review

When an import operator updates the status of the code import, emails
are sent out to the branch subscribers, and to the members of VCS
Imports.

The logged in user is normally subscribed to the new import as it is
created if done through the web UI, so we'll add nopriv here.

    >>> from canonical.launchpad.interfaces import (
    ...     BranchSubscriptionDiffSize,
    ...     BranchSubscriptionNotificationLevel,
    ...     CodeReviewNotificationLevel)
    >>> subscription = code_import.branch.subscribe(
    ...     nopriv,
    ...     BranchSubscriptionNotificationLevel.FULL,
    ...     BranchSubscriptionDiffSize.NODIFF,
    ...     CodeReviewNotificationLevel.FULL)

    >>> from canonical.launchpad.tests.mail_helpers import (
    ...     pop_notifications, print_emails)
    >>> ignore_old_emails = pop_notifications()
    >>> code_import.approve({}, nopriv)
    True
    >>> print_emails(group_similar=True)
    From: No Privileges Person <no-priv@canonical.com>
    To: no-priv@canonical.com
    Subject: Code import product.../name... status: Reviewed
    <BLANKLINE>
    The import has been approved and an import will start shortly.
    -- =
    http://code.launchpad.dev/~vcs-imports/product.../name...
    You are receiving this email as you are subscribed to the branch.
    To unsubscribe from this branch go to http://code.launchpad.dev/~vcs-import=
    s/product.../name.../+edit-subscription.
    ----------------------------------------

Similarly, an email is sent out when the import is suspended or
invalidated.

    >>> code_import.suspend({}, nopriv)
    True
    >>> print_emails(group_similar=True)
    From: No Privileges Person <no-priv@canonical.com>
    To: no-priv@canonical.com
    Subject: Code import product.../name... status: Suspended
    <BLANKLINE>
    The import has been suspended.
    ...
    ----------------------------------------

    >>> code_import.invalidate({}, nopriv)
    True
    >>> print_emails(group_similar=True)
    From: No Privileges Person <no-priv@canonical.com>
    To: no-priv@canonical.com
    Subject: Code import product.../name... status: Invalid
    <BLANKLINE>
    The import has been marked as invalid.
    ...
    ----------------------------------------

    >>> code_import.markFailing({}, nopriv)
    True
    >>> print_emails(group_similar=True)
    From: No Privileges Person <no-priv@canonical.com>
    To: no-priv@canonical.com
    Subject: Code import product.../name... status: Failing
    <BLANKLINE>
    The import has been marked as failing.
    ...
    ----------------------------------------

Finally, the changeDetails method also sends out an email with a
summary of the changes made.

    >>> data = {'svn_branch_url': 'http://svn.example.com/project/trunk'}
    >>> code_import.changeDetails(data, nopriv)
    True
    >>> print_emails(group_similar=True)
    From: No Privileges Person <no-priv@canonical.com>
    To: no-priv@canonical.com
    Subject: Code import product.../name... status: Failing
    <BLANKLINE>
    ... is now being imported from:
        http://svn.example.com/project/trunk
    instead of:
        http://svn.example.com/project
    <BLANKLINE>
    ...
    ----------------------------------------

changeDetails is smart enough to not send an email if no changes were
actually made.

    >>> code_import.changeDetails({}, nopriv)
    False
    >>> print_emails(group_similar=True)


== Update intervals ==

After an import is initially completed, it must be updated regularly. Each
code import can specify a custom update interval, or use a default value.

There is a separate default update interval for each version control system,
set in the Launchpad configuration system.

    >>> from datetime import timedelta
    >>> from canonical.config import config
    >>> default_interval_cvs = timedelta(
    ...     seconds=config.codeimport.default_interval_cvs)
    >>> default_interval_subversion = timedelta(
    ...     seconds=config.codeimport.default_interval_subversion)

By default, code imports are created with an unspecified update interval.

    >>> print cvs_import.update_interval
    None
    >>> print svn_import.update_interval
    None

When the update interval interval is unspecified, the effective update
interval, which decides how often the import is actually updated, uses the
appropriate default value for the RCS type.

    >>> default_interval_cvs
    datetime.timedelta(0, 43200)
    >>> cvs_import.effective_update_interval
    datetime.timedelta(0, 43200)

    >>> default_interval_subversion
    datetime.timedelta(0, 21600)
    >>> svn_import.effective_update_interval
    datetime.timedelta(0, 21600)

If the update interval is set, then it overrides the default value.

As explained in the "Modify CodeImports" section, the interface does not allow
direct attribute modification. So we use removeSecurityProxy in this example.

    >>> removeSecurityProxy(cvs_import).update_interval = (
    ...     timedelta(seconds=7200))
    >>> cvs_import.effective_update_interval
    datetime.timedelta(0, 7200)

    >>> removeSecurityProxy(svn_import).update_interval = (
    ...     timedelta(seconds=3600))
    >>> svn_import.effective_update_interval
    datetime.timedelta(0, 3600)

== Retreiving CodeImports ==

You can retrieve all imports with the `getAll` method of ICodeImport.

    >>> svn_import in code_import_set.getAll()
    True

You can also retrive an import by id, which will be used to present the
object view for an import and also by branch, which will be used to
present the import's details on the page of the branch.

    >>> code_import_set.get(svn_import.id).svn_branch_url
    u'svn://svn.example.com/trunk'
    >>> code_import_set.getByBranch(cvs_import.branch).cvs_root
    u':pserver:anonymous@cvs.example.com:/cvsroot'

Finally, you can search for imports by review status.  For instance,
there is a single sample CodeImport with the "REVIEWED" status:

    >>> from canonical.launchpad.interfaces import CodeImportReviewStatus
    >>> reviewed_imports = list(code_import_set.search(
    ...     review_status=CodeImportReviewStatus.REVIEWED))
    >>> reviewed_imports
    [<...CodeImport...>]
    >>> reviewed_imports[0].review_status.name
    'REVIEWED'

When you ask for an id that is not present ICodeImportSet.get() raises
canonical.launchpad.interfaces.NotFoundError, rather than some
internal database exception.

    >>> code_import_set.get(-10)
    Traceback (most recent call last):
      ...
    NotFoundError: -10


== Canonical URLs ==

We've registered the ICodeImportSet utility on the 'code' part of the
site:

    >>> from canonical.launchpad.webapp import canonical_url
    >>> print canonical_url(code_import_set)
    http://code.launchpad.dev/+code-imports

The code imports themselves are viewed under the branch's URL,
and are not traversable in themselves.

    >>> print canonical_url(svn_import.branch)
    http://code.launchpad.dev/~vcs-imports/firefox/trunk-svn
    >>> print canonical_url(svn_import)
    Traceback (most recent call last):
    NoCanonicalUrl: ...


== Modifying CodeImports ==

Modifications to CodeImport objects must be done using setter methods
that create CodeImportEvent objects when appropriate. This is enforced
by preventing the setting of any attribute through the ICodeImport
interface.

Even though David can access CodeImportObjects, he cannot set attributes
on those objects.

    >>> login('david.allouche@canonical.com')
    >>> svn_import.svn_branch_url
    u'svn://svn.example.com/trunk'
    >>> svn_import.svn_branch_url = 'svn://svn.example.com/branch/1.0'
    Traceback (most recent call last):
      ...
    ForbiddenAttribute: ('svn_branch_url', <CodeImport ...>)

Modifications can be done using the CodeImport.updateFromData
method. If any change were made, this method creates and returns a
CodeImportEvent describing them. The CodeImportEvent records the user
that made the change, so we need to pass the user as an argument.

    >>> svn_import.svn_branch_url
    u'svn://svn.example.com/trunk'
    >>> data = {'svn_branch_url': 'svn://svn.example.com/branch/1.0'}
    >>> modify_event = svn_import.updateFromData(data, nopriv)
    >>> modify_event.event_type.name
    'MODIFY'
    >>> svn_import.svn_branch_url
    u'svn://svn.example.com/branch/1.0'
    >>> svn_events = event_set.getEventsForCodeImport(svn_import)
    >>> [event.event_type.name for event in svn_events]
    ['CREATE', 'MODIFY']

The launchpad.Edit privilege is required to use CodeImport.updateFromData.

    >>> login(ANONYMOUS)
    >>> svn_import.updateFromData({}, nopriv)
    Traceback (most recent call last):
    ...
    Unauthorized: (<CodeImport ...>, 'updateFromData', 'launchpad.Edit')

We saw above how changes to SVN details are displayed in emails above.
CVS details are displayed in a similar way.

    >>> from canonical.launchpad.mailout.codeimport import (
    ...     make_email_body_for_code_import_update)
    >>> login('david.allouche@canonical.com')
    >>> data = {'cvs_root': ':pserver:anoncvs@cvs.example.com:/var/cvsroot'}
    >>> modify_event = cvs_import.updateFromData(data, nopriv)
    >>> print make_email_body_for_code_import_update(modify_event)
    ~vcs-imports/firefox/trunk-cvs is now being imported from:
        hello from :pserver:anoncvs@cvs.example.com:/var/cvsroot
    instead of:
        hello from :pserver:anonymous@cvs.example.com:/cvsroot
