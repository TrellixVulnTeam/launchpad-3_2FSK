Helper Functions
================

There are some helper functions located in canonical.launchpad.helpers
which can be used in order to avoid duplicating code in different parts
of Launchpad.

Checking If the Logged In User is a Maintainer
----------------------------------------------

We can check if the user is a maintainer of something which has an
owner by using is_maintainer():

    >>> from canonical.launchpad.helpers import is_maintainer

Let's create something that provides IHasOwner and set the owner to
Sample Person:

    >>> from zope.component import getUtility
    >>> from zope.interface import implements
    >>> from canonical.launchpad.interfaces import IPersonSet, IHasOwner
    >>> from canonical.launchpad.ftests import login
    >>> personset = getUtility(IPersonSet)
    >>> sample_person = personset.get(12)
    >>> class HasOwner:
    ...     implements(IHasOwner)
    ...     owner = sample_person
    >>> has_owner = HasOwner()

Neither anonymous nor Foo Bar is a maintainer:

    >>> is_maintainer(has_owner)
    False
    >>> login('foo.bar@canonical.com')
    >>> is_maintainer(has_owner)
    False

But Sample Person is:

    >>> login('test@canonical.com')
    >>> is_maintainer(has_owner)
    True

If we set the owner to the Ubuntu Team, Sample Person is no longer a
maintainer, while Foo Bar is, since he's a member of the team:

    >>> ubuntu_team = personset.get(17)
    >>> has_owner.owner = ubuntu_team
    >>> is_maintainer(has_owner)
    False

    >>> login('foo.bar@canonical.com')
    >>> is_maintainer(has_owner)
    True

If hasowner wouldn't provide IHasOwner a TypeError is raised:

    >>> class NoIHasOwner:
    ...     owner = sample_person
    >>> noIHasOwner = NoIHasOwner()
    >>> is_maintainer(noIHasOwner)
    Traceback (most recent call last):
    ...
    TypeError: hasowner doesn't provide IHasOwner


Getting a valid name as our database asks for from a string
-----------------------------------------------------------

    >>> from canonical.launchpad.helpers import getValidNameFromString

The string has capital letters.

    >>> original_string = 'EvilStringNotFollowingOurRules'
    >>> getValidNameFromString(original_string)
    'evilstringnotfollowingourrules'

The string has underscores.

    >>> original_string = 'evil_string_not_following_our_rules'
    >>> getValidNameFromString(original_string)
    'evil-string-not-following-our-rules'

The string has white spaces.

    >>> original_string = 'evil string not following our rules'
    >>> getValidNameFromString(original_string)
    'evil-string-not-following-our-rules'

A mix of all previous cases.

    >>> original_string = 'Evil String Not_Following_our rUles'
    >>> getValidNameFromString(original_string)
    'evil-string-not-following-our-rules'


requestCountry
--------------

    >>> from canonical.launchpad.helpers import requestCountry

Check if the function gets a country for localhost.

    >>> dummy_request = {'REMOTE_ADDR': '127.0.0.1'}
    >>> country = requestCountry(dummy_request)
    >>> country is not None
    True

If we don't have REMOTE_ADDR or HTTP_X_FORWARDED_FOR keys inside the request,
the country is unknown.

    >>> dummy_request = {}
    >>> country = requestCountry(dummy_request)
    >>> country is None
    True

