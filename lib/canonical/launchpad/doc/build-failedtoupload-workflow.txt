= Build FAILEDTOUPLOAD workflow =

A FAILEDTOUPLOAD build record represents a build procedure that
resulted in a binary upload, already gathered in the production
machine disk, that could not be successfully uploaded to Launchpad.

It can be caused by several reasons, inconsistencies generated by the
builders or code failures in upload system.

In all of these cases we want the 'buildd-admins' to be aware of the
failure and provide them all the information required to debug the failure.



== FAILEDTOUPLOAD email notification ==

Once a build result is recognised as FAILEDTOUPLOAD by the
buildmaster/slave-scanner code, an build notification will be issued.
See more information in build-notification.txt file.

  >>> from canonical.launchpad.interfaces import IBuildSet
  >>> from canonical.launchpad.mail import stub
  >>> import transaction
  >>> buildset = getUtility(IBuildSet)


Let's use a sampledata build record in FAILEDTOUPLOAD:

  >>> failedtoupload_candidate = buildset.getByBuildID(22)
  >>> failedtoupload_candidate.title
  u'i386 build of cdrkit 1.0 in ubuntu breezy-autotest RELEASE'
  >>> failedtoupload_candidate.buildstate.name
  'FAILEDTOUPLOAD'


FAILEDTOUPLOAD notification requires 'extra_info' argument to be filled:

  >>> failedtoupload_candidate.notify()
  Traceback (most recent call last):
  ...
  AssertionError: Extra information is required for FAILEDTOUPLOAD notifications.


Normally 'extra_info' will contain the output generated by the binary
upload procedure with instructions to reprocess it:

  >>> failedtoupload_candidate.notify(extra_info='ANY OUTPUT')
  >>> transaction.commit()

As for the other failure notifications we will send emails for the
'lp-buildd-admins' team members (celso.providelo & foo.bar) and for
source creator (mark) as specified in the test configuration:

  >>> from canonical.config import config
  >>> config.builddmaster.notify_owner
  True
  >>> len(stub.test_emails)
  3

  >>> from operator import itemgetter
  >>> stub.test_emails.sort(key=itemgetter(1), reverse=True)

  >>> for from_addr, to_addrs, raw_msg in stub.test_emails:
  ...      print to_addrs
  ['mark@hbd.com']
  ['foo.bar@canonical.com']
  ['celso.providelo@canonical.com']


Note that the generated notification contain the 'extra_info' content:

  >>> from_addr, to_addrs, raw_msg = stub.test_emails.pop()
  >>> print raw_msg
  Content-Type: text/plain; charset="utf-8"
  ...
  X-Creator-Recipient: mark@hbd.com
  X-Launchpad-Build-State: FAILEDTOUPLOAD
  To: celso.providelo@canonical.com
  From: Launchpad Buildd System <noreply@launchpad.net>
  Subject: [Build #22] i386 build of cdrkit 1.0 in ubuntu breezy-autotest RELEASE
  ...
  Reply-To: Launchpad Buildd System <noreply@launchpad.net>
  ...
   * Source Package: cdrkit
   * Version: 1.0
   * Architecture: i386
   * State: Failed to upload
   * Duration: a minute
   * Build Log: http://localhost:58000/1/netapplet-1.0.0.tar.gz
   * Builder: http://launchpad.dev/+builds/bob
   * Source: http://launchpad.dev/ubuntu/+source/cdrkit/1.0
  <BLANKLINE>
  Upload log:
  ANY OUTPUT
  <BLANKLINE>
  If you want further information about this situation, feel free to
  contact a member of the Launchpad Buildd Administrators team.
  <BLANKLINE>
  --
  i386 build of cdrkit 1.0 in ubuntu breezy-autotest RELEASE
  http://launchpad.dev/+builds/+build/22
  <BLANKLINE>


== Rescuing FAILEDTOBUILD record ==

Let's emulate the procedure of rescuing an FAILEDTOUPLOAD build.
A FAILEDTOUPLOAD build obviously has no binaries:

  >>> failedtoupload_candidate.buildstate.name
  'FAILEDTOUPLOAD'

  >>> len(failedtoupload_candidate.binarypackages)
  0


But once the person responsible have received the information about
the binary upload failure via build notification, he will be aware of:

 * The targeted Build ID
 * Path where the rejected/failed upload is, usually in some
   destination inside buildd upload queue (/srv/launchpad.net/builddmaster/*)


Having those informations, one of buildd-admin team members will be
able to reprocess the binary upload via an shell account following
these steps:

 * Move the rejected/failed upload directory to 'incoming' queue.
 * Issue a process-upload command as:
   `process-upload.py
        -C buildd
        -r <DISTRORELEASE>
        -b <BUILD_ID>
        -J <LEAF_NAME>
        -Mvv
        <UPLOAD_FUL_PATH>`
 * LEAF_NAME is the upload directory name, required to not affect
   other uploads in progress.
 * '-Mvv' will produce descriptive debug information and suppress
   upload email notifications, that are definetelly *not wanted*  for
   binary uploads.
 * It's possible to use '-n' (dry-run) if he is unsure about the parameters.


For simplicity we will process the binary upload using the
NascentUpload class instead of calling the script:

  >>> login('foo.bar@canonical.com')

  >>> from canonical.archiveuploader.nascentupload import NascentUpload
  >>> from canonical.archiveuploader.tests import (
  ...    datadir, getPolicy, mock_logger, mock_logger_quiet)


The policy contains the right arguments to reprocess the build for the
right target location, they are passed via process-upload command-line:

  >>> buildd_policy = getPolicy(
  ...     name='buildd',
  ...     distro=failedtoupload_candidate.distribution.name,
  ...     distrorelease=failedtoupload_candidate.distrorelease.name,
  ...     buildid=failedtoupload_candidate.id)

  >>> cdrkit_bin_upload = NascentUpload(
  ...     datadir('suite/cdrkit_1.0/cdrkit_1.0_i386.changes'),
  ...     buildd_policy, mock_logger_quiet)
  >>> cdrkit_bin_upload.process()
  >>> cdrkit_bin_upload.is_rejected
  False
  >>> success, msgs = cdrkit_bin_upload.do_accept()
  >>> cdrkit_bin_upload.queue_root.status.name
  'NEW'


After successfully reprocessing binary upload the originally
FAILEDTOUPLOAD build record is already in FULLYBUILT state (it is
updated during the upload processing time):

  >>> failedtoupload_candidate.buildstate.name
  'FULLYBUILT'

And contains the associated binaries.

  >>> len(failedtoupload_candidate.binarypackages)
  1

