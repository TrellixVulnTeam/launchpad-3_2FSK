= Vocabularies =

== Introduction ==

Vocabularies are lists of terms. In Launchpad's Component Architecture
(CA), a vocabulary is a list of terms that a widget (normally a selection
style widget) "speaks", i.e., its allowed values.

    >>> from zope.component import getUtility
    >>> from canonical.launchpad.ftests import ANONYMOUS, login
    >>> from canonical.launchpad.interfaces import (
    ...     IPersonSet, IOpenLaunchBag, IProductSet, IProjectSet)
    >>> from canonical.database.sqlbase import flush_database_updates
    >>> person_set = getUtility(IPersonSet)
    >>> product_set = getUtility(IProductSet)
    >>> login('foo.bar@canonical.com')
    >>> launchbag = getUtility(IOpenLaunchBag)
    >>> launchbag.clear()


=== Values, Tokens, and Titles ===

In Launchpad, we generally use "tokenized vocabularies." Each term in
a vocabulary has a value, token and title. A term is rendered in a
select widget like this:

<option value="$token">$title</option>

The $token is probably the data you would store in your DB. The Token is
used to uniquely identify a Term, and the Title is the thing you display
to the user.


== Launchpad Vocabularies ==

There are two kinds of vocabularies in Launchpad: enumerable and
non-enumerable. Enumerable vocabularies are short enough to render in a
select widget. Non-enumerable vocabularies require a query interface to make
it easy to choose just one or a couple of options from several hundred,
several thousand, or more.

Vocabularies should not be imported - they can be retrieved from the
vocabulary registry.

    >>> from zope.schema.vocabulary import getVocabularyRegistry
    >>> vocabulary_registry = getVocabularyRegistry()
    >>> product_vocabulary = vocabulary_registry.get(None, "Product")
    >>> product_vocabulary.displayname
    'Select a project'


== Enumerable Vocabularies ==


=== DistributionUsingMaloneVocabulary ===

All the distributions that use Malone as their main bug tracker.

    >>> using_malone_vocabulary = vocabulary_registry.get(
    ...     None, 'DistributionUsingMalone')
    >>> len(using_malone_vocabulary)
    2
    >>> for term in using_malone_vocabulary:
    ...     print term.token, term.value.displayname, term.title
    gentoo Gentoo Gentoo
    ubuntu Ubuntu Ubuntu

    >>> from canonical.launchpad.interfaces import ILaunchpadCelebrities
    >>> ubuntu = getUtility(ILaunchpadCelebrities).ubuntu
    >>> ubuntu in using_malone_vocabulary
    True
    >>> debian = getUtility(ILaunchpadCelebrities).debian
    >>> debian in using_malone_vocabulary
    False

    >>> using_malone_vocabulary.getQuery() is None
    True

    >>> term = using_malone_vocabulary.getTerm(ubuntu)
    >>> print term.token, term.value.displayname, term.title
    ubuntu Ubuntu Ubuntu

    >>> term = using_malone_vocabulary.getTerm(debian)
    Traceback (most recent call last):
    ...
    LookupError:...

    >>> term = using_malone_vocabulary.getTermByToken('ubuntu')
    >>> print term.token, term.value.displayname, term.title
    ubuntu Ubuntu Ubuntu

    >>> term = using_malone_vocabulary.getTermByToken('debian')
    Traceback (most recent call last):
    ...
    LookupError:...


=== BugNominatableSeriesVocabulary ===

All the serieses that can be nominated for fixing.

This vocabulary needs either a product or distribution in the launchbag
to get the available series. It also needs a bug, since it list only
series that haven't already been nominated.

Let's start with putting a product in the launchbag.

    >>> firefox = product_set.getByName('firefox')
    >>> getUtility(IOpenLaunchBag).clear()
    >>> getUtility(IOpenLaunchBag).add(firefox)

Firefox has the following series:

    >>> for series in firefox.serieses:
    ...     print series.name
    1.0
    trunk

Now, if we look at bug one, we can see that it hasn't been targeted
for any Firefox series yet:

    >>> from canonical.launchpad.interfaces import IBugSet

    >>> bug_one = getUtility(IBugSet).get(1)
    >>> for bugtask in bug_one.bugtasks:
    ...     print bugtask.bugtargetdisplayname
    Mozilla Firefox
    mozilla-firefox (Ubuntu)
    mozilla-firefox (Debian)

It has however been nominated for 1.0:

    >>> for nomination in bug_one.getNominations(firefox):
    ...     print nomination.target.name
    1.0

This means that if we iterate through the vocabulary with bug one, only
the trunk will be nominatable:

    >>> firefox_bug_one = bug_one.bugtasks[0]
    >>> firefox_bug_one.target.name
    u'firefox'
    >>> series_vocabulary = vocabulary_registry.get(
    ...     firefox_bug_one, 'BugNominatableSerieses')
    >>> for term in series_vocabulary:
    ...     print "%s: %s" % (term.token, term.title)
    trunk: Trunk

No series is targeted or nominated on bug 4:

    >>> bug_four = getUtility(IBugSet).get(4)
    >>> for bugtask in bug_four.bugtasks:
    ...     print bugtask.bugtargetdisplayname
    Mozilla Firefox

    >>> for nomination in bug_four.getNominations(firefox):
    ...     print nomination.target.name

So if we give bug four to the vocabulary, all serieses will be returned:

    >>> firefox_bug_four = bug_four.bugtasks[0]
    >>> firefox_bug_four.target.name
    u'firefox'
    >>> series_vocabulary = vocabulary_registry.get(
    ...     firefox_bug_four, 'BugNominatableSerieses')
    >>> for term in series_vocabulary:
    ...     print "%s: %s" % (term.token, term.title)
    1.0: 1.0
    trunk: Trunk

The same works for distributions:

    >>> getUtility(IOpenLaunchBag).clear()
    >>> getUtility(IOpenLaunchBag).add(ubuntu)

Bug one is nominated for Ubuntu Hoary:

    >>> bug_one = getUtility(IBugSet).get(1)
    >>> for bugtask in bug_one.bugtasks:
    ...     print bugtask.bugtargetdisplayname
    Mozilla Firefox
    mozilla-firefox (Ubuntu)
    mozilla-firefox (Debian)

    >>> for nomination in bug_one.getNominations(ubuntu):
    ...     print nomination.target.name
    hoary

So Hoary isn't included in the vocabulary:

    >>> ubuntu_bug_one = bug_one.bugtasks[1]
    >>> ubuntu_bug_one.distribution.name
    u'ubuntu'
    >>> serieses_vocabulary = vocabulary_registry.get(
    ...     ubuntu_bug_one, 'BugNominatableSerieses')
    >>> for term in serieses_vocabulary:
    ...     print "%s: %s" % (term.token, term.title)
    breezy-autotest: Breezy-autotest
    grumpy: Grumpy
    warty: Warty

The same is true for bug two, where the bug is targeted to Hoary.

    >>> bug_two = getUtility(IBugSet).get(2)
    >>> for bugtask in bug_two.bugtasks:
    ...     print bugtask.bugtargetdisplayname
    Tomcat
    Ubuntu
    Ubuntu Hoary
    mozilla-firefox (Debian)
    mozilla-firefox (Debian Woody)

    >>> for nomination in bug_two.getNominations(ubuntu):
    ...     print nomination.target.name
    hoary

    >>> ubuntu_bug_two = bug_two.bugtasks[1]
    >>> ubuntu_bug_two.distribution.name
    u'ubuntu'
    >>> serieses_vocabulary = vocabulary_registry.get(
    ...     ubuntu_bug_two, 'BugNominatableSerieses')
    >>> for term in serieses_vocabulary:
    ...     print "%s: %s" % (term.token, term.title)
    breezy-autotest: Breezy-autotest
    grumpy: Grumpy
    warty: Warty

We can get a specific term by using the release name:

    >>> term = serieses_vocabulary.getTermByToken('warty')
    >>> term.value == ubuntu.getSeries('warty')
    True

Trying to get a non-existant release will result in a LookupError:

    >>> series_vocabulary.getTermByToken('non-such-release')
    Traceback (most recent call last):
    ...
    LookupError...


=== ProjectProductsVocabularyUsingMalone ===

All the products in a project using Malone.


    >>> mozilla_project = getUtility(IProjectSet).getByName('mozilla')
    >>> for product in mozilla_project.products:
    ...     print "%s: %s" % (product.name, product.official_malone)
    firefox: True
    thunderbird: False

    >>> mozilla_products_vocabulary = vocabulary_registry.get(
    ...     mozilla_project,'ProjectProductsUsingMalone')
    >>> for term in mozilla_products_vocabulary:
    ...     print "%s: %s" %(term.token, term.title)
    firefox: Mozilla Firefox


== Non-Enumerable Vocabularies ==

Iterating over non-enumerable vocabularies, while possible, will
probably kill the database. Instead, these vocabularies are
search-driven.


=== BinaryAndSourcePackageNameVocabulary ===

The list of binary and source package names, ordered by name.

    >>> package_name_vocabulary = vocabulary_registry.get(
    ...     None, "BinaryAndSourcePackageName")
    >>> package_name_vocabulary.displayname
    'Select a Package'

When a package name matches both a binary package name and a source
package of the exact same name, the binary package name is
returned. This allows us, in bug reporting for example, to collect the
most specific information possible.

Let's demonstrate by searching for "mozilla-firefox", for which there is
both a source and binary package of that name.

    >>> package_name_terms = package_name_vocabulary.searchForTerms(
    ...     "mozilla-firefox")
    >>> package_name_terms.count()
    2
    >>> [(term.token, term.title) for term in package_name_terms]
    [('mozilla-firefox', u'iceweasel huh ?'),
     ('mozilla-firefox-data', u'Mozilla Firefox Data is .....')]

Searching for "mozilla" should return the binary package name above, and
the source package named "mozilla".

    >>> package_name_terms = package_name_vocabulary.searchForTerms("mozilla")
    >>> package_name_terms.count()
    3
    >>> [(term.token, term.title) for term in package_name_terms]
    [('mozilla', 'Not uploaded'),
     ('mozilla-firefox', u'iceweasel huh ?'),
     ('mozilla-firefox-data', u'Mozilla Firefox Data is .....')]

The search does a case-insensitive, substring match.

    >>> package_name_terms = package_name_vocabulary.searchForTerms("lInuX")
    >>> package_name_terms.count()
    2
    >>> [(term.token, term.title) for term in package_name_terms]
    [('linux-2.6.12', u'this kernel is like the crystal method: a temple...'),
     ('linux-source-2.6.15', u'Source of: linux-2.6.12')]


=== BinaryPackageNameVocabulary ===

All the binary packages in Launchpad.

    >>> bpn_vocabulary = vocabulary_registry.get(None, 'BinaryPackageName')
    >>> len(bpn_vocabulary)
    8

    >>> bpn_terms = bpn_vocabulary.searchForTerms("mozilla")
    >>> len(bpn_terms)
    2
    >>> [(term.token, term.title) for term in bpn_terms]
    [('mozilla-firefox', u'iceweasel huh ?'),
     ('mozilla-firefox-data', u'Mozilla Firefox Data is .....')]


=== SourcePackageNameVocabulary ===

All the source packages in Launchpad.

    >>> spn_vocabulary = vocabulary_registry.get(None, 'SourcePackageName')
    >>> len(spn_vocabulary)
    17

    >>> spn_terms = spn_vocabulary.searchForTerms("mozilla")
    >>> len(spn_terms)
    2
    >>> [(term.token, term.title) for term in spn_terms]
    [('mozilla', 'Not yet built'),
     ('mozilla-firefox', u'Source of: mozilla-firefox, mozilla-firefox-data')]

    >>> spn_terms = spn_vocabulary.searchForTerms("pmount")
    >>> len(spn_terms)
    1
    >>> [(term.token, term.title) for term in spn_terms]
    [('pmount', u'Source of: pmount')]


=== BranchVocabulary ===

The list of bzr branches registered in Launchpad.

Searchable by branch name or URL, registrant name, and project name.
Results are not restricted in any way by the context, but the results
are restricted based on who is asking (as far as private branches is
concerned).

    # Just use None as the context.
    >>> branch_vocabulary = vocabulary_registry.get(None, "Branch")
    >>> def print_vocab_branches(vocab, search):
    ...     for term in vocab.searchForTerms(search):
    ...         print term.value.unique_name

    >>> print_vocab_branches(branch_vocabulary, 'main')
    ~name12/firefox/main
    ~stevea/thunderbird/main
    ~justdave/+junk/main
    ~kiko/+junk/main
    ~vcs-imports/evolution/main
    ~name12/gnome-terminal/main

    >>> print_vocab_branches(branch_vocabulary, 'vcs-imports')
    ~vcs-imports/gnome-terminal/import
    ~vcs-imports/evolution/import
    ~vcs-imports/evolution/main

    >>> print_vocab_branches(branch_vocabulary, 'evolution')
    ~carlos/evolution/2.0
    ~vcs-imports/evolution/import
    ~vcs-imports/evolution/main

A search with the full branch unique name should also find the branch.

    >>> print_vocab_branches(branch_vocabulary, '~name12/firefox/main')
    ~name12/firefox/main

The tokens used by terms retrieved from BranchVocabulary use the
branch unique name as an ID:

    >>> from lp.code.interfaces.branchlookup import IBranchLookup
    >>> branch = getUtility(IBranchLookup).get(15)
    >>> print branch.unique_name
    ~name12/gnome-terminal/main
    >>> term = branch_vocabulary.toTerm(branch)
    >>> print term.token
    ~name12/gnome-terminal/main

The BranchVocabulary recognises both unique names and URLs as tokens:

    >>> term = branch_vocabulary.getTermByToken('~name12/gnome-terminal/main')
    >>> term.value == branch
    True
    >>> term = branch_vocabulary.getTermByToken(
    ...     'http://bazaar.launchpad.dev/~name12/gnome-terminal/main/')
    >>> term.value == branch
    True
    >>> term = branch_vocabulary.getTermByToken(
    ...     'http://example.com/gnome-terminal/main')
    >>> term.value == branch
    True

The searches that the BranchVocabulary does are private branch aware.
The results are effectively filtered on what the logged in user is
able to see.

    >>> print_vocab_branches(branch_vocabulary, 'trunk')
    ~spiv/+junk/trunk
    ~limi/+junk/trunk
    ~landscape-developers/landscape/trunk

    >>> login('no-priv@canonical.com')
    >>> print_vocab_branches(branch_vocabulary, 'trunk')
    ~spiv/+junk/trunk
    ~limi/+junk/trunk

    >>> login('foo.bar@canonical.com')


=== BranchRestrictedOnProduct ===

The BranchRestrictedOnProduct vocabulary restricts the result set to
those of the product of the context.  Currently only two types of
context are supported: Product; and Branch.  If a branch is the context,
then the product of the branch is used to restrict the query.

    >>> gnome_terminal = getUtility(IProductSet)["gnome-terminal"]
    >>> branch_vocabulary = vocabulary_registry.get(
    ...     gnome_terminal, "BranchRestrictedOnProduct")
    >>> print_vocab_branches(branch_vocabulary, 'main')
    ~name12/gnome-terminal/main

    >>> print_vocab_branches(branch_vocabulary, 'vcs-imports')
    ~vcs-imports/gnome-terminal/import

If a full unique name is entered that has a different product, the
branch is not part of the vocabulary.

    >>> print_vocab_branches(branch_vocabulary, '~name12/gnome-terminal/main')
    ~name12/gnome-terminal/main

    >>> print_vocab_branches(branch_vocabulary, '~name12/firefox/main')


The BranchRestrictedOnProduct behaves the same way as the more generic
BranchVocabulary with respect to the tokens and privacy awareness.


=== HostedBranchRestrictedOnOwner ===

Here's a vocabulary for all hosted branches owned by the current user.

    >>> from lp.code.enums import BranchType

    >>> a_user = factory.makePerson(name='a-branching-user')
    >>> product1 = factory.makeProduct(name='product-one')
    >>> mirrored_branch = factory.makeBranch(
    ...     owner=a_user, product=product1, name='mirrored',
    ...     branch_type=BranchType.MIRRORED)
    >>> product2 = factory.makeProduct(name='product-two')
    >>> hosted_branch = factory.makeBranch(
    ...     owner=a_user, product=product2, name='hosted')
    >>> foreign_branch = factory.makeBranch()

It returns branches owned by the user, but not ones owned by others, nor
ones that aren't hosted on Launchpad.

    >>> branch_vocabulary = vocabulary_registry.get(
    ...     a_user, "HostedBranchRestrictedOnOwner")
    >>> print_vocab_branches(branch_vocabulary, None)
    ~a-branching-user/product-two/hosted


=== Processor ===

All processors type available in Launchpad.

    >>> vocab = vocabulary_registry.get(None, "Processor")
    >>> vocab.displayname
    'Select a Processor'

    >>> [term.token for term in vocab.searchForTerms('386')]
    ['386']


=== BugWatchVocabulary ===

All bug watches associated with a bugtask's bug.

    >>> bug_one = getUtility(IBugSet).get(1)
    >>> bugtask = bug_one.bugtasks[0]
    >>> vocab = vocabulary_registry.get(bugtask, "BugWatch")
    >>> for term in vocab:
    ...     print term.title
    The Mozilla.org Bug Tracker <a...>#123543</a>
    The Mozilla.org Bug Tracker <a...>#2000</a>
    The Mozilla.org Bug Tracker <a...>#42</a>
    Debian Bug tracker <a...>#304014</a>

Bug watches with an email address URL (i.e. starts with "mailto:") are
treated differently.

    >>> from canonical.launchpad.interfaces import (
    ...     IBugWatchSet, IBugTrackerSet)

    >>> bug_twelve = getUtility(IBugSet).get(12)
    >>> email_bugtracker = getUtility(IBugTrackerSet).getByName('email')
    >>> email_bugwatch = getUtility(IBugWatchSet).createBugWatch(
    ...     bug_twelve, launchbag.user, email_bugtracker, '')
    >>> email_bugwatch.url
    u'mailto:bugs@example.com'

The title is rendered differently compared to other bug watches.

    >>> bugtask = bug_twelve.bugtasks[0]
    >>> vocab = vocabulary_registry.get(bugtask, "BugWatch")
    >>> for term in vocab:
    ...     print term.title
    Email bugtracker &lt;<a...>bugs@example.com</a>&gt;

Additionally, if the bug tracker's title contains the bug tracker's
URL, then the title is linkified instead.

    >>> email_bugtracker.title = (
    ...     'Lionel Richtea (%s)' % (
    ...         email_bugtracker.baseurl,))

    >>> for term in vocab:
    ...     print term.title
    Lionel Richtea (<a...>mailto:bugs@example.com</a>)

When there is no logged-in user, the title is much different. The
email address is hidden, and there is no hyperlink.

    >>> current_user = launchbag.user
    >>> login(ANONYMOUS)

    >>> for term in vocab:
    ...     print term.title
    Lionel Richtea (mailto:&lt;email address hidden&gt;)


== SpecificationDepCandidatesVocabulary ==

All blueprints that can be added as a dependency of the
context blueprint.

First, we set up a product with three blueprints.

    >>> from canonical.launchpad.interfaces import (
    ...     ISpecificationSet, SpecificationDefinitionStatus)
    >>> evolution = product_set.getByName('evolution')
    >>> foobar_person = person_set.getByName('name16')
    >>> foobar_person.displayname
    u'Foo Bar'
    >>> specset = getUtility(ISpecificationSet)
    >>> spec_a = specset.new('spec-a', 'Spec A',
    ...     'http://www.example.org/SpecA', 'The first spec',
    ...     SpecificationDefinitionStatus.APPROVED, foobar_person,
    ...     product=evolution)
    >>> spec_b = specset.new('spec-b', 'Spec B',
    ...     'http://www.example.org/SpecB', 'The second spec',
    ...     SpecificationDefinitionStatus.APPROVED, foobar_person,
    ...     product=evolution)
    >>> spec_c = specset.new('spec-c', 'Spec C',
    ...     'http://www.example.org/SpecC', 'The third spec',
    ...     SpecificationDefinitionStatus.APPROVED, foobar_person,
    ...     product=evolution)
    >>> sorted([spec.name for spec in evolution.specifications()])
    [u'spec-a', u'spec-b', u'spec-c']

The dependency candidates for spec_a are all blueprints for evolution
except for spec_a itself.

    >>> vocab = vocabulary_registry.get(
    ...     spec_a, "SpecificationDepCandidates")
    >>> sorted([term.value.name for term in vocab])
    [u'spec-b', u'spec-c']

Dependency candidate come only from the same product of the blueprint
they depend on.

    >>> unrelated_spec = specset.new('unrelated-spec', 'Unrelated Spec',
    ...     'http://example.com/SpecU', 'A spec unrelated to Evolution',
    ...     SpecificationDefinitionStatus.APPROVED, foobar_person,
    ...     product=firefox)
    >>> vocab = vocabulary_registry.get(
    ...     spec_a, "SpecificationDepCandidates")
    >>> unrelated_spec in vocab
    False
    >>> [term.value.product for term in vocab
    ...  if term.value.product != evolution]
    []

We mark spec_b as a dependency of spec_a and spec_c as a dependency
of spec_b.

    >>> spec_a.createDependency(spec_b)
    <SpecificationDependency at ...>
    >>> [spec.name for spec in spec_a.dependencies]
    [u'spec-b']

    >>> spec_b.createDependency(spec_c)
    <SpecificationDependency at ...>
    >>> [spec.name for spec in spec_b.dependencies]
    [u'spec-c']

No circular dependencies - the vocabulary excludes specifications that
are a dependency of the context spec.

    >>> spec_a in spec_b.all_blocked
    True
    >>> spec_b in spec_c.all_blocked
    True
    >>> vocab = vocabulary_registry.get(
    ...     spec_c, "SpecificationDepCandidates")
    >>> spec_a in [term.value for term in vocab]
    False

This vocabulary provides the IHugeVocabulary interface.

    >>> from canonical.launchpad.webapp.testing import verifyObject
    >>> from canonical.launchpad.webapp.vocabulary import IHugeVocabulary
    >>> verifyObject(IHugeVocabulary, vocab)
    True

The search() method returns specifications within the vocabulary
that matches the search string. The string is matched against the name,
or fallbacks to a full text search.

    >>> vocab = vocabulary_registry.get(
    ...     spec_a, "SpecificationDepCandidates")
    >>> list(vocab.search('spec-b')) == [spec_b]
    True
    >>> list(vocab.search('third')) == [spec_c]
    True

The search method uses the SQL `LIKE` operator, with the values quoted
appropriately. Queries conataining regual expression operators, for
example, will simply look for the respective characters within the
vocabulary's item (this used to be the cause of an OOPS, see
https://bugs.edge.launchpad.net/blueprint/+bug/139385 for more details).

    >>> list(vocab.search('*'))
    []


=== PPA ===

The PPA vocabulary contains all the PPAs available in a particular
collection. It provides the IHugeVocabulary interface.

    >>> from canonical.launchpad.webapp.testing import verifyObject
    >>> from canonical.launchpad.webapp.vocabulary import IHugeVocabulary

    >>> vocabulary = vocabulary_registry.get(None, 'PPA')
    >>> verifyObject(IHugeVocabulary, vocabulary)
    True

    >>> print vocabulary.displayname
    Select a PPA

Iterations over the PPA vocabulary will return on PPA archives.

    >>> sorted([term.value.owner.name for term in vocabulary])
    [u'cprov', u'no-priv', u'sabdfl']

PPA vocabulary terms contain:

 * token: the PPA owner name combined with the archive name (using '/');
 * value: the IArchive object;
 * title: the first line of the PPA description text.

    >>> cprov_term = vocabulary.getTermByToken('cprov/ppa')

    >>> print cprov_term.token
    cprov/ppa

    >>> print cprov_term.value
    <Archive ...>

    >>> print cprov_term.title
    packages to help my friends.

Not found terms result in LookupError.

    >>> vocabulary.getTermByToken('foobar')
    Traceback (most recent call last):
    ...
    LookupError: foobar

PPA vocabulary searches consider the owner FTI and the PPA FTI.

    >>> def print_search_results(results):
    ...     for archive in results:
    ...         term = vocabulary.toTerm(archive)
    ...         print '%s: %s' % (term.token, term.title)

    >>> cprov_search = vocabulary.search('cprov')
    >>> print_search_results(cprov_search)
    cprov/ppa: packages to help my friends.

    >>> celso_search = vocabulary.search('celso')
    >>> print_search_results(celso_search)
    cprov/ppa: packages to help my friends.

    >>> friends_search = vocabulary.search('friends')
    >>> print_search_results(friends_search)
    cprov/ppa: packages to help my friends.

We will create an additional PPA for Celso named 'testing'

    >>> from lp.soyuz.interfaces.archive import (
    ...     ArchivePurpose, IArchiveSet)

    >>> login_person(current_user)
    >>> cprov = getUtility(IPersonSet).getByName('cprov')
    >>> cprov_testing = getUtility(IArchiveSet).new(
    ...     owner=cprov, name='testing', purpose=ArchivePurpose.PPA,
    ...     description='testing packages.')

Now, a search for 'cprov' will return 2 ppas and the result is ordered
by PPA name.

    >>> cprov_search = vocabulary.search('cprov')
    >>> print_search_results(cprov_search)
    cprov/ppa: packages to help my friends.
    cprov/testing: testing packages.

The vocabulary search also supports specific named PPA lookups
follwing the same combined syntax used to build unique tokens.

    >>> named_search = vocabulary.search('cprov/testing')
    >>> print_search_results(named_search)
    cprov/testing: testing packages.

As mentioned the PPA vocabulary term title only contains the first
line of the PPA description.

    >>> cprov.archive.description = "Single line."
    >>> flush_database_updates()

    >>> cprov_term = vocabulary.getTermByToken('cprov/ppa')
    >>> print cprov_term.title
    Single line.

    >>> cprov.archive.description = "First line\nSecond line."
    >>> flush_database_updates()

    >>> cprov_term = vocabulary.getTermByToken('cprov/ppa')
    >>> print cprov_term.title
    First line

PPAs with empty description are identified and have a title saying so.

    >>> cprov.archive.description = None
    >>> flush_database_updates()

    >>> cprov_term = vocabulary.getTermByToken('cprov/ppa')
    >>> print cprov_term.title
    No description available

Queries on empty strings also results in a valid SelectResults.

    >>> empty_search = vocabulary.search('')
    >>> empty_search.count() == 0
    True


# XXX Tom Berger 2007-07-05: document more vocabularies here, particularly
# when they break!
