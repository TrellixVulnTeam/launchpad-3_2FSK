= The Queue Builder =

QueueBuilder is a script to sanely initialize new build jobs, it
verifies the available DistroArchSeriess, for which we are able to
build packages, repairs broken Builds entries that makes sense,
verifies the packages pending to build, install the jobs in
BuildQueue table and scores the build according a bunch of
parameters.


== Setting up ==

    >>> import tempfile, os, operator
    >>> from canonical.buildmaster.master import (BuilddMaster,
    ...   determineArchitecturesToBuild)

import the bunch of required database classes:

    >>> from canonical.launchpad.database import (
    ...      Build, BuildQueue, DistroArchSeries, DistroSeries,
    ...      PocketChroot, SecureSourcePackagePublishingHistory,
    ...      SourcePackagePublishingHistory)

    >>> from canonical.launchpad.interfaces import (
    ...      PackagePublishingPocket, PackagePublishingStatus)

The Master side of Buildd requires access to Launchpad Database, the
user designed for this kind of access is 'fiera', see
test_system_documentation.py for more information.

    >>> import logging
    >>> logger = logging.getLogger()

Now we have satisfied all needs for BuildMaster, let's instantiate it.

    >>> bm = BuilddMaster(logger, transaction)

Emulates a PocketChroot entry to validate the following
distroarchseries:

 * Ubuntu/Warty/i386/RELEASE
 * Ubuntu/Hoary/i386/RELEASE
 * Debian/Woody/i386/RELEASE

    >>> warty = DistroSeries.selectOneBy(name="warty")
    >>> chroot = PocketChroot(distroarchseries=warty['i386'], chroot=1)

    >>> hoary = DistroSeries.selectOneBy(name='hoary')
    >>> chroot = PocketChroot(distroarchseries=hoary['i386'], chroot=1)
    >>> chroot = PocketChroot(distroarchseries=hoary['hppa'], chroot=2)

    >>> woody = DistroSeries.selectOneBy(name='woody')
    >>> chroot = PocketChroot(distroarchseries=woody['i386'], chroot=3)

Produce a set of available DistroArchSeries, for which the
build jobs will be created.

    >>> distroserieses = set()
    >>> for dar in DistroArchSeries.select():
    ...     distroserieses.add(dar.distroseries)
    ...     bm.addDistroArchSeries(dar)
    >>> distroserieses = sorted(distroserieses, key=operator.attrgetter('name'))

Among all the available distroarchseries only the one with chroot will
be considered.

    >>> sorted((arch.distroseries.name, arch.architecturetag)
    ...        for arch in bm._archserieses.keys())
    [(u'hoary', u'hppa'), (u'hoary', u'i386'), (u'warty', u'i386'), (u'woody', u'i386')]


== Ensure sampledata is processed ==

Kick off any pending builds we have to avoid any lint in our tests (there are a
couple that will be created based on our sampledata). This is to allow
us to study carefully what is being added as we add new series and builds.

    >>> for dr in distroserieses:
    ...      bm.createMissingBuilds(dr)

Add the missing build queue entries.

    >>> bm.addMissingBuildQueueEntries()

Store current status of the database:

    >>> old_build_ids = [b.id for b in Build.select()]
    >>> old_job_ids = [bq.id for bq in BuildQueue.select()]


== Create some series and publications ==

Define a helper function to create series and publications for those
series.

We need to publish the source in order to get it visible to the
createMissingBuilds() method. Additionally if the target is an already
released distroseries it can only be visible if published in special
pocket (UPDATES, SECURITY, PROPOSED or BACKPORTS)

    >>> from canonical.launchpad.interfaces import IPersonSet
    >>> cprov = getUtility(IPersonSet).getByName('cprov')

    >>> from canonical.database.sqlbase import commit
    >>> from canonical.launchpad.tests.test_publishing import (
    ...     SoyuzTestPublisher)
    >>> from canonical.testing.layers import LaunchpadZopelessLayer

    >>> commit()
    >>> LaunchpadZopelessLayer.switchDbUser('launchpad')

    >>> test_publisher = SoyuzTestPublisher()
    >>> test_publisher.prepareBreezyAutotest()

Source publication for debian/woody, it won't result in a new build
because this distroseries lacks 'nominatedarchindep'.

    >>> pub_woody = test_publisher.getPubSource(
    ...     sourcename='test-buildd-5', version='671', distroseries=woody,
    ...     architecturehintlist="hppa",
    ...     status=PackagePublishingStatus.PUBLISHED,
    ...     pocket=PackagePublishingPocket.RELEASE)

Several source publications for ubuntu/hoary/RELEASE, which is in
DEVELOPMENT state, so we expect builds to be created respecting
architecturehintlist and P-a-s.

    >>> pub_all = test_publisher.getPubSource(
    ...     sourcename='test-buildd', version='667', distroseries=hoary,
    ...     status=PackagePublishingStatus.PUBLISHED,
    ...     pocket=PackagePublishingPocket.RELEASE)

    >>> pub_any = test_publisher.getPubSource(
    ...     sourcename='test-buildd-2', version='668', distroseries=hoary,
    ...     architecturehintlist="any",
    ...     status=PackagePublishingStatus.PUBLISHED,
    ...     pocket=PackagePublishingPocket.RELEASE)

    >>> pub_three = test_publisher.getPubSource(
    ...     sourcename='test-buildd-3', version='669', distroseries=hoary,
    ...     architecturehintlist="i386 hppa amd64",
    ...     status=PackagePublishingStatus.PUBLISHED,
    ...     pocket=PackagePublishingPocket.RELEASE)

    >>> pub_one = test_publisher.getPubSource(
    ...     sourcename='test-buildd-4', version='670', distroseries=hoary,
    ...     architecturehintlist="hppa",
    ...     status=PackagePublishingStatus.PUBLISHED,
    ...     pocket=PackagePublishingPocket.RELEASE)

Other sources publications to hoary, they use the extended
architecturehintlist kernel notation, see below.

    >>> pub_any_foo = test_publisher.getPubSource(
    ...     sourcename='test-buildd-6', version='672', distroseries=hoary,
    ...     architecturehintlist="any-hppa",
    ...     status=PackagePublishingStatus.PUBLISHED,
    ...     pocket=PackagePublishingPocket.RELEASE)

    >>> pub_linux_foo = test_publisher.getPubSource(
    ...     sourcename='test-buildd-7', version='673', distroseries=hoary,
    ...     architecturehintlist="linux-i386",
    ...     status=PackagePublishingStatus.PUBLISHED,
    ...     pocket=PackagePublishingPocket.RELEASE)

A source published in warty/UPDATES, a stable release update, we
expect it to result in a build.

    >>> pub_updates = test_publisher.getPubSource(
    ...     sourcename='test-updates', version='665', distroseries=warty,
    ...     status=PackagePublishingStatus.PUBLISHED,
    ...     pocket=PackagePublishingPocket.UPDATES)

A source published in warty/RELEASE, it will be ignored.

    >>> pub_ignored = test_publisher.getPubSource(
    ...     sourcename='test-buildd-not', version='666', distroseries=warty,
    ...     status=PackagePublishingStatus.PUBLISHED,
    ...     pocket=PackagePublishingPocket.RELEASE)

A source published in warty/RELEASE which has already failed to build.

    >>> pub_failed = test_publisher.getPubSource(
    ...     sourcename='test-failed', version='1.0', distroseries=warty,
    ...     status=PackagePublishingStatus.PUBLISHED,
    ...     pocket=PackagePublishingPocket.RELEASE)

    >>> from canonical.launchpad.interfaces import BuildStatus
    >>> failed_build = pub_failed.sourcepackagerelease.createBuild(
    ...     warty['i386'], PackagePublishingPocket.RELEASE,
    ...     warty.main_archive, status=BuildStatus.FAILEDTOBUILD)

Exclude the just-created build from the subsequents tests/counters.

    >>> old_build_ids.append(failed_build.id)

A copy of this source to a subsequent distroseries (as if it was
initialized) will result in a new build record, meaning we want to try
it again in the new context. See bug 181328.

    >>> copied_pub = pub_failed.copyTo(
    ...     hoary, PackagePublishingPocket.RELEASE, warty.main_archive)

A source published in warty/RELEASE with a successfully built build
won't be considered for built again.

    >>> pub_success = test_publisher.getPubSource(
    ...     sourcename='test-success', version='1.0', distroseries=warty,
    ...     status=PackagePublishingStatus.PUBLISHED,
    ...     pocket=PackagePublishingPocket.RELEASE)

    >>> ok_build = pub_success.sourcepackagerelease.createBuild(
    ...     warty['i386'], PackagePublishingPocket.RELEASE,
    ...     warty.main_archive, status=BuildStatus.FULLYBUILT)

Exclude the just-created build from the subsequents tests/counters.

    >>> old_build_ids.append(ok_build.id)

A copy of this successfully built source to a subsequent distroseries
will not result in a new build record.

    >>> copied_pub = pub_success.copyTo(
    ...     hoary, PackagePublishingPocket.RELEASE, warty.main_archive)

Finally a publication in Celso's PPA, a build will be created for it
respecting only 'architecturehintlist' and PPA-supported architecture,
it won't be submitted to P-a-s.

    >>> pub_hoary_ppa = test_publisher.getPubSource(
    ...     sourcename='test-ppa', version='674', distroseries=hoary,
    ...     architecturehintlist="i386 hppa", archive=cprov.archive,
    ...     status=PackagePublishingStatus.PUBLISHED,
    ...     pocket=PackagePublishingPocket.RELEASE)

    >>> commit()
    >>> LaunchpadZopelessLayer.switchDbUser(test_dbuser)


== Package Architecture Specific ==

The Package-Architecture-Specific (P-a-s) module is a parser to a set
of restrictions to build packages based on archive-admin experiences.

Those restrictions overlap the metadata information from the source
packages (architecturehintlist).


=== Source PAS ===

    >>> from canonical.buildmaster.pas import BuildDaemonPackagesArchSpecific

Write a harness that lets us easily test PAS statements:

    >>> def getPASVerifier(pas_string, dar=hoary):
    ...   """Build and return a PAS verifier based on the string provided."""
    ...   temp_dir = tempfile.mkdtemp()
    ...   pas_filename = os.path.join(temp_dir, "Packages-arch-specific")
    ...   pas = file(pas_filename, "w")
    ...   pas.write(pas_string)
    ...   pas.close()
    ...   pas_verify = BuildDaemonPackagesArchSpecific(temp_dir, dar)
    ...   os.unlink(pas_filename)
    ...   return pas_verify

    >>> legal_archs = set(hoary.architectures)

First check a positive source listing:

    >>> pas_verify = getPASVerifier("%test-buildd-3: i386")
    >>> [a.architecturetag for a in
    ...       determineArchitecturesToBuild(pub_three, legal_archs, hoary,
    ...                                     pas_verify)]
    [u'i386']

And now a negative source listing:

    >>> pas_verify = getPASVerifier("%test-buildd-3: !i386")
    >>> [a.architecturetag for a in
    ...       determineArchitecturesToBuild(pub_three, legal_archs, hoary,
    ...                                     pas_verify)]
    [u'hppa']

And a source listing which causes us to produce no builds:

    >>> pas_verify = getPASVerifier("%test-buildd-3: sparc")
    >>> [a.architecturetag for a in
    ...       determineArchitecturesToBuild(pub_three, legal_archs, hoary,
    ...                                     pas_verify)]
    []

PPA builds are not affected by P-a-s restrictions, i.e., they will
build for all requested architectures currently supported in the PPA
subsystem.

    >>> pas_verify = getPASVerifier("%test-ppa: hppa")
    >>> [a.architecturetag for a in
    ...      determineArchitecturesToBuild(pub_hoary_ppa, legal_archs,
    ...                                    hoary, pas_verify)]
    [u'i386']

    >>> pas_verify = getPASVerifier("%test-ppa: !i386")
    >>> [a.architecturetag for a in
    ...      determineArchitecturesToBuild(pub_hoary_ppa, legal_archs,
    ...                                    hoary, pas_verify)]
    [u'i386']


== Binary PAS ==

To check binary PAS listings we'll use a source publication for
iceweasel which produces mozilla-firefox binaries in warty and already
has its data set up.

    >>> firefox_pub = SecureSourcePackagePublishingHistory.get(28)
    >>> print firefox_pub.sourcepackagerelease.title
    iceweasel - 1.0
    >>> print firefox_pub.sourcepackagerelease.architecturehintlist
    any
    >>> iceweasel_binaries = warty.getSourcePackage('iceweasel')['1.0'].binaries
    >>> [b.title for b in iceweasel_binaries]
    [u'mozilla-firefox-1.0']

    >>> legal_archs = set(warty.architectures)
    >>> sorted([a.architecturetag for a in legal_archs], reverse=True)
    [u'i386', u'hppa']

Restrict iceweasel targets to i386 and sparc, since the latter is not
present in warty, we will only create a build for i386:

    >>> pas_verify = getPASVerifier("mozilla-firefox: i386 sparc", dar=warty)
    >>> permitted_archs = determineArchitecturesToBuild(
    ...      firefox_pub, legal_archs, warty, pas_verify)
    >>> [a.architecturetag for a in permitted_archs]
    [u'i386']

And a binary PAS listing that tries to exclude i386 and hppa from an
arch-any build. The exclusion of i386 is ignored; see comment in
pas.py:_handleBinaryPAS for more information on why.

    >>> pas_verify = getPASVerifier("mozilla-firefox: !i386 !hppa", dar=warty)
    >>> permitted_archs = determineArchitecturesToBuild(
    ...      firefox_pub, legal_archs, warty, pas_verify)
    >>> [a.architecturetag for a in permitted_archs]
    [u'i386']

XXX cprov 20071211: we can't properly test PPA binary-PAS right now
because there is no binary package published in PPA. The way the P-a-s
component is completely ignored for PPAs indicates that we are safe,
however, for now, we have to rely on the previous primary-archive tests.


== Check the architectures ==

See if the code which determines archs to build does the right thing for
each of these options:

    >>> legal_archs = set(hoary.architectures)
    >>> [a.architecturetag for a in
    ...       determineArchitecturesToBuild(pub_all, legal_archs, hoary)]
    [u'i386']
    >>> [a.architecturetag for a in
    ...       determineArchitecturesToBuild(pub_any, legal_archs, hoary)]
    [u'hppa', u'i386']
    >>> [a.architecturetag for a in
    ...       determineArchitecturesToBuild(pub_three, legal_archs, hoary)]
    [u'hppa', u'i386']
    >>> [a.architecturetag for a in
    ...       determineArchitecturesToBuild(pub_one, legal_archs, hoary)]
    [u'hppa']

== Check support for kernel notation in architecture hint list ==

dpkg supports the use of the '<kernel-><arch>' notation in the
'Architecture' field, where 'kernel-' is one of the kernel platform
available in debian systems: ['linux-', 'kfreebsd', 'hurd-', 'any-']

See bug 73761 and http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=268709
for further information about this dpkg feature.

Soyuz will consider only 'any-' and 'linux-' elements as the
corresponding architecture, since only linux is supported in ubuntu.

    >>> [a.architecturetag for a in
    ...       determineArchitecturesToBuild(pub_any_foo, legal_archs, hoary)]
    [u'hppa']
    >>> [a.architecturetag for a in
    ...       determineArchitecturesToBuild(pub_linux_foo, legal_archs, hoary)]
    [u'i386']


== PPA architectures ==

Only the architecture with established support for PPA will be
considered when creating PPA builds. See distroarchseries.txt for
further information.

    >>> legal_archs = set(hoary.architectures)
    >>> [a.architecturetag for a in
    ...      determineArchitecturesToBuild(pub_hoary_ppa, legal_archs, hoary)]
    [u'i386']


== Create and verify the new builds ==

Create missing builds (packages w/o build entry) for those distroserieses.

We expect to have a couple of new builds for the sane hoary/RELEASE,
one for warty/UPDATES and one for hoary/RELEASE/PPA.

    >>> for dr in distroserieses:
    ...      bm.createMissingBuilds(dr)

Check that we only created new Build entries for the new hoary releases:

    >>> new_builds = [b for b in Build.select() if b.id not in old_build_ids]
    >>> for build in sorted(new_builds, key=operator.attrgetter('id')):
    ...   print build.title
    i386 build of test-buildd 667 in ubuntu hoary RELEASE
    hppa build of test-buildd-2 668 in ubuntu hoary RELEASE
    i386 build of test-buildd-2 668 in ubuntu hoary RELEASE
    hppa build of test-buildd-3 669 in ubuntu hoary RELEASE
    i386 build of test-buildd-3 669 in ubuntu hoary RELEASE
    hppa build of test-buildd-4 670 in ubuntu hoary RELEASE
    hppa build of test-buildd-6 672 in ubuntu hoary RELEASE
    i386 build of test-buildd-7 673 in ubuntu hoary RELEASE
    i386 build of test-failed 1.0 in ubuntu hoary RELEASE
    i386 build of test-ppa 674 in ubuntu hoary RELEASE
    i386 build of test-updates 665 in ubuntu warty UPDATES

And have a look at our arch-all series's build:

    >>> b = Build.selectOneBy(sourcepackagerelease=pub_all.sourcepackagerelease)
    >>> (b.sourcepackagerelease.name, b.distroarchseries.distroseries.name)
    (u'test-buildd', u'hoary')

== Create and verify the new queue entries ==

BuildQueue records corresponding to the build records in NEEDSBUILD
state are immediately created.

    >>> active_jobs = [bq for bq in BuildQueue.select(orderBy='id')
    ...                if bq.id not in old_job_ids]
    >>> len(active_jobs)
    11

The BuildQueue entries created are already 'scored', it means that the job
can be already dispatched once operation is committed, i.e.,
dispatching can happen in parallel with build creation.

    >>> bq = active_jobs[0]
    >>> print bq.build.title
    i386 build of test-buildd 667 in ubuntu hoary RELEASE
    >>> bq.lastscore
    1005

Check the published component name retriever, they might be different,
i.e., the published component can be different than the original component.

    >>> print bq.build.current_component.name
    main
    >>> print bq.build.sourcepackagerelease.component.name
    main

Missing BuildQueue records, resulted of given-back builds are created
in the last stage of the queue-builder script

    >>> given_back_build = bq.build
    >>> bq.destroySelf()
    >>> flush_database_updates()

    >>> print given_back_build.buildqueue_record
    None

    >>> bm.addMissingBuildQueueEntries()

    >>> given_back_build.buildqueue_record is not None
    True
