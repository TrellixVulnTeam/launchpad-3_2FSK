= Package Cache System =

  >>> import transaction

  >>> from canonical.launchpad.database import (
  ...    DistributionSourcePackageCache,
  ...    DistroReleasePackageCache)

  >>> from canonical.launchpad.interfaces import IDistributionSet
  >>> ubuntu = getUtility(IDistributionSet)['ubuntu']
  >>> warty = ubuntu['warty']

Launchpad caches published packages (sources and binaries) details in
order to get better performance on searches.

Cached information for sources is stored in
DistributionSourcePackageCache table, including:

 * distribution, IDistribution where the source was published
 * sourcepackagename, respective ISourcePackageName
 * name, source name in text format.
 * binpkgnames, text containing all the binary package names generated
   by th source.
 * binpkgsummary, text containing all summaries of the binaries
   generated by this source.
 * binpkgdescription, text containing all descriptions of the binaries
   generated by this source.
 * fti, a tsvector generated on insert or update with the text indexes
   for name, binpkgnames, binpkgsummaries and binpkgdescriptions.


  >>> ubuntu_caches = DistributionSourcePackageCache.selectBy(
  ...     distribution=ubuntu)

  >>> ubuntu_caches.count()
  9

  >>> for cache in ubuntu_caches.orderBy('name'):
  ...     print cache.name
  alsa-utils
  cnews
  evolution
  foobar
  libstdc++
  linux-source-2.6.15
  mozilla-firefox
  netapplet
  pmount


Cached information for binaries is stored in DistroReleasePackageCache
table, including:

 * distrorelease, IDistroRelease where the binary is published.
 * binarypackagename, respective IBinaryPackageName.
 * name, binary name in text format.
 * summary, binary summary in text format.
 * description, binary description in text format.
 * summaries, binary summaries  in text format
 * descriptions, binary description in text format.
 * fti, a tsvector generated on insert or update with the text indexes
   for name, summary, description, summaries and descriptions.


  >>> warty_caches = DistroReleasePackageCache.selectBy(distrorelease=warty)
  >>> warty_caches.count()
  5
  >>> for cache in warty_caches.orderBy('name'):
  ...     print cache.name
  at
  foobar
  linux-2.6.12
  mozilla-firefox
  pmount

Different than sources, where multiple generated binaries are very
common, multiple binaries of with the same name are only possible when
versions are not the same across architectures.

Building these caches we can reach good performance on full and
partial term searching.

  >>> len(ubuntu.searchSourcePackages('mozilla'))
  1

  >>> len(ubuntu.searchSourcePackages('moz'))
  1

  >>> len(ubuntu.searchSourcePackages('biscoito'))
  0

The cache update procedure is done by cronscripts/update-pkgcache.py,
which removes obsolete records, update existing ones and add new
records during the scanning of all the publishing records. This
scripts runs periodically in our infrastructure. See usage at the end
of the file.


== Dealing with Source Caches ==


A SourcePackage is present in the sampledata as REVOVED and still part
of the caches:

  >>> foobar_in_ubuntu = ubuntu.getSourcePackage('foobar')
  >>> foobar_rel = foobar_in_ubuntu.releases[0]
  >>> foobar_pub = foobar_rel.publishing_history[0]
  >>> foobar_pub.status.name
  'REMOVED'

  >>> len(ubuntu.searchSourcePackages('foobar'))
  1

  >>> foobar_cache = DistributionSourcePackageCache.selectOneBy(
  ...     distribution=ubuntu, name='foobar')

  >>> foobar_cache.id
  10

Source cache updates are driven by distribution, IDistribution
instance offers a method for removing obsolete records in cache:

Let's use a fake logger object:

  >>> class TestLog:
  ...     def debug(self, msg):
  ...         print 'DEBUG: %s' % msg

  >>> ubuntu.removeOldCacheItems(log=TestLog())
  DEBUG: Removing source cache for 'foobar' (10)

  >>> transaction.commit()

  >>> len(ubuntu.searchSourcePackages('foobar'))
  0

  >>> foobar_cache = DistributionSourcePackageCache.selectOneBy(
  ...     distribution=ubuntu, name='foobar')

  >>> foobar_cache is None
  True

Also, the sampledata provides a published source which is not present
in the caches:

  >>> cdrkit_in_ubuntu = ubuntu.getSourcePackage('cdrkit')
  >>> cdrkit_rel = cdrkit_in_ubuntu.releases[0]
  >>> cdrkit_pub = cdrkit_rel.publishing_history[0]
  >>> cdrkit_pub.status.name
  'PUBLISHED'

  >>> len(ubuntu.searchSourcePackages('cdrkit'))
  0

  >>> cdrkit_cache = DistributionSourcePackageCache.selectOneBy(
  ...     distribution=ubuntu, name='cdrkit')

  >>> cdrkit_cache is None
  True

We can invoke the cache updater directly on IDistrorelease:

  >>> ubuntu.updateCompleteSourcePackageCache(
  ...    ztm=transaction, log=TestLog())
  DEBUG: Considering source 'mozilla-firefox'
  ...
  DEBUG: Considering source 'cdrkit'
  DEBUG: Creating new source cache entry.
  ...

The current transaction should be committed again, to catch the
partial batches (less than 50 sources considered) and also updates
should be flushed since the 'name' (among other texts) are set after
the row creation:

XXX cprov 20061201: it can be considered a bug.

  >>> transaction.commit()

  >>> from canonical.database.sqlbase import flush_database_updates
  >>> flush_database_updates()

Now we the 'cdrkit' source is part of the caches and can be reached
via searches:

  >>> len(ubuntu.searchSourcePackages('cdrkit'))
  1

  >>> cdrkit_cache = DistributionSourcePackageCache.selectOneBy(
  ...     distribution=ubuntu, name='cdrkit')

  >>> cdrkit_cache.id
  11L


== Dealing with Binary Caches ==


A BinaryPackage is present in the sampledata as REVOVED and still part
of the caches:

  >>> foobar_bin_in_warty = warty.getBinaryPackage('foobar')
  >>> foobar_bin_rel = foobar_in_ubuntu.releases[0]
  >>> foobar_bin_pub = foobar_rel.publishing_history[0]
  >>> foobar_bin_pub.status.name
  'REMOVED'

  >>> len(warty.searchPackages('foobar'))
  1

  >>> foobar_bin_cache = DistroReleasePackageCache.selectOneBy(
  ...     distrorelease=warty, name='foobar')

  >>> foobar_bin_cache.id
  8

Binary cache updates are driven by distrorelease, IDistroRelease
instance offers a method for removing obsolete records in cache:

  >>> warty.removeOldCacheItems(log=TestLog())
  DEBUG: Removing binary cache for 'foobar' (8)

  >>> transaction.commit()

  >>> len(warty.searchPackages('foobar'))
  0

  >>> foobar_bin_cache = DistroReleasePackageCache.selectOneBy(
  ...     distrorelease=warty, name='foobar')

  >>> foobar_bin_cache is None
  True

We have a published binary which is not present in the caches:

  >>> cdrkit_bin_in_warty = warty.getBinaryPackage('cdrkit')
  >>> cdrkit_bin_pub = cdrkit_bin_in_warty.current_publishings[0]
  >>> cdrkit_bin_pub.status.name
  'PUBLISHED'

  >>> len(warty.searchPackages('cdrkit'))
  0

  >>> cdrkit_bin_cache = DistroReleasePackageCache.selectOneBy(
  ...     distrorelease=warty, name='cdrkit')

  >>> cdrkit_bin_cache is None
  True

We can invoke the cache updater directly on IDistrorelease:

  >>> warty.updateCompletePackageCache(
  ...    ztm=transaction, log=TestLog())
  DEBUG: Considering binary 'mozilla-firefox'
  ...
  DEBUG: Considering binary 'cdrkit'
  DEBUG: Creating new binary cache entry.
  ...

Transaction behaves exactly the same as for Source Caches, except that
it commits full batches of 100 elements.

XXX cprov 20061201: it can be considered a bug (same than Source
cache interface)

  >>> transaction.commit()

  >>> from canonical.database.sqlbase import flush_database_updates
  >>> flush_database_updates()

Now we the 'cdrkit' binary is part of the caches and can be reached
via searches:

  >>> len(warty.searchPackages('cdrkit'))
  1

  >>> cdrkit_bin_cache = DistroReleasePackageCache.selectOneBy(
  ...     distrorelease=warty, name='cdrkit')

  >>> cdrkit_bin_cache.id
  9L


== Package Counters ==

We also store counters for Sources and Binaries published in a
DistroRelease pocket RELEASE:

  >>> warty.sourcecount
  3
  >>> warty.binarycount
  4

Since we have modified the publication list for warty in order to test
the caching system, we expect similar changes in the
counters. IDistroRelease provides a method to update its own cache:

  >>> warty.updatePackageCount()

New values were stored:

  >>> warty.sourcecount
  4
  >>> warty.binarycount
  5

A similar mechanism is offered by IDistroArchRelease, but only for
binaries (of course):

  >>> warty_i386 = warty['i386']

  >>> warty_i386.package_count
  5

Invoke the counter updater on this architecture:

  >>> warty_i386.updatePackageCount()

New values were stored:

  >>> warty_i386.package_count
  6

