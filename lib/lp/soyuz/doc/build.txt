= The Build table =

The build table contains the information pertaining to a given build
of a sourcepackagerelease on a distroarchseries.

The build record may have many BinaryPackageRelease records pointing
at it and it may reference a build log if the build was done on a
launchpad build daemon.

    # Create a 'mozilla-firefox' build in ubuntutest/breezy-autotest/i386.
    >>> from zope.security.proxy import removeSecurityProxy
    >>> from lp.soyuz.tests.test_publishing import SoyuzTestPublisher
    >>> login('foo.bar@canonical.com')
    >>> test_publisher = SoyuzTestPublisher()
    >>> test_publisher.prepareBreezyAutotest()
    >>> source = test_publisher.getPubSource(
    ...     sourcename='mozilla-firefox', version='0.9')
    >>> binaries = test_publisher.getPubBinaries(
    ...     binaryname='firefox', pub_source=source)
    >>> [firefox_build] = source.getBuilds()
    >>> job = firefox_build.buildqueue_record.job
    >>> removeSecurityProxy(job).start()
    >>> removeSecurityProxy(job).complete()
    >>> login(ANONYMOUS)

A build has a title which describes the context source version and in
which series and architecture it is targeted for.

    >>> print firefox_build.title
    i386 build of mozilla-firefox 0.9 in ubuntutest breezy-autotest RELEASE

A build directly links to the archive, distribution, distroseries,
distroarchseries, pocket in its context and also the source version
that generated it.

    >>> print firefox_build.archive.displayname
    Primary Archive for Ubuntu Test

    >>> print firefox_build.distribution.displayname
    ubuntutest

    >>> print firefox_build.distroseries.displayname
    Breezy Badger Autotest

    >>> print firefox_build.distroarchseries.displayname
    ubuntutest Breezy Badger Autotest i386

    >>> firefox_build.pocket
    <DBItem PackagePublishingPocket.RELEASE, (0) Release>

    >>> print firefox_build.arch_tag
    i386

    >>> firefox_build.is_virtualized
    False

    >>> print firefox_build.sourcepackagerelease.title
    mozilla-firefox - 0.9

A build has an state that represents in which stage it is in a
life-cycle that goes from PENDING to BUILDING until FULLYBUILT or one
of the intermediate failed states (FAILEDTOBUILD, MANUALDEPWAIT,
CHROOTWAIT, SUPERSEDED and FAILEDTOUPLOAD).

    >>> firefox_build.buildstate
    <DBItem BuildStatus.FULLYBUILT, (1) Successfully built>

Builds which were already processed also offer additional information
about its process such as the time it was started and finished and its
'buildlog' and 'upload_changesfile' as librarian files.

    >>> firefox_build.was_built
    True

    >>> firefox_build.calculated_buildstart
    datetime.datetime(...)

    >>> firefox_build.datebuilt
    datetime.datetime(...)

    >>> firefox_build.buildduration
    datetime.timedelta(...)

    >>> print firefox_build.buildlog.filename
    buildlog_ubuntutest-breezy-autotest-i386.mozilla-firefox_0.9_FULLYBUILT.txt.gz

    >>> print firefox_build.build_log_url
    http://launchpad.dev/ubuntutest/+source/mozilla-firefox/0.9/+build/.../+files/buildlog_ubuntutest-breezy-autotest-i386.mozilla-firefox_0.9_FULLYBUILT.txt.gz

    >>> print firefox_build.upload_changesfile.filename
    firefox_0.9_i386.changes

The 'firefox_build' is already finished and requesting the estimated build
start time makes no sense. Hence an exception is raised.

    >>> firefox_build.buildqueue_record.getEstimatedJobStartTime()
    Traceback (most recent call last):
    ...
    AssertionError: The start time is only estimated for pending jobs.

On a build job in state `NEEDSBUILD` we can ask for its estimated
build start time.

    # Create a brand new pending build.
    >>> login('foo.bar@canonical.com')
    >>> source = test_publisher.getPubSource(sourcename='pending-source')
    >>> [pending_build] = source.createMissingBuilds()
    >>> login(ANONYMOUS)

    >>> pending_build.buildqueue_record.getEstimatedJobStartTime()
    datetime.datetime(...)

The currently published component is provided via the 'current_component'
property.  It looks over the publishing records and finds the current
publication of the source in question.

    >>> print firefox_build.current_component.name
    main

It is not necessarily the same as:

    >>> print firefox_build.sourcepackagerelease.component.name
    main

which is the component the source was originally uploaded to, before
any overriding action.

The build can report any corresponding uploads using the package_upload
property:

    >>> firefox_build.package_upload
    <PackageUpload ...>

    >>> firefox_build.package_upload.status
    <DBItem PackageUploadStatus.DONE, (3) Done>

If the build does not have any uploads, None is returned:

    >>> from lp.soyuz.interfaces.build import BuildStatus, IBuildSet
    >>> at_build = getUtility(IBuildSet).getByBuildID(15)
    >>> print at_build.package_upload
    None

Test "retry" functionality:

    >>> firefox_build.can_be_retried
    False

    >>> frozen_build = getUtility(IBuildSet).getByBuildID(9)
    >>> frozen_build.title
    u'i386 build of pmount 0.1-1 in ubuntu warty RELEASE'
    >>> frozen_build.buildstate.title
    'Failed to build'
    >>> frozen_build.can_be_retried
    False

See section 'AssertionErrors in IBuild' for further documentation about
consequences of an denied 'retry' action.

Let's retrieve a build record that can be retried.

    >>> active_build = getUtility(IBuildSet).getByBuildID(9)

    >>> print active_build.title
    i386 build of pmount 0.1-1 in ubuntu warty RELEASE

    >>> print active_build.buildstate.name
    FAILEDTOBUILD

    >>> print active_build.builder.name
    bob

    >>> print active_build.buildlog.filename
    netapplet-1.0.0.tar.gz

At this point, it's also convenient to test if any content can be
stored as 'upload_log' using storeUploadLog().

This method will upload a file to librarian with the given content and
update the context `upload_log` reference.

We store such information persistently to allow users to revisit it,
and potentially fix any issue, after the build has been processed.

We continue to send the upload information with the
build-failure-notification for FAILEDTOUPLOAD builds, see
build-failedtoupload-workflow.txt for further information.

    >>> print active_build.upload_log
    None

    >>> print active_build.upload_log_url
    None

    >>> active_build.storeUploadLog('sample upload log.')
    >>> print active_build.upload_log.filename
    upload_9_log.txt

    >>> print active_build.upload_log_url
    http://launchpad.dev/ubuntu/+source/pmount/0.1-1/+build/9/+files/upload_9_log.txt

Once the transaction is committed, the file is available in the
librarian, and we can retrieve its contents.

    >>> transaction.commit()
    >>> active_build.upload_log.open()
    >>> print active_build.upload_log.read()
    sample upload log.

The 'upload_log' library file privacy is set according to the build
target archive.

    >>> print active_build.archive.private
    False

    >>> print active_build.upload_log.restricted
    False

Transforming ubuntu primary archive in a private archive makes
storeUploadLog() upload the given content as a restricted file.

    >>> login('foo.bar@canonical.com')
    >>> active_build.archive.buildd_secret = "secret"
    >>> active_build.archive.private = True
    >>> login(ANONYMOUS)

Simply changing the archive privacy after the 'upload_log' is stored
doesn't make it restricted. The archive privacy will be respected in
the next upload attempt only.

    >>> print active_build.upload_log.restricted
    False

In order to call storeUploadLog() again for the same build, we have to
remove the previously stored 'upload_log'. See the check below in
'AssertionErrors in IBuild' for more detail.

    >>> login('foo.bar@canonical.com')
    >>> active_build.upload_log = None
    >>> login(ANONYMOUS)

Once targeted to a private archive the 'upload_log' gets stored in the
restricted librarian instance.

    >>> print active_build.archive.private
    True

    >>> active_build.storeUploadLog('private upload log.')
    >>> print active_build.upload_log.restricted
    True

Restore ubuntu main archive state to not affect the rest of the tests.

    >>> login('foo.bar@canonical.com')
    >>> active_build.archive.buildd_secret = ''
    >>> active_build.archive.private = False
    >>> login(ANONYMOUS)

Since ubuntu/warty is already released the failed build can't be
retried.

    >>> active_build.can_be_retried
    False

We will reactivate ubuntu/warty allowing the pmount build to be
retried.

    >>> from canonical.launchpad.interfaces import SeriesStatus
    >>> from lp.registry.interfaces.distribution import IDistributionSet
    >>> login('foo.bar@canonical.com')
    >>> ubuntu = getUtility(IDistributionSet)['ubuntu']
    >>> warty = ubuntu.getSeries('warty')
    >>> warty.status = SeriesStatus.DEVELOPMENT
    >>> flush_database_updates()
    >>> login(ANONYMOUS)

    >>> active_build.can_be_retried
    True

Before we actually retry the build on hand let's set its start time.
This will allow us to observe the fact that a build retry does not
change the start time if it was set already.

    >>> from datetime import datetime, timedelta
    >>> import pytz
    >>> UTC = pytz.timezone('UTC')
    >>> time_now = datetime.now(UTC)
    >>> unsecured_build = removeSecurityProxy(active_build)
    >>> unsecured_build.date_first_dispatched = time_now
    >>> active_build.date_first_dispatched == time_now
    True

Re-trying builds requires the user to be logged in as an admin (including
buildd admin) to gain launchpad.Edit on the build record.  As an anonymous
user, retrying will fail:

    >>> active_build.retry()
    Traceback (most recent call last):
    ...
    Unauthorized:...

Login as an admin and retry the Build record in question:

    >>> login('foo.bar@canonical.com')
    >>> active_build.retry()

The build was retried but its start time remains the same.

    >>> active_build.date_first_dispatched == time_now
    True

Build record has no history and is NEEDSBUILD and a corresponding
BuildQueue record was created.

    >>> print active_build.builder
    None

    >>> print active_build.buildstate.name
    NEEDSBUILD

    >>> print active_build.buildqueue_record
    <...BuildQueue...>

'buildlog' and 'upload_log' librarian references were removed when the
build was retried. They will be garbage-collected later by
'librariangc' and replaced by new ones when the build re-attempt
finishes.

    >>> print active_build.buildlog
    None

    >>> print active_build.upload_log
    None

We will restore ubuntu/warty previously changes status, SUPPORTED, so
it won't interfere in the next tests.

    >>> login('foo.bar@canonical.com')
    >>> warty.status = SeriesStatus.SUPPORTED
    >>> flush_database_updates()
    >>> login(ANONYMOUS)

Initialize all the required arguments to create a binary package for a
given build record entry.

    >>> from canonical.launchpad.interfaces import IBinaryPackageNameSet
    >>> binarypackagename = getUtility(IBinaryPackageNameSet).ensure('demo').id
    >>> version = '0.0.1-demo'
    >>> summary = 'Summmmmmmmary'
    >>> description = 'Descripppppppption'
    >>> from canonical.launchpad.interfaces import BinaryPackageFormat
    >>> binpackageformat = BinaryPackageFormat.DEB
    >>> component = firefox_build.sourcepackagerelease.component.id
    >>> section = firefox_build.sourcepackagerelease.section.id
    >>> from canonical.launchpad.interfaces import PackagePublishingPriority
    >>> priority = PackagePublishingPriority.STANDARD
    >>> shlibdeps = None
    >>> depends = None
    >>> recommends = None
    >>> suggests = None
    >>> conflicts = None
    >>> replaces = None
    >>> provides = None
    >>> essential = False
    >>> installedsize = 0
    >>> architecturespecific = False
    >>> pre_depends = None
    >>> enhances = None
    >>> breaks = None

Invoke createBinaryPackageRelease with all required arguments.

    # Load a build from the samepledata for creating binaries.
    >>> pmount_build = getUtility(IBuildSet).getByBuildID(19)

    >>> bin = pmount_build.createBinaryPackageRelease(
    ...     binarypackagename, version, summary, description,
    ...     binpackageformat, component, section, priority, shlibdeps,
    ...     depends, recommends, suggests, conflicts, replaces, provides,
    ...     pre_depends, enhances, breaks, essential, installedsize,
    ...     architecturespecific)

    >>> from canonical.launchpad.interfaces import IBinaryPackageRelease
    >>> from canonical.launchpad.webapp.testing import verifyObject
    >>> verifyObject(IBinaryPackageRelease, bin)
    True

Commit previous transaction, data we want to preserve:

XXX: flush_database_updates() shouldn't be needed. This seems to be
Bug 3989 -- StuarBishop 20060713

    >>> flush_database_updates()
    >>> transaction.commit()

Check binarypackages property:

    >>> for b in pmount_build.binarypackages:
    ...     b.version
    u'0.0.1-demo'
    u'0.1-1'

Emulate a huge list of binaries for 'pmount':

    >>> bpnameset = getUtility(IBinaryPackageNameSet)
    >>> for i in range(15):
    ...     version = "%d" % i
    ...     binarypackagename = bpnameset.ensure("test-%d" % i).id
    ...     b = pmount_build.createBinaryPackageRelease(
    ...         binarypackagename, version, summary, description,
    ...         binpackageformat, component, section, priority, shlibdeps,
    ...         depends, recommends, suggests, conflicts, replaces, provides,
    ...         pre_depends, enhances, breaks, essential, installedsize,
    ...         architecturespecific)


Check if the property is still working:

    >>> pmount_build.binarypackages.count()
    17

Ensure the list is ordered by 'name'

    >>> for b in pmount_build.binarypackages:
    ...     b.name, b.version
    (u'demo', u'0.0.1-demo')
    (u'pmount', u'0.1-1')
    (u'test-0', u'0')
    (u'test-1', u'1')
    (u'test-10', u'10')
    (u'test-11', u'11')
    (u'test-12', u'12')
    (u'test-13', u'13')
    (u'test-14', u'14')
    (u'test-2', u'2')
    (u'test-3', u'3')
    (u'test-4', u'4')
    (u'test-5', u'5')
    (u'test-6', u'6')
    (u'test-7', u'7')
    (u'test-8', u'8')
    (u'test-9', u'9')

Rollback transaction to no disturb the other tests:

    >>> transaction.abort()


== The BuildSet Class ==

The BuildSet class gives us some useful ways to consider the
collection of builds.

    >>> bs = getUtility(IBuildSet)

We can find builds given a source package release and architecture tag.

    >>> i386_builds = bs.getBuildBySRAndArchtag(20, 'i386')
    >>> i386_builds.count()
    4

IHasBuildRecords uses a base method provided by IBuildSet,
getBuildsByArchIds():

It receives list of architectures IDs:

    >>> hoary = ubuntu.getSeries('hoary')
    >>> arch_ids = [arch.id for arch in hoary.architectures]
    >>> bs.getBuildsByArchIds(arch_ids).count()
    5

It still working for empty list or None:

    >>> bs.getBuildsByArchIds([]).count()
    0

    >>> bs.getBuildsByArchIds(None).count()
    0

Using build status, only the successfully built ones:

    >>> bs.getBuildsByArchIds(arch_ids,
    ...     status=BuildStatus.FULLYBUILT).count()
    2

Check the result content:

    >>> [b.title for b in bs.getBuildsByArchIds(arch_ids,
    ...     status=BuildStatus.FULLYBUILT)]
    [u'i386 build of pmount 0.1-1 in ubuntu hoary RELEASE', u'hppa build
    of pmount 0.1-1 in ubuntu hoary RELEASE']

Using optional 'name' filter (matching with SQL LIKE %||filter||%)

    >>> bs.getBuildsByArchIds(arch_ids,
    ...     status=BuildStatus.FULLYBUILT,
    ...     name='pmo').count()
    2

Checking optional 'pocket' restriction:

    >>> from lp.registry.interfaces.pocket import PackagePublishingPocket
    >>> bs.getBuildsByArchIds(arch_ids,
    ...     pocket=PackagePublishingPocket.UPDATES).count()
    0

    >>> bs.getBuildsByArchIds(arch_ids,
    ...     pocket=PackagePublishingPocket.RELEASE).count()
    5

getBuildsByArchIds will also return builds for archives other than the
primary archive.

    >>> breezy = ubuntu.getSeries('breezy-autotest')
    >>> arch_ids = [arch.id for arch in breezy.architectures]
    >>> [(build.archive.purpose.name, build.title) for build in
    ...    bs.getBuildsByArchIds(arch_ids, name='commercialpackage')]
    [('PARTNER', u'i386 build of commercialpackage 1.0-1 in ubuntu breezy-autotest RELEASE')]

`IBuildSet` also provides getStatusSummaryForBuilds which summarizes the
build status of a set of builds:

First we'll define a helper to print the build summary:

    >>> def print_build_summary(summary):
    ...     print "%s\n%s\nRelevant builds:\n%s" % (
    ...         summary['status'].title,
    ...         summary['status'].description,
    ...         "\n".join(
    ...             " - %s" % build.title for build in summary['builds'])
    ...     )

    >>> build_summary = bs.getStatusSummaryForBuilds(i386_builds)
    >>> print_build_summary(build_summary)
    NEEDSBUILD
    There are some builds waiting to be built.
    Relevant builds:
     - i386 build of pmount 0.1-1 in ubuntu warty RELEASE

The build set class furthermore provides a mechanism to load build-related
data from the database for a given set of builds:

    >>> from storm.expr import In
    >>> from lp.soyuz.model.build import Build
    >>> from canonical.launchpad.webapp.interfaces import (
    ...     IStoreSelector, MAIN_STORE, DEFAULT_FLAVOR)
    >>> store = getUtility(IStoreSelector).get(MAIN_STORE, DEFAULT_FLAVOR)
    >>> results = list(store.find(Build, In(Build.id, (2,6,7,8))))
    >>> rset = removeSecurityProxy(bs)._prefetchBuildData(results)
    >>> def filename_or_none(item):
    ...     if item is not None:
    ...         return '%s' % item.filename
    ...     else:
    ...         return 'n/a'
    >>> def id_or_none(item):
    ...     if item is not None:
    ...         return '%d' % item.id
    ...     else:
    ...         return 'n/a'
    >>> def sort_result_key(row):
    ...     return row[0].id
    >>> for row in sorted(rset, key=sort_result_key):
    ...     (sourcepackagerelease, buildlog,
    ...      sourcepackagename, buildlog_content, builder) = row
    ...     print(
    ...         'builder: %s, spr: %s, log: %s' %
    ...         (id_or_none(builder),
    ...          sourcepackagerelease.title, filename_or_none(buildlog)))
    builder:   1, spr: mozilla-firefox - 0.9, log: netapplet-1.0.0.tar.gz
    builder: n/a, spr: mozilla-firefox - 0.9, log: n/a
    builder:   1, spr:        pmount - 0.1-1, log: netapplet-1.0.0.tar.gz
    builder:   1, spr:          foobar - 1.0, log: netapplet-1.0.0.tar.gz


== IHadBuildRecords.getBuildRecords() Implementations ==

XXX: Michael Nelson 20090701 bug=394276
The documentation for IHasBuildRecords is now in
lp/soyuz/doc/hasbuildrecords.txt. The following implementation tests should
be converted to unit-tests in lib/soyuz/tests/test_hasbuildrecords.py.

We can find recent and pending builds for a given distrarchoseries.

    >>> hoaryi386 = hoary['i386']
    >>> hoaryi386.title
    u'The Hoary Hedgehog Release for i386 (x86)'

Exercises IHasBuildRecords abilities for distroarchseriess

    >>> hoaryi386.getBuildRecords().count()
    4

    >>> hoaryi386.getBuildRecords(build_state=BuildStatus.FULLYBUILT).count()
    1

    >>> hoaryi386.getBuildRecords(name='pm').count()
    1

    >>> hoaryi386.getBuildRecords(
    ...     pocket=PackagePublishingPocket.RELEASE).count()
    4

    >>> hoaryi386.getBuildRecords(
    ...     pocket=PackagePublishingPocket.UPDATES).count()
    0


For SourcePackages, getBuildRecords() returns all build records
published in its context (distroseries and distribution main
archives), independent of their corresponding source publishing
status.

    >>> firefox = warty.getSourcePackage('mozilla-firefox')

    >>> firefox.getBuildRecords().count()
    8

    >>> firefox.getBuildRecords(
    ...     build_state=BuildStatus.FULLYBUILT).count()
    6

    >>> firefox.getBuildRecords(
    ...     pocket=PackagePublishingPocket.RELEASE).count()
    8

    >>> firefox.getBuildRecords(
    ...     pocket=PackagePublishingPocket.UPDATES).count()
    0

As mentioned above, SourcePackage.getBuildRecords() will return builds
for packages that are no longer published. At first, there are no
traces of the 'old-source' sourcepackage in ubuntutest/breezy-autotest

    >>> ubuntutest = getUtility(IDistributionSet).getByName('ubuntutest')
    >>> breezy_autotest = ubuntutest.getSeries('breezy-autotest')
    >>> print breezy_autotest.getSourcePackage('old-source')
    None

Once the SourcePackage exists and has builds, they will be returned by
getBuildRecords() ordered by descending creation date.

    # Create a DELETED and a SUPERSEDED source publication in
    # ubuntutest/breezy-autotest.
    >>> from canonical.launchpad.interfaces import PackagePublishingStatus
    >>> login('foo.bar@canonical.com')
    >>> old_source_pub = test_publisher.getPubSource(
    ...     sourcename='old-source', version='1.0',
    ...     status=PackagePublishingStatus.SUPERSEDED)
    >>> [superseded_build] = old_source_pub.createMissingBuilds()
    >>> deleted_source_pub = test_publisher.getPubSource(
    ...     sourcename='old-source', version='1.1',
    ...     status=PackagePublishingStatus.DELETED)
    >>> [deleted_build] = deleted_source_pub.createMissingBuilds()
    >>> login(ANONYMOUS)

    >>> old_source_sp = breezy_autotest.getSourcePackage('old-source')
    >>> old_source_builds = old_source_sp.getBuildRecords()
    >>> [deleted_build, superseded_build] == list(old_source_builds)
    True

    >>> deleted_build.datecreated > superseded_build.datecreated
    True

Builds records for the exactly the same `SourcePackageRelease`s may
exist in a rebuild archive context, but they do not 'leak' to the
domain of SourcePackage.

    # Create a rebuild archive, copy the 'old-source' source
    # publications to it and create builds in the rebuild archive
    # context.
    >>> from lp.soyuz.interfaces.archive import ArchivePurpose
    >>> login('foo.bar@canonical.com')
    >>> rebuild_archive = factory.makeArchive(
    ...     ubuntutest, ubuntutest.owner, 'test-rebuild',
    ...     ArchivePurpose.COPY)
    >>> rebuild_old_pub = old_source_pub.copyTo(
    ...     breezy_autotest, PackagePublishingPocket.RELEASE,
    ...     rebuild_archive)
    >>> [rebuild_old_build] = rebuild_old_pub.createMissingBuilds()
    >>> rebuild_deleted_pub = deleted_source_pub.copyTo(
    ...     breezy_autotest, PackagePublishingPocket.RELEASE,
    ...     rebuild_archive)
    >>> [rebuild_deleted_build] = rebuild_deleted_pub.createMissingBuilds()
    >>> login(ANONYMOUS)

    >>> rebuild_builds = rebuild_archive.getBuildRecords()
    >>> [rebuild_deleted_build, rebuild_old_build] == list(rebuild_builds)
    True

    >>> old_source_sp.getBuildRecords().count()
    2

For a given distribution as well:

    >>> ubuntu.getBuildRecords().count()
    17

    >>> L = ubuntu.getBuildRecords(build_state=BuildStatus.FULLYBUILT)
    >>> for l in L:
    ...     print l.datebuilt, l.id, l.buildstate.value
    2007-08-10 00:00:14+00:00 30 1
    2007-08-09 23:59:59+00:00 29 1
    2005-03-25 00:00:03+00:00 7 1
    2005-03-25 00:00:02+00:00 16 1
    2005-03-25 00:00:01+00:00 19 1
    2004-09-27 11:57:14+00:00 2 1
    2004-09-27 11:57:13+00:00 18 1

Retrieve the current PENDING builds

    >>> builds = ubuntu.getBuildRecords(build_state=BuildStatus.NEEDSBUILD)
    >>> builds.count()
    2

Note, by ordering the build by BuildQueue.lastscore, it already notice
the existence of a new pending build, since retry already creates a
new BuildQueue record:

    >>> builds = ubuntu.getBuildRecords(build_state=BuildStatus.NEEDSBUILD)
    >>> builds.count()
    2

Note that they are ordered by DESC lastscore, as expected:

    >>> for b in builds:
    ...     b.id, b.buildstate.value, b.buildqueue_record.lastscore
    (11, 0, 10)
    (9, 0, 0)

Define a helper function to print out build details.

    >>> def print_build_details(builds):
    ...     for build in builds:
    ...         if build.archive.owner:
    ...             print "%s: %s" % (build.archive.owner.name, build.title)
    ...         else:
    ...             print "main: %s" % (build.title)

Using the optional name argument to filter build results:

    >>> builds = ubuntu.getBuildRecords(name='pm')
    >>> builds.count()
    4
    >>> print_build_details(builds)
    ubuntu-team: i386 build of pmount 0.1-1 in ubuntu warty RELEASE
    ubuntu-team: i386 build of pmount 0.1-1 in ubuntu breezy-autotest RELEASE
    ubuntu-team: hppa build of pmount 0.1-1 in ubuntu hoary RELEASE
    ubuntu-team: i386 build of pmount 0.1-1 in ubuntu hoary RELEASE

or using optional pocket argument:

    >>> from lp.registry.interfaces.pocket import PackagePublishingPocket

    >>> ubuntu.getBuildRecords(
    ...    build_state=BuildStatus.NEEDSBUILD,
    ...    pocket=PackagePublishingPocket.RELEASE).count()
    2

    >>> ubuntu.getBuildRecords(
    ...    build_state=BuildStatus.NEEDSBUILD,
    ...    pocket=PackagePublishingPocket.SECURITY).count()
    0

IHasBuildRecords is implemented by Builder.  It can filter on build state
and name.  A user can also be passed for security checks on private builds;
if user is not passed then the query runs anonymously which means private
builds are excluded from anything returned.

Log in as admin to avoid security on IBuild for the moment.

    >>> login('foo.bar@canonical.com')

Let's make cprov's archive private (and hence its builds become private):

    >>> from canonical.launchpad.interfaces import IPersonSet
    >>> cprov = removeSecurityProxy(getUtility(IPersonSet).getByName('cprov'))
    >>> cprov.archive.buildd_secret = "secret"
    >>> cprov.archive.private = True
    >>> flush_database_updates()

The default set of builds with no user specified excludes private builds:

    >>> from canonical.launchpad.interfaces import IBuilderSet
    >>> bob = getUtility(IBuilderSet)['bob']
    >>> bob_builds = bob.getBuildRecords()
    >>> print_build_details(bob_builds)
    ubuntu-team: hppa build of mozilla-firefox 0.9 in ubuntu warty RELEASE
    no-priv: i386 build of cdrkit 1.0 in ubuntu warty RELEASE
    ubuntu-team: i386 build of cdrkit 1.0 in ubuntu breezy-autotest RELEASE
    ...
    ubuntu-team: i386 build of mozilla-firefox 0.9 in ubuntu warty RELEASE
    ubuntu-team: i386 build of mozilla-firefox 0.9 in ubuntu breezy-autotest 
    RELEASE
    
    >>> bob_builds.count()
    13

If we include an admin user, we can see all the builds.  Here, we get
three additional private builds for cprov:

    >>> from canonical.launchpad.interfaces import ILaunchpadCelebrities
    >>> admin = getUtility(ILaunchpadCelebrities).admin
    >>> bob_builds = bob.getBuildRecords(user=admin)
    >>> print_build_details(bob_builds)
    ubuntu-team: hppa build of mozilla-firefox 0.9 in ubuntu warty RELEASE
    cprov: hppa build of mozilla-firefox 0.9 in ubuntu warty RELEASE
    cprov: i386 build of pmount 0.1-1 in ubuntu warty RELEASE
    cprov: i386 build of cdrkit 1.0 in ubuntu breezy-autotest RELEASE
    no-priv: i386 build of cdrkit 1.0 in ubuntu warty RELEASE
    ubuntu-team: i386 build of cdrkit 1.0 in ubuntu breezy-autotest RELEASE
    ...
    ubuntu-team: i386 build of mozilla-firefox 0.9 in ubuntu warty RELEASE
    ubuntu-team: i386 build of mozilla-firefox 0.9 in ubuntu breezy-autotest
        RELEASE
    
    >>> bob_builds.count()
    16

Cprov can also see his own builds of course:

    >>> bob_builds = bob.getBuildRecords(user=cprov)
    >>> print_build_details(bob_builds)
    ubuntu-team: hppa build of mozilla-firefox 0.9 in ubuntu warty RELEASE
    cprov: hppa build of mozilla-firefox 0.9 in ubuntu warty RELEASE
    cprov: i386 build of pmount 0.1-1 in ubuntu warty RELEASE
    cprov: i386 build of cdrkit 1.0 in ubuntu breezy-autotest RELEASE
    no-priv: i386 build of cdrkit 1.0 in ubuntu warty RELEASE
    ubuntu-team: i386 build of cdrkit 1.0 in ubuntu breezy-autotest RELEASE
    ...
    ubuntu-team: i386 build of mozilla-firefox 0.9 in ubuntu warty RELEASE
    ubuntu-team: i386 build of mozilla-firefox 0.9 in ubuntu breezy-autotest
        RELEASE

    >>> bob_builds.count()
    16

Buildd admins specifically are not allowed to see private builds, which will
be filtered from the list returned:

    >>> buildd_admin = factory.makePerson()
    >>> buildd_admins = getUtility(
    ...     IPersonSet).getByName('launchpad-buildd-admins')
    >>> ignored = buildd_admins.addMember(buildd_admin, buildd_admin)
    >>> bob_builds = bob.getBuildRecords(user=buildd_admin)
    >>> print_build_details(bob_builds)
    ubuntu-team: hppa build of mozilla-firefox 0.9 in ubuntu warty RELEASE
    no-priv: i386 build of cdrkit 1.0 in ubuntu warty RELEASE
    ubuntu-team: i386 build of cdrkit 1.0 in ubuntu breezy-autotest RELEASE
    ...
    ubuntu-team: i386 build of mozilla-firefox 0.9 in ubuntu warty RELEASE
    ubuntu-team: i386 build of mozilla-firefox 0.9 in ubuntu breezy-autotest
    RELEASE

    >>> bob_builds.count()
    13

You can filter on build state:

    >>> bob_failed_builds = bob.getBuildRecords(
    ...     build_state=BuildStatus.FAILEDTOBUILD, user=admin)
    >>> bob_failed_builds.count()
    3

You can filter on package name:

    >>> bob_pmount_builds = bob.getBuildRecords(name='pmount', user=admin)
    >>> bob_pmount_builds.count()
    4

You can filter on build state and package name:

    >>> bob_pmount_ok_builds = bob.getBuildRecords(
    ...    build_state=BuildStatus.FULLYBUILT, name='pmount', user=admin)
    >>> bob_pmount_ok_builds.count()
    4

Restore cprov to non-private:

    >>> login('foo.bar@canonical.com')
    >>> removeSecurityProxy(cprov).archive.private = False
    >>> flush_database_updates()
    >>> login(ANONYMOUS)


== AssertionErrors in IBuild ==

Build records inserted by gina don't provide calculated_buildstart
value, since they miss fields used in its calculation.

    >>> gina_build = getUtility(IBuildSet).getByBuildID(10)
    >>> gina_build.title
    u'i386 build of cnews cr.g7-37 in ubuntu warty RELEASE'

even if IBuild.was_built return true:

    >>> gina_build.was_built
    True

this method is protected by an assertion on valid buildduration and
datebuilt, it makes the diagnosis of problems in current DB easier.

    >>> gina_build.calculated_buildstart
    Traceback (most recent call last):
    ...
    AssertionError: value is not suitable for this build record (10)

Only builds in failed_states (FAILEDTOBUILD, MANUALDEPWAIT and
CHROOTWAIT) can be retried. We must check if Soyuz is able to accept
its result in case of success, i.e., we should not be able to retry a
build for a released pocket.

All those conditions are controlled by IBuild.can_be_retried() property
(see above).

    >>> failed_build = getUtility(IBuildSet).getByBuildID(6)

    >>> failed_build.title
    u'i386 build of foobar 1.0 in ubuntu warty RELEASE'

    >>> failed_build.buildstate.name
    'FAILEDTOBUILD'

    >>> failed_build.can_be_retried
    False

Attempt to retry this build record will fail with an AssertionError:

    >>> login('foo.bar@canonical.com')
    >>> failed_build.retry()
    Traceback (most recent call last):
    ...
    AssertionError: Build 6 cannot be retried

    >>> login(ANONYMOUS)

Partner archive builds are an exception to this rule; they can be retried
in the release pocket for a released distro.  Let's turn build 9 into a
partner archive build:

    >>> partner_archive = ubuntu.getArchiveByComponent('partner')
    >>> removeSecurityProxy(failed_build).archive = partner_archive

The build can now be re-tried:

    >>> failed_build.can_be_retried
    True

Similarly to PPA builds, they can be retried for release pockets since
they will happen in another archive.

    >>> removeSecurityProxy(failed_build).archive = cprov.archive

    >>> failed_build.can_be_retried
    True

storeUploadLog() refuses to override any previously stored
'upload_log'.

    >>> failedtoupload_build = getUtility(IBuildSet).getByBuildID(22)
    >>> print failedtoupload_build.title
    i386 build of cdrkit 1.0 in ubuntu breezy-autotest RELEASE

    >>> print failedtoupload_build.upload_log.filename
    upload_22_log.txt

    >>> failedtoupload_build.storeUploadLog('something')
    Traceback (most recent call last):
    ...
    AssertionError: Upload log information already exists and cannot be
    overridden.

It's only possible to store another 'upload_log' content once the
build is retried.

    >>> login('foo.bar@canonical.com')
    >>> failedtoupload_build.retry()
    >>> login(ANONYMOUS)
    >>> print failedtoupload_build.upload_log
    None

    >>> failedtoupload_build.storeUploadLog('something')

    >>> print failedtoupload_build.upload_log.filename
    upload_22_log.txt


== Updating build-dependencies line ==

The IBuild.dependencies field is only filled when a build job is
collected as MANUALDEPWAIT, its content is informed by the
buildd-slave in the apt-dependencies format.

    >>> depwait_build = getUtility(IBuildSet).getByBuildID(12)
    >>> print depwait_build.dependencies
    cpp (>= 4:4.0.1-3), gcc-4.0 (>= 4.0.1-2)

IBuild.updateDependencies is designed to process this field and
eliminate dependencies that can be satisfied. It is used as part of the
auto-depwait processing where all builds marked as MANUALDEPWAIT are
re-processed and the ones with empty dependencies are re-queued.

If nothing has changed, which is the case of the current
depwait_build, the 'dependencies' field remains the same.

    >>> old_dep = depwait_build.dependencies
    >>> depwait_build.updateDependencies()
    >>> depwait_build.dependencies == old_dep
    True

A dependency can only be used if it is an a component allowed in our
context (see above on 'Ogre' components). If we do a build using a
dependency available in the sample data but published in an unreachable
component, we will see that the dependency is considered to be unsatisfied.
See also bug 177827.

    >>> login('foo.bar@canonical.com')
    >>> depwait_build.dependencies = 'pmount'
    >>> flush_database_updates()

'pmount' in hoary/i386 is published in the 'universe' component:

    >>> hoary_i386 = depwait_build.distroarchseries
    >>> pmount_pub = hoary_i386[
    ...     'pmount'].currentrelease.current_publishing_record
    >>> print pmount_pub.component.name
    universe

The build is only allowed to depend on packages published in 'main':

    >>> print depwait_build.current_component.name
    main

    >>> from lp.soyuz.adapters.archivedependencies import (
    ...     get_components_for_building)
    >>> print get_components_for_building(depwait_build)
    ['main']

Thus the 'pmount' dependency remains unsatisfied.

    >>> depwait_build.updateDependencies()
    >>> print depwait_build.dependencies
    pmount

If we make pmount in hoary/i386 reachable, by moving it to the 'main'
component, we can see that it will be excluded from the dependencies
list.

    >>> login('foo.bar@canonical.com')
    >>> from lp.soyuz.interfaces.component import IComponentSet
    >>> main_component = getUtility(IComponentSet)['main']
    >>> pmount_pub.component = main_component
    >>> depwait_build.dependencies = 'mozilla-firefox, pmount'
    >>> from canonical.database.sqlbase import flush_database_caches
    >>> flush_database_caches()
    >>> login(ANONYMOUS)

    >>> flush_database_updates()

Note that only the satisfied dependencies are removed the build
dependency list.

    >>> depwait_build.updateDependencies()
    >>> print depwait_build.dependencies
    mozilla-firefox

'pmount' dependency is also satisfied in the Celso's PPA context,
even when it is published in a component not allowed in its current
component domain ('ogre_components'). That's because PPAs implicitly
depend on all components of its distribution PRIMARY archive.


    >>> login('foo.bar@canonical.com')
    >>> depwait_build.dependencies = 'biscuit, pmount'
    >>> universe_component = getUtility(IComponentSet)['universe']
    >>> pmount_pub.component = universe_component
    >>> removeSecurityProxy(depwait_build).archive = cprov.archive
    >>> flush_database_caches()
    >>> login(ANONYMOUS)

    >>> print get_components_for_building(depwait_build)
    ['main']

    >>> print pmount_pub.component.name
    universe

    >>> depwait_build.updateDependencies()
    >>> print depwait_build.dependencies
    biscuit

Restore depwait_build previous state.

    >>> login('foo.bar@canonical.com')
    >>> pmount_pub.component = main_component
    >>> removeSecurityProxy(depwait_build).archive = ubuntu.main_archive
    >>> flush_database_caches()
    >>> login(ANONYMOUS)

=== Retrying DEPWAIT builds ===

It depends on the callsite to decide whether or not to 'retry' a
build after calling updateDependencies, to encapsulate such decision
for performing the mentioned  auto-depwait procedure we have a utility
in IBuildSet called retryDepWaiting().

    >>> print depwait_build.buildstate.name
    MANUALDEPWAIT
    >>> print depwait_build.distroarchseries.title
    The Hoary Hedgehog Release for i386 (x86)

In order to allow depwait_build to be retried we will forge a
'fully-satisfiable' dependencies field.

    >>> login('foo.bar@canonical.com')
    >>> depwait_build.dependencies = 'pmount'
    >>> login(ANONYMOUS)
    >>> flush_database_updates()

Then we can run the utility method for the target distroarchseries and
expect depwait_build to be 'retried' and scored.

    >>> getUtility(IBuildSet).retryDepWaiting(hoaryi386)

    >>> print depwait_build.buildstate.name
    NEEDSBUILD

    >>> depwait_build.buildqueue_record.lastscore
    2505

The 'retryDepWaiting' task is performed periodically via cronjob by
cronscript/buildd-retry-depwait.py. It can be run in parallel with
other buildd tasks because the procedure is 'atomic' enough, i.e.,
after the commit the retried jobs are ready to be dispatched.


== Build rescoring ==

Some builds can be rescored, to determine if it's possible check the
can_be_rescored property:

    >>> depwait_build.can_be_rescored
    True

We need to be at least a buildd-admin to rescore:

    >>> depwait_build.rescore(1000)
    Traceback (most recent call last):
    ...
    Unauthorized:...

    >>> login('celso.providelo@canonical.com')
    >>> depwait_build.rescore(1000)
    >>> print depwait_build.buildqueue_record.lastscore
    1000

If a callsite tries to rescore a build that is not in the NEEDSBUILD state,
a CannotBeRescored exception is raised.

    >>> depwait_build.buildstate = BuildStatus.FAILEDTOUPLOAD
    >>> depwait_build.rescore(1000)
    Traceback (most recent call last):
    ...
    CannotBeRescored: Build cannot be rescored.

    >>> login(ANONYMOUS)


== Build record security ==

IBuild's content class is wrapped in a Zope security wrapper that prevents
access to private builds for unauthorised users.

cprov's archive is private which makes its builds private.  We'll add
an extra build that is not published anywhere but in his PPA.

    >>> login('foo.bar@canonical.com')
    >>> test_publisher.prepareBreezyAutotest()
    >>> removeSecurityProxy(cprov).archive.private = True
    >>> private_source_pub = test_publisher.getPubSource(
    ...     status=PackagePublishingStatus.PUBLISHED,
    ...     sourcename='privacy-test',
    ...     architecturehintlist='i386',
    ...     archive=cprov.archive)
    >>> [private_build] = private_source_pub.createMissingBuilds()
    >>> private_build.builder = bob
    >>> flush_database_updates()

Accessing the cprov builds when logged in as admin will see the records:

    >>> bob_builds = bob.getBuildRecords(user=admin)
    >>> print_build_details(bob_builds)
    cprov: i386 build of privacy-test 666 in ubuntutest breezy-autotest...
    ubuntu-team: hppa build of mozilla-firefox 0.9 in ubuntu warty RELEASE
    cprov: hppa build of mozilla-firefox 0.9 in ubuntu warty RELEASE
    cprov: i386 build of pmount 0.1-1 in ubuntu warty RELEASE
    cprov: i386 build of cdrkit 1.0 in ubuntu breezy-autotest RELEASE
    ...

Likewise when logged in as cprov:

    >>> login('celso.providelo@canonical.com')
    >>> bob_builds = bob.getBuildRecords(user=admin)
    >>> print_build_details(bob_builds)
    cprov: i386 build of privacy-test 666 in ubuntutest breezy-autotest...
    ubuntu-team: hppa build of mozilla-firefox 0.9 in ubuntu warty RELEASE
    cprov: hppa build of mozilla-firefox 0.9 in ubuntu warty RELEASE
    cprov: i386 build of pmount 0.1-1 in ubuntu warty RELEASE
    cprov: i386 build of cdrkit 1.0 in ubuntu breezy-autotest RELEASE
    ...

A user who is a buildd admin is not allowed to see the build records for
private builds. Even though they are admin, privacy must be maintained.

    >>> login(buildd_admin.preferredemail.email)
    >>> bob_builds = bob.getBuildRecords(user=admin)

Define a helper function to catch the security exception:

    >>> from zope.security.interfaces import Unauthorized
    >>> def print_builds_with_exception(builds):
    ...     try:
    ...         print_build_details(bob_builds)
    ...     except Unauthorized:
    ...         print "Generated Unauthorized exception as expected"
    ...     else:
    ...         print "FAIL: should raise Unauthorized exception"

And try to access the builds:

    >>> print_builds_with_exception(bob_builds)
    Generated Unauthorized exception as expected

When logged in as anonymous this will generate a securtity exception
when accessing the builds:

    >>> login(ANONYMOUS)
    >>> bob_builds = bob.getBuildRecords(user=admin)
    >>> print_builds_with_exception(bob_builds)
    Generated Unauthorized exception as expected

There are other settable attributes declared in the zcml that require
launchpad.Edit.

    >>> def check_setting_property(build_rec, property, value, should_fail):
    ...     try:
    ...         setattr(build_rec, property, value)
    ...         if should_fail:
    ...             print "Should have failed setting %s" % property
    ...     except Unauthorized:
    ...         if not should_fail:
    ...             print "Did not fail when expected setting %s" % property
    >>> from canonical.database.constants import UTC_NOW
    >>> properties = {
    ...     'buildlog': 1,
    ...     'datebuilt': UTC_NOW,
    ...     'buildduration': None,
    ...     'builder': bob,
    ...     'buildstate': BuildStatus.FAILEDTOUPLOAD,
    ...     'dependencies': 'whatever',
    ...     'upload_log': 1,
    ...     }

Login as a non-privileged user and set the properties.  It will fail.

    >>> login('no-priv@canonical.com')
    >>> for property in properties:
    ...     check_setting_property(
    ...         depwait_build, property, properties[property],
    ...         should_fail=True)

As a buildd-admin it will work:

    >>> login('celso.providelo@canonical.com')
    >>> for property in properties:
    ...     check_setting_property(
    ...         depwait_build, property, properties[property],
    ...         should_fail=False)

== Estimated Build Duration ==

Build records will have an 'estimated_duration' time in the associated
BuildQueue record. The latter is set from a previous builds' 'buildduration'
value.

We will use SoyuzTestPublisher to generate coherent publications to
test this behaviour.

    >>> login('foo.bar@canonical.com')

Create oldest SourcePackageRelease instance.

    >>> oldest_spr = test_publisher.getPubSource(
    ...     status=PackagePublishingStatus.PUBLISHED,
    ...     sourcename='ebdtest')

Create oldest build instance.

    >>> oldest_build = oldest_spr.sourcepackagerelease.createBuild(
    ...         test_publisher.breezy_autotest_hppa,
    ...         PackagePublishingPocket.UPDATES,
    ...         test_publisher.breezy_autotest.main_archive,
    ...         status=BuildStatus.FULLYBUILT)
    >>> oldest_build.buildduration = timedelta(minutes=72)
    >>> oldest_build.datebuilt = datetime(2008, 4, 1, 10, 45, 39, tzinfo=UTC)

Check that the oldest build instance's 'estimated_duration'
is initialized based on its package size. Since the latter is very
small (less than a KB) the 'estimated_duration' will be a
minute.

    >>> bq = oldest_build.queueBuild()
    >>> bq.estimated_duration
    datetime.timedelta(0, 60)

Create intermediate SourcePackageRelease instance.

    >>> medium_spr = test_publisher.getPubSource(
    ...     status=PackagePublishingStatus.PUBLISHED,
    ...     sourcename='ebdtest')

Create intermediate build instance.

    >>> medium_build = medium_spr.sourcepackagerelease.createBuild(
    ...         test_publisher.breezy_autotest_hppa,
    ...         PackagePublishingPocket.UPDATES,
    ...         test_publisher.breezy_autotest.main_archive,
    ...         status=BuildStatus.FULLYBUILT)
    >>> medium_build.buildduration = timedelta(minutes=60)
    >>> medium_build.datebuilt = datetime(2008, 4, 2, 11, 56, 33, tzinfo=UTC)

Check whether the intermediate build instance's 'estimated_duration'
value equals the oldest instance's 'buildduration' (72 minutes equals 4320
seconds).

    >>> bq = medium_build.queueBuild()
    >>> bq.estimated_duration
    datetime.timedelta(0, 4320)

Create most recent SourcePackageRelease instance.

    >>> recent_spr = test_publisher.getPubSource(
    ...     status=PackagePublishingStatus.PUBLISHED,
    ...     sourcename='ebdtest')

Create most recent build instance. Please note: this one is in state
NEEDSBUILD.

    >>> recent_build = recent_spr.sourcepackagerelease.createBuild(
    ...         test_publisher.breezy_autotest_hppa,
    ...         PackagePublishingPocket.UPDATES,
    ...         test_publisher.breezy_autotest.main_archive,
    ...         status=BuildStatus.NEEDSBUILD)

Check whether the most recent build instance's 'estimated_duration'
value equals the intermediate instance's 'buildduration'.

    >>> bq = recent_build.queueBuild()
    >>> bq.estimated_duration
    datetime.timedelta(0, 3600)

Create a SourcePackageRelease instance in a PPA.

    >>> ppa_spr = test_publisher.getPubSource(
    ...     status=PackagePublishingStatus.PUBLISHED,
    ...     sourcename='ebdtest')

Create most recent build instance.

    >>> ppa_build = ppa_spr.sourcepackagerelease.createBuild(
    ...         test_publisher.breezy_autotest_hppa,
    ...         PackagePublishingPocket.UPDATES,
    ...         cprov.archive,
    ...         status=BuildStatus.NEEDSBUILD)

Check whether the PPA build instance's 'estimated_duration'
value was set from the intermediate instance's 'buildduration' in
the main archive.

    >>> bq = ppa_build.queueBuild()
    >>> bq.estimated_duration
    datetime.timedelta(0, 3600)


== IBuildSet.getBuildsBySourcePackageRelease() ==

getBuildsBySourcePackageRelease() will return all the Build records for
all the SourcePackageRelease IDs passed.

Create some sources with builds:

    >>> source_one = test_publisher.getPubSource(
    ...     status=PackagePublishingStatus.PUBLISHED,
    ...     sourcename='sourceone')
    >>> source_two = test_publisher.getPubSource(
    ...     status=PackagePublishingStatus.PUBLISHED,
    ...     sourcename='sourcetwo')
    >>> build_one = source_one.sourcepackagerelease.createBuild(
    ...         test_publisher.breezy_autotest_hppa,
    ...         PackagePublishingPocket.RELEASE,
    ...         test_publisher.breezy_autotest.main_archive,
    ...         status=BuildStatus.FULLYBUILT)
    >>> build_two = source_two.sourcepackagerelease.createBuild(
    ...         test_publisher.breezy_autotest_hppa,
    ...         PackagePublishingPocket.RELEASE,
    ...         test_publisher.breezy_autotest.main_archive,
    ...         status=BuildStatus.NEEDSBUILD)

    >>> source_ids = (
    ...     source_one.sourcepackagerelease.id,
    ...     source_two.sourcepackagerelease.id,
    ...     )
    >>> builds = removeSecurityProxy(bs).getBuildsBySourcePackageRelease(
    ...     source_ids)
    >>> import operator
    >>> for build in sorted(builds, key=operator.attrgetter("id")):
    ...     print build.title, build.buildstate.name
    hppa build of sourceone 666 in ubuntutest breezy-autotest RELEASE
        FULLYBUILT
    hppa build of sourcetwo 666 in ubuntutest breezy-autotest RELEASE
        NEEDSBUILD

The results can also be filtered on build state:

    >>> builds = removeSecurityProxy(bs).getBuildsBySourcePackageRelease(
    ...     source_ids, buildstate=BuildStatus.FULLYBUILT)
    >>> for build in sorted(builds, key=operator.attrgetter("id")):
    ...     print build.title, build.buildstate.name
    hppa build of sourceone 666 in ubuntutest breezy-autotest RELEASE
        FULLYBUILT

If there are no matching results then it returns an empty SelectResults.

    >>> builds = removeSecurityProxy(bs).getBuildsBySourcePackageRelease(
    ...     source_ids, buildstate=BuildStatus.CHROOTWAIT)
    >>> print builds.count()
    0

Supplying an empty list or None for the IDs results in an empty list
being returned.

    >>> removeSecurityProxy(bs).getBuildsBySourcePackageRelease(None)
    []

    >>> removeSecurityProxy(bs).getBuildsBySourcePackageRelease([])
    []


== Getting the build records for a particular builder ==

The getBuildsForBuilder method returns all the builds for the 
specified builder ID, ordered from most-recently built.

    Create some source packages with which to test the 
    getBuildsForBuilder method:

    >>> src_pkg_earlier = test_publisher.getPubSource(
    ...     status=PackagePublishingStatus.PUBLISHED,
    ...     sourcename='earlierbuildsrc', architecturehintlist='hppa i386')
    >>> src_pkg_later = test_publisher.getPubSource(
    ...     status=PackagePublishingStatus.PUBLISHED,
    ...     sourcename='laterbuildsrc',
    ...     architecturehintlist='hppa i386')
    
    Create the builds based on the source packages, with the builds
    for 'earlierbuildsrc' built one day before the 'laterbuildsrc':

    >>> frog_builder = getUtility(IBuilderSet)['frog']
    >>> bob_builder = getUtility(IBuilderSet)['bob']

    >>> earlier_builds = src_pkg_earlier.createMissingBuilds()
    >>> eg_build_date = earlier_builds[0].datecreated
    >>> for build in earlier_builds:
    ...     build.datebuilt = eg_build_date - timedelta(1)

    >>> later_builds = src_pkg_later.createMissingBuilds()
    >>> for build in later_builds:
    ...     build.datebuilt = eg_build_date
    
    Ensure that the i386 builds are created by the 'frog' builder,
    while the hppa builds are created by 'bob' the builder:
    
    >>> builds = earlier_builds + later_builds
    >>> for build in builds:
    ...     if build.processor.name == u'386':
    ...         build.builder = frog_builder
    ...     else:
    ...         build.builder = bob_builder

    A call to getBuildsForBuilder returns only those builds that were
    built by the specified builder, ordered by datebuilt DESC:
    
    >>> frog_builds = getUtility(IBuildSet).getBuildsForBuilder(
    ...     frog_builder.id)
    >>> print_build_details(frog_builds)
    ubuntu-team: i386 build of laterbuildsrc 666 in ubuntutest
        breezy-autotest RELEASE
    ubuntu-team: i386 build of earlierbuildsrc 666 in ubuntutest
        breezy-autotest RELEASE


== Source publication for builds ==

The current source publication for a given build is available via
its 'current_source_publication' property.

We will create a new publication and its corresponding build.

    >>> original_pub = test_publisher.getPubSource()
    >>> [build] = original_pub.createMissingBuilds()

The publication returned by 'current_source_publication' is the one
that originated the build.

    >>> build.current_source_publication == original_pub
    True

We will override the source publication, moving it from 'main'
component (default) to 'universe'.

    >>> universe_component = getUtility(IComponentSet)['universe']
    >>> secure_overridden_pub = original_pub.changeOverride(
    ...     new_component=universe_component)

Fetching the corresponding `SourcePackagePublishingHistory` for the
comparisons.

    >>> from lp.soyuz.model.publishing import (
    ...     SourcePackagePublishingHistory)
    >>> overridden_pub = SourcePackagePublishingHistory.get(
    ...     secure_overridden_pub.id)

An we can see that the build 'current_source_publication' now points
to the most recent publication, the overridden one.

    >>> original_pub == build.current_source_publication
    False

    >>> overridden_pub == build.current_source_publication
    True
