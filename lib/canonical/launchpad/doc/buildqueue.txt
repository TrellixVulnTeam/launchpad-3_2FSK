= BuildQueue =

BuildQueue class represents the run-time-records of builds being
processed.

See buildd-queuebuilder.txt for more information about the BuildQueue
initialisation.

BuildQueue should provide all the information needed for dispatching
and collecting build results.

As soon as a build job is processed succesfully (dispatched &
collected) the BuildQueue record representing it is removed.

    >>> from canonical.launchpad.webapp.testing import verifyObject
    >>> from canonical.launchpad.interfaces import IBuildQueue
    >>> from canonical.launchpad.interfaces import IBuildQueueSet

Get an instance of Builder from the current sampledata using the
IBuildQueueSet zope utility. The zope utility itself will be
documented later on this document, we are only using it to retrive an
IBuildQueue record with the security proxies in place:

    >>> bq = getUtility(IBuildQueueSet).get(1)

Instances returned by IBuildQueueSet provides the IBuildQueue interface:

    >>> verifyObject(IBuildQueue, bq)
    True

The IBuild record related to this job is provided by the 'build'
attribute:

    >>> bq.build.id
    8
    >>> bq.build.buildstate.name
    'BUILDING'

The static timestamps, representing when the record was initialised
(inserted) and when the job was dispatched are provided as datetime
instances:

    >>> bq.created
    datetime.datetime(...)

    >>> bq.buildstart
    datetime.datetime(...)

Check Builder foreign key, which indicated which builder 'is processing'
the job in question:

The 'builder' attribute provides the IBuilder instance of the builder
currently processing this job:

    >>> bq.builder.name
    u'bob'

'logtail' is a text field which stores up to 1 Kbyte of the last
logged actions during the build process, it is updated according the
frequency set in buildd-slavescanner, normally 10 seconds, see
buildd-slavescanner.txt for further information:

    >>> bq.logtail
    u'Dummy sampledata entry, not processing'

'lastscore' is the heuristic index generated by queuebuilder to order
the dispatching process, see more information in
buildd-queuebuilder.txt:

    >>> bq.lastscore
    1

'manual' is a boolean, which is meant to suppress the auto-scoring
procedure, i.e., when it is set the job do not get re-scored, it is
used to manually reorder jobs via the web UI:

    >>> bq.manual
    False

BuildQueue provides a property which calculates the partial duration
of the build procedure (NOW - buildstart), it's mainly used in the UI.

    >>> bq.buildduration
    datetime.timedelta(...)

Some local properties inherited from related content classes:

    >>> bq.archseries.id == bq.build.distroarchseries.id
    True
    >>> bq.urgency == bq.build.sourcepackagerelease.urgency
    True
    >>> bq.archhintlist == bq.build.sourcepackagerelease.architecturehintlist
    True
    >>> bq.name == bq.build.sourcepackagerelease.name
    True
    >>> bq.version == bq.build.sourcepackagerelease.version
    True
    >>> bq.files.count() == bq.build.sourcepackagerelease.files.count()
    True
    >>> bq.builddependsindep == bq.build.sourcepackagerelease.builddependsindep
    True

BuildQueue provides the name for the logfile resulting from the build:

    >>> bq.getLogFileName()
    u'buildlog_ubuntu-hoary-i386.mozilla-firefox_0.9_BUILDING.txt'

BuildQueue provides a method to handle "manual scoring" procedure
properly, in order to retain the manually set score we need to
set 'manual' attribute atomically. For this we use manualScore:

    >>> pending_bq = getUtility(IBuildQueueSet).get(2)

    >>> pending_bq.manual, pending_bq.lastscore
    (False, 10)
    >>> pending_bq.manualScore(1000)

    >>> pending_bq.manual, pending_bq.lastscore
    (True, 1000)


Now perform the tests for the BuildQueue zope utility, BuildQueueSet.
Check if the instance returned as utility corresponds to its
respective interface:

    >>> bqset = getUtility(IBuildQueueSet)
    >>> verifyObject(IBuildQueueSet, bqset)
    True

IBuildQueueSet utility is iterable:

    >>> for bq in bqset:
    ...     bq.id
    1
    2

Also provides a getter:

    >>> bqset[1].id
    1

a 'get' method:

    >>> bqset.get(2).id
    2

and a full counter:

    >>> bqset.count()
    2

IBuildQueueSet provides a method to retrieve the active job:

    >>> for bq in bqset.getActiveBuildJobs():
    ...     bq.id, bq.builder.name
    (1, u'bob')

A method to fetch all BuildQueue instances inside a list of ids (see
build.txt):

    >>> for bq in bqset.fetchByBuildIds([1, 2, 8]):
    ...     bq.id, bq.build.id
    (1, 8)

Another method to fetch the BuildQueue being processed for a builder,
there should be only one since the builders are sigle-task
applications:

    >>> from canonical.launchpad.interfaces import IBuilderSet
    >>> bob = getUtility(IBuilderSet)['bob']

    >>> current_job = bqset.getByBuilder(bob)
    >>> current_job.builder.name
    u'bob'

BuildQueueSet provides a method used in the builddmaster context to
calculate retrieve every instance for a set of distroarchseriess
corresponding to a build record in NEEDSBUILD state.

Use all architectures available in ubuntu/hoary, i.e, i386 and hppa:

    >>> from canonical.launchpad.interfaces import IDistributionSet
    >>> ubuntu = getUtility(IDistributionSet)['ubuntu']
    >>> hoary = ubuntu['hoary']
    >>> archseries = [arch for arch in hoary.architectures]

Create a new Builds and corresponding BuildQueues in ubuntu/hoary/hppa
for testing if we will also be able to deal with more than one architecture.

    >>> from canonical.launchpad.interfaces import (
    ...     PackagePublishingPocket)
    >>> alsa_hoary = hoary.getSourcePackage('alsa-utils')
    >>> alsa_spr = alsa_hoary.currentrelease.sourcepackagerelease
    >>> alsa_build = alsa_spr.createBuild(
    ...     hoary['hppa'], PackagePublishingPocket.RELEASE,
    ...     hoary.main_archive)
    >>> alsa_build.createBuildQueueEntry().lastscore = 500

    >>> pmount_hoary = hoary.getSourcePackage('pmount')
    >>> pmount_spr = pmount_hoary.currentrelease.sourcepackagerelease
    >>> pmount_build = pmount_spr.createBuild(
    ...     hoary['hppa'], PackagePublishingPocket.RELEASE,
    ...     hoary.main_archive)
    >>> pmount_build.createBuildQueueEntry().lastscore = 1500

Materialize the changes in database:

    >>> from canonical.database.sqlbase import flush_database_updates
    >>> flush_database_updates()

Note that the results are ordered by descending BuildQueue.lastscore
and restricted

    >>> for bq in bqset.calculateCandidates(archseries):
    ...     build = bq.build
    ...     print "%s (%s, %d)" % (build.title, bq.lastscore, bq.id)
    hppa build of pmount 0.1-2 in ubuntu hoary RELEASE (1500, 4)
    i386 build of alsa-utils 1.0.9a-4ubuntu1 in ubuntu hoary RELEASE (1000, 2)
    hppa build of alsa-utils 1.0.9a-4ubuntu1 in ubuntu hoary RELEASE (500, 3)

Restricting the domain to only hoary/hppa:

    >>> archseries = [hoary['hppa']]
    >>> for bq in bqset.calculateCandidates(archseries):
    ...     build = bq.build
    ...     print "%s (%s, %d)" % (build.title, bq.lastscore, bq.id)
    hppa build of pmount 0.1-2 in ubuntu hoary RELEASE (1500, 4)
    hppa build of alsa-utils 1.0.9a-4ubuntu1 in ubuntu hoary RELEASE (500, 3)

This method asserts a valid 'archseries' argument, None or an empty
list will result in a AssertionFailure.

    >>> bqset.calculateCandidates(None).count()
    Traceback (most recent call last):
    ...
    AssertionError: Given 'archseries' cannot be None/empty.

    >>> bqset.calculateCandidates([]).count()
    Traceback (most recent call last):
    ...
    AssertionError: Given 'archseries' cannot be None/empty.

