= OpenID =

== Introduction ==

Launchpad is an OpenID provider. If the URL is accessed by a web browser,
an informative message is displayed as per the OpenID spec.

    >>> anon_browser.open('http://openid.launchpad.dev')
    >>> print anon_browser.headers
    Status: 200 Ok
    ...
    Content-Type: text/html;charset=utf-8
    ...

    >>> print '\n' + anon_browser.contents
    <BLANKLINE>
    ...
    This is the Launchpad login service.  This site allows you
    to use your Launchpad account to log into other services
    related to Canonical and Ubuntu.
    ...


We are going to fake a consumer for these examples. In order to ensure
that the consumer is being fed the correct replies, we use a view that
renders the parameters in the response in an easily testable format.

NB. The plus is in the query to ensure this test is running with an up to
date enough Zope3

    >>> anon_browser.open('http://launchpad.dev/+openid-consumer?foo=%2Bbar')
    >>> print anon_browser.contents
    Consumer received GET
    foo:+bar


== OpenID Server Discovery ==

A Launchpad user's home page contains the required <link rel="openid.server" />
tag to allow OpenID consumers to determine the URL of the OpenID server to
be contacted.

    >>> anon_browser.open('http://launchpad.dev/~sabdfl')
    >>> print anon_browser.contents
    <...
    <head>
    ...
    <link rel="openid.server" href="http://openid.launchpad.dev/+openid" />
    <link
        rel="openid.delegate"
        href="http://openid.launchpad.dev/+id/sabdfl_oid" />
    </head>
    ...


Teams do not have this tag of course.

    >>> anon_browser.open('http://launchpad.dev/~admins')
    >>> 'openid' in anon_browser.contents
    False


The standard person homepage delegates to a permanent identity URL

    >>> anon_browser.open('http://openid.launchpad.dev/+id/sabdfl_oid')
    >>> print anon_browser.contents
    <html ...>
    <head>
    ...
    <link rel="openid.server" href="http://openid.launchpad.dev/+openid" />
    ...
    >>> 'openid.delegate' in anon_browser.contents
    False


If a permanent, human memorable, identity URL is needed we have that too.
It is just a redirect to the above permanent identity URL.

    >>> anon_browser.open('http://openid.launchpad.dev/sabdfl')
    >>> anon_browser.url
    'http://openid.launchpad.dev/+id/sabdfl_oid'


== associate Mode ==

Establish a shared secret between Consumer and Identity Provider.

After determining the URL of the OpenID server, the next thing a consumer
needs to do is associate with the server and get a shared secret via a
POST request.

    >>> from urllib import urlencode
    >>> anon_browser.open(
    ...     'http://openid.launchpad.dev/+openid', data=urlencode({
    ...         'openid.mode': 'associate',
    ...         'openid.assoc_type': 'HMAC-SHA1'}))
    >>> print anon_browser.headers
    Status: 200 Ok
    ...
    Content-Type: text/plain
    ...
    >>> print anon_browser.contents
    assoc_handle:{HMAC-SHA1}{...}{...}
    assoc_type:HMAC-SHA1
    expires_in:1209...
    mac_key:...
    <BLANKLINE>


Get the association handle, which we will need for later tests.

    >>> import re
    >>> [assoc_handle] = re.findall('assoc_handle:(.*)', anon_browser.contents)

== checkid_immediate Mode ==

Ask an Identity Provider if a End User owns the Claimed Identifier,
getting back an immediate "yes" or "can't say" answer.

Once the shared secret is negotiated, the consumer can send
checkid_immediate and checkid_setup GET requests.checkid_immediate requests
will currently return "can't say" as we are not yet logged into Launchpad.

    >>> args = urlencode({
    ...     'openid.mode': 'checkid_immediate',
    ...     'openid.identity':
    ...         'http://openid.launchpad.dev/+id/sabdfl_oid',
    ...     'openid.assoc_handle': assoc_handle,
    ...     'openid.return_to': 'http://launchpad.dev/+openid-consumer',
    ...     })
    >>> anon_browser.open('http://openid.launchpad.dev/+openid?%s' % args)
    >>> print anon_browser.contents
    Consumer received GET
    openid.assoc_handle:...
    openid.mode:id_res
    ...
    openid.user_setup_url:http://openid.launchpad.dev/+openid?...
    <BLANKLINE>


An error is returned to the consumer if an attempt to login as an invalid
user.

    >>> args = urlencode({
    ...     'openid.mode': 'checkid_immediate',
    ...     'openid.identity': 'http://launchpad.dev/+id/limi_oid',
    ...     'openid.assoc_handle': assoc_handle,
    ...     'openid.return_to': 'http://launchpad.dev/+openid-consumer',
    ...     })
    >>> user_browser.open('http://openid.launchpad.dev/+openid?%s' % args)
    >>> print user_browser.contents
    Consumer received GET
    openid.assoc_handle:...
    openid.mode:id_res
    ...
    openid.user_setup_url:http://openid.launchpad.dev/+openid?...
    <BLANKLINE>

We test a success below in the 'Sticky Authorization' section.


== checkid_setup Mode ==

checkid_setup is interactive with the user. We can extract the
URL for the checkid_setup from the result of the previous test.

    >>> [setup_url] = re.findall(
    ...     '(?m)^openid.user_setup_url:(.*)$', anon_browser.contents
    ...     )


Lets start a new browser session so we don't have any credentials.
When we go to the OpenID setup URL, we are presented with a login
form.  By entering an email address and password, we are directed back
to the consumer, completing the OpenID request:

    >>> sabdfl_browser = setupBrowser()
    >>> sabdfl_browser.open(setup_url)
    >>> print sabdfl_browser.url
    http://openid.launchpad.dev/+openid?...
    >>> print sabdfl_browser.title
    Launchpad Login Service
    >>> sabdfl_browser.getControl(name='field.email').value = 'mark@hbd.com'
    >>> sabdfl_browser.getControl(name='field.password').value = 'test'
    >>> sabdfl_browser.getControl('Continue').click()

    >>> print sabdfl_browser.url
    http://launchpad.dev/+openid-consumer?...
    >>> print sabdfl_browser.contents
    Consumer received GET
    openid.assoc_handle:...
    openid.claimed_id:http://openid.launchpad.dev/+id/sabdfl_oid
    openid.identity:http://openid.launchpad.dev/+id/sabdfl_oid
    openid.mode:id_res
    openid.ns:http://specs.openid.net/auth/2.0
    openid.op_endpoint:http://openid.launchpad.dev/+openid
    openid.response_nonce:...
    openid.return_to:http://launchpad.dev/+openid-consumer
    openid.sig:...
    openid.signed:...
    <BLANKLINE>

We will record the signature from this response to use in the next test:

    >>> [sig] = re.findall('sig:(.*)', sabdfl_browser.contents)


If we had been logged into Launchpad, we would instead have seen a
simple approve/deny form since Launchpad already knows who we are.
This can be seen using the existing browser session:

    >>> sabdfl_browser.open(setup_url)
    >>> print sabdfl_browser.title
    Authenticate to http://launchpad.dev/+openid-consumer
    >>> sabdfl_browser.getControl("Not Now").click()

    >>> print sabdfl_browser.url
    http://launchpad.dev/+openid-consumer?...
    >>> print sabdfl_browser.contents
    Consumer received GET
    openid.mode:cancel
    openid.ns:http://specs.openid.net/auth/2.0
    <BLANKLINE>


== check_authentication Mode ==

Ask an Identity Provider if a message is valid. For dumb, stateless
Consumers or when verifying an invalidate_handle response.

If an association handle is stateful (genereted using the associate Mode),
check_authentication will fail.

    >>> args = urlencode({
    ...     'openid.mode': 'check_authentication',
    ...     'openid.assoc_handle': assoc_handle,
    ...     'openid.sig': sig,
    ...     'openid.signed':  'return_to,mode,identity',
    ...     'openid.identity':
    ...         'http://openid.launchpad.dev/+id/sabdfl_oid',
    ...     'openid.return_to': 'http://launchpad.dev/+openid-consumer',
    ...     })
    >>> sabdfl_browser.open('http://openid.launchpad.dev/+openid?%s' % args)
    >>> print sabdfl_browser.contents
    is_valid:false
    <BLANKLINE>


If we are a dumb consumer though, we must invoke the check_authentication
mode, passing back the association handle, signature and values of all
fields that were signed.

    >>> args = urlencode({
    ...     'openid.mode': 'checkid_setup',
    ...     'openid.identity':
    ...         'http://openid.launchpad.dev/+id/sabdfl_oid',
    ...     'openid.return_to': 'http://launchpad.dev/+openid-consumer',
    ...     })
    >>> sabdfl_browser.open('http://openid.launchpad.dev/+openid?%s' % args)
    >>> sabdfl_browser.getControl('Sign In', index=0).click()
    >>> print sabdfl_browser.contents
    Consumer received GET
    openid.assoc_handle:...
    openid.identity:http://openid.launchpad.dev/+id/sabdfl_oid
    openid.mode:id_res
    openid.op_endpoint:http://openid.launchpad.dev/+openid
    openid.response_nonce:...
    openid.return_to:http://launchpad.dev/+openid-consumer
    openid.sig:...
    openid.signed:...
    <BLANKLINE>

    >>> fields = dict(line.split(':', 1)
    ...               for line in sabdfl_browser.contents.splitlines()[1:]
    ...               if line.startswith('openid.'))
    >>> signed = ['openid.' + name
    ...           for name in fields['openid.signed'].split(',')]
    >>> message = dict((key, value) for (key, value) in fields.items()
    ...                if key in signed)
    >>> message.update({
    ...     'openid.mode': 'check_authentication',
    ...     'openid.assoc_handle': fields['openid.assoc_handle'],
    ...     'openid.sig': fields['openid.sig'],
    ...     'openid.signed': fields['openid.signed'],
    ...     })

    >>> args = urlencode(message)
    >>> sabdfl_browser.open('http://openid.launchpad.dev/+openid', args)
    >>> print sabdfl_browser.contents
    is_valid:true
    <BLANKLINE>


== Sticky Authorization ==

XXX: 2007-06-13 jamesh
Tests disabled because we are hiding sticky authorizations during
phase 1.

Users can select how long our OpenID server will continue to authorize
them to a particular consumer.

#    >>> sabdfl_browser.open(setup_url)
#    >>> sabdfl_browser.getControl(name='allow_duration').value=['3600']
#    >>> sabdfl_browser.getControl('Sign In', index=0).click()
#    >>> print sabdfl_browser.contents
#    Consumer received GET
#    ...
#    openid.identity:http://openid.launchpad.dev/+id/sabdfl_oid
#    openid.mode:id_res
#    openid.return_to:http://launchpad.dev/+openid-consumer
#    ...


Now that we have authorized for 1 hour, further auth requests
automatically succeed without user intervention.

#    >>> sabdfl_browser.open(setup_url)
#    >>> print sabdfl_browser.contents
#    Consumer received GET
#    ...
#    openid.identity:http://openid.launchpad.dev/+id/sabdfl_oid
#    openid.mode:id_res
#    openid.return_to:http://launchpad.dev/+openid-consumer
#    ...


== Identity Ownership ==

You cannot log in as someone elses identity. If you try to, you will be
prompted with a login screen to connect as the correct user.

Immediate mode:

    >>> args = urlencode({
    ...     'openid.mode': 'checkid_immediate',
    ...     'openid.identity':
    ...         'http://openid.launchpad.dev/+id/stub_oid',
    ...     'openid.assoc_handle': assoc_handle,
    ...     'openid.return_to': 'http://launchpad.dev/+openid-consumer',
    ...     })
    >>> sabdfl_browser.open('http://openid.launchpad.dev/+openid?%s' % args)
    >>> print sabdfl_browser.contents
    Consumer received GET
    openid.assoc_handle:...
    openid.mode:id_res
    openid.sig:...
    openid.signed:...
    openid.user_setup_url:http://openid.launchpad.dev/+openid?...
    <BLANKLINE>


Interactive mode:

    >>> [setup_url] = re.findall(
    ...     '(?m)^openid.user_setup_url:(.*)$', sabdfl_browser.contents
    ...     )

#    >>> sabdfl_browser.handleErrors = False
#    >>> sabdfl_browser.open(setup_url)
#    Traceback (most recent call last):
#    ...
#    Unauthorized: You are not authorized to use this OpenID identifier.
#    >>> sabdfl_browser.handleErrors = True

    >>> sabdfl_browser.open(setup_url)
    >>> print sabdfl_browser.url
    http://launchpad.dev/+openid-consumer?...
    >>> print sabdfl_browser.contents
    Consumer received GET
    openid.mode:cancel
    openid.ns:http://specs.openid.net/auth/2.0


== Invalid identities ==

If you attempt interactive authentication with an invalid OpenID
identifier, you get a nice error page.

    >>> args = urlencode({
    ...     'openid.mode': 'checkid_immediate',
    ...     'openid.identity':
    ...         'http://some/other/site',
    ...     'openid.assoc_handle': assoc_handle,
    ...     'openid.return_to': 'http://launchpad.dev/+openid-consumer',
    ...     })
    >>> sabdfl_browser.open('http://openid.launchpad.dev/+openid?%s' % args)
    >>> [setup_url] = re.findall(
    ...     '(?m)^openid.user_setup_url:(.*)$', sabdfl_browser.contents
    ...     )
    >>> sabdfl_browser.open(setup_url)
    >>> print '\n' + sabdfl_browser.contents
    <BLANKLINE>
    ...
    that is not a valid Launchpad OpenID identity URL, such as
    <strong>http://launchpad.dev/~sabdfl</strong>
    ...
    <form action="http://launchpad.dev/+openid-consumer?openid.mode=cancel...">
    <input type="submit" value="Continue" />
    </form>
    ...


== Broken Consumers ==

Really bad requests might trigger a protocol error

    >>> args = urlencode({
    ...     'openid.mode': 'whoops',
    ...     })
    >>> sabdfl_browser.handleErrors = True
    >>> sabdfl_browser.open('http://openid.launchpad.dev/+openid?%s' % args)
    >>> print sabdfl_browser.contents
    error:No decoder for mode 'whoops'
    mode:error
    <BLANKLINE>


If there is a valid return_to, then the consumer gets notified.

    >>> args = urlencode({
    ...     'openid.mode': 'whoops',
    ...     'openid.return_to': 'http://launchpad.dev/+openid-consumer',
    ...     })
    >>> sabdfl_browser.open('http://openid.launchpad.dev/+openid?%s' % args)
    >>> print sabdfl_browser.contents
    Consumer received GET
    openid.error:No decoder for mode 'whoops'
    openid.mode:error
    <BLANKLINE>
