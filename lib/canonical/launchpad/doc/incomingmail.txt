Incoming Mail
=============

When an email is sent to Launchpad we need to handle it somehow. This
is done by handleEmails:

    >>> from canonical.launchpad.mail.incoming import handleMail

Basically what it does is to open the Launchpad mail box, and for each
message it:

    * Authenticates the sender
    * Finds the correct mail handler
    * Lets the handler process the message
    * Deletes the message from the mail box

Mail Handlers
-------------

A mail handler is a utility which knows how to handle mail sent to a
specific domain. It is registered as a named utility providing
IMailHandler. The name of the utility is the domain that's handled.

Let's create some utilities which keep track of which mails they
handle, and register them for some domains:

    >>> from canonical.launchpad.interfaces import IMailHandler, IProductSet
    >>> from zope.interface import implements
    >>> from canonical.config import config
    >>> class MockHandler:
    ...     implements(IMailHandler)
    ...     def __init__(self, allow_unknown_users=False):
    ...         self.allow_unknown_users = allow_unknown_users
    ...         self.handledMails = []
    ...     def process(self, mail, to_addr, filealias):
    ...         self.handledMails.append(mail['Message-Id'])
    ...         return True

    >>> from canonical.launchpad.mail.handlers import mail_handlers
    >>> foo_handler = MockHandler()
    >>> bar_handler = MockHandler(allow_unknown_users=True)
    >>> error_handler = MockHandler()
    >>> mail_handlers.add('foo.com', foo_handler)
    >>> mail_handlers.add('bar.com', bar_handler)
    >>> dummy, errors_domain = config.launchpad.errors_address.split('@')
    >>> mail_handlers.add(errors_domain, error_handler)

We temporarily override the error mails' From address, so that they will
pass through the authentication stage:

    >>> old_error_from_address = config.malone.bugmail_error_from_address
    >>> config.malone.bugmail_error_from_address = 'foo.bar@canonical.com'

Now we send a few test mails to foo.com, bar.com, and baz.com:

    >>> import transaction
    >>> from canonical.launchpad.mail.ftests import read_test_message
    >>> from canonical.launchpad.mail import sendmail

    >>> msgids = {'foo.com': [], 'bar.com': [], 'baz.com': []}
    >>> for domain in ('foo.com', 'bar.com', 'foo.com', 'baz.com'):
    ...     msg = read_test_message('signed_detached.txt')
    ...     msg.replace_header('To', '123@%s' % domain)
    ...     msgids[domain].append("<%s>" % sendmail(msg))
    ...     transaction.commit()

The test mails are now in Launchpad's mail box, so now we can call
handleMail, so that every mail gets handled by the correct handler.
Since the User gets authenticated using OpenPGP signatures we have to
import the keys first. We also need to start the Librarian, since every
mail will get filed in there:

    >>> from canonical.launchpad.ftests import import_public_test_keys
    >>> from canonical.librarian.ftests.harness import LibrarianTestSetup
    >>> import_public_test_keys()
    >>> transaction.commit()
    >>> LibrarianTestSetup().setUp()

    >>> handleMail()
    WARNING:canonical.launchpad.mail:No X-Original-To header was present in email: ...
    WARNING:canonical.launchpad.mail:No X-Original-To header was present in email: ...
    WARNING:canonical.launchpad.mail:No X-Original-To header was present in email: ...
    WARNING:canonical.launchpad.mail:No X-Original-To header was present in email: ...

Now we can see that each handler handled that mails sent to its domain:

    >>> foo_handler.handledMails == msgids['foo.com']
    True
    >>> bar_handler.handledMails == msgids['bar.com']
    True


Unhandled Mail
--------------

So, what happened to the message that got sent to baz.com? Since there
wasn't a handler registered for that domain, an error message was sent
to the errors email address, which is specified in launchpad.conf as
errors_address.

    >>> len(error_handler.handledMails)
    0
    >>> handleMail()
    WARNING:canonical.launchpad.mail:No X-Original-To header was present in email: ...
    >>> len(error_handler.handledMails)
    1

    >>> from canonical.launchpad.mail import stub
    >>> stub.test_emails = []

Mail from Persons not registered in Launchpad
---------------------------------------------

If a Person who isn't registered in Launchpad sends an email, we'll
most of the time reject the email:

    >>> moin_change = read_test_message('moin-change.txt')
    >>> moin_change['X-Original-To'] = '123@foo.com'
    >>> msgid = "<%s>" % sendmail(moin_change)
    >>> transaction.commit()
    >>> handleMail()
    >>> msgid not in foo_handler.handledMails
    True

    >>> stub.test_emails = []

However, bar_handler specifies that it can handle such emails:

    >>> bar_handler.allow_unknown_users
    True

So if we send the mail to bar.com, bar_handler will handle the mail:

    >>> moin_change.replace_header('X-Original-To', '123@bar.com')
    >>> msgid = "<%s>" % sendmail(moin_change)
    >>> transaction.commit()
    >>> handleMail()
    >>> msgid in bar_handler.handledMails
    True

    >>> stub.test_emails = []

X-Original-To
-------------

If available, the X-Original-To header is used to determine to which
address the email was sent to:

    >>> from canonical.launchpad.mail import raw_sendmail
    >>> msg = read_test_message('signed_detached.txt')
    >>> msg.replace_header('To', '123@foo.com')
    >>> msg['CC'] = '123@foo.com'
    >>> msg['X-Original-To'] = '123@bar.com'
    >>> msgid = '<%s>' % raw_sendmail (
    ...     msg['From'], ['123@bar.com'], msg.as_string())
    >>> transaction.commit()
    >>> handleMail()
    >>> msgid in bar_handler.handledMails
    True

Only the address in X-Original-To header will be used. The addresses in
the To and CC headers will be ignored:

    >>> msgid in foo_handler.handledMails
    False

DB exceptions
-------------

If something goes wrongs in the handler, a DB exception can be raised,
leaving the database in a bad state. If that happens a traceback should
be printed, and the mail should be deleted from the queue.

Let's create and register a handler which violates a DB constraint:

    >>> from canonical.database.sqlbase import flush_database_updates
    >>> class DBExceptionRaiser:
    ...     implements(IMailHandler)
    ...     def process(self, mail, to_addr, filealias):
    ...         firefox = getUtility(IProductSet)['firefox']
    ...         firefox.name = 'invalid name'
    ...         flush_database_updates()

    >>> mail_handlers.add('except.com', DBExceptionRaiser())

Now we send a mail to the handler, which will cause an exception:

    >>> exception_raiser = """From: Foo Bar <foo.bar@canonical.com>
    ... To: something@except.com
    ... X-Original-To: something@except.com
    ... Subject: Raise an exception
    ...
    ... This part is not important.
    ... """
    >>> raw_sendmail(
    ...     'foo.bar@canonical.com', ['something@exception.com'],
    ...     exception_raiser)
    '...'
    >>> transaction.commit()

We send another mail as well, in order to make sure that it gets
processed as well:

    >>> msg = read_test_message('signed_detached.txt')
    >>> msg.replace_header('To', '123@foo.com')
    >>> msgid = '<%s>' % sendmail(msg)
    >>> transaction.commit()


If we call handleMail(), we'll see some useful error messages printed
out:

    >>> handleMail(transaction)
    ERROR:...:An exception was raised inside the handler: http://...
    ERROR: new row for relation "product" violates check constraint "valid_name"
    <BLANKLINE>
    /*...*/ UPDATE Product SET name = 'invalid name' WHERE id = 4
    WARNING...


The second mail we sent got handled despite the exception:

    >>> msgid in foo_handler.handledMails
    True

There are no mails left in the mail box:

    >>> len(stub.test_emails)
    0

Librarian not running
---------------------

If for some reason the Librarian isn't up and running, we shouldn't
loose any emails. All that should happen is that an error should get
logged.

    >>> LibrarianTestSetup().tearDown()
    >>> msg = read_test_message('signed_detached.txt')
    >>> msg.replace_header('To', '123@foo.com')
    >>> msgid = '<%s>' % sendmail(msg)
    >>> transaction.commit()
    >>> len(stub.test_emails)
    1

    >>> handleMail(transaction)
    ERROR:...:Upload to Librarian failed...
    ...
    UploadFailed: (111, 'Connection refused')

    >>> len(stub.test_emails)
    1

    >>> LibrarianTestSetup().setUp()
    >>> stub.test_emails = []

Handling bounces
----------------

Some broken mailers might not respect the Errors-To and Return-Path
headers, send error messages back to the address, from which the email
was sent. To prevent mail loops, we try to detect such errors, and
simply drop the emails.

Emails with an empty Return-Path header should be dropped:

    >>> stub.test_emails = []
    >>> msg = read_test_message('signed_detached.txt')
    >>> msg.replace_header('To', '123@foo.com')
    >>> msg['Return-Path'] = '<>'
    >>> msgid = '<%s>' % sendmail(msg)
    >>> transaction.commit()
    >>> handleMail()
    >>> msgid in foo_handler.handledMails
    False

Since this shouldn't occur that often, an email is sent about it to the
errors-list. This is to make it easier to detect any errors, and fine
tune it. Later we might simply drop the email without noticing anyone
about it.

    >>> import email
    >>> from_addr, to_addr, raw_mail = stub.test_emails[-1]
    >>> error_mail = email.message_from_string(raw_mail)
    >>> error_mail['To'] == config.launchpad.errors_address
    True
    >>> print error_mail['Subject']
    Unhandled Email:...
    >>> print error_mail.get_payload()
    The following email was unhandled:
    ...
    Message had an empty Return-Path.

    >>> LibrarianTestSetup().tearDown()
    >>> config.malone.bugmail_error_from_address = old_error_from_address
    >>> mail_handlers.add('foo.com', None)
    >>> mail_handlers.add('bar.com', None)
    >>> mail_handlers.add(errors_domain, None)
    >>> mail_handlers.add('except.com', None)
