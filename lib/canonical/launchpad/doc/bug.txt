Bugs in Malone
==============

This document describes what a Bug is in Malone, and provides some (currently
rather incomplete) info on how to poke at bugs through the Component
Architecture.

Working with Bugs
-----------------

Bugs are created and retrieved via IBugSet.

    >>> from zope.component import getUtility
    >>> from canonical.launchpad.interfaces import IBugSet
    >>> bugset = getUtility(IBugSet)

To demonstrate how to retrieve a specific bug, let's simulate that we're
interacting with the system as an anonymous user:

    >>> import zope.security.management
    >>> from canonical.launchpad.ftests import login
    >>> login("launchpad.anonymous")

To retrieve a specific Bug, use IBugSet.get:

    >>> firefox_crashes = bugset.get(6)
    >>> print firefox_crashes.title
    Firefox crashes when Save As dialog for a nonexistent window is closed

Searching for Bugs
------------------

To search for bugs matching specific criteria, use IBugSet.search:

    >>> from canonical.database.sqlbase import flush_database_updates

    >>> login("foo.bar@canonical.com")

    >>> firefox_test_bug = bugset.get(3)
    >>> firefox_test_bug.duplicateof = firefox_crashes.id
    >>> flush_database_updates()
    >>> dups_of_bug_six = bugset.search(duplicateof = firefox_crashes)
    >>> print dups_of_bug_six.count()
    1
    >>> dups_of_bug_six[0].id
    3

    >>> firefox_test_bug.duplicateof = None
    >>> flush_database_updates()
    >>> dups_of_bug_six = bugset.search(duplicateof = firefox_crashes)
    >>> print dups_of_bug_six.count()
    0

    >>> login("launchpad.anonymous")

Absolute URLs
-------------

For things like bug notification emails, it's handy to be able to
include a URL to the bug inside the email. In Launchpad, the absolute
URL of a bug is found by using zapi.absoluteURL.

    >>> from zope.app import zapi
    >>> from zope.publisher.browser import TestRequest
    >>> request = TestRequest()

    >>> zapi.absoluteURL(firefox_crashes, request)
    'http://127.0.0.1/malone/bugs/6'

Bug Privacy
===========

A Bug has a "private" field. If Bug.private is False, the bug is publicly
visible. If Bug.private is True, only people who are explicitly subscribed to
the bug can see it.

Marking Bugs Private
--------------------

For the purposes of demonstration, we'll make the firefox crashing bug
private. A bug cannot be made private by an anonymous user.

    >>> firefox_crashes.private = True
    Traceback (most recent call last):
      ...
    Unauthorized: ('private', 'launchpad.Edit')

We have to be logged in, so let's do that (or pretend to do that, anyway :):

    >>> login("test@canonical.com")

Now we can toggle the privacy flag on a bug, but before we do, let's note what
happens to subscriptions on a bug before and after it's marked private. So,
there are currently no explicit subscripitions to this bug.

    >>> print firefox_crashes.subscriptions
    []

The maintainer is "implicitly" subscribed to the bug. However, the rule with
private bugs is that only explicit subscribers can view the bug after it's been
marked private. So, when we mark bug #15 private:

    >>> from zope.event import notify
    >>> from canonical.launchpad.event.sqlobjectevent import \
    ...     SQLObjectModifiedEvent, SQLObjectToBeModifiedEvent
    >>> from canonical.launchpad.interfaces import IPersonSet
    >>> new_values = {"private" : True}
    >>> bug_will_be_set_private = SQLObjectToBeModifiedEvent(
    ...     firefox_crashes, new_values)

    >>> notify(bug_will_be_set_private)

    >>> def capture_state(obj, *fields):
    ...     class State: pass
    ...     state = State()
    ...     for field in fields:
    ...         setattr(state, field, getattr(obj, field))
    ...     return state
    >>> old_state = capture_state(
    ...     firefox_crashes, "id", "title", "summary", "description", "name",
    ...     "private", "duplicateof")
    >>> firefox_crashes.private = True
    >>> bug_set_private = SQLObjectModifiedEvent(
    ...     firefox_crashes, old_state,
    ...     ["id", "title", "private"],
    ...     getUtility(IPersonSet).get(12),
    ...     request)

    >>> notify(bug_set_private)

The maintainer is automatically explicitly subscribed.

    >>> people_ids_subscribed = [
    ...     subscription.person.id
    ...     for subscription in list(firefox_crashes.subscriptions)]
    >>> people_ids_subscribed.sort()
    >>> print people_ids_subscribed
    [12]

How Privacy Affects Access to a Bug
-----------------------------------

Once a bug is made private, it can only be accessed by the users that
are explicitly subscribed to the bug; in other words, users for which
there is a row in the BugSubscription table linking them to this bug.

So, remembering that we're still logged in as Sample Person (ID 12 in
the Person table), and that Sample Person is an explicit subscriber to
the firefox_crashes bug, we can still access properties of this bug:

    >>> firefox_crashes.title
    u'Firefox crashes when Save As dialog for a nonexistent window is closed'

But, if we temporarily switch to a user that isn't an explicit
subscriber, e.g. Foo Bar:

    >>> login("foo.bar@canonical.com")

Trying to access a property of this bug will result in an Unauthorized
exception:

    >>> firefox_crashes.title
    Traceback (most recent call last):
      ...
    Unauthorized: ('title', 'launchpad.View')

As one would expect, the permissions are team aware. So, let's
retrieve a bug on which Foo Bar is a member of the maintainer team:

    >>> blackhole_trash_folder = bugset.get(2)

And again, let's fake setting the bug private:

    >>> new_values = {"private" : True}
    >>> bug_will_be_set_private = SQLObjectToBeModifiedEvent(
    ...     blackhole_trash_folder, new_values)

    >>> notify(bug_will_be_set_private)

    >>> old_state = capture_state(
    ...     blackhole_trash_folder, "id", "title", "summary",
    ...     "description", "name", "private", "duplicateof")
    >>> blackhole_trash_folder.private = True
    >>> bug_set_private = SQLObjectModifiedEvent(
    ...     blackhole_trash_folder, old_state,
    ...     ["id", "title", "private"],
    ...     getUtility(IPersonSet).get(16),
    ...     request)

    >>> notify(bug_set_private)

Now, because Foo Bar is a member of the Ubuntu Team, and this bug is
filed on upstream Ubuntu, Foo Bar can still access the properties of
the bug when it's private:

    >>> blackhole_trash_folder.title
    u'Blackhole Trash folder'

If we login as someone who *isn't* a member of the Ubuntu Team (and
isn't otherwise someone who should be allowed to access the properties
of this bug) though, e.g. Robert Collins:

    >>> login("robertc@robertcollins.net")

Trying to access a property of this bug will again raise an
Unauthorized:

    >>> blackhole_trash_folder.title
    Traceback (most recent call last):
      ...
    Unauthorized: ('title', 'launchpad.View')

Filing Public vs. Private Bugs
------------------------------

Let's log back in as Foo Bar to continue our examples:

    >>> login("foo.bar@canonical.com")

When a public bug is filed:

>>> from zope.app.event.objectevent import ObjectCreatedEvent
>>> from canonical.launchpad.database.bug import BugFactory
>>> from canonical.launchpad.interfaces import IProductSet
>>> from canonical.launchpad.interfaces import IPersonSet
>>> from canonical.launchpad.interfaces import IBugSet
>>> productset = getUtility(IProductSet)
>>> personset = getUtility(IPersonSet)
>>> bugset = getUtility(IBugSet)

>>> firefox = productset.get(4)
>>> foobar = personset.get(16)
>>> added_bug = BugFactory(
...     product = firefox, title = "test firefox bug",
...     comment = "blah blah blah", owner = foobar)
>>> notify(ObjectCreatedEvent(added_bug))
>>> public_bug = bugset.get(added_bug.id)

the submitter is explicitly subscribed. The maintainer is considered implicitly
subscribed:

>>> print [subscription.person.id for subscription in public_bug.subscriptions]
[16]

The first comment made (this is submitted in the bug report) is set to
the description of the bug:

>>> public_bug.description
u'blah blah blah'

The bug description can also be accessed through the task:

>>> public_bug.bugtasks[0].bugdescription
u'blah blah blah'
>>> public_bug.description = 'a new description'
>>> public_bug.bugtasks[0].bugdescription
u'a new description'

When a private bug is filed:

>>> added_bug = BugFactory(
...     product = firefox, title = "test firefox bug",
...     comment = "blah blah blah", owner = foobar,
...     private = True)
>>> notify(ObjectCreatedEvent(added_bug))
>>> private_bug = bugset.get(added_bug.id)

*only* the submitter is explicitly subscribed:

>>> print [subscription.person.id for subscription in private_bug.subscriptions]
[16]

It's up to the submitter to explicitly subscribe the maintainer, if
they so choose.

Note that this works similarly for distributions; in this case the
"maintainer" is considered the person who maintains the applicable
sourcepackage. E.g.

>>> from canonical.launchpad.interfaces import IDistributionSet, \
...     ISourcePackageNameSet
>>> distributionset = getUtility(IDistributionSet)
>>> spnset = getUtility(ISourcePackageNameSet)
>>> ubuntu = distributionset.get(1)
>>> evolution = spnset.get(9)
>>> added_bug = BugFactory(
...     distribution = ubuntu.id, sourcepackagename = evolution,
...     title = "test firefox bug", comment = "blah blah blah",
...     owner = foobar, private = True)
>>> notify(ObjectCreatedEvent(added_bug))
>>> private_bug = bugset.get(added_bug.id)
>>> print [subscription.person.id for subscription in private_bug.subscriptions]
[16]
