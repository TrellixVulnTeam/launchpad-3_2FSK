= launchpadlib =

launchpadlib is the standalone Python language bindings to Launchpad's web
services API.  It is officially supported by Canonical, although third party
packages may be available to provide bindings to other programming languages.

launchpadlib is currently in pre-alpha release.

    >>> import launchpadlib
    >>> launchpadlib.__version__
    '0.1'

launchpadlib talks to Launchpad's API facet, but anonymous users are not
allowed to access even the root service.

    >>> from urllib import urlopen
    >>> import lxml.objectify
    >>> def parse(url):
    ...     connection = urlopen(url)
    ...     try:
    ...         tree = lxml.objectify.parse(connection)
    ...     finally:
    ...         connection.close()
    ...     return tree.getroot()

    >>> root = parse('http://api.launchpad.dev')
    >>> root.head.title
    'Forbidden'
    >>> root.body.div[1].table.tr.td.div.text.strip()
    u'Not logged in \u2014'

Anonymous users cannot even access the beta service.

    >>> root = parse('http://api.launchpad.dev/beta')
    >>> root.head.title
    'Forbidden'
    >>> root.body.div[1].table.tr.td.div.text.strip()
    u'Not logged in \u2014'


== OAuth authentication ==

The Launchpad API requires user authentication via OAuth, and launchpadlib
provides a high level interface to OAuth for the most common use cases.
Several pieces of information are necessary to complete the OAuth request:

 * A consumer key, which is unique to the application using the API
 * An access token, which represents the user to the web service

Consumer keys are hard-baked into the application.  They are generated by the
application developer and registered with Launchpad independently of the use
of the application.

The access token cannot be provided directly.  Instead, the application
generates an unauthenticated request token, exchanging this for an access
token after obtaining approval to so from the user.  This permission is
typically gained by redirecting the user through their trusted web browser,
then back to the application.

This entire exchange is managed by the Credentials class.  The application can
begin by creating a Credentials instance naming a file system path, and any
stored credentials information will be loaded from that file automatically.
Since the application already knows the consumer key, it must supply it now.

    >>> consumer_key = 'launchpadlib-example'

    >>> import os
    >>> import tempfile
    >>> tempdir = tempfile.mkdtemp()
    >>> credentials_file = os.path.join(tempdir, '.credentials')
    >>> from launchpadlib.credentials import Credentials
    >>> credentials = Credentials(consumer_key, filename=credentials_file)

Initially though, there are no stored credentials.

    >>> print credentials.access_token
    None

In the simplest case, the application itself will now obtain the user's
approval to access the Launchpad API on her behalf.  How the application does
this is up to the application, provided it conforms to the OAuth protocol.

    >>> credentials.access_token = 'hgm2VK35vXD6rLg5pxWw'

And now the root service can be accessed, using these credentials.

    >>> from launchpadlib.launchpad import Launchpad
    >>> launchpad = Launchpad(credentials=credentials)
    >>> launchpad.root
    'ROOT'

The credentials can also be stored in the file, so that the authentication
dance can be avoided the next time the user interacts with the web service.

    >>> credentials.save()

    >>> credentials = Credentials(consumer_key, filename=credentials_file)
    >>> credentials.access_token
    'hgm2VK35vXD6rLg5pxWw'

    >>> launchpad = Launchpad(credentials=credentials)
    >>> launchpad.root
    'ROOT'

If the application does not want to store the access key on the file system
(for security purposes), it can simply always provide the access token.

    >>> credentials = Credentials(
    ...     consumer_key, access_token='hgm2VK35vXD6rLg5pxWw')
    >>> launchpad = Launchpad(credentials=credentials)
    >>> launchpad.root
    'ROOT'

It is an error to save a credentials file when no access token is available.

    >>> os.remove(credentials_file)
    >>> credentials = Credentials(consumer_key, filename=credentials_file)
    >>> credentials.save()
    Traceback (most recent call last):
    ...
    CredentialsFileError: No access token to save

It is an error to save a credentials file when no file name is given.

    >>> credentials = Credentials(
    ...     consumer_key, access_token='hgm2VK35vXD6rLg5pxWw')
    >>> credentials.save()
    Traceback (most recent call last):
    ...
    CredentialsFileError: No credentials file given

But you can give an overriding file name in the save() method.

    >>> credentials.save(credentials_file)
    >>> credentials = Credentials(consumer_key, filename=credentials_file)
    >>> credentials.access_token
    'hgm2VK35vXD6rLg5pxWw'

If you use the wrong access token, you also get an exception.

    >>> credentials = Credentials(consumer_key, access_token='bad')
    >>> launchpad = Launchpad(credentials=credentials)
    >>> launchpad.root
    'BADNESS'


== Clean up ==

    >>> import shutil
    >>> shutil.rmtree(tempdir)
