= RESTful Web Services =

LAZR builds on Zope conventions to make it easy to expose your model
objects as RESTful HTTP resources. I'll demonstrate these features by
defining a model for managing recipes, and then publishing the model
objects as resources through a web service.


== Example model objects ==

Here's the interface for a simple set of model objects. This is the
kind of model object you'd find in any Zope application, with no
special knowledge of web services. The model is of a group of
cookbooks. Each cookbook has a known person as the author. Each
cookbook contains multiple recipes. A recipe is a recipe _for_ a dish,
and two or more cookbooks may provide different recipes for the same
dish. Users may comment on cookbooks and on individual recipes.

    # All classes defined in this test are new-style classes.
    >>> __metaclass__ = type

    >>> from zope.interface import Interface, Attribute
    >>> from zope.schema import Int, Text, TextLine, Object

    >>> class IAuthor(Interface):
    ...     name = TextLine(title=u"Name", required=True)

    >>> class IComment(Interface):
    ...     text = TextLine(title=u"Text", required=True)

    >>> class ICookbook(Interface):
    ...     name = TextLine(title=u"Name", required=True)
    ...     author = Object(schema=IAuthor)
    ...     recipes = Attribute("List of recipes published in this cookbook.")
    ...     comments = Attribute("List of comments about this cookbook.")

    >>> class ICookbookComment(IComment):
    ...     cookbook = Object(schema=ICookbook)

    >>> class IDish(Interface):
    ...     name = TextLine(title=u"Name", required=True)
    ...     recipes = Attribute("List of recipes for this dish.")

    >>> class IRecipe(Interface):
    ...     id = Int(title=u"Unique ID", required=True)
    ...     dish = Object(schema=IDish)
    ...     cookbook = Object(schema=ICookbook)
    ...     instructions = Text(title=u"How to prepare the recipe.",
    ...         required=True)
    ...     comments = Attribute("List of comments on the recipe.")

    >>> class IRecipeComment(IComment):
    ...     recipe = Object(schema=IRecipe)

Here's the interface for the 'set' objects that manage the authors,
cookbooks, and dishes. The inconsistent naming is intentional.

    >>> class IAuthorSet(Interface):
    ...     def getAllAuthors(self):
    ...         "Get all authors."
    ...
    ...     def getAuthor(self, name):
    ...         "Retrieve a single author by name."

    >>> class ICookbookSet(Interface):
    ...     def getAll(self):
    ...         "Get all cookbooks."
    ...
    ...     def get(self, name):
    ...         "Retrieve a single cookbook by name."

    >>> class IDishSet(Interface):
    ...     def getAll(self):
    ...         "Get all dishes."
    ...
    ...     def get(self, name):
    ...         "Retrieve a single dish by name."


Here are simple implementations of IAuthor, ICookbook, IDish, and IRecipe.

    >>> from zope.interface import implements
    >>> from zope.security.checker import CheckerPublic
    >>> from canonical.lazr.security import protect_schema

    >>> class Author:
    ...     implements(IAuthor)
    ...     def __init__(self, name):
    ...         self.name = name
    >>> protect_schema(Author, IAuthor, write_permission=CheckerPublic)

    >>> class Comment(object):
    ...     implements(IComment)
    ...     def __init__(self, text):
    ...         self.text = text
    >>> protect_schema(Comment, IComment, write_permission=CheckerPublic)

    >>> class Cookbook:
    ...     implements(ICookbook)
    ...     def __init__(self, name, author):
    ...         self.name = name
    ...         self.author = author
    ...         self.recipes = []
    ...         self.comments = []
    >>> protect_schema(Cookbook, ICookbook, write_permission=CheckerPublic)

    >>> class CookbookComment(Comment):
    ...     implements(ICookbookComment)
    ...     def __init__(self, text, cookbook):
    ...         super(CookbookComment, self).__init__(text)
    ...         self.cookbook = cookbook
    ...         cookbook.comments.append(self)
    >>> protect_schema(
    ...     CookbookComment, ICookbookComment, write_permission=CheckerPublic)

    >>> class Dish:
    ...     implements(IDish)
    ...     def __init__(self, name):
    ...         self.name = name
    ...         self.recipes = []
    >>> protect_schema(Dish, IDish, write_permission=CheckerPublic)

    >>> class Recipe:
    ...     implements(IRecipe)
    ...     def __init__(self, id, cookbook, dish, instructions):
    ...         self.id = id
    ...         self.cookbook = cookbook
    ...         self.cookbook.recipes.append(self)
    ...         self.dish = dish
    ...         self.dish.recipes.append(self)
    ...         self.instructions = instructions
    ...         self.comments = []
    >>> protect_schema(Recipe, IRecipe, write_permission=CheckerPublic)

    >>> class RecipeComment(Comment):
    ...     implements(IRecipeComment)
    ...     def __init__(self, text, recipe):
    ...         super(RecipeComment, self).__init__(text)
    ...         self.recipe = recipe
    ...         recipe.comments.append(self)
    >>> protect_schema(
    ...     RecipeComment, IRecipeComment, write_permission=CheckerPublic)

Here are the "model objects" themselves:

    >>> A1 = Author("Julia Child")
    >>> A2 = Author("Irma S. Rombauer")
    >>> A3 = Author("James Beard")

    >>> C1 = Cookbook("Mastering the Art of French Cooking", A1)
    >>> C2 = Cookbook("The Joy of Cooking", A2)
    >>> C3 = Cookbook("James Beard's American Cookery", A3)

    >>> D1 = Dish("Roast chicken")
    >>> C1_D1 = Recipe(1, C1, D1, "You can always judge...")
    >>> C2_D1 = Recipe(2, C2, D1, "Draw, singe, stuff, and truss...")
    >>> C3_D1 = Recipe(3, C3, D1, "A perfectly roasted chicken is...")

    >>> D2 = Dish("Baked beans")
    >>> C2_D2 = Recipe(4, C2, D2, "Preheat oven to...")
    >>> C3_D2 = Recipe(5, C3, D2, "Without doubt the most famous...")

    >>> D3 = Dish("Foies de voilaille en aspic")
    >>> C1_D3 = Recipe(6, C1, D3, "Chicken livers sauteed in butter...")

    >>> COM1 = RecipeComment("Clear and concise.", C2_D1)
    >>> COM2 = CookbookComment("A kitchen staple.", C2)

Here's a simple CookbookSet with a predefined list of cookbooks.

    >>> class CookbookSet:
    ...     implements(ICookbookSet)
    ...     def __init__(self):
    ...         self.cookbooks = [C1, C2, C3]
    ...
    ...     def getAll(self):
    ...         return self.cookbooks
    ...
    ...     def get(self, name):
    ...         match = [c for c in self.cookbooks if c.name == name]
    ...         if len(match) > 0:
    ...             return match[0]
    ...         return None
    >>> protect_schema(CookbookSet, ICookbookSet)

Here's a simple AuthorSet with predefined authors.

    >>> class AuthorSet:
    ...     implements(IAuthorSet)
    ...     def __init__(self):
    ...         self.authors = [A1, A2, A3]
    ...
    ...     def getAllAuthors(self):
    ...         return self.authors
    ...
    ...     def getAuthor(self, name):
    ...         match = [p for p in self.authors if p.name == name]
    ...         if len(match) > 0:
    ...             return match[0]
    ...         return None
    >>> protect_schema(AuthorSet, IAuthorSet)

Finally, a simple DishSet with predefined dishes.

    >>> class DishSet:
    ...     implements(IDishSet)
    ...     def __init__(self):
    ...         self.dishes = [D1, D2, D3]
    ...
    ...     def getAll(self):
    ...         return self.dishes
    ...
    ...     def get(self, name):
    ...         match = [d for d in self.dishes if d.name == name]
    ...         if len(match) > 0:
    ...             return match[0]
    ...         return None
    >>> protect_schema(DishSet, IDishSet)

The web service uses the standard Navigation components to map URLs to
components to publish (see navigation.txt) and the standard ICanonicalUrlData
to map content object back to URL (see canonical_url.txt).

The navigation for these components:

    >>> from urllib import unquote
    >>> from canonical.launchpad.webapp.publisher import (
    ...     Navigation, stepthrough)
    >>> from zope.component import provideAdapter
    >>> from zope.publisher.interfaces.browser import (
    ...     IBrowserPublisher, IDefaultBrowserLayer)

    >>> def register_navigation(navigation, for_):
    ...     provideAdapter(navigation, [for_, IDefaultBrowserLayer],
    ...         IBrowserPublisher)

    >>> class DishSetNavigation(Navigation):
    ...     def traverse(self, name):
    ...         return self.context.get(unquote(name))
    >>> register_navigation(DishSetNavigation, IDishSet)

    >>> class AuthorSetNavigation(Navigation):
    ...     def traverse(self, name):
    ...         return self.context.getAuthor(unquote(name))
    >>> register_navigation(AuthorSetNavigation, IAuthorSet)

    >>> class CookbookSetNavigation(Navigation):
    ...     def traverse(self, name):
    ...         return self.context.get(unquote(name))
    >>> register_navigation(CookbookSetNavigation, ICookbookSet)

    >>> class CookbookNavigation(Navigation):
    ...     @stepthrough('comments')
    ...     def traverse_comments(self, name):
    ...         try:
    ...             return self.context.comments[int(name)-1]
    ...         except (IndexError, TypeError, ValueError):
    ...             return None
    ...
    ...     @stepthrough('recipes')
    ...     def traverse_recipes(self, name):
    ...         name = unquote(name)
    ...         for recipe in self.context.recipes:
    ...             if recipe.dish.name == name:
    ...                 return recipe
    ...         return None
    >>> register_navigation(CookbookNavigation, ICookbook)

    >>> class RecipeNavigation(Navigation):
    ...     @stepthrough('comments')
    ...     def traverse_comments(self, name):
    ...         try:
    ...             return self.context.comments[int(name)-1]
    ...         except (IndexError, TypeError, ValueError):
    ...             return None
    >>> register_navigation(RecipeNavigation, IRecipe)

    >>> class RootNavigation(Navigation):
    ...     top_level_names = {
    ...         'dishes': DishSet(),
    ...         'cookbooks': CookbookSet(),
    ...         'authors': AuthorSet()}
    ...
    ...     def traverse(self, name):
    ...         return self.top_level_names.get(name)

The canonical URLs for these components:

    >>> from urllib import quote
    >>> from canonical.launchpad.webapp.interfaces import ICanonicalUrlData
    >>> class BaseUrlData(object):
    ...     inside = None
    ...     def __init__(self, context):
    ...         self.context = context
    ...         self.rootsite = None
    ...
    ...     @property
    ...     def path(self):
    ...         return quote(self.context.name)

    >>> class AuthorUrlData(BaseUrlData):
    ...     @property
    ...     def inside(self):
    ...         return AuthorSet()
    >>> provideAdapter(AuthorUrlData, [IAuthor], ICanonicalUrlData)

    >>> class DishUrlData(BaseUrlData):
    ...     @property
    ...     def inside(self):
    ...         return DishSet()
    >>> provideAdapter(DishUrlData, [IDish], ICanonicalUrlData)

    >>> class RecipeUrlData(BaseUrlData):
    ...     @property
    ...     def inside(self):
    ...         return self.context.cookbook
    ...     @property
    ...     def path(self):
    ...         return quote(u"recipes/%s" % str(self.context.dish.name))
    >>> provideAdapter(RecipeUrlData, [IRecipe], ICanonicalUrlData)

    >>> class CookbookUrlData(BaseUrlData):
    ...     @property
    ...     def inside(self):
    ...         return CookbookSet()
    >>> provideAdapter(CookbookUrlData, [ICookbook], ICanonicalUrlData)

    >>> class DishSetUrlData(BaseUrlData):
    ...     path = 'dishes'
    >>> provideAdapter(DishSetUrlData, [IDishSet], ICanonicalUrlData)

    >>> class CookbookSetUrlData(BaseUrlData):
    ...     path = 'cookbooks'
    >>> provideAdapter(CookbookSetUrlData, [ICookbookSet], ICanonicalUrlData)

    >>> class AuthorSetUrlData(BaseUrlData):
    ...     path = 'authors'
    >>> provideAdapter(AuthorSetUrlData, [IAuthorSet], ICanonicalUrlData)

    >>> class CookbookCommentUrlData(BaseUrlData):
    ...     @property
    ...     def path(self):
    ...         return "comments/%d" % (
    ...             self.context.cookbook.comments.index(self.context)+1)
    ...     @property
    ...     def inside(self):
    ...         return self.context.cookbook
    >>> provideAdapter(
    ...     CookbookCommentUrlData, [ICookbookComment], ICanonicalUrlData)

    >>> class RecipeCommentUrlData(BaseUrlData):
    ...     @property
    ...     def path(self):
    ...         return "comments/%d" % (
    ...             self.context.recipe.comments.index(self.context)+1)
    ...     @property
    ...     def inside(self):
    ...         return self.context.recipe
    >>> provideAdapter(
    ...     RecipeCommentUrlData, [IRecipeComment], ICanonicalUrlData)


== Defining the resources ==

LAZR provides an interface, IEntry, used by an individual model object
exposed through a specific resource. Right now it's just a marker
interface, but it's expected to define a number of data fields: the
same kind of fields defined by a model interface like IRecipe.

If there's not much to an interface, you can expose it through the web
service exactly as it's defined, by defining a class that inherits
from both the interface and IEntry. Since IAuthor and IComment are so
simple, we can implement IAuthorEntry and ICommentEntry this way:

    >>> from canonical.lazr.interfaces import IEntry
    >>> class IAuthorEntry(IAuthor, IEntry):
    ...     """The part of an author we expose through the web service."""

    >>> from canonical.lazr.interfaces import IEntry
    >>> class ICommentEntry(IComment, IEntry):
    ...     """The part of a comment we expose through the web service."""

That usually doesn't work, though, because we usually don't want to
expose to the web service the same data model we expose
internally. Usually there are fields we don't want to expose,
synthetic fields we do want to expose, fields we want to expose as a
different type under a different name, and so on. This is why we have
IEntry in the first place: the IEntry subclass defines the interface
we _do_ want to expose through the web service.

The reason we can't just define IDishEntry(IDish, IEntry) is that
IDish defines the "recipes" collection as an Attribute. Attribute is
about as generic as "object", and doesn't convey any information about
what kind of object is in the collection, or even that "recipes" is a
collection at all. To expose the corresponding field to the web
service we use CollectionField.

    >>> from canonical.lazr.rest.schema import CollectionField
    >>> class IDishEntry(IEntry):
    ...     "The part of a dish that we expose through the web service."
    ...     recipes = CollectionField(value_type=Object(schema=IRecipe))


In the following code block we define an interface that exposes the
underlying Recipe's name but not its ID. References to associated
objects (like the recipe's cookbook) are represented with the
zope.schema.Object type: this makes it possible to serve a link from a
recipe to its cookbook.

    >>> class IRecipeEntry(IEntry):
    ...     "The part of a recipe that we expose through the web service."
    ...     cookbook = Object(schema=ICookbook)
    ...     dish = Object(schema=IDish)
    ...     instructions = Text(title=u"Name", required=True)
    ...     comments = CollectionField(value_type=Object(schema=IComment),
    ...         is_entry_container=True)

Note that CollectionField is used slightly differently here than in
IDishEntry. We pass in a new argument, is_entry_container=True. This
is because a recipe's comments are exposed beneath the recipe: the
recipe actually contains its comments. is_entry_container allows us to
have one 'comment' type that can be associated with either a recipe or
a cookbook.

    >>> class ICookbookEntry(IEntry):
    ...     name = TextLine(title=u"Name", required=True)
    ...     author = Object(schema=IAuthor)
    ...     recipes = CollectionField(value_type=Object(schema=IRecipe))
    ...     comments = CollectionField(value_type=Object(schema=IComment),
    ...         is_entry_container=True)


== Implementing the resources ==

Here's the implementation of IAuthorEntry: a simple decorator on the
original model object. It subclasses Entry, a simple base class that
defines a constructor. (See lazr/doc/decorates.txt for more on
decorates().)

    >>> from zope.component import adapts
    >>> from canonical.lazr import decorates
    >>> from canonical.lazr.rest import Entry

    >>> class AuthorEntry(Entry):
    ...     """An author, as exposed through the web service."""
    ...     adapts(IAuthor)
    ...     decorates(IAuthorEntry)
    ...     schema = IAuthorEntry
    ...
    ...     _parent_collection_path = ['authors']

The "schema" attribute points to the interface class that defines the
attributes exposed through the web service. Above, "schema" is
IAuthorEntry, which exposes only "name". Below, "schema" is
ICookbookEntry, which exposes "name" and "author", "recipes", and
"comments".

    >>> class CookbookEntry(Entry):
    ...     """A cookbook, as exposed through the web service."""
    ...     adapts(ICookbook)
    ...     decorates(ICookbookEntry)
    ...     schema = ICookbookEntry
    ...
    ...     _parent_collection_path = ['cookbooks']

    >>> class DishEntry(Entry):
    ...     """A dish, as exposed through the web service."""
    ...     adapts(IDish)
    ...     decorates(IDishEntry)
    ...     schema = IDishEntry
    ...
    ...     _parent_collection_path = ['dishes']

The comment entry is a little different. Note that it doesn't define
_parent_collection_path. That's because a comment will delegates many
of an entry's tasks to whatever collection contains it. This is the
flip side of the is_entry_container we saw earlier.

    >>> class CommentEntry(Entry):
    ...     """A comment, as exposed through the web service."""
    ...     adapts(IComment)
    ...     decorates(ICommentEntry)
    ...     schema = ICommentEntry

The recipe entry is also different. It defines a
_parent_collection_path of more than one element. A recipe's canonical
home is 'beneath' the cookbook it was published in. The
_parent_collection_path will be used whether the recipe in question was
found in a cookbook's collection of recipes or with some other
collection (such as the recipes for a specific dish).

    >>> class RecipeEntry(Entry):
    ...     adapts(IRecipe)
    ...     decorates(IRecipeEntry)
    ...     schema = IRecipeEntry
    ...
    ...     _parent_collection_path = [
    ...         'cookbooks', lambda r: r.cookbook, 'recipes']


We need to register these entries as an adapter from (eg.) IAuthor to
(eg.) IAuthorEntry. In ZCML a registration would look like this.

    <adapter
        for="my.app.interfaces.IAuthor"
        provides="my.app.interfaces.IAuthorEntry"
        factory="my.app.rest.AuthorEntry"
        />

Since we're in the middle of a Python test we need to do the equivalent
in Python code:

    >>> provideAdapter(AuthorEntry, [IAuthor], IAuthorEntry)
    >>> provideAdapter(CookbookEntry, [ICookbook], ICookbookEntry)
    >>> provideAdapter(DishEntry, [IDish], IDishEntry)
    >>> provideAdapter(CommentEntry, [IComment], ICommentEntry)
    >>> provideAdapter(RecipeEntry, [IRecipe], IRecipeEntry)

LAZR also defines an interface and a base class for collections of
objects. I'll use it to expose the AuthorSet collection and other
top-level collections through the web service. A collection must
define a method called find(), which returns the model objects in the
collection.

    >>> from canonical.lazr.rest import Collection
    >>> from canonical.lazr.interfaces import ICollection

    >>> class AuthorCollection(Collection):
    ...     """A collection of authors, as exposed through the web service."""
    ...
    ...     def find(self):
    ...        """Find all the authors."""
    ...        return self.context.getAllAuthors()
    ...
    ...     def lookupEntry(self, name):
    ...        """Find a single author by name."""
    ...        return self.context.getAuthor(name)
    ...
    ...     def getEntryPath(self, entry):
    ...         """Use an author's name as its URI fragment."""
    ...         return entry.name
    >>> provideAdapter(AuthorCollection, [IAuthorSet], ICollection)

    >>> class CookbookCollection(Collection):
    ...     """A collection of cookbooks, as exposed through the web service.
    ...     """
    ...
    ...     def find(self):
    ...        """Find all the cookbooks."""
    ...        return self.context.getAll()
    ...
    ...     def lookupEntry(self, name):
    ...        """Find a single cookbook by name."""
    ...        return self.context.get(name)
    ...
    ...     def getEntryPath(self, entry):
    ...         """Use a cookbook's name as its URI fragment."""
    ...         return entry.context.name
    >>> provideAdapter(CookbookCollection, [ICookbookSet], ICollection)

    >>> class DishCollection(Collection):
    ...     """A collection of dishes, as exposed through the web service."""
    ...
    ...     def find(self):
    ...        """Find all the dishes."""
    ...        return self.context.getAll()
    ...
    ...     def lookupEntry(self, name):
    ...        """Find a single dish by name."""
    ...        return self.context.get(name)
    ...
    ...     def getEntryPath(self, entry):
    ...         """Use a dish's name as its URI fragment."""
    ...         return entry.context.name
    >>> provideAdapter(DishCollection, [IDishSet], ICollection)

Like Entry, Collection is a simple base class that defines a
constructor.

We need to define a collection of the recipes associated with a
cookbook. We say that the collection of recipes is scoped to a
cookbook. This class manages a collection of a cookbook's or dish's
recipes. It'll work with any collection of recipes.

    >>> from canonical.lazr.rest import ScopedCollection
    >>> class RecipeScopedCollection(ScopedCollection):
    ...
    ...     def lookupEntry(self, name):
    ...         for recipe in self.collection:
    ...             if recipe.dish.name == name:
    ...                 return recipe
    ...         return None
    ...
    ...     def getEntryPath(self, entry):
    ...         return entry.dish.name

    >>> from canonical.lazr.interfaces import IScopedCollection
    >>> provideAdapter(RecipeScopedCollection, [ICookbook, IRecipe],
    ...                IScopedCollection)
    >>> provideAdapter(RecipeScopedCollection, [IDish, IRecipe],
    ...                IScopedCollection)

We also need to define collections of the comments associated with a
recipe or cookbook. These will be scoped collections too, but they're
a little different from an cookbook-scoped collection of
recipes. RecipeEntry defines _parent_collection_path and CommentEntry
doesn't. So the list of comments scoped to a recipe (or cookbook)
needs to take on some of the duties handled by the kind of collection
that defines _parent_collection_path. Fortunately, there's a predefined
class that works in cases like this one, where the elements are
indexed by their order within a parent collection:
OrderBasedScopedCollection.

    >>> from canonical.lazr.rest.resource import OrderBasedScopedCollection
    >>> provideAdapter(OrderBasedScopedCollection, [IRecipe, IComment],
    ...                IScopedCollection)

    >>> provideAdapter(OrderBasedScopedCollection, [ICookbook, IComment],
    ...                IScopedCollection)


== Resource objects ==

LAZR's Resource objects are the objects that actually handle incoming
HTTP requests. There are a few very common types of HTTP resources,
and LAZR defines classes for some of them. For instance, there's the
"collection" resource that responds to GET (to get the items in the
collection) and POST (to add a new item to the collection). LAZR
implements this as a CollectionResource which uses the HTTP arguments
to drive Collection methods like find() and createNew() (createNew()
isn't implemented yet).

Of course, a CollectionResource has to expose a collection _of_
something. That's why each CollectionResource is associated with some
concrete implementation of ICollection, like AuthorCollection. All you
have to do is define the behaviour of the collection, and
CollectionResource takes care of exposing the collection through HTTP.

Similarly, you can implement RecipeEntry to the IEntry interface, and
expose it through the web as an EntryResource.


== The Service Root Resource ==

How are these Resource objects connected to the web? Through the
ServiceRootResource. This is a special resource that represents the
root of the object tree.

    >>> from canonical.lazr.rest import ServiceRootResource
    >>> from canonical.launchpad.interfaces import IWebServiceApplication
    >>> class MyServiceRootResource(ServiceRootResource):
    ...     implements(IWebServiceApplication)
    >>> register_navigation(RootNavigation, IWebServiceApplication)

If you call the service root resource, and pass in an HTTP request, it
will act as though you had performed a GET on the URL
'http://api.launchpad.net/'.

    >>> from canonical.launchpad.webapp.servers import WebServiceTestRequest
    >>> from canonical.launchpad.webapp.servers import WebServicePublication

    >>> def create_web_service_request(
    ...     path_info, method='GET', body_instream=None, environ=None):
    ...     test_environ = {
    ...         'SERVER_URL': 'http://api.launchpad.dev',
    ...         'HTTP_HOST': 'api.lauchpad.dev',
    ...         'PATH_INFO': path_info,
    ...     }
    ...     if environ:
    ...         test_environ.update(environ)
    ...     request = WebServiceTestRequest(
    ...         body_instream=body_instream, environ=test_environ,
    ...         method=method)
    ...     request.setPublication(WebServicePublication(None))
    ...     # Set the "current" request.
    ...     login(ANONYMOUS, request)
    ...     return request

    >>> request = create_web_service_request('/')
    >>> app = MyServiceRootResource()
    >>> app(request)
    'This is a web service.'

The standard canonical_url() function can be used to generate URLs to
content objects published on the web service. It works for the web
service root also.

    >>> from canonical.launchpad.webapp import canonical_url
    >>> from canonical.launchpad.webapp.interfaces import ICanonicalUrlData
    >>> ICanonicalUrlData.providedBy(app)
    True
    >>> canonical_url(app)
    u'http://api.launchpad.dev/'


== Collection resources ==

The default root navigation defined in our model contains the top-level
Set objects that should be published. When these sets are published on
the web service, they will we wrapped in the appropriate
CollectionResource. (It doesn't need navigation, because the default
Zope which traverse to attributes is fine.)

The following example is equivalent to requesting
'http://api.launchpad.net/cookbooks/'. The code will traverse to the
CookbookSet published normally at '/cookbooks' and it will be wrapped
into a CollectionResource.

    >>> request = create_web_service_request('/cookbooks')
    >>> collection = request.traverse(app)
    >>> collection
    <canonical.lazr.rest.resource.CollectionResource object ...>

Calling the collection resource yields a JSON document, which can be
parsed with standard tools.

    >>> import simplejson
    >>> representation = simplejson.loads(collection())


== Entry resources ==

The collection resource is a list of entries. Each entry has some
associated information (like 'name'), a 'self_link' (the URL to the
entry's resource), and possibly links to associated resources.

    >>> len(representation)
    3
    >>> representation[1]['name']
    u'The Joy of Cooking'
    >>> representation[1]['self_link']
    u'http://api.launchpad.dev/cookbooks/The%20Joy%20of%20Cooking'

Each cookbook, for instance, has a link to its author.

    >>> representation[1]['author_link']
    u'http://api.launchpad.dev/authors/Irma%20S.%20Rombauer'

Calling the CollectionResource object makes it process the incoming
request. Since this is a GET request, calling the resource publishes
the resource to the web. A CollectionResource is made up of a bunch of
EntryResources, and the base EntryResource class knows how to use the
entry schema class (in this case, IRecipeEntry) to publish a JSON
document.

The same way collections are wrapped into CollectionResource, navigating
to an object that has an IEntry adapter, will wrap it into an
EntryResource.

For instance, requesting "/cookbooks/The%20Joy%20of%20Cooking" will wrap
A CollectionResource object also implements IPublishTraverse: you can
navigate from a collection to one of the entries in that collection.
It's the corresponding Collection's job to implement lookupEntry() so
that (for instance) /recipes/10 is mapped to the "Raw celery" Entry.

    >>> request = create_web_service_request(
    ...     quote('/cookbooks/The Joy of Cooking'))
    >>> joy_resource = request.traverse(app)
    >>> joy_resource
    <canonical.lazr.rest.resource.EntryResource object ...>

    >>> joy = simplejson.loads(joy_resource())
    >>> sorted(joy.items())
    [(u'author_link',
      u'http://api.launchpad.dev/authors/Irma%20S.%20Rombauer'),
     (u'comments_collection_link',
      u'http://api.launchpad.dev/cookbooks/The%20Joy%20of%20Cooking/comments'),
     (u'name', u'The Joy of Cooking'),
     (u'recipes_collection_link',
      u'http://api.launchpad.dev/cookbooks/The%20Joy%20of%20Cooking/recipes'),
     (u'self_link',
      u'http://api.launchpad.dev/cookbooks/The%20Joy%20of%20Cooking')]

You can also traverse from an entry to an associated collection:

    >>> request = create_web_service_request(
    ...     quote('/cookbooks/The Joy of Cooking/recipes'))
    >>> joy_recipes = request.traverse(app)

    >>> request = create_web_service_request(
    ...     quote('/cookbooks/The Joy of Cooking/recipes/Roast chicken'))
    >>> chicken_recipe_resource = request.traverse(app)
    >>> chicken_recipe = simplejson.loads(chicken_recipe_resource())
    >>> sorted(chicken_recipe.items())
    [(u'comments_collection_link',
      u'http://api.launchpad.dev/cookbooks/The%20Joy%20of%20Cooking/recipes/Roast%20chicken/comments'),
    (u'cookbook_link',
     u'http://api.launchpad.dev/cookbooks/The%20Joy%20of%20Cooking'),
    (u'dish_link', u'http://api.launchpad.dev/dishes/Roast%20chicken'),
    (u'instructions', u'Draw, singe, stuff, and truss...'),
    (u'self_link',
     u'http://api.launchpad.dev/cookbooks/The%20Joy%20of%20Cooking/recipes/Roast%20chicken')]

Scoped collections work the same way whether the entries are "really"
in the collection (as with comments, below) or whether they're
"really" in a top-level collection (as with recipes, above).

    >>> roast_chicken_comments_url = quote(
    ... '/cookbooks/The Joy of Cooking/recipes/Roast chicken/comments')
    >>> request = create_web_service_request(roast_chicken_comments_url)
    >>> comments_resource = request.traverse(app)

    >>> comments = simplejson.loads(comments_resource())
    >>> [c['text'] for c in comments]
    [u'Clear and concise.']

    >>> request = create_web_service_request(
    ...     roast_chicken_comments_url + '/1')
    >>> comment_one_resource = request.traverse(app)
    >>> comment_one = simplejson.loads(comment_one_resource())
    >>> sorted(comment_one.items())
    [(u'self_link',
      u'http://api.launchpad.dev/cookbooks/The%20Joy%20of%20Cooking/recipes/Roast%20chicken/comments/1'),
     (u'text', u'Clear and concise.')]


== Requesting non available resources ==

If the user tries to traverse to a nonexistent object, the result is a
NotFound exception.

Requesting a non-existent top-level collection:

    >>> request = create_web_service_request('/nosuchcollection')
    >>> request.traverse(app)
    Traceback (most recent call last):
    ...
    NotFound: ... name: u'nosuchcollection'

Requesting a non-existent cookbook:

    >>> request = create_web_service_request('/cookbooks/104')
    >>> request.traverse(app)
    Traceback (most recent call last):
    ...
    NotFound: ... name: u'104'


== Manipulating entries ==

Most entry resources support write operations by responding to PATCH
requests. The entity-body of a PATCH request should be a JSON document
with new values for some of the entry's attributes. Basically, a set
of assertions about what the object *should* look like.

Here, we modify the name of one of the cookbooks.

    >>> from StringIO import StringIO
    >>> headers = { 'CONTENT_TYPE' : 'application/json' }
    >>> body = StringIO('{"name" : "The Joy of Cooking (revised)"}')

    >>> patch_request = create_web_service_request(
    ...     '/cookbooks/The%20Joy%20of%20Cooking', body_instream=body,
    ...     environ=headers, method='PATCH')
    >>> joy_resource_patch = patch_request.traverse(app)
    >>> joy_resource_patch()
    >>> patch_request.response.getStatus()
    301
    >>> patch_request.response.getHeader('Location')
    'http://api.../cookbooks/The%20Joy%20of%20Cooking%20%28revised%29'

The new name is reflected in the cookbook's representation, and the
cookbook's URL has changed as well.

    >>> request = create_web_service_request(
    ...     '/cookbooks/The%20Joy%20of%20Cooking%20%28revised%29')
    >>> joy_resource = request.traverse(app)
    >>> joy = simplejson.loads(joy_resource())
    >>> joy['name']
    u'The Joy of Cooking (revised)'

