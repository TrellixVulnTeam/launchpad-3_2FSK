=====
OAuth
=====

This is a mechanism for allowing a third party application to access
Launchpad on a user's behalf.  These applications are identified by a
unique key and are stored as OAuthConsumers.  The OAuth specification is
defined in <http://oauth.net/core/1.0/>.

Access tokens
=============

As shown above, access tokens can be created from any reviewed (and
authorized) request tokens. These tokens are then stored by the consumer
and included in all further requests made on behalf of the same user, so
we need a way to retrieve an access token from any consumer.

    >>> consumer.getAccessToken(access_token.key) == access_token
    True

An access token can only be changed by the person associated with it.

    >>> access_token.permission = OAuthPermission.WRITE_PUBLIC
    Traceback (most recent call last):
    ...
    Unauthorized:...
    >>> login_person(access_token.person)
    >>> access_token.permission = AccessLevel.WRITE_PUBLIC

From any given person it's possible to retrieve his non-expired access
tokens.

    >>> access_token.person.oauth_access_tokens.count()
    4
    >>> access_token.date_expires = (
    ...     datetime.now(pytz.timezone('UTC')) - timedelta(hours=1))
    >>> syncUpdate(access_token)
    >>> access_token.person.oauth_access_tokens.count()
    3

It's also possible to retrieve the user's non-expired request tokens.

    >>> unclaimed_request_token = consumer.newRequestToken()
    >>> unclaimed_request_token.review(salgado, OAuthPermission.WRITE_PUBLIC)
    >>> salgado.oauth_request_tokens.count()
    5
    >>> salgado.oauth_request_tokens[0].date_expires = (
    ...     datetime.now(pytz.timezone('UTC')) - timedelta(hours=1))
    >>> syncUpdate(unclaimed_request_token)
    >>> salgado.oauth_request_tokens.count()
    4

A user has edit permission over his own access tokens, he can expire them.

    >>> api_user = factory.makePerson()
    >>> login_person(api_user)
    >>> api_request_token = consumer.newRequestToken()
    >>> api_request_token.review(api_user, OAuthPermission.WRITE_PUBLIC)
    >>> api_access_token = api_request_token.createAccessToken()
    >>> api_access_token.date_expires = (
    ...     datetime.now(pytz.timezone('UTC')) - timedelta(hours=1))


Nonces and timestamps
=====================

A nonce is a random string, generated by the client for each request.

A timestamp is also generated by the client, and indicates when the request
was generated, according to the client's clock, expressed in the number of
seconds since January 1, 1970 00:00:00 GMT.

A nonce must be unique for the combination of a client and a timestamp.
Launchpad implements this constraint. If a nonce is not unique for a client
and a timestamp, the code will raise a NonceAlreadyUsed exception.

Here's a quick demonstration of the behavior.

- We can use a nonce.

    >>> import time
    >>> now = time.time() - 1
    >>> nonce1 = access_token.checkNonceAndTimestamp('boo', now)
    >>> verifyObject(IOAuthNonce, nonce1)
    True

- We can use an existing nonce with a new time.

    >>> now += 1
    >>> nonce2 = access_token.checkNonceAndTimestamp('boo', now)
    >>> IOAuthNonce.providedBy(nonce2)
    True
    >>> nonce1 is nonce2
    False

- We can use a new nonce with the same time.

    >>> nonce3 = access_token.checkNonceAndTimestamp('surprise!', now)
    >>> IOAuthNonce.providedBy(nonce3)
    True
    >>> nonce1 is nonce3 or nonce2 is nonce3
    False

- But we cannot use an existing nonce used for the same time.

    >>> access_token.checkNonceAndTimestamp('boo', now)
    Traceback (most recent call last):
    ...
    NonceAlreadyUsed: ...

According to the oauth specification <http://oauth.net/core/1.0/#nonce>, for a
given client, an application should not accept a timestamp older than the most
recent timestamp received.

For instance, if a client sends a timestamp of 2009-02-24T13:43:08Z, a
subsequent request for any earlier time (even one second earlier,
2009-02-24T13:43:07Z) should generate an error. A request with the same
timestamp or later is acceptable.

These limitations of the nonce and the timestamp are intended to reduce the
opportunity for replay attacks, particularly within the context of an insecure
channel such as HTTP.

Launchpad relaxes the constraint on the timestamp. Rather than accepting any
request within the same second, Launchpad accepts any request within the past
60 seconds (or, as defined by the code, within the past number of seconds
specified by canonical.launchpad.database.oauth.TIMESTAMP_ACCEPTANCE_WINDOW).

For instance, in Launchpad, if a client sends a timestamp of
2009-02-24T13:43:08Z, a subsequent request of any time up to 60 seconds prior
will be accepted. That means that the next request can specify
2009-02-24T13:42:08Z or later. Otherwise the code will raise a
TimestampOrderingError.

Here's a quick demonstration of the behavior.

- Within the TIMESTAMP_ACCEPTANCE_WINDOW, we can create a nonce with an
  earlier time.

    >>> from canonical.launchpad.database.oauth import (
    ...     TIMESTAMP_ACCEPTANCE_WINDOW)
    >>> TIMESTAMP_ACCEPTANCE_WINDOW
    60
    >>> nonce4 = access_token.checkNonceAndTimestamp('boo', now-30)
    >>> IOAuthNonce.providedBy(nonce4)
    True
    >>> nonce5 = access_token.checkNonceAndTimestamp('boo', now-60)
    >>> IOAuthNonce.providedBy(nonce5)
    True

- Once outside of the window (defined by the *latest* timestamp, even if it
  is not the most recent), we get a TimestampOrderingError.

    >>> access_token.checkNonceAndTimestamp('boo', now-61)
    Traceback (most recent call last):
    ...
    TimestampOrderingError: ...

This change is intended to support pipelining requests, and to acknowledge
that network latency, multiple concurrent clients with the same credentials,
and other situations can cause timestamps to get out of order (see
http://groups.google.com/group/oauth/msg/387fdafcf0be322a and LP bug 319710
for more background).

The code also raises a ClockSkew error if the timestamp is more than
TIMESTAMP_SKEW_WINDOW seconds away from the server's clock (ahead or
behind). This number of seconds is currently equal to one hour (60*60). The
primary reason for this behavior is so that a clock skew too far in the future
does not essentially make the authentication tokens useless once the client's
clock is corrected. In addition, it gives us a constraint within which we can
reason about clock-related errors reported by customers.

Here's a quick demonstration of the behavior.

- We can access the system with a timestamp 55 minutes in the future.

    >>> from canonical.launchpad.database.oauth import (
    ...     TIMESTAMP_SKEW_WINDOW)
    >>> TIMESTAMP_SKEW_WINDOW
    3600
    >>> nonce6 = access_token.checkNonceAndTimestamp('boo', now + 55*60)
    >>> IOAuthNonce.providedBy(nonce6)
    True

- We cannot access it 65 minutes in the future.

    >>> access_token.checkNonceAndTimestamp('boo', now + 65*60)
    Traceback (most recent call last):
    ...
    ClockSkew: ...

- It's also worth noting that now the TIMESTAMP_ACCEPTANCE_WINDOW is based
  off of the time 55 minutes in the future.

    >>> nonce7 = access_token.checkNonceAndTimestamp('boo', now + 54*60 + 30)
    >>> IOAuthNonce.providedBy(nonce7)
    True
    >>> access_token.checkNonceAndTimestamp('boo', now + 60)
    Traceback (most recent call last):
    ...
    TimestampOrderingError: ...
    >>> access_token.checkNonceAndTimestamp('boo', now + 53*60)
    Traceback (most recent call last):
    ...
    TimestampOrderingError: ...


Helper methods
==============

The oauth_access_token_for() helper function makes it easy to get an
access token for any user, consumer key, permission, and context.

If the user already has an access token that does what you need,
oauth_access_token_for() returns the existing token.

    >>> from lp.testing import oauth_access_token_for
    >>> existing_token = salgado.oauth_access_tokens[0]
    >>> token = oauth_access_token_for(
    ...     existing_token.consumer.key, existing_token.person,
    ...     existing_token.permission, existing_token.context)

    >>> from zope.proxy import sameProxiedObjects
    >>> sameProxiedObjects(token, existing_token)
    True

If the user does not already have an access token that matches your
requirements, oauth_access_token_for() creates a request token and
automatically authorizes it. Here, we create a brand new token for a
never-before-seen consumer.

    >>> new_consumer = 'new consumer key to test oauth_access_token_for'
    >>> token = oauth_access_token_for(
    ...     new_consumer, salgado, 'WRITE_PRIVATE', firefox)

    >>> print token.consumer.key
    new consumer key to test oauth_access_token_for

    >>> print token.person.name
    salgado

    >>> token.permission
    <DBItem AccessLevel.WRITE_PRIVATE...>

    >>> print token.context.name
    firefox

    >>> print token.date_expires
    None

You can use the token identifying one of Launchpad's OAuth permission
levels instead of the constant itself, but if you specify a
nonexistent permission you'll get an error.

    >>> oauth_access_token_for(
    ...     new_consumer, salgado, 'NO_SUCH_PERMISSION', firefox)
    Traceback (most recent call last):
    ...
    KeyError: 'NO_SUCH_PERMISSION'
