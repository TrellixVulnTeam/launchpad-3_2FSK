= PackageUpload View Classes and Pages =

The QueueItemsView (browser/queue.py) is extended by the default view
for IDistroSeries context (IDistroSeriesView)

Let's instantiate the view for +queue for anonymous access:

  >>> from zope.component import queryMultiAdapter
  >>> from canonical.launchpad.webapp.servers import LaunchpadTestRequest
  >>> from canonical.launchpad.interfaces import IDistributionSet
  >>> from canonical.launchpad.database import LibraryFileAlias
  >>> fake_chroot = LibraryFileAlias.get(1)

  >>> ubuntu = getUtility(IDistributionSet)['ubuntu']
  >>> breezy_autotest = ubuntu['breezy-autotest']
  >>> breezy_autotest_i386 = breezy_autotest['i386']
  >>> unused = breezy_autotest_i386.addOrUpdateChroot(fake_chroot)

  >>> request = LaunchpadTestRequest()
  >>> queue_view = queryMultiAdapter(
  ...     (breezy_autotest, request), name="+queue")

View parameters need to be set properly before start:

  >>> queue_view.setupQueueList()

After setup we have a 'batched' list:

  >>> from canonical.launchpad.webapp.interfaces import IBatchNavigator
  >>> from canonical.launchpad.webapp.testing import verifyObject
  >>> verifyObject(IBatchNavigator, queue_view.batchnav)
  True

  >>> len(queue_view.batchnav.currentBatch())
  6

The local state (PackageUploadStatus, dbschema)

  >>> queue_view.state.name
  'NEW'

A list of available actions in this queue:

  >>> queue_view.availableActions()
  []

Let's instantiate the view for a specific queue:

  >>> from canonical.launchpad.interfaces import PackageUploadStatus
  >>> request = LaunchpadTestRequest(
  ...     form={'queue_state': PackageUploadStatus.DONE.value})
  >>> warty = ubuntu['warty']
  >>> queue_view = queryMultiAdapter((warty, request), name="+queue")
  >>> queue_view.setupQueueList()
  >>> queue_view.state.name
  'DONE'
  >>> len(queue_view.batchnav.currentBatch())
  2

Unexpected values for queue_state results in a proper error, anything
that can't be can't fit as an integer is automatically assume as the
default value (NEW queue).

  >>> request = LaunchpadTestRequest(
  ...     form={'queue_state': 'foo'})
  >>> warty = ubuntu['warty']
  >>> queue_view = queryMultiAdapter((warty, request), name="+queue")
  >>> queue_view.setupQueueList()
  >>> queue_view.state.name
  'NEW'
  >>> len(queue_view.batchnav.currentBatch())
  0

If a invalid integer is posted it raises.

  >>> request = LaunchpadTestRequest(
  ...     form={'queue_state': '10'})
  >>> warty = ubuntu['warty']
  >>> queue_view = queryMultiAdapter((warty, request), name="+queue")
  >>> queue_view.setupQueueList()
  Traceback (most recent call last):
  ...
  UnexpectedFormData: No suitable status found for value "10"

Anonymous users also have access to all queues, including UNAPPROVED
but they are not allowed to perform any action.

  >>> request = LaunchpadTestRequest(
  ...     form={'queue_state': PackageUploadStatus.UNAPPROVED.value})
  >>> queue_view = queryMultiAdapter(
  ...     (breezy_autotest, request), name="+queue")
  >>> queue_view.setupQueueList()
  >>> queue_view.state.name
  'UNAPPROVED'
  >>> len(queue_view.batchnav.currentBatch())
  5

  >>> queue_view.availableActions()
  []

Now, let's instantiate the view for +queue as a privileged user:

  >>> login('foo.bar@canonical.com')

  >>> queue_view = queryMultiAdapter(
  ...     (breezy_autotest, request), name="+queue")
  >>> queue_view.setupQueueList()
  >>> queue_view.availableActions()
  ['Accept', 'Reject']

Attempt to view and act on UNAPPROVED queue works for administrators.

  >>> request = LaunchpadTestRequest(
  ...     form={'queue_state': PackageUploadStatus.UNAPPROVED.value})
  >>> queue_view = queryMultiAdapter(
  ...     (breezy_autotest, request), name="+queue")
  >>> queue_view.setupQueueList()
  >>> queue_view.state.name
  'UNAPPROVED'
  >>> queue_view.availableActions()
  ['Accept', 'Reject']

Action on presented queue are controlled and performed by the
'performAction' method, which return a HTML-formatted report text
about the actions performed.

It accepts the 'Accept'/'Reject' and 'QUEUE_ID' arguments via POST.

Accepting an item from NEW queue.

  >>> from canonical.launchpad.interfaces import IPackageUploadSet
  >>> getUtility(IPackageUploadSet).get(1).status.name
  'NEW'
  >>> getUtility(IPackageUploadSet).get(3).status.name
  'NEW'

  >>> request = LaunchpadTestRequest(
  ...     form={'queue_state': PackageUploadStatus.NEW.value,
  ...           'Accept': 'Accept',
  ...           'QUEUE_ID': ['1', '3']})
  >>> request.method = 'POST'

Add fake librarian files so that email notifications work:

  >>> from canonical.archiveuploader.tests import (
  ...     insertFakeChangesFileForAllPackageUploads)
  >>> insertFakeChangesFileForAllPackageUploads()

Anonymous attempts to accept queue items are ignored and an error
message is presented.

  >>> login(ANONYMOUS)
  >>> queue_view = queryMultiAdapter(
  ...     (breezy_autotest, request), name="+queue")
  >>> queue_view.setupQueueList()
  >>> queue_view.performQueueAction()
  >>> print queue_view.error
  You do not have permission to act on queue items.

  >>> getUtility(IPackageUploadSet).get(1).status.name
  'NEW'
  >>> getUtility(IPackageUploadSet).get(3).status.name
  'NEW'

Privileged user can accept queue items.

  >>> login('foo.bar@canonical.com')
  >>> queue_view = queryMultiAdapter(
  ...     (breezy_autotest, request), name="+queue")
  >>> queue_view.setupQueueList()

  >>> queue_view.performQueueAction()

  >>> getUtility(IPackageUploadSet).get(1).status.name
  'ACCEPTED'
  >>> getUtility(IPackageUploadSet).get(3).status.name
  'DONE'

Rejection an item from NEW queue:

  >>> target = getUtility(IPackageUploadSet).get(2)
  >>> target.status.name
  'NEW'

  >>> request = LaunchpadTestRequest(
  ...     form={'queue_state': PackageUploadStatus.NEW.value,
  ...           'Reject': 'Reject',
  ...           'QUEUE_ID': '2'})
  >>> request.method = 'POST'

Anonymous attempts to reject queue items are ignored and an error
message is presented.

  >>> login(ANONYMOUS)
  >>> queue_view = queryMultiAdapter(
  ...     (breezy_autotest, request), name="+queue")
  >>> queue_view.setupQueueList()
  >>> queue_view.performQueueAction()
  >>> print queue_view.error
  You do not have permission to act on queue items.

  >>> target.status.name
  'NEW'

Privileged user can reject queue items.

  >>> login('foo.bar@canonical.com')
  >>> queue_view = queryMultiAdapter(
  ...     (breezy_autotest, request), name="+queue")
  >>> queue_view.setupQueueList()

  >>> queue_view.performQueueAction()

  >>> target.status.name
  'REJECTED'


== Calculation of "new" binaries ==

The queue page will show the user which binaries in a build upload are
new or not.  Since multiple binary package releases can appear in one
build, it's possible that a package that is not already published
can be uploaded alongside incremental versions of existing packages.
In that case, the whole upload is considered new and appears in the
"new" queue.

We can demonstrate this situation by creating a binary publication
for a package "foo" and uploading a new build that has "foo" and
"foo-dev" binaries in it.

    >>> from lp.soyuz.tests.test_publishing import (
    ...     SoyuzTestPublisher)
    >>> from lp.soyuz.interfaces.publishing import (
    ...     PackagePublishingStatus)
    >>> from canonical.launchpad.interfaces import ILibraryFileAliasSet
    >>> stp = SoyuzTestPublisher()
    >>> hoary = ubuntu['hoary']
    >>> stp.prepareBreezyAutotest()
    >>> fake_chroot = getUtility(ILibraryFileAliasSet)[1]
    >>> trash = hoary['i386'].addOrUpdateChroot(fake_chroot)
    >>> foo_source = stp.getPubSource(
    ...     sourcename="foo", distroseries=hoary, version="1.0-1",
    ...     status=PackagePublishingStatus.PUBLISHED)
    >>> foo_bin = stp.getPubBinaries(
    ...     binaryname="foo", status=PackagePublishingStatus.PUBLISHED,
    ...     distroseries=hoary, pub_source=foo_source)

Now that "foo" is published in Hoary, we can upload a new build.

    >>> from canonical.launchpad.ftests import import_public_test_keys
    >>> from canonical.launchpad.interfaces import IComponentSet
    >>> from lp.soyuz.model.component import ComponentSelection
    >>> from canonical.archiveuploader.tests import (
    ...     datadir, getPolicy, mock_logger_quiet)
    >>> from canonical.archiveuploader.nascentupload import NascentUpload
    >>> import_public_test_keys()
    >>> universe = getUtility(IComponentSet)['universe']
    >>> trash = ComponentSelection(distroseries=hoary, component=universe)
    >>> sync_policy = getPolicy(name='sync', distro='ubuntu',
    ...    distroseries='hoary')
    >>> sync_policy.can_upload_binaries = True
    >>> sync_policy.can_upload_mixed = True
    >>> foo_upload = NascentUpload(
    ...    datadir('suite/foo_1.0-2_multi_binary/foo_1.0-2_i386.changes'),
    ...    sync_policy, mock_logger_quiet)
    >>> foo_upload.process()
    >>> foo_upload.do_accept()
    True

Now we can examine the view, which provides an is_new method:

    >>> queue_view = queryMultiAdapter(
    ...     (hoary, request), name="+queue")
    >>> queue_view.setupQueueList()

The template calls decoratedQueueBatch() to retrieve the current batch
of uploads to display; this action also calculates data that the
is_new() method requires to work.

    >>> discard = queue_view.decoratedQueueBatch()

    >>> binary_packages = foo_upload.queue_root.builds[0].build.binarypackages
    >>> for binarypackage in binary_packages:
    ...     print binarypackage.name, queue_view.is_new(binarypackage)
    foo False
    foo-dev True


We created librarian files that need cleaning up before leaving the test.

  >>> from canonical.librarian.ftests.harness import cleanupLibrarianFiles
  >>> cleanupLibrarianFiles()
