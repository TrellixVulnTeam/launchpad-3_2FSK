Bug Filing Pages
================

Filing a Bug
------------

There are three objects on which you can file a bug. An
SQLObjectCreatedEvent is published when the bug is filed. Let's register
an event listener to demonstrate this.

    >>> from canonical.launchpad.ftests.event import TestEventListener
    >>> from canonical.launchpad.event.interfaces import ISQLObjectCreatedEvent
    >>> from canonical.launchpad.interfaces import IBug
    >>> def on_created_event(object, event):
    ...     print "SQLObjectCreatedEvent: %r" % object
    >>> on_created_listener = TestEventListener(
    ...     IBug, ISQLObjectCreatedEvent, on_created_event)

1. Filing a bug on a distribution.

The distribution filebug page will always attach a bugtask to a
sourcepackage, if the user provides a valid name of a specific package
when reporting the bug.

If the package name entered by the user happens to be a binary package
name, that information is recorded in the description, and the first
comment, of the bug report.

    >>> from zope.component import getView, getUtility
    >>> from canonical.launchpad.interfaces import (
    ...     IBugTaskSet, IBugSet, IDistributionSet, BugTaskSearchParams,
    ...     IProductSet, ILaunchBag)
    >>> from canonical.launchpad.webapp.servers import LaunchpadTestRequest

    >>> login("foo.bar@canonical.com")

    >>> ubuntu = getUtility(IDistributionSet).getByName("ubuntu")
    >>> request = LaunchpadTestRequest(form={
    ...     'field.title': 'bug in bin pkg',
    ...     'field.comment': 'a bug in a bin pkg',
    ...     'packagename_option': 'choose',
    ...     'field.packagename': 'linux-2.6.12',
    ...     'FORM_SUBMIT': 'Submit Bug Report'})

    >>> ubuntu_filebug = getView(ubuntu, "+filebug", request)

    >>> ubuntu_filebug.process_form()
    SQLObjectCreatedEvent: <Bug at ...>

    >>> current_user = getUtility(ILaunchBag).user
    >>> search_params = BugTaskSearchParams(
    ...     searchtext="bin pkg", user=current_user)

    >>> latest_ubuntu_bugtask = ubuntu.searchTasks(
    ...     search_params)[0]

The user specified a binary package name, so that's been added to the
bug description and the first comment:

    >>> print latest_ubuntu_bugtask.bug.description
    Binary package hint: linux-2.6.12
    <BLANKLINE>
    <BLANKLINE>
    a bug in a bin pkg

    >>> print latest_ubuntu_bugtask.bug.messages[0].text_contents
    Binary package hint: linux-2.6.12
    <BLANKLINE>
    <BLANKLINE>
    a bug in a bin pkg

And the source package from which the binary was built has been set on
the bugtask.

    >>> print latest_ubuntu_bugtask.sourcepackagename.name
    linux-source-2.6.15

2. Filing a bug on a product.

    >>> firefox = getUtility(IProductSet).getByName("firefox")
    >>> request = LaunchpadTestRequest(form={
    ...     'field.title': 'a firefox bug',
    ...     'field.comment': 'a test bug',
    ...     'FORM_SUBMIT': 'Submit Bug Report'})

    >>> firefox_filebug = getView(firefox, "+filebug", request)

    >>> firefox_filebug.process_form()
    SQLObjectCreatedEvent: <Bug at ...>

3. Filing a bug on a distribution source package.

    >>> ubuntu_firefox = ubuntu.getSourcePackage("mozilla-firefox")

    >>> request = LaunchpadTestRequest(form={
    ...     'field.title': 'a firefox bug',
    ...     'field.comment': 'a test bug',
    ...     'FORM_SUBMIT': 'Submit Bug Report'})

    >>> ubuntu_firefox_filebug = getView(
    ...     ubuntu_firefox, "+filebug", request)

    >>> ubuntu_firefox_filebug.process_form()
    SQLObjectCreatedEvent: <Bug at ...>

(Unregister the listener, since we no longer need it.)

    >>> on_created_listener.unregister()

Bug Portlets
============

Duplicates Portlet
------------------

The duplicate bugs portlet lists duplicates of the current bug. If the
duplicate bug affects the current context, the link to the dupe will
remain in the current context. If the dupe has not been reported in
the current context, the dupe link will be to the generic
/bugs/$bug.id redirect link.

    >>> bugset = getUtility(IBugSet)
    >>> bugtaskset = getUtility(IBugTaskSet)
    >>> request = LaunchpadTestRequest()

Bug 6 is a duplicate of bug 5, and since both bugs affect Firefox, the
duplicate link remains in the current context.

    >>> bug_five_in_firefox = bugtaskset.get(14)

    >>> print bug_five_in_firefox.bug.id
    5
    >>> print bug_five_in_firefox.product.name
    firefox


    >>> bug_page_view = getView(
    ...     bug_five_in_firefox, "+portlet-duplicates", request)

    >>> bug_six = bugset.get(6)

    >>> from canonical.launchpad.interfaces import IOpenLaunchBag

    >>> getUtility(IOpenLaunchBag).add(bug_five_in_firefox)

    >>> print bug_page_view.getDupeBugLink(bug_six)
    http://.../products/firefox/+bug/6

Bug 2 is not reported in Firefox. Let's mark bug 2 as a dupe of bug 5,
and see how the returned link changes.

    >>> bug_two = bugset.get(2)
    >>> bug_two.duplicateof = 5

    >>> bug_page_view = getView(
    ...     bug_five_in_firefox, "+portlet-duplicates", request)

    >>> print bug_page_view.getDupeBugLink(bug_two)
    http://.../bugs/2

Bug Naviation
-------------

The +subscribe link has different text depending on if the user is
subscribe to the bug, or if a team is subscribed to it.

If the user isn't subscribed to the bug and neither of his teams are
subscribed to it, 'Subscribe' is shown.

    >>> login("foo.bar@canonical.com")
    >>> from canonical.launchpad.interfaces import IPersonSet
    >>> foo_bar = getUtility(IPersonSet).getByEmail('foo.bar@canonical.com')
    >>> bug_one = getUtility(IBugSet).get(1)
    >>> bug_one.isSubscribed(foo_bar)
    False
    >>> for team in foo_bar.teams_participated_in:
    ...     if bug_one.isSubscribed(team):
    ...         print "%s is subsribed to the bug" % team.displayname
    ...         break
    ... else:
    ...     print "No teams are subscribed to the bug."
    No teams are subscribed to the bug.

    >>> from canonical.launchpad.browser import BugContextMenu
    >>> bug_one_bugtask = bug_one.bugtasks[0]
    >>> getUtility(IOpenLaunchBag).clear()
    >>> getUtility(IOpenLaunchBag).add(bug_one_bugtask)
    >>> bug_menu = BugContextMenu(bug_one_bugtask)
    >>> bug_menu.subscription().text
    'Subscribe'

    >>> bug_menu.subscription().icon
    'add'

If we subscribe Foo Bar, 'Unsubscribe' is shown.

    >>> bug_one.subscribe(foo_bar)
    <BugSubscription at ...>
    >>> bug_menu = BugContextMenu(bug_one_bugtask)
    >>> bug_menu.subscription().text
    'Unsubscribe'

    >>> bug_menu.subscription().icon
    'remove'

If we subscribe one of the teams that Foo Bar is a member of, it will
still say 'Unsubscribe':

    >>> launchpad_team = getUtility(IPersonSet).getByName('launchpad')
    >>> foo_bar.inTeam(launchpad_team)
    True
    >>> bug_one.subscribe(launchpad_team)
    <BugSubscription at ...>
    >>> bug_menu = BugContextMenu(bug_one_bugtask)
    >>> bug_menu.subscription().text
    'Unsubscribe'

    >>> bug_menu.subscription().icon
    'remove'

However, if we now unsubscribe Foo Bar, but leaving the Launchpad team
subscribed, it will say 'Subscribe/Unsubscribe' since he will have the
option of either subscribe himself or unsubscribe the Launchpad team.

    >>> bug_one.unsubscribe(foo_bar)

    >>> bug_menu = BugContextMenu(bug_one_bugtask)
    >>> bug_menu.subscription().text
    'Subscribe/Unsubscribe'

    >>> bug_menu.subscription().icon
    'edit'

He will have the possibility to unsubscribe only the team that he's a
member of, so if we unsubscribe the Launchpad team and subscribe some
other team, it will say only 'Subscribe'.

    >>> shipit_team = getUtility(IPersonSet).getByName('shipit-admins')
    >>> foo_bar.inTeam(shipit_team)
    False
    >>> bug_one.unsubscribe(launchpad_team)
    >>> bug_one.subscribe(shipit_team)
    <BugSubscription at ...>

    >>> bug_menu = BugContextMenu(bug_one_bugtask)
    >>> bug_menu.subscription().text
    'Subscribe'

    >>> bug_menu.subscription().icon
    'add'

If the user is logged out, it also says 'Subscribe/Unsubscribe', since
we can't know if the user is subscribed or not.

    >>> login(ANONYMOUS)
    >>> bug_menu = BugContextMenu(bug_one_bugtask)
    >>> bug_menu.subscription().text
    'Subscribe/Unsubscribe'

    >>> bug_menu.subscription().icon
    'edit'

Bug Edit Page
=============

The bug edit page is used to edit the summary, description, nick name,
and bug tags. If the user try to add a tag that hasn't been used in the
current context, we display a confirmation button, which shouldn't be
automatically rendered by the form template. In order to show how it
works, let's override the edit page, making it a bit shorter, and
initialize the test harness.

    >>> from canonical.launchpad.browser import BugEditView
    >>> class BugEditViewTest(BugEditView):
    ...     def edit_page(self):
    ...         print 'EDIT BUG'

    >>> firefox_task = bug_one.bugtasks[0]
    >>> firefox_task.targetname
    u'firefox (upstream)'
    >>> from canonical.launchpad.ftests import LaunchpadFormHarness
    >>> bug_edit = LaunchpadFormHarness(firefox_task, BugEditViewTest)

Initially, the normal edit page is shown, with a single button.

    >>> bug_edit.view.render()
    EDIT BUG
    >>> [action.label for action in bug_edit.view.actions]
    ['Change']

If we fill in some values and submit the action, the view will redirect
and the bug will have been edited.

    >>> login('test@canonical.com')
    >>> edit_values = {
    ...     'field.title': u'New title',
    ...     'field.description': u'New description.',
    ...     'field.name': u'new-nickname',
    ...     'field.tags': u'doc'}

    >>> bug_edit.submit('change', edit_values)
    >>> bug_edit.hasErrors()
    False
    >>> bug_edit.wasRedirected()
    True

    >>> bug_one.title
    u'New title'
    >>> bug_one.description
    u'New description.'
    >>> bug_one.name
    u'new-nickname'
    >>> bug_one.tags
    [u'doc']


The tag 'doc' has already been used for other Firefox bugs, let's try
adding a tag that hasn't already been used.

    >>> edit_values['field.tags'] = u'doc new-tag'
    >>> bug_edit.submit('change', edit_values)

Now the form will have a notification, asking us to confirm that we indeed
want to use a new tag. The notification includes a button, with which
the user can confirm that he wants to add the tag.

    >>> bug_edit.hasErrors()
    False
    >>> for message in bug_edit.view.notifications:
    ...     print message
    The tag "new-tag" hasn't yet been used by firefox (upstream) before.
    Is this a new tag?...<input ...Yes, define new tag...>

    >>> bug_edit.wasRedirected()
    False

The form still contains the 'Change' button, though, so that the user
can edit the tag and submit the form again.

    >>> bug_edit.view.render()
    EDIT BUG
    >>> [action.label for action in bug_edit.view.actions]
    ['Change']

If we click on the 'Yes, define new tag' button, we'll get redirected to
the bug page, and the bug will have the new tag.

    >>> bug_edit.submit('confirm_tag', edit_values)
    >>> bug_edit.hasErrors()
    False
    >>> bug_edit.wasRedirected()
    True

    >>> bug_one.tags
    [u'doc', u'new-tag']
