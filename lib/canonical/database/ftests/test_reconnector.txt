
This test demonstrates the reconnecting wrapper.  Compare and contrast to
test_disconnection.txt.

Make a TCP proxy to postgres.

    >>> import os
    >>> from canonical.ftests.pgsql import PgTestSetup
    >>> from canonical.database.ftests import PortForwardTestSetup
    >>> portforward = PortForwardTestSetup()
    >>> portforward.setUp()

Install the reconnector.

    >>> from canonical.database import reconnect
    >>> reconnect.install()

You can't install the reconnector twice accidentally, though.

    >>> reconnect.install()
    Traceback (most recent call last):
    ...
    AlreadyInstalledError: reconnector already installed
    
Connect to postgres via the proxy.  This will use the reconnector.

    >>> import psycopg
    >>> dsn = 'dbname=%s host=localhost port=5555' % PgTestSetup().dbname
    >>> conn = psycopg.connect(dsn)

Check that the connection is working normally.

    >>> cur = conn.cursor()
    >>> cur.execute("SELECT 1;")
    >>> cur.fetchone()[0]
    1

Genuine (not connection related) errors still work normally, too.

    >>> cur.execute("SELECT garbage invalid sql;")
    Traceback (most recent call last):
    ....
    <BLANKLINE>
    ...
    ProgrammingError: ERROR:  syntax error at or near "invalid"
    LINE 1: SELECT garbage invalid sql;
                           ^
    <BLANKLINE>
    SELECT garbage invalid sql;

Break the connection by stopping the proxy.

    >>> portforward.tearDown()

Executing a query now blocks until the database connection can be
reestablished.

    >>> import threading
    >>> thread_result = []
    >>> before_select = threading.Event()
    >>> def foo():
    ...     before_select.set()
    ...     cur.execute('SELECT 1;')
    ...     thread_result.append(cur.fetchone()[0])

Create the thread, and make sure it has started running:

    >>> thread = threading.Thread(target=foo)
    >>> thread.start()
    >>> before_select.wait()

Execution does not complete because the database
can't be reached:

    >>> thread.join(1)
    >>> thread.isAlive()
    True

# TODO: test that the disconnection is logged -- spiv

Restart the proxy:

    >>> portforward.setUp()

Now, our blocked thread should've finished successfully.

    >>> thread.join()
    >>> thread.isAlive()
    False
    >>> thread_result
    [1]

Also, using our connection should still work.

    >>> cur.execute("SELECT 1;")
    >>> cur.fetchone()[0]
    1


XXX: Test that interrupting a transaction still fails -- spiv

Clean up the proxy.

    >>> portforward.tearDown()
    >>> os.remove(portforward.logfile)

Close our connection

    >>> conn.close()

Uninstall the reconnector.

    >>> reconnect.uninstall()

