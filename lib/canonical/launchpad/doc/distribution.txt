Distributions
=============

From the DerivationOverview spec[1]:

    A distribution of GNU/Linux comprises a set of packages, an installer,
    possibly a live-CD, some amount of metadata associated with the arrangement
    of those elements and also a lot of information on managing it.

In Launchpad, one distribution is mapped to one row in the Distribution table.
To retrieve a distribution, use the IDistributionSet utility. If you've already
used IPersonSet to retrieve a Person, or IBugTaskSet to retrieve a task, this
syntax should look familiar.

The IDistributionSet utility is accessed in the usual fashion:

    >>> from zope.component import getUtility
    >>> from canonical.launchpad.interfaces import (
    ...     IDistributionSet, IPersonSet, ICountrySet, IDistroReleaseSet,
    ...     IDistroArchReleaseSet)
    >>> from canonical.lp.dbschema import (
    ...     PackagePublishingPocket, MirrorSpeed, MirrorContent,
    ...     MirrorPulseType)
    >>> distroset = getUtility(IDistributionSet)

To retrieve a specific distribution, use IDistributionSet.get:

    >>> ubuntu = distroset.get(1)
    >>> print ubuntu.name
    ubuntu

Or, to grab one by name, use:

    >>> gentoo = distroset.getByName("gentoo")

Once you've got a distribution, you can retrieve a source package if you
have a SourcePackageName object for it.

    >>> from canonical.launchpad.database.sourcepackagename import (
    ...                                          SourcePackageName)
    >>> from canonical.launchpad.interfaces import (
    ...     IDistributionSourcePackage,
    ...     IDistributionSourcePackageRelease)

    >>> evo = SourcePackageName.byName("evolution")
    >>> evo_ubuntu = ubuntu.getSourcePackage(evo)
    >>> print evo_ubuntu.name
    evolution

    >>> IDistributionSourcePackage.providedBy(evo_ubuntu)
    True

    >>> from canonical.launchpad.database.sourcepackagerelease import (
    ...                                           SourcePackageRelease)
    >>> sourcepackagerelease = SourcePackageRelease.selectOneBy(
    ...     sourcepackagenameID=evo.id, version='1.0')
    >>> sourcepackagerelease.name
    u'evolution'

    >>> evo_ubuntu_rel = ubuntu.getSourcePackageRelease(
    ...                    sourcepackagerelease)
    >>> IDistributionSourcePackageRelease.providedBy(evo_ubuntu_rel)
    True

You can also get a release by name:

    >>> hoary = ubuntu.getRelease("hoary")
    >>> print hoary.name
    hoary

Or by version:

    >>> v504 = ubuntu.getRelease("5.04")
    >>> print v504.name
    hoary

You can list development distroreleases:

    >>> devdists = ubuntu.getDevelopmentReleases()
    >>> for devdist in devdists:
    ...     print devdist.name
    hoary

Retrieving packages by name, returns a tuple of
Source/BinaryPackageName instancefound within this distribution:

    >>> from canonical.launchpad.interfaces import (
    ...     ISourcePackageName, IBinaryPackageName)
    >>> source_name, bin_name = ubuntu.getPackageNames('pmount')
    >>> ISourcePackageName.providedBy(source_name)
    True
    >>> IBinaryPackageName.providedBy(bin_name)
    True
    >>> source_name.name, bin_name.name
    (u'pmount', u'pmount')

Prevents wrong usage by and assertion error:

    >>> name_tuple = ubuntu.getPackageNames(ubuntu)
    Traceback (most recent call last):
    ...
    AssertionError: Only ever call this with a string

Raises NotFoundError for following conditions:

    >>> name_tuple = ubuntu.getPackageNames('@#$')
    Traceback (most recent call last):
    ...
    NotFoundError: 'Invalid package name: @#$'

    >>> name_tuple = ubuntu.getPackageNames('zeca')
    Traceback (most recent call last):
    ...
    NotFoundError: 'Unknown package: zeca'

    >>> name_tuple = ubuntu.getPackageNames('1234')
    Traceback (most recent call last):
    ...
    NotFoundError: 'Unknown package: 1234'

It also raises NotFoundError on distributions with no releases:

    >>> source_name, bin_name = gentoo.getPackageNames('pmount')
    Traceback (most recent call last):
    ...
    NotFoundError: "Distribution has no releases; 'pmount' was never published in it"


Searching for DistributionSourcePackages
----------------------------------------

The distribution also allows you to look for source packages that match
a certain string through the magic of fti. For instance:

    >>> packages = ubuntu.searchSourcePackages("mozilla")
    >>> print len(packages)
    1

The search also matches on exact package names which fti doesn't like,
and even on substrings:

    >>> packages = ubuntu.searchSourcePackages("linux-source-2.6.15")
    >>> print len(packages)
    1
    >>> packages = ubuntu.searchSourcePackages("nux-sour")
    >>> print len(packages)
    1


CVE BugTasks on a Distribution
------------------------------

A distribution should know what CVE-related bug tasks exist on it, and what
state they are in. We should be able to find open, and closed, bugtasks,
using this API. Based on the sample data we know the following about Ubuntu:

    >>> tasks = ubuntu.open_cve_bugtasks
    >>> for task in tasks:
    ...     print task.id
    17
    26

There should be NO resolved CVE tasks:

    >>> tasks = ubuntu.resolved_cve_bugtasks
    >>> print tasks.count()
    0

[1] https://wiki.launchpad.canonical.com/DerivationOverview


Finding distroreleases and pockets from distribution names
----------------------------------------------------------

A distribution knows what distroreleases it has. Those distroreleases have
pockets which have suffixes used by the archive publisher. Because we sometimes
need to talk about distroreleases such as ubuntu/hoary-security we need some
way to decompose that into the distrorelease and the pocket. Distribution
can do that for us.

If we ask for a totally unknown distrorelease, we raise NotFoundError
    >>> ubuntu.getDistroReleaseAndPocket('unknown')
    Traceback (most recent call last):
    ...
    NotFoundError: 'unknown'

If we ask for a plain distrorelease, it should come back with the RELEASE
pocket as the pocket.
    >>> dr, pocket = ubuntu.getDistroReleaseAndPocket('hoary')
    >>> print dr.name
    hoary
    >>> print pocket.name
    RELEASE

If we ask for a security pocket in a known distrorelease it should come out
on the other side.
    >>> dr, pocket = ubuntu.getDistroReleaseAndPocket('hoary-security')
    >>> print dr.name
    hoary
    >>> print pocket.name
    SECURITY

Find the backports pocket, too:
    >>> dr, pocket = ubuntu.getDistroReleaseAndPocket('hoary-backports')
    >>> print dr.name
    hoary
    >>> print pocket.name
    BACKPORTS

If we ask for a valid distrorelease which doesn't have a given pocket it should
raise NotFoundError for us
    >>> ubuntu.getDistroReleaseAndPocket('hoary-bullshit')
    Traceback (most recent call last):
    ...
    NotFoundError: 'hoary-bullshit'



Upload related stuff
--------------------

When uploading to a distribution we need to query its uploaders. Each
uploader record is in fact a DistroComponentUploader record which
tells us what component is uploadable to by what person or group of
people.

   >>> for dcu in ubuntu.uploaders:
   ...     assert dcu.distribution == ubuntu
   ...     print dcu.component.name
   ...     print dcu.uploader.displayname
   main
   Ubuntu Team
   restricted
   Ubuntu Team
   universe
   Ubuntu Team

When processing an upload we may want to find a file (E.g. if an
incomplete source is uploaded).

    >>> ubuntu.getFileByName('firefox-0.9.2.tar.gz').url
    'http://localhost:58000/3/firefox-0.9.2.tar.gz'
    >>> ubuntu.getFileByName('firefox-0.9.2.tar.gz', source=False).url
    'http://localhost:58000/3/firefox-0.9.2.tar.gz'
    >>> ubuntu.getFileByName('firefox-0.9.2.tar.gz', binary=False).url
    Traceback (most recent call last):
    ...
    NotFoundError: 'firefox-0.9.2.tar.gz'
    >>> ubuntu.getFileByName('', source=False, binary=False)
    Traceback (most recent call last):
    ...
    AssertionError: searching in an explicitly empty space is pointless


Launchpad Usage
---------------

A distribution can specify if it uses Malone or Rosetta officially.
Ubuntu uses both Malone and Rosetta:

    >>> from canonical.launchpad.interfaces import ILaunchpadCelebrities
    >>> ubuntu = getUtility(ILaunchpadCelebrities).ubuntu
    >>> ubuntu.official_malone
    True
    >>> ubuntu.official_rosetta
    True

While Debian uses neither:

    >>> debian = getUtility(ILaunchpadCelebrities).debian
    >>> debian.official_malone
    False
    >>> debian.official_rosetta
    False

Gentoo only uses Malone

    >>> print gentoo.official_malone
    True
    >>> print gentoo.official_rosetta
    False



