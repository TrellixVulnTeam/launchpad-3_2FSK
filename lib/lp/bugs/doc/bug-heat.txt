Calculating bug heat
====================

Launchpad bugs each have a 'heat' rating. This is an indicator of how
problematic a given bug is to the community and can be used to determine
which bugs should be tackled first.

A new bug will have a heat of zero.

    >>> bug_owner = factory.makePerson()
    >>> bug = factory.makeBug(owner=bug_owner)
    >>> bug.heat
    0

It will also have a heat_last_updated of None.

    >>> print bug.heat_last_updated
    None

The bug's heat can be set by calling its setHeat() method.

    >>> bug.setHeat(42)
    >>> bug.heat
    42

Its heat_last_updated will also have been set.

    >>> bug.heat_last_updated
    datetime.datetime(..., tzinfo=<UTC>)


Getting bugs whose heat is outdated
-----------------------------------

It's possible to get the set of bugs whose heat hasn't been updated for
a given amount of time by calling IBugSet's getBugsWithOutdatedHeat()
method.

First, we'll set the heat of all bugs so that none of them are out of
date.

    >>> from lp.bugs.interfaces.bug import IBugSet
    >>> for bug in getUtility(IBugSet).dangerousGetAllBugs():
    ...     bug.setHeat(0)

If we call getBugsWithOutdatedHeat() now, the set that is returned will
be empty because all the bugs have been recently updated.
getBugsWithOutdatedHeat() takes a single parameter, max_heat_age, which
is the maximum age, in days, that a bug's heat can be before it gets
included in the returned set.

    >>> getUtility(IBugSet).getBugsWithOutdatedHeat(1).count()
    0

IBug.setHeat() takes a timestamp parameter so that we can set the
heat_last_updated date manually for the purposes of testing. If we make
a bug's heat older than the max_heat_age that we pass to
getBugsWithOutdatedHeat() it will appear in the set returned by
getBugsWithOutdatedHeat().

    >>> from datetime import datetime, timedelta
    >>> from pytz import timezone
    >>> old_heat_bug = factory.makeBug()
    >>> old_heat_bug.setHeat(
    ...     0, datetime.now(timezone('UTC')) - timedelta(days=2))

    >>> outdated_bugs = getUtility(IBugSet).getBugsWithOutdatedHeat(1)
    >>> outdated_bugs.count()
    1

    >>> outdated_bugs[0] == old_heat_bug
    True

getBugsWithOutdatedHeat() also returns bugs whose heat has never been
updated.

    >>> new_bug = factory.makeBug()
    >>> outdated_bugs = getUtility(IBugSet).getBugsWithOutdatedHeat(1)
    >>> outdated_bugs.count()
    2

    >>> new_bug in outdated_bugs
    True


The BugHeatUpdater class
---------------------------

In order to calculate bug heat we need to use the BugHeatUpdater
class, which is designed precisely for that task. It's part of the garbo
module and runs as part of the garbo-daily cronjob.

    >>> from canonical.launchpad.scripts.garbo import BugHeatUpdater
    >>> from canonical.launchpad.scripts import FakeLogger

    >>> update_bug_heat = BugHeatUpdater(FakeLogger(), max_heat_age=1)

BugHeatUpdater implements ITunableLoop and as such is callable. Calling
it as a method will update the heat for all the bugs whose heat is more
than seven days old.

Before update_bug_heat is called, new_bug and old_heat_bug will have no
heat.

    >>> old_heat_bug.heat
    0

    >>> new_bug.heat
    0

We need to flush the store to ensure that the bugs we've created are
available to the update_bug_heat script.

    >>> import transaction
    >>> transaction.commit()

    >>> getUtility(IBugSet).getBugsWithOutdatedHeat(1).count()
    2

We need to run update_bug_heat() twice to ensure that both the bugs are
updated.

    >>> update_bug_heat(chunk_size=2)
    DEBUG Updating 1 Bugs (starting id: ...

The bugs' heat will now be greater than 0

    >>> old_heat_bug = getUtility(IBugSet).get(old_heat_bug.id)
    >>> old_heat_bug.heat > 0
    True

    >>> new_bug = getUtility(IBugSet).get(new_bug.id)
    >>> new_bug.heat > 0
    True

IBugSet.getBugsWithOutdatedHeat() will now return an empty set since all
the bugs have been updated.

    >>> getUtility(IBugSet).getBugsWithOutdatedHeat(1).count()
    0


Caculating the maximum heat for a target
----------------------------------------

When we update the heat value for a bug, the maximum heat value for the targets
for all of its tasks is calculated and cached.

    >>> product = factory.makeProduct()
    >>> bug = factory.makeBug(product=product)
    >>> print product.max_bug_heat
    None
    >>> bug.setHeat(123)
    >>> print product.max_bug_heat
    123

The maximum heat for a project is the value for tasks on all its products.

    >>> project = factory.makeProject()
    >>> product.project = project
    >>> bug.setHeat(123)
    >>> print project.max_bug_heat
    123

A DistributionSourcePackage has its own maximum heat.

    >>> dsp = factory.makeDistributionSourcePackage()
    >>> dsp_task = bug.addTask(bug.owner, dsp)
    >>> print dsp.max_bug_heat
    123

Transitioning from one target to another, calculates the value for the new
target.

    >>> another_product = factory.makeProduct()
    >>> bug.bugtasks[0].transitionToTarget(another_product)
    >>> print another_product.max_bug_heat
    123

ProductSeries and DistroSeries simply delegate to their corresponding Product
or Distribution.

    >>> product_series = factory.makeProductSeries()
    >>> ps_task = bug.addTask(bug.owner, product_series)
    >>> print product_series.max_bug_heat
    123
    >>> print product_series.product.max_bug_heat
    123

    >>> distro_series = factory.makeDistroSeries()
    >>> ds_task = bug.addTask(bug.owner, distro_series)
    >>> print distro_series.max_bug_heat
    123
    >>> print distro_series.distribution.max_bug_heat
    123

Maximum heat is limited to bugs of a specific target.

    >>> product = factory.makeProduct()
    >>> product_bug = factory.makeBug(product=product)
    >>> product_bug.setHeat(123)
    >>> distro = factory.makeDistribution()
    >>> distro_bug = factory.makeBug()
    >>> distro_task = distro_bug.addTask(bug.owner, distro)
    >>> distro_bug.setHeat(456)
    >>> print product.max_bug_heat
    123
    >>> print distro.max_bug_heat
    456


