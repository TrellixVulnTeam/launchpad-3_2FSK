== Import Script ==

The imports are performed by a dedicated cron script.

A template and two pofile will be imported.

    >>> potemplate_header = r"""
    ... msgid ""
    ... msgstr ""
    ... "POT-Creation-Date: 2004-07-11 16:16+0900\n"
    ... "Content-Type: text/plain; charset=CHARSET\n"
    ... "Plural-Forms: nplurals=INTEGER; plural=EXPRESSION;\n"
    ...
    ... """

    >>> pofile_header = r"""
    ... msgid ""
    ... msgstr ""
    ... "PO-Revision-Date: 2005-06-03 20:41+0100\n"
    ... "Last-Translator: Foo <no-priv@canonical.com>\n"
    ... "Content-Type: text/plain; charset=UTF-8\n"
    ... "Plural-Forms: nplurals=2; plural=(n!=1);\n"
    ...
    ... """

    >>> po_content = r"""
    ... #: test.c:13
    ... msgid "baz"
    ... msgstr "%s"
    ...
    ... #, c-format
    ... msgid "Foo %%s"
    ... msgstr "%s"
    ...
    ... #, c-format
    ... msgid "Singular %%d"
    ... msgid_plural "Plural %%d"
    ... msgstr[0] "%s"
    ... msgstr[1] "%s"
    ...
    ... msgid "translator-credits"
    ... msgstr "%s"
    ... """

    >>> potemplate_content = potemplate_header + po_content % (('',) * 5) 
    >>> pofile_eo_content = pofile_header + po_content % (
    ...     "baz eo", "Foo eo %s", "Singular eo %s", "Plural eo %s",
    ...     "helpful-eo@example.com")
    >>> pofile_nl_content = pofile_header + po_content % (
    ...     "baz nl", "Foo nl %s", "Singular nl %s", "Plural nl %s",
    ...     "helpful-nl@example.com")
    >>> print pofile_eo_content

There is annoying sample data in the queue that needs to be removed.

    >>> from lp.translations.interfaces.translationimportqueue import (
    ...     ITranslationImportQueue, RosettaImportStatus)
    >>> queue = getUtility(ITranslationImportQueue)
    >>> for entry in queue:
    ...     queue.remove(entry)


The files have been uploaded to the queue for a source package and have
already been approved.

    >>> distroseries = factory.makeUbuntuDistroSeries()
    >>> sourcepackagename = factory.makeSourcePackageName()
    >>> potemplate = factory.makePOTemplate(
    ...     distroseries=distroseries, sourcepackagename=sourcepackagename)
    >>> pofile_eo = potemplate.newPOFile('eo')
    >>> pofile_nl = potemplate.newPOFile('nl')
    
    >>> from canonical.launchpad.interfaces.launchpad import (
    ...     ILaunchpadCelebrities)
    >>> rosetta_experts = getUtility(ILaunchpadCelebrities).rosetta_experts
    
    >>> template_entry = queue.addOrUpdateEntry(
    ...     potemplate.path, potemplate_content, True, potemplate.owner,
    ...     distroseries=distroseries, sourcepackagename=sourcepackagename,
    ...     potemplate=potemplate)
    >>> pofile_eo_entry = queue.addOrUpdateEntry(
    ...     'eo.po', pofile_eo_content, True, potemplate.owner,
    ...     distroseries=distroseries, sourcepackagename=sourcepackagename,
    ...     potemplate=potemplate, pofile=pofile_eo)
    >>> pofile_nl_entry = queue.addOrUpdateEntry(
    ...     'nl.po', pofile_nl_content, True, potemplate.owner,
    ...     distroseries=distroseries, sourcepackagename=sourcepackagename,
    ...     potemplate=potemplate, pofile=pofile_nl)

    >>> print "the distroseries %r" % distroseries
    >>> print "the sourcepackagename %r" % sourcepackagename
    >>> for entry in queue:
    ...     print "potemplate:        %r" % entry.potemplate
    ...     print "pofile:            %r" % entry.pofile
    ...     print "path:              '%s'" % entry.path
    ...     print "productseries:     %r" % entry.productseries
    ...     print "distroseries:      %r" % entry.distroseries
    ...     print "sourcepackagename: %r" % entry.sourcepackagename
    ...     print "status:            %r" % entry.status
    ...     print "---------"
    >>> for entry in queue:
    ...     entry.setStatus(RosettaImportStatus.APPROVED, rosetta_experts)
    >>> transaction.commit()
    >>> for entry in queue:
    ...     print "potemplate:        %r" % entry.potemplate
    ...     print "pofile:            %r" % entry.pofile
    ...     print "path:              '%s'" % entry.path
    ...     print "productseries:     %r" % entry.productseries
    ...     print "distroseries:      %r" % entry.distroseries
    ...     print "sourcepackagename: %r" % entry.sourcepackagename
    ...     print "status:            %r" % entry.status
    ...     print "---------"

The import script can do its work.

    >>> from canonical.launchpad.scripts import FakeLogger
    >>> from lp.translations.scripts.po_import import TranslationsImport
    >>> from lp.translations.scripts.import_queue_gardener import (
    ...     ImportQueueGardener)
    >>> import email
    >>> from lp.services.mail import stub
    >>> process = TranslationsImport('poimport', test_args=[])
    >>> process.logger = FakeLogger()
    >>> process.main()
    DEBUG   Starting the import process.
    INFO    Importing: Template ...
    INFO    Importing: Esperanto (eo) ... of ...
    INFO    Importing: Dutch (nl) ... of ...
    INFO    Import requests completed.
    DEBUG   Finished the import process.

The import script also generates an email similar to the ones we saw
composed before, but also sends it.

    >>> len(stub.test_emails)
    1

    >>> from_addr, to_addrs, raw_message = stub.test_emails.pop()
    >>> msg = email.message_from_string(raw_message)
    >>> print msg["Subject"]
    Translation template import - ...

    >>> print msg.get_payload(decode=True)
    Hello Mark Shuttleworth,
    <BLANKLINE>
    On ..., you uploaded a translation
    template for ... in Launchpad.
    <BLANKLINE>
    The template has now been imported successfully.
    <BLANKLINE>
    Thank you,
    <BLANKLINE>
    The Launchpad team

Now the queue gardener runs. This can happen anytime, since it's
asynchronous to the po-import script. The script tries to approve any
entries that have not been approved, but look like they could be,
without human intervention. This involves a bit of guesswork about what
the imported file is and where it belongs. It similarly blocks entries
that it thinks should be blocked, and also purges deleted or completed
entries from the queue. Running at this point, all it does is purge the
two hand-approved Welsh translations that have just been imported.

    >>> import logging
    >>> from lp.testing.logger import MockLogger
    >>> process = ImportQueueGardener('approver', test_args=[])
    >>> process.logger = MockLogger()
    >>> process.logger.setLevel(logging.INFO)
    >>> process.main()
    log>    Removed 2 entries from the queue.
    >>> transaction.commit()

If users upload two versions of the same file, they are imported in the
order in which they were uploaded.

    >>> first_pofile_content = r'''
    ... msgid ""
    ... msgstr ""
    ... "PO-Revision-Date: 2005-06-04 20:41+0100\n"
    ... "Last-Translator: Foo <no-priv@canonical.com>\n"
    ... "Content-Type: text/plain; charset=UTF-8\n"
    ... "X-Rosetta-Export-Date: %s\n"
    ...
    ... msgid "Foo %%s"
    ... msgstr "Bar"
    ...
    ... msgid "translator-credits"
    ... msgstr "The world will never know."
    ... ''' % datetime.datetime.now(UTC).isoformat()

    >>> second_pofile_content = r'''
    ... msgid ""
    ... msgstr ""
    ... "PO-Revision-Date: 2005-06-04 21:41+0100\n"
    ... "Last-Translator: Jordi Mallach <jordi@canonical.com>\n"
    ... "Content-Type: text/plain; charset=UTF-8\n"
    ... "X-Rosetta-Export-Date: %s\n"
    ...
    ... msgid "Foo %%s"
    ... msgstr "Bars"
    ...
    ... msgid "translator-credits"
    ... msgstr "I'd like to thank John, Kathy, my pot plants, and all the..."
    ... ''' % datetime.datetime.now(UTC).isoformat()

We flush the entry contents.

    >>> for entry in translation_import_queue:
    ...     translation_import_queue.remove(entry)
    >>> translation_import_queue.countEntries()
    0

Attach the first version of the file.

    >>> entry = translation_import_queue.addOrUpdateEntry(
    ...     pofile.path, first_pofile_content, False, rosetta_experts,
    ...     sourcepackagename=pofile.potemplate.sourcepackagename,
    ...     distroseries=pofile.potemplate.distroseries,
    ...     productseries=pofile.potemplate.productseries)
    >>> transaction.commit()

It's in the queue now.

    >>> translation_import_queue.countEntries()
    1

For the second version, we need a new importer, in this case, Jordi.

    >>> jordi = person_set.getByName('jordi')

Attach the second version of the file.

    >>> entry = translation_import_queue.addOrUpdateEntry(
    ...     pofile.path, second_pofile_content, False, jordi,
    ...     sourcepackagename=pofile.potemplate.sourcepackagename,
    ...     distroseries=pofile.potemplate.distroseries,
    ...     productseries=pofile.potemplate.productseries)
    >>> transaction.commit()

It's in the queue now.

    >>> translation_import_queue.countEntries()
    2
    >>> print entry.status.name
    NEEDS_REVIEW

The queue gardener runs again. This time it sees the two submitted
translations and approves them for import based on some heuristic
intelligence.

    >>> process = ImportQueueGardener('approver', test_args=[])
    >>> process.logger = MockLogger()
    >>> process.logger.setLevel(logging.INFO)
    >>> process.main()
    log>    The automatic approval system approved some entries.
    >>> print entry.status.name
    APPROVED
    >>> syncUpdate(entry)

Now that these submissions have been approved, the next run of the
import script picks them up and processes them.

    >>> process = TranslationsImport('poimport', test_args=[])
    >>> process.logger = FakeLogger()
    >>> process.main()
    DEBUG   Starting the import process.
    INFO    Importing: Welsh (cy) ... of firefox in Mozilla Firefox trunk
    INFO    Importing: Welsh (cy) ... of firefox in Mozilla Firefox trunk
    INFO    Import requests completed.
    DEBUG   Finished the import process.

    >>> print entry.status.name
    IMPORTED
    >>> syncUpdate(entry)

And there are no more entries to import

    >>> translation_import_queue.getFirstEntryToImport() is None
    True

We've imported a new translation for "Foo %s."

    >>> welsh = getUtility(ILanguageSet).getLanguageByCode('cy')
    >>> foos = potemplate['Foo %s'].getLocalTranslationMessages(
    ...     potemplate, welsh)
    >>> sorted([foo.msgstr0.translation for foo in foos])
    [u'Bar', u'Bars', u'blah %i']

Since this last upload was not the upstream one, however, its credits
message translations were ignored.

    >>> message = get_pofile_translation_message(
    ...     pofile, u'translator-credits')
    >>> message.msgstr0.translation
    u'helpful@example.com'
    >>> list(potemplate['translator-credits'].getLocalTranslationMessages(
    ...     potemplate, welsh))
    []

Imports so far have been associated with a product series. We can also
submit translations for a distroseries.

    >>> from lp.registry.interfaces.distribution import (
    ...     IDistributionSet)
    >>> ubuntu = getUtility(IDistributionSet).getByName('ubuntu')
    >>> warty = ubuntu.getSeries('warty')
    >>> print warty.name
    warty
    >>> firefox_name = SourcePackageName.byName('mozilla-firefox')
    >>> subset = POTemplateSubset(sourcepackagename=firefox_name,
    ...     distroseries=warty)
    >>> potemplate = subset.new(
    ...     name='firefox-warty',
    ...     translation_domain='firefox-warty',
    ...     path='po/firefox.pot',
    ...     owner=person)

As it happens, the administrator has blocked imports to warty, e.g.
because an in-database update of its translations has been scheduled
and we don't want interference from queued imports while that happens.
It doesn't really matter whether entries still get auto-approved, but
we can't accept new translation imports just now.

    >>> warty.defer_translation_imports = True
    >>> syncUpdate(warty)

Nevertheless, someone submits an import request for warty, not knowing
or caring that imports are deferred. The entry still gets approved as
normal:

    >>> entry = translation_import_queue.addOrUpdateEntry(
    ...     potemplate.path, potemplate_contents, True, potemplate.owner,
    ...     sourcepackagename=firefox_name, distroseries=warty,
    ...     potemplate=potemplate)
    >>> entry.setStatus(RosettaImportStatus.APPROVED, rosetta_experts)
    >>> syncUpdate(entry)
    >>> transaction.commit()

Since imports for warty are suspended, and the only entry we happen to
have waiting right now is for warty, the queue has no importable
entries for us.

    >>> warty.getFirstEntryToImport() is None
    True

So if we try to import now, nothing happens. Our request remains on the
queue, but doesn't become a candidate for processing until warty
imports are resumed.

    >>> process = TranslationsImport('poimport', test_args=[])
    >>> process.logger = FakeLogger()
    >>> process.main()
    DEBUG Starting the import process.
    INFO No requests pending.

    >>> print entry.status.name
    APPROVED

Once imports are allowed again, the import is done after all.

    >>> warty.defer_translation_imports = False
    >>> syncUpdate(warty)
    >>> (subject, body) = potemplate.importFromQueue(entry, FakeLogger())

    >>> print entry.status.name
    IMPORTED

No Contact Address
------------------

Not every user has a valid email address.  For instance, Kermit the
Hermit has none at the moment.

    >>> from canonical.launchpad.interfaces.emailaddress import (
    ...     EmailAddressStatus)
    >>> from canonical.launchpad.helpers import get_contact_email_addresses
    >>> hermit = factory.makePerson(
    ...     name='hermit', email_address_status=EmailAddressStatus.OLD)

    >>> len(get_contact_email_addresses(hermit))
    0

Kermit uploads a translation, which gets approved.

    >>> pofile = factory.makePOFile('lo')

    >>> entry = translation_import_queue.addOrUpdateEntry(
    ...     'lo.po', 'Invalid content', True, hermit,
    ...     pofile=pofile, potemplate=pofile.potemplate,
    ...     productseries=pofile.potemplate.productseries)
    >>> entry.setStatus(RosettaImportStatus.APPROVED, rosetta_experts)
    >>> transaction.commit()

The import fails.  The importer would like to send Kermit an email about
this, but is unable to.  This is unfortunate, but does not faze the
importer.  It completes normally.

    >>> process = TranslationsImport('poimport', test_args=[])
    >>> process.logger = FakeLogger()
    >>> process.main()
    DEBUG Starting the import process.
    INFO Importing: Lao ...
    INFO Import requests completed.
    DEBUG Finished the import process.

    >>> print entry.status.name
    FAILED
