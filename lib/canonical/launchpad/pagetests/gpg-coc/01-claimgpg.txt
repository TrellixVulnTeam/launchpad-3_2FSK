
This test verifies the basic claim a GPG key workflow.

  >>> import email, re
  >>> from canonical.launchpad.mail import stub
  >>> from canonical.zeca.ftests.harness import ZecaTestSetup

Setup the stub KeyServer

  >>> z = ZecaTestSetup()
  >>> z.setUp()

Start out with a clean page:

  >>> user_browser.open("http://launchpad.dev/people/name12/+editpgpkeys")
  >>> "<title>Sample Person's OpenPGP keys</title>" in user_browser.contents
  True
  >>> "1024D/DFD20543" in user_browser.contents
  False

Claim OpenPGP key:

  >>> key = "A419AE861E88BC9E04B9C26FBA2B9389DFD20543"
  >>> user_browser.getControl(name='fingerprint').value = key
  >>> user_browser.getControl(name='import').click()
  >>> "error message" not in user_browser.contents
  True
  >>> print user_browser.contents
  <BLANKLINE>
  ...
  A message has been sent to <code>test@canonical.com</code>, encrypted
  with the key <code>1024D/DFD20543</code>.
  To confirm the key is yours, decrypt the message and follow the
  link inside.
  ...

Recover token URL..

  >>> from_addr, to_addrs, raw_msg = stub.test_emails.pop()
  >>> msg = email.message_from_string(raw_msg)

..decoding the content, originally encoded in 'base-64' or 'quoted-printable':
  
  >>> cipher_body = msg.get_payload(decode=True)

  >>> from canonical.launchpad.helpers import setupInteraction
  >>> setupInteraction(None)

  >>> from canonical.launchpad.interfaces import IGPGHandler 
  >>> from zope.component import getUtility
  >>> gpghandler = getUtility(IGPGHandler)

Import the secret keys needed for this test:

  >>> from canonical.launchpad.ftests import import_secret_test_key
  >>> import_secret_test_key()

'cipher_body' is a message encrypted with the just-imported
1024D/DFD20543 OpenPGP key, we need to access the current IGpghandler
instance to access this key and decrypt the message.

  >>> body = gpghandler.decryptContent(cipher_body, 'test')

  >>> from zope.security.management import endInteraction
  >>> endInteraction()

Do the usual procedure to extract the token URL
 
  >>> link = re.findall(r'http.*/token/.*', body)[0]
  >>> token = re.sub(r'.*token/', '', link)

Ensure token is ascii to avoid utf-8 mess in URL  

  >>> base_path = '/token/%s' % token.encode('ascii')

Go to the link sent by email, to validate the email address.

  >>> user_browser.open("http://launchpad.dev%s" % base_path)

Get redirected to +validategpg, and confirm token:

  >>> print user_browser.url
  http://launchpad.dev/token/.../+validategpg
  >>> user_browser.getControl(name='VALIDATE').click()

Get redirected to the user's homepage with a greeting:

  >>> user_browser.url
  'http://launchpad.dev/people/name12'
  >>> "The key 1024D/DFD20543 was successfully validated" in user_browser.contents
  True

Certify the key is imported:

  >>> user_browser.open("http://launchpad.dev/people/name12/+editpgpkeys")

  >>> print user_browser.contents
  <BLANKLINE>
  ...
  <h2>Valid keys</h2>
  ...
  1024D/DFD20543
  ...

Make sure that the revoked UID in the key wasn't added as an email address:

  >>> user_browser.open("http://launchpad.dev/people/name12/+editemails")
  >>> "sample.person@canonical.com" in user_browser.contents
  True
  >>> "test@canonical.com" in user_browser.contents
  True
  >>> "sample.revoked@canonical.com" in user_browser.contents
  False

Verify that the key was imported with the "can encrypt" flag set:

  >>> from canonical.launchpad.database import GPGKey
  >>> key = GPGKey.selectOneBy(
  ...     fingerprint='A419AE861E88BC9E04B9C26FBA2B9389DFD20543')
  >>> print key.owner.name
  name12
  >>> print key.can_encrypt
  True

Kill stub KeyServer
  
  >>> z.tearDown()

