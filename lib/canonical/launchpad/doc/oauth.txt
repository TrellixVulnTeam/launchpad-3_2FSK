=====
OAuth
=====

This is a mechanism for allowing a third party application to access
Launchpad on a user's behalf.  These applications are identified by a
unique key and are stored as OAuthConsumers.  The OAuth specification is
defined in <http://oauth.net/core/1.0/>.

These applications (also called consumers) are managed by the
OAuthConsumerSet utility.

    >>> from canonical.launchpad.webapp.testing import verifyObject
    >>> from canonical.launchpad.webapp.interfaces import (
    ...     AccessLevel, OAuthPermission)
    >>> from canonical.launchpad.interfaces import (
    ...     IOAuthAccessToken, IOAuthConsumer, IOAuthConsumerSet,
    ...     IOAuthNonce, IOAuthRequestToken, IPersonSet)
    >>> consumer_set = getUtility(IOAuthConsumerSet)
    >>> verifyObject(IOAuthConsumerSet, consumer_set)
    True

    >>> consumer = consumer_set.new(key='asdfg')
    >>> verifyObject(IOAuthConsumer, consumer)
    True

    >>> consumer_set.getByKey('asdfg') == consumer
    True

    >>> print consumer_set.getByKey('gfdsa')
    None

As mentioned above, the keys are unique, so we can't create a second
Consumer with the same key.

    >>> consumer_set.new(key='asdfg')
    Traceback (most recent call last):
    ...
    AssertionError: ...


Request tokens
==============

When a consumer wants to access protected resources on Launchpad, it
must first ask for an OAuthRequestToken, which is then used when the
consumer sends the user to the Launchpad authorization page.


Creating request tokens
-----------------------

The request tokens are created using IOAuthConsumer.newRequestToken().

    # XXX EdwinGrubbs 2008-10-03 bug=277756
    # Tests could be simplified with helper methods for creating tokens
    # in different states.
    >>> request_token = consumer.newRequestToken()
    >>> verifyObject(IOAuthRequestToken, request_token)
    True

The token's key and secret have a length of 20 and 80 respectively.

    >>> len(request_token.key)
    20
    >>> len(request_token.secret)
    80

Newly created tokens have no context associated with.

    >>> print request_token.context
    None

Initially, a token does not have a person or permission associated with it as
the consumer doesn't know the user's identity on Launchpad.

    >>> print request_token.person
    None
    >>> print request_token.permission
    None
    >>> print request_token.date_reviewed
    None

Once the user reviews (approve/decline) the consumer's request, the
token is considered used and can only be exchanged for an access token
(when the access is granted by the user).

    >>> salgado = getUtility(IPersonSet).getByName('salgado')
    >>> request_token.review(salgado, OAuthPermission.WRITE_PUBLIC)
    >>> from canonical.launchpad.ftests import syncUpdate
    >>> syncUpdate(request_token)

    >>> from datetime import datetime, timedelta
    >>> import pytz
    >>> print request_token.person.name
    salgado
    >>> request_token.permission
    <DBItem OAuthPermission.WRITE_PUBLIC...
    >>> request_token.date_reviewed <= datetime.now(pytz.timezone('UTC'))
    True
    >>> request_token.is_reviewed
    True

When reviewing a token, we can also change the context associated with
it, which means the consumer using that token will only have access
to things linked to that context (Product, Project, Distribution,
DistroSourcePackage).

    >>> from lp.registry.interfaces.distribution import IDistributionSet
    >>> from lp.registry.interfaces.product import IProductSet
    >>> from lp.registry.interfaces.project import IProjectSet

    >>> firefox = getUtility(IProductSet)['firefox']
    >>> request_token2 = consumer.newRequestToken()
    >>> request_token2.review(
    ...     salgado, OAuthPermission.WRITE_PRIVATE, context=firefox)
    >>> print request_token2.context.title
    Mozilla Firefox

    >>> mozilla = getUtility(IProjectSet)['mozilla']
    >>> request_token2 = consumer.newRequestToken()
    >>> request_token2.review(
    ...     salgado, OAuthPermission.WRITE_PRIVATE, context=mozilla)
    >>> print request_token2.context.title
    The Mozilla Project

    >>> ubuntu = getUtility(IDistributionSet)['ubuntu']
    >>> evolution = ubuntu.getSourcePackage('evolution')
    >>> request_token2 = consumer.newRequestToken()
    >>> request_token2.review(
    ...     salgado, OAuthPermission.WRITE_PRIVATE, context=evolution)

    >>> from canonical.encoding import ascii_smash
    >>> print ascii_smash(request_token2.context.title)
    "cevolution" package in Ubuntu


Retrieving request tokens
-------------------------

Any consumer can retrieve its request tokens as long as it knows their
keys.

    >>> consumer.getRequestToken(request_token.key) == request_token
    True

If there is no token with the given key, or the existing token is
associated with another consumer, getRequestToken() will return None.

    >>> print consumer.getRequestToken('zzzzzzzz')
    None
    >>> consumer2 = consumer_set.new(key='foobar')
    >>> print consumer2.getRequestToken(request_token.key)
    None

We also have OAuthRequestTokenSet.getByKey(), which allows us to get a
request token with the given key regardless of the consumer associated
with it.

    >>> from canonical.launchpad.interfaces import IOAuthRequestTokenSet
    >>> token_set = getUtility(IOAuthRequestTokenSet)
    >>> token_set.getByKey(request_token.key) == request_token
    True

    >>> request_token2 = consumer2.newRequestToken()
    >>> token_set.getByKey(request_token2.key) == request_token2
    True

    >>> print token_set.getByKey('zzzzzzzzz')
    None


Exchanging request tokens for access tokens
-------------------------------------------

Once a request token has been reviewed it may be exchanged for an access
token. That may happen only if the user actually granted some sort of
permission to the consumer when reviewing the request.

The access token's permission will be the same as the request token's
one, but it is an item of AccessLevel rather than OAuthPermission
because the former doesn't have an UNAUTHORIZED item (which doesn't
make sense in access tokens).

    >>> request_token.is_reviewed
    True
    >>> request_token.permission
    <DBItem OAuthPermission.WRITE_PUBLIC...
    >>> access_token = request_token.createAccessToken()
    >>> verifyObject(IOAuthAccessToken, access_token)
    True
    >>> access_token.permission
    <DBItem AccessLevel.WRITE_PUBLIC...

After the access token is generated, the request token is deleted.

    >>> print consumer.getRequestToken(request_token.key)
    None

By default, access tokens don't expire.

    >>> print access_token.date_expires
    None

Access tokens will also inherit the context from the request token.

    >>> request_token2 = consumer.newRequestToken()
    >>> request_token2.review(
    ...     salgado, OAuthPermission.WRITE_PRIVATE, context=firefox)
    >>> access_token2 = request_token2.createAccessToken()
    >>> print access_token2.context.title
    Mozilla Firefox

If the request token hasn't been reviewed yet, it can't be used to
create an access token.

    >>> request_token = consumer.newRequestToken()
    >>> request_token.is_reviewed
    False
    >>> access_token = request_token.createAccessToken()
    Traceback (most recent call last):
    ...
    AssertionError: ...

The same holds true for request tokens that have UNAUTHORIZED as their
permission.

    >>> request_token.review(salgado, OAuthPermission.UNAUTHORIZED)
    >>> request_token.is_reviewed
    True
    >>> access_token = request_token.createAccessToken()
    Traceback (most recent call last):
    ...
    AssertionError: ...


Access tokens
=============

As shown above, access tokens can be created from any reviewed (and
authorized) request tokens. These tokens are then stored by the consumer
and included in all further requests made on behalf of the same user, so
we need a way to retrieve an access token from any consumer.

    >>> consumer.getAccessToken(access_token.key) == access_token
    True

An access token can only be changed by the person associated with it.

    >>> access_token.permission = OAuthPermission.WRITE_PUBLIC
    Traceback (most recent call last):
    ...
    Unauthorized:...
    >>> login_person(access_token.person)
    >>> access_token.permission = AccessLevel.WRITE_PUBLIC

From any given person it's possible to retrieve his non-expired access
tokens.

    >>> access_token.person.oauth_access_tokens.count()
    4
    >>> access_token.date_expires = (
    ...     datetime.now(pytz.timezone('UTC')) - timedelta(hours=1))
    >>> syncUpdate(access_token)
    >>> access_token.person.oauth_access_tokens.count()
    3

It's also possible to retrieve the user's non-expired request tokens.

    >>> unclaimed_request_token = consumer.newRequestToken()
    >>> unclaimed_request_token.review(salgado, OAuthPermission.WRITE_PUBLIC)
    >>> salgado.oauth_request_tokens.count()
    5
    >>> salgado.oauth_request_tokens[0].date_expires = (
    ...     datetime.now(pytz.timezone('UTC')) - timedelta(hours=1))
    >>> syncUpdate(unclaimed_request_token)
    >>> salgado.oauth_request_tokens.count()
    4


Nonces and timestamps
=====================

A nonce is a random string, generated by the client for each request.

A timestamp is also generated by the client, and indicates when the request
was generated, according to the client's clock, expressed in the number of
seconds since January 1, 1970 00:00:00 GMT.

A nonce must be unique for the combination of a client and a timestamp.
Launchpad implements this constraint. If a nonce is not unique for a client
and a timestamp, the code will raise a NonceAlreadyUsed exception.

Here's a quick demonstration of the behavior.

- We can use a nonce.

    >>> import time
    >>> now = time.time() - 1
    >>> nonce1 = access_token.checkNonceAndTimestamp('boo', now)
    >>> verifyObject(IOAuthNonce, nonce1)
    True

- We can use an existing nonce with a new time.

    >>> now += 1
    >>> nonce2 = access_token.checkNonceAndTimestamp('boo', now)
    >>> IOAuthNonce.providedBy(nonce2)
    True
    >>> nonce1 is nonce2
    False

- We can use a new nonce with the same time.

    >>> nonce3 = access_token.checkNonceAndTimestamp('surprise!', now)
    >>> IOAuthNonce.providedBy(nonce3)
    True
    >>> nonce1 is nonce3 or nonce2 is nonce3
    False

- But we cannot use an existing nonce used for the same time.

    >>> access_token.checkNonceAndTimestamp('boo', now)
    Traceback (most recent call last):
    ...
    NonceAlreadyUsed: ...

According to the oauth specification <http://oauth.net/core/1.0/#nonce>, for a
given client, an application should not accept a timestamp older than the most
recent timestamp received.

For instance, if a client sends a timestamp of 2009-02-24T13:43:08Z, a
subsequent request for any earlier time (even one second earlier,
2009-02-24T13:43:07Z) should generate an error. A request with the same
timestamp or later is acceptable.

These limitations of the nonce and the timestamp are intended to reduce the
opportunity for replay attacks, particularly within the context of an insecure
channel such as HTTP.

Launchpad relaxes the constraint on the timestamp. Rather than accepting any
request within the same second, Launchpad accepts any request within the past
60 seconds (or, as defined by the code, within the past number of seconds
specified by canonical.launchpad.database.oauth.TIMESTAMP_ACCEPTANCE_WINDOW).

For instance, in Launchpad, if a client sends a timestamp of
2009-02-24T13:43:08Z, a subsequent request of any time up to 60 seconds prior
will be accepted. That means that the next request can specify
2009-02-24T13:42:08Z or later. Otherwise the code will raise a
TimestampOrderingError.

Here's a quick demonstration of the behavior.

- Within the TIMESTAMP_ACCEPTANCE_WINDOW, we can create a nonce with an
  earlier time.

    >>> from canonical.launchpad.database.oauth import (
    ...     TIMESTAMP_ACCEPTANCE_WINDOW)
    >>> TIMESTAMP_ACCEPTANCE_WINDOW
    60
    >>> nonce4 = access_token.checkNonceAndTimestamp('boo', now-30)
    >>> IOAuthNonce.providedBy(nonce4)
    True
    >>> nonce5 = access_token.checkNonceAndTimestamp('boo', now-60)
    >>> IOAuthNonce.providedBy(nonce5)
    True

- Once outside of the window (defined by the *latest* timestamp, even if it
  is not the most recent), we get a TimestampOrderingError.

    >>> access_token.checkNonceAndTimestamp('boo', now-61)
    Traceback (most recent call last):
    ...
    TimestampOrderingError: ...

This change is intended to support pipelining requests, and to acknowledge
that network latency, multiple concurrent clients with the same credentials,
and other situations can cause timestamps to get out of order (see
http://groups.google.com/group/oauth/msg/387fdafcf0be322a and LP bug 319710
for more background).

The code also raises a ClockSkew error if the timestamp is more than
TIMESTAMP_SKEW_WINDOW seconds away from the server's clock (ahead or
behind). This number of seconds is currently equal to one hour (60*60). The
primary reason for this behavior is so that a clock skew too far in the future
does not essentially make the authentication tokens useless once the client's
clock is corrected. In addition, it gives us a constraint within which we can
reason about clock-related errors reported by customers.

Here's a quick demonstration of the behavior.

- We can access the system with a timestamp 55 minutes in the future.

    >>> from canonical.launchpad.database.oauth import (
    ...     TIMESTAMP_SKEW_WINDOW)
    >>> TIMESTAMP_SKEW_WINDOW
    3600
    >>> nonce6 = access_token.checkNonceAndTimestamp('boo', now + 55*60)
    >>> IOAuthNonce.providedBy(nonce6)
    True

- We cannot access it 65 minutes in the future.

    >>> access_token.checkNonceAndTimestamp('boo', now + 65*60)
    Traceback (most recent call last):
    ...
    ClockSkew: ...

- It's also worth noting that now the TIMESTAMP_ACCEPTANCE_WINDOW is based
  off of the time 55 minutes in the future.

    >>> nonce7 = access_token.checkNonceAndTimestamp('boo', now + 54*60 + 30)
    >>> IOAuthNonce.providedBy(nonce7)
    True
    >>> access_token.checkNonceAndTimestamp('boo', now + 60)
    Traceback (most recent call last):
    ...
    TimestampOrderingError: ...
    >>> access_token.checkNonceAndTimestamp('boo', now + 53*60)
    Traceback (most recent call last):
    ...
    TimestampOrderingError: ...
