= An example of EnumCol with EnumeratedTypes =

Test imports and setup.

    >>> from canonical.database.sqlbase import SQLBase
    >>> from canonical.database.constants import DEFAULT
    >>> from canonical.launchpad.ftests.harness import LaunchpadTestSetup

Let's make a example table to demonstrate EnumCol with.  
Enumerations are stored in the database as integers, 
and we'll give the column a default value.

    >>> connection = LaunchpadTestSetup().connect()
    >>> cursor = connection.cursor()
    >>> cursor.execute('''
    ...     CREATE TABLE FooTest (
    ...         id serial NOT NULL,
    ...         foo integer DEFAULT 1 NOT NULL 
    ...     );
    ... ''')
    >>> cursor.execute('GRANT ALL ON TABLE FooTest TO launchpad;')
    >>> cursor.execute('GRANT ALL ON footest_id_seq TO launchpad;')
    >>> connection.commit()

Let's define a schema for that column.

    >>> from canonical.launchpad.webapp.enum import (
    ...     EnumeratedType, DBEnumeratedType, DBItem, Item, extends)
    >>> class FooType(DBEnumeratedType):
    ...     """Enumerated type for the foo column."""
    ...     ONE = DBItem(1, """
    ...         One
    ... 
    ...         Number one.
    ...         """)
    ...
    ...     TWO = DBItem(2, """
    ...         Two
    ... 
    ...         Number two.
    ...         """)
 
Now let's define an SQLObject for that table, using FooType as the schema for
the foo column.  We declare the default value for the foo column to be whatever
the database's default is.

    >>> from canonical.database.enumcol import EnumCol
    >>> class FooTest(SQLBase):
    ...     foo = EnumCol(enum=FooType, default=DEFAULT)

Create a row in the table.
 
    >>> t = FooTest()

The value of the foo column has been set to the default defined in the database,
because we didn't specify one.

    >>> t.foo == FooType.ONE
    True

You cannot use integers or strings as EnumCol values:

    >>> t.foo = 2
    Traceback (most recent call last):
    ...
    TypeError: Need to set an EnumeratedType Enum column to an Item, not an int

    >>> t.foo = "TWO"
    Traceback (most recent call last):
    ...
    TypeError: Not a DBItem: 'TWO'

You can of course use items from FooSchema.

    >>> t.foo = FooType.TWO
    >>> t.foo
    <DBItem FooType.TWO, (2) Two>

But not items from another schema.

    >>> class AnotherType(DBEnumeratedType):
    ...     ONE = DBItem(1, """
    ...         One
    ... 
    ...         Number one.
    ...         """)
    >>> t.foo = AnotherType.ONE
    Traceback (most recent call last):
    ...
    TypeError: DBItem from wrong type, 'FooType' not in ['AnotherType']

But it will allow setting from an item from an enumerated type that 
inherits or extends the original enumerated type where the item was in
that original type.

    >>> class FooBarType(FooType):
    ...     THREE = DBItem(3, "Three")

    >>> t.foo = FooBarType.ONE

Even though the assignment is from a derived enumeration, the value
that is available through the EnumCol is the item from the assigned
enumeration.

    >>> t.foo
    <DBItem FooType.ONE, (1) One>
    >>> t.foo = FooBarType.THREE
    Traceback (most recent call last):
    ...
    TypeError: DBItem from wrong type, 'FooType' not in ['FooBarType']

    >>> class FooBazType(EnumeratedType):
    ...     extends(FooType)
    ...     THREE = DBItem(3, "Three")
    ...     FOUR = Item("Four")

    >>> t.foo = FooBazType.ONE
    >>> t.foo
    <DBItem FooType.ONE, (1) One>
    
    >>> t.foo = FooBazType.THREE
    Traceback (most recent call last):
    ... 
    TypeError: DBItem from wrong type, 'FooType' not in ['FooBazType']

    >>> t.foo = FooBazType.FOUR
    Traceback (most recent call last):
    ...
    TypeError: Not a DBItem: <Item FooBazType.FOUR, Four>

