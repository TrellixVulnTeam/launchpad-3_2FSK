****************************
Feature Flag Developer Guide
****************************

Introduction
************

The point of feature flags is to let us turn some features of Launchpad on
and off without changing the code or restarting the application, and to
expose different features to different subsets of users.  

See <https://dev.launchpad.net/LEP/FeatureFlags> for more discussion and
rationale.

The typical use for feature flags is within web page requests but they can
also be used in asynchronous jobs or apis or other parts of Launchpad.

Internal model for feature flags
********************************

A feature flag maps from a *name* to a *value*.  The specific value used
for a particular request is determined by a set of zero or more *scopes*
that apply to that request, by finding the *rule* with the highest
*priority*. 

Flags are defined by a *name* that typically looks like a Python
identifier, for example ``notification.global.text``.  A definition is
given for a particular *scope*, which also looks like a dotted identifier,
for example ``user.beta`` or ``server.edge``.  This is just a naming
convention, and they do not need to correspond to Python modules.

The value is stored in the database as just a Unicode string, and it might
be interpreted as a boolean, number, human-readable string or whatever.

The default for flags is to be None if they're not set in the database, so
that should be a sensible baseline default state.

Performance model
*****************

Flags are supposed to be cheap enough that you can introduce them without
causing a performance concern.

If the page does not check any flags, no extra work will be done.  The
first time a page checks a flag, all the rules will be read from the
database and held in memory for the duration of the request.

Scopes may be expensive in some cases, such as checking group membership.
Whether a scope is active or not is looked up the first time it's needed
within a particular request.

The standard page footer identifies the flags and scopes that were
actually used by the page.

Naming conventions
******************

We have naming conventions for feature flags and scopes, so that people can
understand the likely impact of a particular flag and so they can find all
the flags likely to affect a feature.

So for any flag we want to say:

* What application area does this affect? (malone, survey, questions, code, etc)

* What specific feature does it change?

* What affect does it have on this feature?  The most common is "enabled"
  but for some other we want to specify a specific value as well such as
  "date" or "size".

These are concatenated with dots so the overall feature name looks a bit
like a Python module name.

A similar approach is used for scopes.

Checking flags in page templates
********************************

You can conditionally show some text like this::

  <tal:survey condition="features/user_survey.enabled">
    &nbsp;&bull;&nbsp;
    <a href="http://www.surveymonkey.com/s/launchpadsummer2010">Take our survey!</a>
  </tal:survey>

You can use the built-in TAL feature of prepending ``not:`` to the condition, and for flags that have a value you could use them in ``tal:replace`` or ``tal:attributes``.  

If you just want to simply insert some text taken from a feature, say
something like::

  Message of the day: ${motd.text}

Debugging feature usage
***********************

The flags active during a page request, and the scopes that were looked
up are visible in the comment at the bottom of every standard Launchpad
page.

Checking flags in code
**********************

Defining scopes
***************


.. vim: ft=rst
