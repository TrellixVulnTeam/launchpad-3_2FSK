= Projects =

A Project is basically a group of Products, making it possible to for
example see all bugs in the Project's Product, or make them share a
common external bug tracker.

    # Some basic imports
    >>> from canonical.launchpad.interfaces import IProjectSet, IProject
    >>> from zope.interface.verify import verifyObject
    >>> projectset = getUtility(IProjectSet)


== Creating new projects ==

When creating a new project there are a bunch of things we need to provide.
While some of them (homepageurl, icon, logo and mugshot) are optional, others
(name, displayname, title, summary, description and owner) are required).

    >>> from canonical.launchpad.interfaces import IPersonSet
    >>> no_priv = getUtility(IPersonSet).getByName('no-priv')
    >>> test_project = projectset.new(
    ...     name='project-test', displayname='Test Project', 
    ...     title='Just a test project', homepageurl=None,
    ...     summary='Mandatory summary', description='blah',
    ...     owner=no_priv)
    >>> test_project.name
    u'project-test'


== Looking up existing projects ==

We can get a project using IProjectSet, by supplying the project's name.

    >>> gnome = projectset['gnome']
    >>> gnome.name
    u'gnome'

    >>> verifyObject(IProject, gnome)
    True

Make sure that a project provides the IProject interface.

    >>> IProject.providedBy(gnome)
    True


If there is no project with the specified name, a NotFoundError will be
raised.

    >>> projectset['non-existant']
    Traceback (most recent call last):
    ...
    NotFoundError:...

The same will happen if we set a product to be inactive. This is a good
way of hiding bogus projects, without actually deleting them from the
db, since the __getitem__ method of IProjectSet is used to traverse to
the project.

    >>> from canonical.database.sqlbase import flush_database_updates
    >>> login("foo.bar@canonical.com")
    >>> gnome.active = False
    >>> flush_database_updates()


    >>> gnome = getUtility(IProjectSet)['gnome']
    Traceback (most recent call last):
    ...
    NotFoundError:...

The inactive project will still be accessible using
IProjectSet.getByName(), though.
But it should be shown using the getByName()

    >>> gnome = getUtility(IProjectSet).getByName('gnome')
    >>> gnome.name
    u'gnome'
    >>> gnome.active
    False

getByName() also accepts an argument to ignore inactive projects.

    >>> print getUtility(IProjectSet).getByName('gnome', ignore_inactive=True)
    None

== Products which are part of a project ==

The products which are part of a given project are given by a project's
.products property. Note that only active products are included and they're
ordered by their names.

    >>> [product.name for product in gnome.products]
    [u'applets', u'evolution', u'gnome-terminal', u'gnomebaker', u'netapplet']

    >>> netapplet = gnome.getProduct('netapplet')
    >>> netapplet.active = False
    >>> flush_database_updates()
    >>> [product.name for product in gnome.products]
    [u'applets', u'evolution', u'gnome-terminal', u'gnomebaker']

    # Re-activate netapplet so that we don't interfere in other tests below.
    >>> netapplet.active = True
    >>> flush_database_updates()


== Specification Listings ==

We should be able to generate filtered lists of specs on a project.

 >>> mozilla = getUtility(IProjectSet).getByName('mozilla')
 >>> from canonical.lp.dbschema import SpecificationFilter

First, there should be only one informational spec for mozilla:

 >>> filter = [SpecificationFilter.INFORMATIONAL]
 >>> for spec in mozilla.specifications(filter=filter):
 ...    print spec.name
 extension-manager-upgrades


There are no completed specs for mozilla:

 >>> filter = [SpecificationFilter.COMPLETE]
 >>> for spec in mozilla.specifications(filter=filter):
 ...    print spec.name


And there are five incomplete specs:

 >>> filter = [SpecificationFilter.INCOMPLETE]
 >>> mozilla.specifications(filter=filter).count()
 5

We can filter for specifications that contain specific text:

 >>> for spec in mozilla.specifications(filter=['install']):
 ...     print spec.name
 extension-manager-upgrades


Inactive products are excluded from the listings.

 >>> filter = [SpecificationFilter.INCOMPLETE]
 >>> mozilla.specifications(filter=filter).count()
 5

 >>> from canonical.launchpad.interfaces import IProductSet
 >>> firefox = getUtility(IProductSet).getByName('firefox')
 >>> firefox.active = False
 >>> flush_database_updates()
 >>> filter = [SpecificationFilter.INCOMPLETE]
 >>> mozilla.specifications(filter=filter).count()
 0

Reset firefox so we don't mess up later tests.

 >>> firefox.active = True
 >>> flush_database_updates()

We can get all the specifications via the all_specifications property,
and all valid specifications via the valid_specifications property:

 >>> for spec in mozilla.all_specifications:
 ...    print spec.name
 svg-support
 canvas
 extension-manager-upgrades
 mergewin
 e4x

 >>> for spec in mozilla.valid_specifications:
 ...    print spec.name
 svg-support
 canvas
 extension-manager-upgrades
 mergewin
 e4x


== translatables ==

A project would have IProduct objects that have resources to translate. This
method return us the ones that are translatable and officially using Rosetta
to handle translations.

  # Revert any change done until now.
  >>> import transaction
  >>> transaction.abort()

GNOME Project is a good example that has translations.
It has one translatable product.

  >>> gnome = getUtility(IProjectSet)['gnome']
  >>> translatables = gnome.translatables()
  >>> translatables.count()
  1

And that translatable product is 'Evolution'.

  >>> evolution = translatables[0]
  >>> print evolution.title
  The Evolution Groupware Application

With its 'trunk' series translatable.

  >>> evo_series = evolution.translatable_series
  >>> len(evo_series)
  1
  >>> evo_trunk = evo_series[0]
  >>> print evo_trunk.name
  trunk

That is using Rosetta officially.

  >>> evolution.official_rosetta
  True

GNOME project has also another product, netapplet.

  >>> netapplet = gnome.getProduct('netapplet')
  >>> print netapplet.title
  Network Applet

But it was not returned from 'translatables' method because it's not using
Rosetta officially.

  >>> netapplet.official_rosetta
  False

Even if it has resources to translate.

  >>> len(netapplet.translatable_series)
  1
