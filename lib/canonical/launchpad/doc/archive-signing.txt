= Archive signing =

`IArchive ` objects may be signed using its a IGPGKey pointed by its
'signing_key' attribute.

PPAs are created (activated, in production jargon) without a defined
'signing_key'. A GPG key will be generated later by a auxiliary script
and attached to the corresponding `IArchive`.

The secret part of the key will be stored in the path pointed by
`config.personalpackagearchive.sigining_keys_root`, named by their
fingerprint. E.g.: ABCDEF0123456789ABCDDCBA0000111112345678.key

Once the signing key is available, the subsequent publications will
result in a signed repository.

The signed repository will contained a de-attached signature of the
top-level 'Release' file, named 'Release.gpg' and a ASCII-armoded
export of the public GPG key (name 'key.gpg')


== Querying 'pending sigining key' PPAs ==

`IArchiveSet.getPPAsPendingSigningKey` allows call-sites to query for
PPA pending signing key generation.

    >>> from canonical.launchpad.interfaces.archive import IArchiveSet
    >>> from canonical.launchpad.interfaces.person import IPersonSet

    >>> archive_set = getUtility(IArchiveSet)
    >>> for ppa in archive_set.getPPAsPendingSigningKey():
    ...     print ppa.title
    PPA for Celso Providelo
    PPA for Mark Shuttleworth
    PPA for No Privileges Person

Disabled PPAs are excluded from the 'PendingSigningKey' pool:

    >>> no_priv = getUtility(IPersonSet).getByName('no-priv')

    >>> login('foo.bar@canonical.com')
    >>> no_priv.archive.enabled = False
    >>> login(ANONYMOUS)

    >>> for ppa in archive_set.getPPAsPendingSigningKey():
    ...     print ppa.title
    PPA for Celso Providelo
    PPA for Mark Shuttleworth

Indeed, Marks's PPA does not have a defined 'sigining_key'.

    >>> sabdfl = getUtility(IPersonSet).getByName('sabdfl')
    >>> print sabdfl.archive.signing_key
    None

We will select the only available IGPGKey from the sampledata.

    >>> foo_bar = getUtility(IPersonSet).getByName('name16')
    >>> [a_key] = foo_bar.gpgkeys
    >>> print a_key.displayname
    1024D/12345678

And use it as the Mark's PPA sigining key.

    >>> login('foo.bar@canonical.com')
    >>> sabdfl.archive.signing_key = a_key
    >>> login(ANONYMOUS)

It will exclude Mark's PPA from the 'PendingSigningKey' pool as well.

    >>> for ppa in archive_set.getPPAsPendingSigningKey():
    ...     print ppa.title
    PPA for Celso Providelo


== Generating a PPA signing key ==

As mentioned above, generated sigining_keys will be stored in a
location defined by the system configuration.

    >>> from canonical.config import config
    >>> print config.personalpackagearchive.signing_keys_root
    /var/tmp/ppa-signing-keys

In order to manipulate 'signing_keys' securely the target archive
object has to be adapted to `IArchiveSigningKey`.

    >>> from canonical.launchpad.interfaces.archivesigningkey import (
    ...     IArchiveSigningKey)

We will adapt Celso's PPA after modifing its distribution to allow
proper publish configuration based on the sampledata.

    >>> cprov = getUtility(IPersonSet).getByName('cprov')

    >>> from canonical.launchpad.interfaces.distribution import (
    ...     IDistributionSet)
    >>> login('foo.bar@canonical.com')
    >>> cprov.archive.distribution = getUtility(
    ...     IDistributionSet).getByName('ubuntutest')
    >>> login(ANONYMOUS)

    >>> archive_signing_key = IArchiveSigningKey(cprov.archive)

Once adapted `IArchiveSigningKey` is properly implemented.

    >>> from zope.interface.verify import verifyObject
    >>> verifyObject(IArchiveSigningKey, archive_signing_key)
    True

`IArchiveSigningKey` object contain the corresponding IArchive
object.

    >>> print archive_signing_key.archive.title
    PPA for Celso Providelo

It also implements `exportPublicKey` and `exportSecretKey` methods
with receive a `PymeKey` and export it in the appropriate location.

We will create MockKey objects implementing only the methods required
to test the export funtions

    >>> class MockKey:
    ...     def __init__(self, secret):
    ...         self.secret = secret
    ...         self.fingerprint = 'fpr'
    ...     def export(self):
    ...         return "Secret %s" % self.secret

`exportPublicKey` raises an error if given a secret key.

    >>> archive_signing_key.exportPublicKey(MockKey(True))
    Traceback (most recent call last):
    ...
    AssertionError: Only public keys should be exported.

Similarly, `exportSecretKey` raises an error if given a public key.

    >>> archive_signing_key.exportSecretKey(MockKey(False))
    Traceback (most recent call last):
    ...
    AssertionError: Only secret keys should be exported.

Now, if given the right type of key, both will result in a exported key
in the expected path.

    >>> mock_key = MockKey(True)
    >>> archive_signing_key.exportSecretKey(mock_key)

    >>> import os
    >>> from canonical.config import config

    >>> secret_export_path = os.path.join(
    ...     config.personalpackagearchive.signing_keys_root,
    ...     '%s.gpg' % mock_key.fingerprint)

    >>> print open(secret_export_path).read()
    Secret True

    >>> archive_signing_key.exportPublicKey(MockKey(False))

    >>> from zope.security.proxy import removeSecurityProxy
    >>> naked_pub_config = removeSecurityProxy(cprov.archive.getPubConfig())
    >>> pub_export_path = os.path.join(
    ...     naked_pub_config.archiveroot, 'key.pub')

    >>> print open(pub_export_path).read()
    Secret False

Use an `IArchiveSigningKey` to generate and assign a real signing_key.

    >>> archive_signing_key.generateSigningKey()

The assigned key is a sign-only, password-less 1024-RSA GPG key owner
by the 'PPA key guard' celebrity and represented by a IGPGKey record.

    >>> signing_key = cprov.archive.signing_key

    >>> from canonical.launchpad.interfaces.gpg import IGPGKey
    >>> verifyObject(IGPGKey, signing_key)
    True

    >>> print signing_key.owner.displayname
    PPA key guard

    >>> print signing_key.algorithm.description
    RSA

    >>> print signing_key.keysize
    1024

    >>> print signing_key.active
    True

    >>> print signing_key.can_encrypt
    False

The public key can be accessed publically via its export placed in the
repository root as 'key.pub'.

    >>> print open(pub_export_path).read()
    -----BEGIN PGP PUBLIC KEY BLOCK-----
    ...
    -----END PGP PUBLIC KEY BLOCK-----
    <BLANKLINE>

On the other hand, the secret key is securily stored in the
designed configuration path. So only the IGPGHandler itself can access
it.

    >>> secret_export_path = os.path.join(
    ...     config.personalpackagearchive.signing_keys_root,
    ...     '%s.gpg' % signing_key.fingerprint)

    >>> print open(secret_export_path).read()
    -----BEGIN PGP PRIVATE KEY BLOCK-----
    ...
    -----END PGP PRIVATE KEY BLOCK-----
    <BLANKLINE>

If called against a PPA which already has a 'signing_key'
`generateSigningKey` will raise an error.

    >>> archive_signing_key.generateSigningKey()
    Traceback (most recent call last):
    ...
    AssertionError: Cannot override signing_keys.

Purge 'signing_keys_root' and the PPA repository root.

    >>> import shutil
    >>> shutil.rmtree(config.personalpackagearchive.signing_keys_root)
    >>> shutil.rmtree(config.personalpackagearchive.root)

