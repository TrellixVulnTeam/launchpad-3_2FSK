= Source Package Release =

The SourcePackageRelease table represents a particular release of a
SourcePackageName, but isn't tied to any particular DistroSeries
as the same release can appear in many.

In a very basic explanation, this table caches the attributes of an
uploaded DSC (Debian Source Control) file.

This model allow us to have more granular control of the fields,
enabling faster searches, faster readings and model constraints.

== Basic attributes ==

Let's get one from the database:

   >>> from canonical.launchpad.database import SourcePackageRelease
   >>> spr = SourcePackageRelease.get(14)
   >>> spr.name
   u'mozilla-firefox'
   >>> spr.version
   u'0.9'
   >>> spr.dateuploaded
   datetime.datetime(...)

published_archives returns a set of all the archives that this
SourcePackageRelease is published in.

    >>> for archive in spr.published_archives:
    ...     print archive.title
    Primary Archive for Ubuntu Linux
    Primary Archive for Ubuntu Test

'age' is a special property that performs on-the-fly:
{{{
NOW - dateuploaded
}}}
It returns a timedelta object:

   >>> spr.age
   datetime.timedelta(...)

Check if the result match the locally calculated one:

   >>> import datetime
   >>> import pytz
   >>> local_now = datetime.datetime.now(pytz.timezone('UTC'))

   >>> expected_age = local_now - spr.dateuploaded
   >>> spr.age.days == expected_age.days
   True

Modify dateuploaded to a certain number of days in the past and check
if the 'age' result looks sane:

   >>> spr.dateuploaded = (local_now - datetime.timedelta(days=10))
   >>> spr.age.days == 10
   True

Mozilla-firefox 0.9 has got some builds. including a PPA build.  The 'builds'
property only returns the non-PPA builds.

   >>> from canonical.launchpad.interfaces import IPersonSet
   >>> from canonical.launchpad.database.build import Build
   >>> cprov_ppa = getUtility(IPersonSet).getByName('cprov').archive
   >>> ff_ppa_build = Build.selectBy(
   ...     archive=cprov_ppa, sourcepackagerelease=spr)
   >>> ff_ppa_build.count()
   1
   >>> ff_ppa_build[0].archive.purpose.name
   'PPA'
   >>> spr.builds.count()
   4

All the builds returned are for non-PPA archives:

   >>> set(build.archive.purpose.name for build in spr.builds)
   set(['PRIMARY'])

We can use the magic productrelease property to map this to a ProductRelease:

   >>> pr = spr.productrelease
   >>> print pr.product.name
   firefox
   >>> print pr.productseries.name
   trunk
   >>> print pr.version
   0.9

We can use the sourcepackage and distrosourcepackage properties to
grab magical objects representing that package in the distribution to
which it was uploaded:

   >>> print spr.sourcepackage.displayname
   Hoary mozilla-firefox
   >>> print spr.distrosourcepackage.displayname
   mozilla-firefox in ubuntu

It should also work when the version has a dash and packaging revision
after it:

   >>> spr = SourcePackageRelease.get(16)
   >>> print spr.name
   netapplet
   >>> print spr.version
   1.0-1
   >>> pr = spr.productrelease
   >>> print pr.product.name
   netapplet
   >>> print pr.productseries.name
   trunk
   >>> print pr.version
   1.0

If there isn't one, that should return None.

   >>> print SourcePackageRelease.get(20).productrelease
   None

Check that the uploaded changesfile works:

   >>> commercial = SourcePackageRelease.get(36)
   >>> commercial.upload_changesfile.http_url
   'http://.../commercialpackage_1.0-1_source.changes'

Check ISourcePackageRelease.override() behaviour:

   >>> spr.component.name, spr.section.name
   (u'main', u'editors')

   >>> from canonical.launchpad.interfaces import (
   ...     IComponentSet, ISectionSet)
   >>> new_comp = getUtility(IComponentSet)['universe']
   >>> new_sec = getUtility(ISectionSet)['mail']

Override the current sourcepackagerelease with new component/section
pair:

   >>> spr.override(component=new_comp, section=new_sec)

   >>> spr.component.name, spr.section.name
   (u'universe', u'mail')

Abort transaction to avoid error propagation of the new attributes:

   >>> import transaction
   >>> transaction.abort()


Verify the creation of a new ISourcePackageRelease based on the
IDistroSeries API:

  >>> from canonical.launchpad.interfaces import (
  ...     IDistributionSet, ISourcePackageNameSet, IGPGKeySet)
  >>> from canonical.database.constants import UTC_NOW
  >>> from canonical.launchpad.interfaces import SourcePackageUrgency

  >>> hoary = getUtility(IDistributionSet)['ubuntu']['hoary']

All the arguments to create an ISourcePackageRelease are obtained when
processing a source upload, see more details in nascentupload.txt.
Some of the 20 required arguments are foreign keys or DB contants:

  >>> arg_name = getUtility(ISourcePackageNameSet)['pmount']
  >>> arg_comp = getUtility(IComponentSet)['universe']
  >>> arg_sect = getUtility(ISectionSet)['web']
  >>> arg_key = getUtility(IGPGKeySet).get(1)
  >>> arg_maintainer = hoary.owner
  >>> arg_creator = hoary.owner
  >>> arg_urgency = SourcePackageUrgency.LOW

The other argurments are strings:

  >>> version = '0.0.99'
  >>> dsc = 'smashed dsc...'
  >>> copyright = 'smashed debian/copyright ...'
  >>> changelog_entry = 'contigous text....'
  >>> archhintlist = 'any'
  >>> builddepends = 'cdbs, debhelper (>= 4.1.0), libsysfs-dev, libhal-dev'
  >>> builddependsindep = ''
  >>> dsc_maintainer_rfc822 = 'Foo Bar <foo@bar.com>'
  >>> dsc_standards_version = '2.6.1'
  >>> dsc_format = '1.0'
  >>> dsc_binaries = 'pmount'
  >>> archive = hoary.main_archive

Having proper arguments in hand we can create a new
ISourcePackageRelease, it will automatically set the
'upload_distroseries' to the API entry point, in this case Hoary.

  >>> new_spr = hoary.createUploadedSourcePackageRelease(
  ...     arg_name, version, arg_maintainer,
  ...     builddepends, builddependsindep, archhintlist, arg_comp, arg_creator,
  ...     arg_urgency, changelog_entry, dsc, arg_key, arg_sect,
  ...     dsc_maintainer_rfc822, dsc_standards_version, dsc_format,
  ...     dsc_binaries, archive, copyright=copyright,
  ...      build_conflicts=None, build_conflicts_indep=None)

  >>> new_spr.upload_distroseries.name
  u'hoary'
  >>> new_spr.version
  u'0.0.99'
  >>> new_spr.upload_archive.id == hoary.main_archive.id
  True
  >>> new_spr.copyright
  u'smashed debian/copyright ...'

Throw away the DB changes:

  >>> transaction.abort()

Let's get a sample SourcePackageRelease:

   >>> spr_test = SourcePackageRelease.get(20)
   >>> spr_test.name
   u'pmount'


== Counting bugs ==

The SourcePackageRelease offers a convenient way of checking how many
bugs are open against this package in the distribution to which it was
uploaded. Because of bug privacy, this method needs a user supplied.

   >>> spr = SourcePackageRelease.get(14)
   >>> print spr.name
   mozilla-firefox
   >>> login('no-priv@canonical.com')
   >>> no_priv = getUtility(ILaunchBag).user
   >>> print spr.countOpenBugsInUploadedDistro(no_priv)
   1


== Uploading translations ==

It's time to check the translation upload function.

   >>> import canonical.launchpad
   >>> import os.path
   >>> import transaction
   >>> from canonical.launchpad.interfaces import ITranslationImportQueue
   >>> from canonical.librarian.interfaces import ILibrarianClient
   >>> translation_import_queue = getUtility(ITranslationImportQueue)
   >>> client = getUtility(ILibrarianClient)

We need a test tarball uploaded into librarian to run this test.

   >>> test_file_name = os.path.join(
   ...     os.path.dirname(canonical.launchpad.__file__),
   ...     'doc/sourcepackagerelease-translations.tar.gz')
   >>> file = open(test_file_name)
   >>> size = len(file.read())
   >>> file.seek(0)
   >>> alias = client.addFile(
   ...     name='test.tar.gz',
   ...     size=size,
   ...     file=file,
   ...     contentType='application/x-gtar')

We need the commit to see the upload.

   >>> transaction.commit()

Now we do the upload. It's necessary to retrive an ILibraryFileAlias
correspondent to the alias (long) we already have.

   >>> from canonical.launchpad.interfaces import ILibraryFileAliasSet
   >>> file_alias = getUtility(ILibraryFileAliasSet)[alias]

   >>> spr_test = SourcePackageRelease.get(20)
   >>> spr_test.name
   u'pmount'

Before the final upload, the queue should be empty.

   >>> translation_import_queue.getAllEntries(
   ...     target=spr_test.sourcepackage).count()
   0

   >>> spr_test.attachTranslationFiles(file_alias, True)

The commit is needed to see the new entries

   >>> transaction.commit()

And the queue should have a new entry.

   >>> translation_import_queue.getAllEntries(
   ...     target=spr_test.sourcepackage).count()
   1

Now, we need to do the final import. It's done as a two steps procedure.

The first one, approves the import.

    >>> import subprocess, sys
    >>> process = subprocess.Popen([
    ...     sys.executable, 'cronscripts/rosetta-approve-imports.py'
    ...     ], stdin=subprocess.PIPE, stdout=subprocess.PIPE,
    ...     stderr=subprocess.STDOUT
    ...     )
    >>> (output, empty) = process.communicate()
    >>> print output
    INFO    creating lockfile
    INFO    The automatic approval system approved some entries.
    INFO    Removed 2 entries from the queue.
    <BLANKLINE>

The second one, executes the import.

    >>> import subprocess, sys
    >>> process = subprocess.Popen([
    ...     sys.executable, 'cronscripts/rosetta-poimport.py'
    ...     ], stdin=subprocess.PIPE, stdout=subprocess.PIPE,
    ...     stderr=subprocess.STDOUT
    ...     )
    >>> (output, empty) = process.communicate()
    >>> print output
    INFO    creating lockfile
    INFO    Importing: Spanish (es) translation of pmount in Ubuntu Hoary package "pmount"
    ...
