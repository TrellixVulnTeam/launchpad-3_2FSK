= Validation =

The validation interface contains different kinds of validation functions.

== validate_distrotask() ==

The validate_distrotask() function is used to guarantee that distribution
bugtasks are unique per bug.

    >>> from lp.registry.interfaces.distribution import IDistributionSet
    >>> from lp.registry.interfaces.sourcepackagename import (
    ...     ISourcePackageNameSet)
    >>> from lp.bugs.interfaces.bug import IBugSet
    >>> from canonical.launchpad.interfaces.validation import (
    ...     validate_distrotask)

    >>> bug_two = getUtility(IBugSet).get(2)
    >>> debian = getUtility(IDistributionSet).getByName('debian')
    >>> mozilla_firefox = getUtility(
    ...     ISourcePackageNameSet).queryByName('mozilla-firefox')
    >>> alsa_utils = getUtility(
    ...     ISourcePackageNameSet).queryByName('alsa-utils')

We aren't allowed to have two distrotasks with the same sourcepackage.

    >>> validate_distrotask(bug_two, debian, mozilla_firefox)
    Traceback (most recent call last):
      ...
    LaunchpadValidationError: ...

But it's legal to have two bugtasks with different sourcepackages.

    >>> validate_distrotask(bug_two, debian, alsa_utils)

If the bug already has a distribution task with no source package, it's
not possible to add a another one.

    >>> from lp.registry.interfaces.distribution import IDistributionSet
    >>> from lp.bugs.interfaces.bug import CreateBugParams

    >>> login('no-priv@canonical.com')
    >>> no_priv = getUtility(ILaunchBag).user
    >>> ubuntu = getUtility(IDistributionSet).getByName('ubuntu')
    >>> ubuntu_bug_no_sourcepackage = ubuntu.createBug(
    ...     CreateBugParams(no_priv, 'Test Bug', 'This is a test'))
    >>> validate_distrotask(ubuntu_bug_no_sourcepackage, ubuntu, None)
    Traceback (most recent call last):
      ...
    LaunchpadValidationError: ...

It's also not possible to have a bugtask for a sourcepackage that has
not been published in the target distribution.

    >>> foobar = getUtility(
    ...     ISourcePackageNameSet).queryByName('foobar')
    >>> validate_distrotask(ubuntu_bug_no_sourcepackage, ubuntu, foobar)
    Traceback (most recent call last):
    ...
    LaunchpadValidationError: u'Package foobar not published in Ubuntu'

It's not allowed even if the sourcepackage has been published in a
PPA.

    >>> from lp.soyuz.tests.ppa import publishToPPA
    >>> from lp.soyuz.interfaces.publishing import PackagePublishingStatus
    >>> publishToPPA(
    ...     person_name='cprov',
    ...     sourcepackage_name='foobar',
    ...     sourcepackage_version='1.0',
    ...     distribution_name='ubuntu',
    ...     distroseries_name='hoary',
    ...     publishing_status=PackagePublishingStatus.PUBLISHED)

    >>> validate_distrotask(ubuntu_bug_no_sourcepackage, ubuntu, foobar)
    Traceback (most recent call last):
    ...
    LaunchpadValidationError: u'Package foobar not published in Ubuntu'

Adding a task with a source package is still possible.

    >>> validate_distrotask(ubuntu_bug_no_sourcepackage, ubuntu, alsa_utils)


== validate_new_distrotask() ==

The validate_new_distrotask() function does the same checks as
validate_distrotask(), but it does some extra checks as well.

We can't add a task on just the distribution, because it doesn't
make sense to have tasks open on just the distribution and also packages
in that distribution on the same bug.

    >>> from canonical.launchpad.interfaces.validation import (
    ...     validate_new_distrotask)
    >>> validate_new_distrotask(bug_two, debian, None)
    Traceback (most recent call last):
      ...
    LaunchpadValidationError: ...

If the bug already has a distribution with no package, we can't add
another distribution task with a source package (the task with no
package should be edited instead).

    >>> validate_new_distrotask(
    ...     ubuntu_bug_no_sourcepackage, ubuntu, alsa_utils)
    Traceback (most recent call last):
      ...
    LaunchpadValidationError: ...


== LaunchpadValidationError ==

LaunchpadValidationError is the standard exception used for custom
validators upon a validation error. Rendering one is done by getting
an IWidgetInputErrorView:

    >>> from canonical.launchpad.validators import (
    ...     LaunchpadValidationError)
    >>> from canonical.launchpad.webapp.servers import (
    ...     LaunchpadTestRequest)
    >>> from zope.app.form.browser.interfaces import (
    ...     IWidgetInputErrorView)
    >>> from zope.app import zapi

    >>> error = LaunchpadValidationError('lp validation error')
    >>> request = LaunchpadTestRequest()
    >>> view = zapi.getMultiAdapter((error, request),
    ...     IWidgetInputErrorView)

    >>> IWidgetInputErrorView.providedBy(view)
    True
    >>> view.snippet()
    u'lp validation error'
