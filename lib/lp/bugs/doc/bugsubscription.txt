= BugSubscription =

Users can get email notifications of changes to bugs by subscribing to
them.

== Bug Subscriber APIs ==

First, let's login:

    >>> from canonical.launchpad.ftests import login
    >>> login("foo.bar@canonical.com")

IBug has a subscriptions attribute:

    >>> from canonical.launchpad.interfaces import IBugSet
    >>> from zope.component import getUtility
    >>> bugset = getUtility(IBugSet)
    >>> bug = bugset.get(1)
    >>> bug.subscriptions.count()
    2

This list returns only *direct* subscribers. Bugs can also have
indirect subscribers.

=== Direct vs. Indirect Subscriptions ===

A user is directly subscribed to a bug if they or someone else has
subscribed them to the bug.

Then there are three kinds of users that are indirectly subscribed to
a bug:

    * assignees
    * structural subscribers (subscribers to the bug's target)
    * direct subscribers from dupes

Bugs may get reassigned, bug subscribers may come and go, and dupes may
be unduped or reduped to other bugs. Indirect subscriptions are looked
up at mail sending time, so the mail is automatically sent to new bug
subscribers or assignees, stops being sent to subscribers from dupes when
a bug is unduped, and so forth.

Let's create a new bug to demonstrate how direct and indirect
subscriptions work.

    >>> from canonical.launchpad.interfaces import (
    ...     IDistributionSet, ILaunchBag, IPersonSet, CreateBugParams)
    >>> ubuntu = getUtility(IDistributionSet).getByName("ubuntu")
    >>> personset = getUtility(IPersonSet)

    >>> linux_source = ubuntu.getSourcePackage("linux-source-2.6.15")
    >>> linux_source.bug_subscriptions
    []
    >>> print linux_source.distribution.bug_supervisor
    None

    >>> foobar = getUtility(ILaunchBag).user
    >>> print foobar.name
    name16

    >>> params = CreateBugParams(
    ...     title="a bug to test subscriptions",
    ...     comment="test", owner=foobar)
    >>> linux_source_bug = linux_source.createBug(params)

The list of direct bug subscribers is accessed via
IBug.getDirectSubscribers().

    >>> def print_displayname(subscribers):
    ...     subscriber_names = sorted(subscriber.displayname
    ...                               for subscriber in subscribers)
    ...     for name in subscriber_names:
    ...         print name

    >>> print_displayname(linux_source_bug.getDirectSubscribers())
    Foo Bar

    >>> mark = personset.getByName("mark")

    >>> linux_source_bug.subscribe(mark, mark)
    <BugSubscription ...>

    >>> print_displayname(linux_source_bug.getDirectSubscribers())
    Foo Bar
    Mark Shuttleworth

The list of indirect subscribers is accessed via
IBug.getIndirectSubscribers().

    >>> linux_source_bug.getIndirectSubscribers()
    [<Person at ...>]

Finer-grained access to indirect subscribers is provided by
getAlsoNotifiedSubscribers() and getSubscribersFromDuplicates().

    >>> linux_source_bug.getAlsoNotifiedSubscribers()
    [<Person at ...>]
    >>> linux_source_bug.getSubscribersFromDuplicates()
    []

It is also possible to get the list of indirect subscribers for an
individual bug task.

    >>> from canonical.launchpad.mailnotification import (
    ...     get_bugtask_indirect_subscribers)
    >>> get_bugtask_indirect_subscribers(
    ...     linux_source_bug.bugtasks[0])
    [<Person at ...>]

The list of all bug subscribers can also be accessed via
IBugTask.bug_subscribers. Our event handling machinery compares a
"snapshot" of this value, before a bug was changed, to the current
value, to check if there are new bugcontacts subscribed to this bug as a
result of a product or sourcepackage reassignment. It's also an
optimization to snapshot this list only on IBugTask, because we don't
need it for changes made only to IBug.

    >>> task = linux_source_bug.bugtasks[0]
    >>> print_displayname(task.bug_subscribers)
    Foo Bar
    Mark Shuttleworth
    Ubuntu Team

Here are some examples of the three types of indirect subscribers:

1. Assignees

    >>> sample_person = personset.getByName("name12")

    >>> linux_source_bug.bugtasks[0].transitionToAssignee(sample_person)

    >>> print_displayname(linux_source_bug.getIndirectSubscribers())
    Sample Person
    Ubuntu Team

    >>> linux_source_bug.getSubscribersFromDuplicates()
    []

    >>> print_displayname(linux_source_bug.getAlsoNotifiedSubscribers())
    Sample Person
    Ubuntu Team

2. Structural subscribers

    >>> mr_no_privs = personset.getByName("no-priv")

    >>> subscription_no_priv = linux_source.addBugSubscription(
    ...     mr_no_privs, mr_no_privs)

    >>> print_displayname(
    ...     sub.subscriber for sub in linux_source.bug_subscriptions)
    No Privileges Person

    >>> print_displayname(linux_source_bug.getIndirectSubscribers())
    No Privileges Person
    Sample Person
    Ubuntu Team

    >>> linux_source_bug.getSubscribersFromDuplicates()
    []
    >>> print_displayname(linux_source_bug.getAlsoNotifiedSubscribers())
    No Privileges Person
    Sample Person
    Ubuntu Team

    >>> ubuntu_team = personset.getByName("ubuntu-team")

    >>> linux_source.distribution.setBugSupervisor(ubuntu_team, ubuntu_team)

    >>> print_displayname(linux_source_bug.getIndirectSubscribers())
    No Privileges Person
    Sample Person
    Ubuntu Team

    >>> print_displayname(linux_source_bug.getAlsoNotifiedSubscribers())
    No Privileges Person
    Sample Person
    Ubuntu Team

After adding a product bugtask we can see that the upstream bug
supervisor is also an indirect subscriber.

    >>> from canonical.launchpad.interfaces import IBugTaskSet, IProductSet
    >>> firefox = getUtility(IProductSet).get(4)

    >>> getUtility(IBugTaskSet).createTask(
    ...     product=firefox, bug=linux_source_bug,
    ...     owner=foobar)
    <BugTask ...>

    >>> lifeless = personset.getByName("lifeless")
    >>> firefox.setBugSupervisor(lifeless, lifeless)

    >>> print_displayname(linux_source_bug.getIndirectSubscribers())
    No Privileges Person
    Robert Collins
    Sample Person
    Ubuntu Team

    >>> print_displayname(linux_source_bug.getAlsoNotifiedSubscribers())
    No Privileges Person
    Robert Collins
    Sample Person
    Ubuntu Team

If there were no upstream product bug subscribers, the product owner
would be used instead.

    >>> firefox.setBugSupervisor(None, None)

    >>> print_displayname(linux_source_bug.getIndirectSubscribers())
    No Privileges Person
    Robert Collins
    Sample Person
    Ubuntu Team

    >>> print_displayname(linux_source_bug.getAlsoNotifiedSubscribers())
    No Privileges Person
    Robert Collins
    Sample Person
    Ubuntu Team

    >>> previous_owner = firefox.owner

    >>> firefox.owner = lifeless

    >>> print_displayname(linux_source_bug.getIndirectSubscribers())
    No Privileges Person
    Robert Collins
    Sample Person
    Ubuntu Team

    >>> print_displayname(linux_source_bug.getAlsoNotifiedSubscribers())
    No Privileges Person
    Robert Collins
    Sample Person
    Ubuntu Team

    >>> firefox.owner = previous_owner
    >>> firefox.setBugSupervisor(lifeless, lifeless)

IBug.getAlsoNotifiedSubscribers() and IBug.getIndirectSubscribers() take
an optional parameter `level` allowing us to filter the result by
SubscriptionNotificationLevel for structural subscriptions.  Only subscribers who
have a bug notification level greater than or equal to the value passed
in the `level` parameter are returned.

The bug notification level of No Privileges Person's structural
subscription is currently set to COMMENTS.

    >>> print subscription_no_priv.bug_notification_level.name
    COMMENTS

With this subscription level, No Privileges Person is returned for all
parameter values of level.

    >>> from lp.registry.interfaces.structuralsubscription import (
    ...     SubscriptionNotificationLevel)
    >>> print_displayname(linux_source_bug.getAlsoNotifiedSubscribers(
    ...     level=SubscriptionNotificationLevel.COMMENTS))
    No Privileges Person
    Robert Collins
    Sample Person
    Ubuntu Team

    >>> print_displayname(linux_source_bug.getIndirectSubscribers(
    ...     level=SubscriptionNotificationLevel.COMMENTS))
    No Privileges Person
    Robert Collins
    Sample Person
    Ubuntu Team

    >>> print_displayname(linux_source_bug.getAlsoNotifiedSubscribers(
    ...     level=SubscriptionNotificationLevel.LIFECYCLE))
    No Privileges Person
    Robert Collins
    Sample Person
    Ubuntu Team

    >>> print_displayname(linux_source_bug.getIndirectSubscribers(
    ...     level=SubscriptionNotificationLevel.LIFECYCLE))
    No Privileges Person
    Robert Collins
    Sample Person
    Ubuntu Team

If No Privileges Person sets his notification level to LIFECYCLE, he will
not be included, if the parameter `level` is METADATA or COMMENTS.

    >>> subscription_no_priv.bug_notification_level = (
    ...     SubscriptionNotificationLevel.LIFECYCLE)

    >>> print_displayname(linux_source_bug.getAlsoNotifiedSubscribers(
    ...     level=SubscriptionNotificationLevel.LIFECYCLE))
    No Privileges Person
    Robert Collins
    Sample Person
    Ubuntu Team

    >>> print_displayname(linux_source_bug.getIndirectSubscribers(
    ...     level=SubscriptionNotificationLevel.LIFECYCLE))
    No Privileges Person
    Robert Collins
    Sample Person
    Ubuntu Team

    >>> print_displayname(linux_source_bug.getAlsoNotifiedSubscribers(
    ...     level=SubscriptionNotificationLevel.METADATA))
    Robert Collins
    Sample Person
    Ubuntu Team

    >>> print_displayname(linux_source_bug.getIndirectSubscribers(
    ...     level=SubscriptionNotificationLevel.METADATA))
    Robert Collins
    Sample Person
    Ubuntu Team

3. Direct subscribers of duplicate bugs.

    >>> keybuk = personset.getByName("keybuk")

    >>> params = CreateBugParams(
    ...     title="a bug to test subscriptions",
    ...     comment="test", owner=keybuk)
    >>> linux_source_bug_dupe = linux_source.createBug(params)

    >>> print_displayname(linux_source_bug_dupe.getDirectSubscribers())
    Scott James Remnant

Indirect subscribers of duplicates are *not* subscribed to dupe
targets. For example, assigning stub to the dupe bug will demonstrate
how he, as an indirect subscriber of the dupe, but does not get
subscribed to the dupe target.

    >>> linux_source_bug_dupe.bugtasks[0].transitionToAssignee(
    ...     personset.getByName("stub"))

    >>> print_displayname(linux_source_bug_dupe.getIndirectSubscribers())
    No Privileges Person
    Stuart Bishop
    Ubuntu Team

    >>> linux_source_bug_dupe.markAsDuplicate(linux_source_bug)
    >>> linux_source_bug_dupe.syncUpdate()

    >>> print_displayname(linux_source_bug.getIndirectSubscribers())
    No Privileges Person
    Robert Collins
    Sample Person
    Scott James Remnant
    Ubuntu Team

    >>> print_displayname(linux_source_bug.getSubscribersFromDuplicates())
    Scott James Remnant

If Scott James Remnant makes a structural subscription to linux_source,
he will no longer appear in the list of subscribers of the duplicate
bug...

    >>> subscription_keybuk = linux_source.addBugSubscription(
    ...     keybuk, keybuk)
    >>> linux_source_bug.getSubscribersFromDuplicates()
    []

...but if he sets his subscription level to LIFECYCLE and the parameter
`level` with a value greater than LIFECYCLE is passed to
Bug.getDuplicateSubscribers(), he will be again listed as a subscriber
of a duplicate bug.

    >>> subscription_keybuk.bug_notification_level = (
    ...     SubscriptionNotificationLevel.LIFECYCLE)
    >>> print_displayname(linux_source_bug.getSubscribersFromDuplicates(
    ...     level=SubscriptionNotificationLevel.METADATA))
    Scott James Remnant

When a bug is marked private, all its indirect subscribers become direct
subscribers.

    >>> from zope.event import notify

    >>> from lazr.lifecycle.event import ObjectModifiedEvent
    >>> from lazr.lifecycle.snapshot import Snapshot
    >>> from canonical.launchpad.interfaces import IBug

    >>> print_displayname(linux_source_bug.getDirectSubscribers())
    Foo Bar
    Mark Shuttleworth

    >>> bug_before_modification = Snapshot(linux_source_bug, providing=IBug)
    >>> linux_source_bug.setPrivate(True, getUtility(ILaunchBag).user)
    True

    >>> notify(
    ...     ObjectModifiedEvent(
    ...         linux_source_bug, bug_before_modification, ["private"]))

    >>> print_displayname(linux_source_bug.getDirectSubscribers())
    Foo Bar
    Mark Shuttleworth
    No Privileges Person
    Robert Collins
    Sample Person
    Scott James Remnant
    Ubuntu Team

A private bug never has indirect subscribers. Since all our indirect
subscribers have been made into direct subscribers, let's add another
indirect subscriber to show that they still aren't included in the
indirect subscriptions.

    >>> linux_source_bug.bugtasks[0].transitionToAssignee(
    ...     personset.getByName("martin-pitt"))

    >>> linux_source_bug.getIndirectSubscribers()
    []

    >>> linux_source_bug.getSubscribersFromDuplicates()
    []

Direct subscriptions always take precedence over indirect
subscriptions. So, if we unmark the above bug as private,
indirect_subscribers will include only martin-pitt.

    >>> linux_source_bug.setPrivate(False, getUtility(ILaunchBag).user)
    True
    >>> linux_source_bug.syncUpdate()

    >>> print_displayname(linux_source_bug.getDirectSubscribers())
    Foo Bar
    Mark Shuttleworth
    No Privileges Person
    Robert Collins
    Sample Person
    Scott James Remnant
    Ubuntu Team

    >>> print_displayname(linux_source_bug.getIndirectSubscribers())
    Martin Pitt

    >>> print_displayname(linux_source_bug.getAlsoNotifiedSubscribers())
    Martin Pitt

To find out which email addresses should receive a notification email on
a bug, and why, IBug.getBugNotificationRecipients() assembles an
INotificationRecipientSet instance for us:

   >>> recipients = linux_source_bug.getBugNotificationRecipients()

You can query for the addresses and reasons:

   >>> addresses = recipients.getEmails()
   >>> [(address, recipients.getReason(address)[1]) for address in addresses]
    [('foo.bar@canonical.com', 'Subscriber'),
     ('mark@example.com', 'Subscriber'),
     ('no-priv@canonical.com', 'Subscriber'),
     ('robertc@robertcollins.net', 'Subscriber'),
     ('support@ubuntu.com', u'Subscriber @ubuntu-team'),
     ('test@canonical.com', 'Subscriber')]

If IBug.getBugNotificationRecipients() is passed a  SubscriptionNotificationLevel
in its `level` parameter, only structural subscribers with that
notification level or higher will be returned. When the linux_source_bug
was temporarily set to "private", the structural subscriber Sample Person
was directly subscribed, thus he is returned by
getBugNotificationRecipients() even if the parameter level is larger than
his structural subscription setting.

   >>> recipients = linux_source_bug.getBugNotificationRecipients(
   ...     level=SubscriptionNotificationLevel.COMMENTS)
   >>> addresses = recipients.getEmails()
   >>> [(address, recipients.getReason(address)[1]) for address in addresses]
    [('foo.bar@canonical.com', 'Subscriber'),
     ('mark@example.com', 'Subscriber'),
     ('no-priv@canonical.com', 'Subscriber'),
     ('robertc@robertcollins.net', 'Subscriber'),
     ('support@ubuntu.com', u'Subscriber @ubuntu-team'),
     ('test@canonical.com', 'Subscriber')]

When Sample Person is unsubscribed from linux_source_bug, he is no
longer included in the result of getBugNotificationRecipients() for
the COMMENTS level...

   >>> linux_source_bug.unsubscribe(mr_no_privs, mr_no_privs)
   >>> recipients = linux_source_bug.getBugNotificationRecipients(
   ...     level=SubscriptionNotificationLevel.COMMENTS)
   >>> addresses = recipients.getEmails()
   >>> [(address, recipients.getReason(address)[1]) for address in addresses]
    [('foo.bar@canonical.com', 'Subscriber'),
     ('mark@example.com', 'Subscriber'),
     ('robertc@robertcollins.net', 'Subscriber'),
     ('support@ubuntu.com', u'Subscriber @ubuntu-team'),
     ('test@canonical.com', 'Subscriber')]

...but remains included for the level LIFECYCLE.

   >>> linux_source_bug.unsubscribe(mr_no_privs, mr_no_privs)
   >>> recipients = linux_source_bug.getBugNotificationRecipients(
   ...     level=SubscriptionNotificationLevel.LIFECYCLE)
   >>> addresses = recipients.getEmails()
   >>> [(address, recipients.getReason(address)[1]) for address in addresses]
    [('foo.bar@canonical.com', 'Subscriber'),
     ('mark@example.com', 'Subscriber'),
     ('no-priv@canonical.com', u'Subscriber (linux-source-2.6.15 in ubuntu)'),
     ('robertc@robertcollins.net', 'Subscriber'),
     ('support@ubuntu.com', u'Subscriber @ubuntu-team'),
     ('test@canonical.com', 'Subscriber')]

To find out if someone is already directly subscribed to a bug, call
IBug.isSubscribed, passing in an IPerson:

    >>> linux_source_bug.isSubscribed(personset.getByName("debonzi"))
    False
    >>> linux_source_bug.isSubscribed(sample_person)
    True

Call isSubscribedToDupes to see if a user is directly subscribed to
dupes of a bug. This is useful for, for example, figuring out how to
display the Subscribe/Unsubscribe menu option, and in TAL, for deciding
whether the user needs to be warned, while unsubscribing, that they will
be unsubscribed from dupes.

    >>> bug_five = bugset.get(5)
    >>> bug_six = bugset.get(6)

    >>> bug_six.duplicateof == bug_five
    True

    >>> bug_five.isSubscribedToDupes(sample_person)
    False

    >>> bug_six.subscribe(sample_person, sample_person)
    <BugSubscription...>

    >>> bug_five.isSubscribedToDupes(sample_person)
    True

== Subscribing and Unsubscribing ==

To subscribe people to and unsubscribe people from a bug, use
IBug.subscribe and IBug.unsubscribe:

    >>> foobar = personset.getByName("name16")

    >>> bug.isSubscribed(foobar)
    False
    >>> subscription = bug.subscribe(foobar, foobar)
    >>> bug.isSubscribed(foobar)
    True

    >>> bug.unsubscribe(foobar, foobar)
    >>> bug.isSubscribed(foobar)
    False

By default, the bug_notification_level of the new subscription will be
COMMENTS, so the user will receive all notifications about the bug.

    >>> print subscription.bug_notification_level.title
    Discussion

To unsubscribe from all dupes for a bug, call
IBug.unsubscribeFromDupes. This is useful because direct subscribers
from dupes are automatically subscribed to dupe targets, so we provide
them a way to unsubscribe.

For example, Sample Person can be unsubscribed from bug #6, by
unsubscribing them from the dupes of bug #5, because bug #6 is a dupe of
bug #5.

    >>> bug_six.duplicateof == bug_five
    True

    >>> bug_six.isSubscribed(sample_person)
    True

The return value of unsubscribeFromDupes() is a list of bugs from which
the user was unsubscribed.

    >>> [bug.id for bug in bug_five.unsubscribeFromDupes(
    ...     sample_person, sample_person)]
    [6]

    >>> bug_six.isSubscribed(sample_person)
    False


=== Determining whether a user can unsubscribe someone ===

As user can't unsubscribe just anyone from a bug. To check whether
someone can be unusubscribed, the canBeUnsubscribedByUser() method on
the BugSubscription object is used.

The user can of course unsubscribe himself, even if someone else
subscribed him.

    >>> bug = factory.makeBug()
    >>> subscriber = factory.makePerson()
    >>> subscribed_by = factory.makePerson()
    >>> subscription = bug.subscribe(subscriber, subscribed_by)
    >>> subscription.canBeUnsubscribedByUser(subscriber)
    True

The one who subscribed the subscriber doesn't have permission to
unsubscribe him.

    >>> subscription.canBeUnsubscribedByUser(subscribed_by)
    False

The anonymous user (represented by None) also can't unsubscribe him.

    >>> subscription.canBeUnsubscribedByUser(None)
    False

A user can unsubscribe a team he's a member of.

    >>> team = factory.makeTeam()
    >>> member = factory.makePerson()
    >>> member.join(team)
    >>> subscription = bug.subscribe(team, subscribed_by)
    >>> subscription.canBeUnsubscribedByUser(member)
    True

    >>> non_member = factory.makePerson()
    >>> subscription.canBeUnsubscribedByUser(non_member)
    False

The anonymous user (represented by None) also can't unsubscribe the team.

    >>> subscription.canBeUnsubscribedByUser(None)
    False

A bug's unsubscribe method uses canBeUnsubscribedByUser to check
that the unsubscribing user has the appropriate permissions.  unsubscribe
will raise an exception if the user does not have permission.

    >>> bug.unsubscribe(team, non_member)
    Traceback (most recent call last):
    ...
    UserCannotUnsubscribePerson: ...


== Automatic Subscriptions on Bug Creation ==

When a new bug is opened, only the bug reporter is automatically, explicitly
subscribed to the bug:

XXX: Brad Bollenbach, 2005-11-25: These bits need real sample data. See
https://launchpad.net/bugs/5484.

Define a function that get subscriber email addresses back conveniently:

    >>> def getSubscribers(bug):
    ...     recipients = bug.getBugNotificationRecipients()
    ...     return recipients.getEmails()

Let's have a look at an example for a distribution bug:

    >>> ubuntu.setBugSupervisor(sample_person, sample_person)

    >>> params = CreateBugParams(
    ...     title="a test bug", comment="a test description",
    ...     owner=foobar)
    >>> new_bug = ubuntu.createBug(params)

Only the bug reporter, Foo Bar, has an explicit subscription.

    >>> [subscription.person.displayname
    ...  for subscription in new_bug.subscriptions]
    [u'Foo Bar']

But because Sample Person is the distribution contact for Ubuntu, he
will be implicitly added to the notification recipients.

    >>> getSubscribers(new_bug)
    ['foo.bar@canonical.com', 'support@ubuntu.com', 'test@canonical.com']

The distro contact will also be subscribed to private bugs, because
there is no security contact:

    >>> ubuntu.security_contact is None
    True

    >>> from lp.services.mail import stub
    >>> transaction.commit()
    >>> stub.test_emails = []

    >>> params = CreateBugParams(
    ...     title="a test bug", comment="a test description",
    ...     owner=foobar, security_related=True, private=True)
    >>> new_bug = ubuntu.createBug(params)

    >>> getSubscribers(new_bug)
    ['foo.bar@canonical.com', 'support@ubuntu.com']

Even though support@ubuntu.com got subscribed while filing the bug, no
"You have been subscribed" notification was sent, which is normally sent
to new subscribers.

    >>> transaction.commit()
    >>> stub.test_emails
    []

Another example, this time for an upstream:

    >>> firefox.setBugSupervisor(mark, mark)

    >>> params = CreateBugParams(
    ...     title="a test bug", comment="a test description",
    ...     owner=foobar)
    >>> new_bug = firefox.createBug(params)

Again, only Foo Bar is explicitly subscribed:

    >>> [subscription.person.displayname
    ...  for subscription in new_bug.subscriptions]
    [u'Foo Bar']

But the upstream Firefox bug supervisor, mark, is implicitly added to the
recipients list.

    >>> getSubscribers(new_bug)
    ['foo.bar@canonical.com', 'mark@example.com', 'robertc@robertcollins.net']

If we create a bug task on Ubuntu in the same bug, the Ubuntu bug
supervisor will be subscribed:

    >>> ubuntu_task = getUtility(IBugTaskSet).createTask(
    ...     bug=new_bug, distribution=ubuntu, owner=mark)

    >>> print '\n'.join(getSubscribers(new_bug))
    foo.bar@canonical.com
    mark@example.com
    robertc@robertcollins.net
    support@ubuntu.com
    test@canonical.com

But still, only Foo Bar is explicitly subscribed.

    >>> [subscription.person.displayname
    ...  for subscription in new_bug.subscriptions]
    [u'Foo Bar']

When an upstream does *not* have a specific bug supervisor set, the
product.owner is used instead. So, if Firefox's bug supervisor is unset,
Sample Person, the Firefox "owner" will get subscribed instead:

    >>> firefox.setBugSupervisor(None, None)

    >>> params = CreateBugParams(
    ...     title="a test bug", comment="a test description",
    ...     owner=foobar)
    >>> new_bug = firefox.createBug(params)

Foo Bar is the only explicit subscriber:

    >>> [subscription.person.displayname
    ...  for subscription in new_bug.subscriptions]
    [u'Foo Bar']

But the product owner, Sample Person, is implicitly added to the
recipient list:

    >>> print '\n'.join(getSubscribers(new_bug))
    foo.bar@canonical.com
    mark@example.com
    robertc@robertcollins.net
    test@canonical.com

The upstream maintainer will be subscribed to security-related private
bugs, because upstream has no security contact, in this case.

    >>> firefox.security_contact is None
    True

    >>> params = CreateBugParams(
    ...     title="a test bug", comment="a test description",
    ...     owner=foobar, security_related=True, private=True)
    >>> new_bug = firefox.createBug(params)

    >>> getSubscribers(new_bug)
    ['foo.bar@canonical.com', 'test@canonical.com']

Now let's create a bug on a specific package, which has no package bug
contacts:

    >>> evolution = ubuntu.getSourcePackage("evolution")
    >>> evolution.bug_subscriptions
    []

    >>> params = CreateBugParams(
    ...     title="another test bug",
    ...     comment="another test description",
    ...     owner=foobar)
    >>> new_bug = evolution.createBug(params)

    >>> getSubscribers(new_bug)
    ['foo.bar@canonical.com', 'support@ubuntu.com', 'test@canonical.com']

Adding a package bug contact for evolution will mean that that package
bug contact gets implicitly subscribed to all bugs ever opened on that
package.

So, if the Ubuntu team is added as a bug contact to evolution:

    >>> evolution.addBugSubscription(ubuntu_team, ubuntu_team)
    <StructuralSubscription at ...>

The team will be implicitly subscribed to the previous bug we
created. (Remember that Sample Person is also implicitly subscribed
because they are the distro bug contact):

    >>> [subscription.person.displayname
    ...  for subscription in new_bug.subscriptions]
    [u'Foo Bar']

    >>> getSubscribers(new_bug)
    ['foo.bar@canonical.com', 'support@ubuntu.com', 'test@canonical.com']

And the Ubuntu team will be implicitly subscribed to future bugs:

    >>> params = CreateBugParams(
    ...     title="yet another test bug",
    ...     comment="yet another test description",
    ...     owner=foobar)
    >>> new_bug = evolution.createBug(params)

    >>> [subscription.person.displayname
    ...  for subscription in new_bug.subscriptions]
    [u'Foo Bar']

    >>> getSubscribers(new_bug)
    ['foo.bar@canonical.com', 'support@ubuntu.com', 'test@canonical.com']

The distribution maintainer, Ubuntu Team, gets subscribed to the private
security bug filed on a package, because Ubuntu has no security contact:

    >>> ubuntu.security_contact is None
    True

    >>> params = CreateBugParams(
    ...     title="yet another test bug",
    ...     comment="yet another test description",
    ...     owner=foobar, security_related=True, private=True)
    >>> new_bug = evolution.createBug(params)

    >>> getSubscribers(new_bug)
    ['foo.bar@canonical.com', 'support@ubuntu.com']


== Subscribed by ==

Each `BugSubscription` records who created it, and provides a handy
utility method for formatting this information. The methods
`getDirectSubscriptions` and `getSubscriptionsFromDuplicates` provide
an equivalent to the -Subscribers methods, but returning the
subscriptions themselves, rather than the subscribers.

    >>> params = CreateBugParams(
    ...     title="one more test bug",
    ...     comment="one more test description",
    ...     owner=mark)
    >>> ff_bug = firefox.createBug(params)
    >>> ff_bug.subscribe(lifeless, mark)
    <BugSubscription at ...>
    >>> for subscription in ff_bug.getDirectSubscriptions():
    ...     print '%s (%s)' % (
    ...         subscription.person.displayname,
    ...         subscription.display_subscribed_by)
    Mark Shuttleworth (Subscribed themselves)
    Robert Collins (Subscribed by Mark Shuttleworth)
    >>> params = CreateBugParams(
    ...     title="one more dupe test bug",
    ...     comment="one more dupe test description",
    ...     owner=keybuk)
    >>> dupe_ff_bug = firefox.createBug(params)
    >>> dupe_ff_bug.markAsDuplicate(ff_bug)
    >>> dupe_ff_bug.syncUpdate()
    >>> dupe_ff_bug.subscribe(foobar, lifeless)
    <BugSubscription at ...>
    >>> for subscription in ff_bug.getSubscriptionsFromDuplicates():
    ...     print '%s (%s)' % (
    ...         subscription.person.displayname,
    ...         subscription.display_subscribed_by)
    Foo Bar (Subscribed by Robert Collins)
    Scott James Remnant (Subscribed themselves)
