= Package Cache System =

Launchpad caches published packages (sources and binaries) details in
order to get better performance on searches.

Cached information for sources is stored in
DistributionSourcePackageCache table, including:

 * distribution, IDistribution where the source was published
 * archive, IArchive where the source was published
 * sourcepackagename, respective ISourcePackageName
 * name, source name in text format.
 * binpkgnames, text containing all the binary package names generated
   by th source.
 * binpkgsummary, text containing all summaries of the binaries
   generated by this source.
 * binpkgdescription, text containing all descriptions of the binaries
   generated by this source.
 * fti, a tsvector generated on insert or update with the text indexes
   for name, binpkgnames, binpkgsummaries and binpkgdescriptions.

  >>> from canonical.launchpad.interfaces import IDistributionSet

  >>> ubuntu = getUtility(IDistributionSet)['ubuntu']

  >>> ubuntu_caches = ubuntu.getSourcePackageCaches()

  >>> ubuntu_caches.count()
  10

  >>> for name in sorted([cache.name for cache in ubuntu_caches]):
  ...     print name
  alsa-utils
  cnews
  commercialpackage
  evolution
  foobar
  libstdc++
  linux-source-2.6.15
  mozilla-firefox
  netapplet
  pmount


Cached information for binaries is stored in DistroSeriesPackageCache
table, including:

 * distroseries, IDistroSeries where the binary is published.
 * archive, IArchive where the source was published
 * binarypackagename, respective IBinaryPackageName.
 * name, binary name in text format.
 * summary, binary summary in text format.
 * description, binary description in text format.
 * summaries, binary summaries  in text format
 * descriptions, binary description in text format.
 * fti, a tsvector generated on insert or update with the text indexes
   for name, summary, description, summaries and descriptions.

  >>> warty = ubuntu['warty']
  >>> warty_caches = warty.getBinaryPackageCaches()
  >>> warty_caches.count()
  5
  >>> for name in sorted([cache.name for cache in warty_caches]):
  ...     print name
  at
  foobar
  linux-2.6.12
  mozilla-firefox
  pmount

Different than sources, where multiple generated binaries are very
common, multiple binaries of with the same name are only possible when
versions are not the same across architectures.

Building these caches we can reach good performance on full and
partial term searching.

  >>> len(ubuntu.searchSourcePackages('mozilla'))
  1

  >>> len(ubuntu.searchSourcePackages('moz'))
  1

  >>> len(ubuntu.searchSourcePackages('biscoito'))
  0

The cache update procedure is done by cronscripts/update-pkgcache.py,
which removes obsolete records, update existing ones and add new
records during the scanning of all the publishing records. This
scripts runs periodically in our infrastructure. See usage at
package-cache-script.txt.


== Dealing with Source Caches ==

A SourcePackage that has the status DELETED will be deleted from the
cache when it's updated.

  >>> foobar_in_ubuntu = ubuntu.getSourcePackage('foobar')
  >>> foobar_rel = foobar_in_ubuntu.releases[0]
  >>> foobar_pub = foobar_rel.publishing_history[0]
  >>> foobar_pub.status.name
  'DELETED'

  >>> len(ubuntu.searchSourcePackages('foobar'))
  1

  >>> from canonical.launchpad.database import (
  ...    DistributionSourcePackageCache)

  >>> foobar_cache = DistributionSourcePackageCache.selectOneBy(
  ...     archive=ubuntu.main_archive, distribution=ubuntu, name='foobar')

  >>> foobar_cache is not None
  True

Source cache updates are driven by distribution, IDistribution
instance offers a method for removing obsolete records in cache:

Let's use a fake logger object:

  >>> class TestLog:
  ...     def debug(self, msg):
  ...         print 'DEBUG: %s' % msg

  >>> ubuntu.removeOldCacheItems(archive=ubuntu.main_archive, log=TestLog())
  DEBUG: Removing source cache for 'foobar' (10)

  >>> import transaction
  >>> transaction.commit()

  >>> len(ubuntu.searchSourcePackages('foobar'))
  0

  >>> foobar_cache = DistributionSourcePackageCache.selectOneBy(
  ...     archive=ubuntu.main_archive, distribution=ubuntu, name='foobar')

  >>> foobar_cache is None
  True

A source package that has the status PUBLISHED will be added to the
cache when it's updated the next time.

  >>> cdrkit_in_ubuntu = ubuntu.getSourcePackage('cdrkit')
  >>> cdrkit_rel = cdrkit_in_ubuntu.releases[0]
  >>> cdrkit_pub = cdrkit_rel.publishing_history[0]
  >>> cdrkit_pub.status.name
  'PUBLISHED'

  >>> len(ubuntu.searchSourcePackages('cdrkit'))
  0

  >>> cdrkit_cache = DistributionSourcePackageCache.selectOneBy(
  ...     archive=ubuntu.main_archive, distribution=ubuntu, name='cdrkit')

  >>> cdrkit_cache is None
  True

We can invoke the cache updater directly on IDistroSeries:

  >>> ubuntu.updateCompleteSourcePackageCache(
  ...    archive=ubuntu.main_archive, ztm=transaction, log=TestLog())
  DEBUG: Considering source 'mozilla-firefox'
  ...
  DEBUG: Considering source 'cdrkit'
  DEBUG: Creating new source cache entry.
  ...

The current transaction should be committed since the script only
commits full batches of 50 elements:

  >>> transaction.commit()

Also updates should be flushed since the 'name' (among other texts)
are set after the row creation:

XXX cprov 20061201: flush_database_updates should not be required
after issuing a commit(), bug #3989

  >>> from canonical.database.sqlbase import flush_database_updates
  >>> flush_database_updates()

Now we see that the 'cdrkit' source is part of the caches and can be
reached via searches:

  >>> len(ubuntu.searchSourcePackages('cdrkit'))
  1

  >>> cdrkit_cache = DistributionSourcePackageCache.selectOneBy(
  ...     archive=ubuntu.main_archive, distribution=ubuntu, name='cdrkit')

  >>> cdrkit_cache is not None
  True


== Dealing with Binary Caches ==

A BinaryPackage that has the status DELETED will be deleted from the
cache when it's updated.

  >>> foobar_bin_in_warty = warty.getBinaryPackage('foobar')
  >>> foobar_bin_rel = foobar_in_ubuntu.releases[0]
  >>> foobar_bin_pub = foobar_rel.publishing_history[0]
  >>> foobar_bin_pub.status.name
  'DELETED'

  >>> len(warty.searchPackages('foobar'))
  1

  >>> from canonical.launchpad.database import (
  ...      DistroSeriesPackageCache)

  >>> foobar_bin_cache = DistroSeriesPackageCache.selectOneBy(
  ...     archive=ubuntu.main_archive, distroseries=warty, name='foobar')

  >>> foobar_bin_cache is not None
  True

Binary cache updates are driven by distroseries, IDistroSeries
instance offers a method for removing obsolete records in cache:

  >>> warty.removeOldCacheItems(archive=ubuntu.main_archive, log=TestLog())
  DEBUG: Removing binary cache for 'foobar' (8)

  >>> transaction.commit()

  >>> len(warty.searchPackages('foobar'))
  0

  >>> foobar_bin_cache = DistroSeriesPackageCache.selectOneBy(
  ...     archive=ubuntu.main_archive, distroseries=warty, name='foobar')

  >>> foobar_bin_cache is None
  True

A binary package that has been published since the last update of the
cache will be added to it.

  >>> cdrkit_bin_in_warty = warty.getBinaryPackage('cdrkit')
  >>> cdrkit_bin_pub = cdrkit_bin_in_warty.current_publishings[0]
  >>> cdrkit_bin_pub.status.name
  'PUBLISHED'

  >>> len(warty.searchPackages('cdrkit'))
  0

  >>> cdrkit_bin_cache = DistroSeriesPackageCache.selectOneBy(
  ...     archive=ubuntu.main_archive, distroseries=warty, name='cdrkit')

  >>> cdrkit_bin_cache is None
  True

We can invoke the cache updater directly on IDistroSeries:

  >>> warty.updateCompletePackageCache(
  ...    archive=ubuntu.main_archive, ztm=transaction, log=TestLog())
  DEBUG: Considering binary 'mozilla-firefox'
  ...
  DEBUG: Considering binary 'cdrkit'
  DEBUG: Creating new binary cache entry.
  ...

Transaction behaves exactly the same as for Source Caches, except that
it commits full batches of 100 elements.

  >>> transaction.commit()

XXX cprov 20061201: see above, same than Source cache interface), bug #3989

  >>> from canonical.database.sqlbase import flush_database_updates
  >>> flush_database_updates()

Now we see that the 'cdrkit' binary is part of the caches and can be
reached via searches:

  >>> len(warty.searchPackages('cdrkit'))
  1

  >>> cdrkit_bin_cache = DistroSeriesPackageCache.selectOneBy(
  ...     archive=ubuntu.main_archive, distroseries=warty, name='cdrkit')

  >>> cdrkit_bin_cache is not None
  True


== PPA package caches ==

Package caches are also populated for PPAs, allowing users to search
for them considering the packages currently published in their context.

We will use Celso's PPA.

  >>> from canonical.launchpad.interfaces import IPersonSet
  >>> cprov = getUtility(IPersonSet).getByName('cprov')

With empty cache contents in Archive table we can't even find a PPA by
owner name.

  >>> print ubuntu.searchPPAs(text='cprov').count()
  0

Sampledata contains stub counters.

  >>> print cprov.archive.sources_cached
  3

  >>> print cprov.archive.binaries_cached
  3

We have to issue 'updateArchiveCache' to include the owner 'name' and
'displayname' field in the archive caches.

  >>> cprov.archive.updateArchiveCache()
  >>> transaction.commit()
  >>> flush_database_updates()

Now Celso's PPA can be found via searches and the package counters got
reset, reflecting that nothing is cached in the database yet.

  >>> print ubuntu.searchPPAs(text='cprov')[0].title
  PPA for Celso Providelo

  >>> print cprov.archive.sources_cached
  0

  >>> print cprov.archive.binaries_cached
  0

The sampledata contains no package caches, so attempts to find
'pmount' (a source), 'firefox' (a binary name term) or 'shortdesc' (a
term used in the pmount binary summary) fail.

  >>> ubuntu.searchPPAs(text='pmount').count()
  0
  >>> ubuntu.searchPPAs(text='firefox').count()
  0
  >>> ubuntu.searchPPAs(text='warty').count()
  0
  >>> ubuntu.searchPPAs(text='shortdesc').count()
  0

If we populate the package caches and update the archive caches, the
same queries work, pointing to Celso's PPA.

  >>> ubuntu.updateCompleteSourcePackageCache(
  ...    archive=cprov.archive, ztm=transaction, log=TestLog())
  DEBUG: Considering source 'pmount'
  ...

  >>> warty.updateCompletePackageCache(
  ...    archive=cprov.archive, ztm=transaction, log=TestLog())
  DEBUG: Considering binary 'mozilla-firefox'
  ...

  >>> cprov.archive.updateArchiveCache()
  >>> transaction.commit()
  >>> flush_database_updates()

  >>> print ubuntu.searchPPAs(text='cprov')[0].title
  PPA for Celso Providelo
  >>> print ubuntu.searchPPAs(text='pmount')[0].title
  PPA for Celso Providelo
  >>> print ubuntu.searchPPAs(text='firefox')[0].title
  PPA for Celso Providelo
  >>> print ubuntu.searchPPAs(text='warty')[0].title
  PPA for Celso Providelo
  >>> print ubuntu.searchPPAs(text='shortdesc')[0].title
  PPA for Celso Providelo


== Package Counters ==

We also store counters for the number of Sources and Binaries
published in a DistroSeries pocket RELEASE:

  >>> warty.sourcecount
  3
  >>> warty.binarycount
  4

Since we have modified the publication list for warty in order to test
the caching system, we expect similar changes in the
counters. IDistroSeries provides a method to update its own cache:

  >>> warty.updatePackageCount()

New values were stored:

  >>> warty.sourcecount
  5
  >>> warty.binarycount
  6

A similar mechanism is offered by IDistroArchSeries, but only for
binaries (of course):

  >>> warty_i386 = warty['i386']

  >>> warty_i386.package_count
  5

Invoke the counter updater on this architecture:

  >>> warty_i386.updatePackageCount()

New values were stored:

  >>> warty_i386.package_count
  8


== DistroSeriesBinaryPackage cache lookups ==

The DistroSeriesBinaryPackage and DistroArchSeriesBinaryPackage
objects uses a DistroSeriesPackageCache record to present summary and
description for the context binary package.

  >>> from canonical.launchpad.interfaces import IBinaryPackageNameSet
  >>> foobar_name = getUtility(IBinaryPackageNameSet).queryByName('foobar')

  >>> primary_cache = DistroSeriesPackageCache(
  ...     archive=ubuntu.main_archive, distroseries=warty,
  ...     binarypackagename=foobar_name, summary='main foobar',
  ...     description='main foobar description')

The DistroSeriesBinaryPackage.

  >>> foobar_binary = warty.getBinaryPackage('foobar')

  >>> foobar_binary.cache == primary_cache
  True

  >>> print foobar_binary.summary
  main foobar

  >>> print foobar_binary.description
  main foobar description

The DistroArchSeriesBinaryPackage.

  >>> warty_i386 = warty['i386']
  >>> foobar_arch_binary = warty_i386.getBinaryPackage('foobar')

  >>> foobar_arch_binary.cache == primary_cache
  True

  >>> print foobar_arch_binary.summary
  main foobar

  >>> print foobar_arch_binary.description
  main foobar description

This lookup mechanism will continue to work even after we have added a
cache entry for a PPA package with the same name.

  >>> ppa_cache = DistroSeriesPackageCache(
  ...     archive=cprov.archive, distroseries=warty,
  ...     binarypackagename=foobar_name, summary='ppa foobar')

  >>> foobar_binary = warty.getBinaryPackage('foobar')
  >>> foobar_binary.cache != ppa_cache
  True

  >>> foobar_arch_binary = warty_i386.getBinaryPackage('foobar')
  >>> foobar_arch_binary.cache != ppa_cache
  True
