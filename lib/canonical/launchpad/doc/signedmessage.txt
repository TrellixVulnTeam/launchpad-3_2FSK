SignedMessage extends email.Message.Message in order to provide easy
access to signed content and the signature of messages:

    >>> from canonical.launchpad.mail.signedmessage import SignedMessage

You can create it from a string using email.message_from_string passing
SignedMessage as the _class parameter.  Let's start with a simple
message, where the signature is inline with the signed content:

    >>> from canonical.launchpad.helpers import read_test_message
    >>> msg = read_test_message('signed_inline.txt')

You can access the headers of the message:

    >>> print msg['From']
    Sample Person <test@canonical.com>

The raw text that was signed is available as msg.signedContent:

    >>> print msg.signedContent
    Some signed content.
    <BLANKLINE>
    With multiple paragraphs.

And to make it easier to work with, it's available as an email.Message
object as well:

    >>> signed_msg = msg.signedMessage
    >>> print signed_msg.get_payload()
    Some signed content.
    <BLANKLINE>
    With multiple paragraphs.

Finally the signature can be accessed via msg.signature:

    >>> print msg.signature
    -----BEGIN PGP SIGNATURE-----
    Version: GnuPG v1.2.5 (GNU/Linux)
    <BLANKLINE>
    iD8DBQFCXaoOuiuTid/SBUMRAoRkAJoCuy/kSVPCN1kBTqMG+cgsbhhFbwCfeSjH
    /Uc8UVJBiA94yh4G50qgD8o=
    =lNZi
    -----END PGP SIGNATURE-----

If some lines in the signed content begin with a '-', they need to be
dashed escaped in the actual email with a '-' followed by a space
character. For example, signed_dash_escaped.txt contains a standard
signature separator, '-- ':

    >>> msg = read_test_message('signed_dash_escaped.txt')
    >>> print msg.get_payload()
    -----BEGIN PGP SIGNED MESSAGE-----
    ...
    - --
    Sample Person
    ...

The signed content is unescaped, though:

    >>> print msg.signedContent
    Some signed content.
    <BLANKLINE>
    --
    Sample Person


It also works when the signature is detached, that is the message
contains of two MIME parts, the signed text, and the signature:

    >>> msg = read_test_message('signed_detached.txt')

The signed content includes the MIME headers as well:

    >>> print msg.signedContent
    Content-Type: text/plain; charset=us-ascii
    Content-Disposition: inline
    <BLANKLINE>
    Some signed content.

In signedMessage you can access the headers and the content
separately:

    >>> print msg.signedMessage['Content-Type']
    text/plain; charset=us-ascii
    >>> print msg.signedMessage.get_payload()
    Some signed content.


And of course the signature is accessible as well:

    >>> print msg.signature
    -----BEGIN PGP SIGNATURE-----
    Version: GnuPG v1.2.5 (GNU/Linux)
    <BLANKLINE>
    iD8DBQFCXah8uiuTid/SBUMRAotfAJwOYuLfnW0mV3EA67gXhuhnE/Ur7wCfRVMZ
    xIlThcNdAY9Wkd289kB5W8I=
    =fQDd
    -----END PGP SIGNATURE-----

If the message is unsigned, all attributes will be None:

    >>> msg = read_test_message('unsigned_multipart.txt')
    >>> msg.signedContent is None
    True
    >>> msg.signedMessage is None
    True
    >>> msg.signature is None
    True

It handles signed multipart messages as well:

    >>> msg = read_test_message('signed_multipart.txt')
    >>> content, attachment = msg.signedMessage.get_payload()
    >>> print content.get_payload()
    Some signed content.
    <BLANKLINE>
    >>> print attachment.get_payload()
    A signed attachment.
    <BLANKLINE>

    >>> print msg.signature
    -----BEGIN PGP SIGNATURE-----
    Version: GnuPG v1.2.5 (GNU/Linux)
    <BLANKLINE>
    iD8DBQFCXajSjn63CGxkqMURAtNPAJ4myfPemSBEMR3e4TGvg9LgqiBOJwCdHjRu
    cdC/h/xgiwwrHaUFTk/guuY=
    =fBjf
    -----END PGP SIGNATURE-----
