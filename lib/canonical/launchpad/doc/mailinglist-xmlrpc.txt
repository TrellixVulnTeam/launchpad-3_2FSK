= XML-RPC integration for mailing lists =

Team mailing lists are requested in Launchpad, but the lists actually live in
an external system running GNU Mailman.  The communication pattern is
initiated by Mailman in all cases; in other words, Mailman polls Launchpad to
see if there is any work for Mailman to do.

    >>> import xmlrpclib
    >>> from canonical.functional import XMLRPCTestTransport
    >>> mailinglist_api = xmlrpclib.ServerProxy(
    ...    'http://test@canonical.com:test@xmlrpc.launchpad.dev/mailinglists/',
    ...    transport=XMLRPCTransport())


== Set up ==

Let's start by seeding the database with some sample teams and their mailing
lists.

    >>> from canonical.launchpad.interfaces import IPersonSet
    >>> from canonical.launchpad.ftests import login, ANONYMOUS
    >>> login(ANONYMOUS)
    >>> personset = getUtility(IPersonSet)
    >>> ddaa = personset.getByName('ddaa')
    >>> team_one = personset.newTeam(ddaa, 'team-one', 'Team One')
    >>> team_two = personset.newTeam(ddaa, 'team-two', 'Team Two')
    >>> list_registry = MailingListRegistry()
    >>> list_one = list_registry.register(team_one)
    >>> list_two = list_registry.register(team_two)
    >>> from canonical.database.sqlbase import flush_database_updates
    >>> flush_database_updates()

Here's a helper function for printing the pending actions data structure.

    >>> def print_actions(pending_actions):
    ...     for action in sorted(pending_actions):
    ...         for team in sorted(action):
    ...             if action in ('create', 'modify'):
    ...                 team, modification = team
    ...                 print team, '-->', action, modification
    ...             else:
    ...                 print team, '-->', action


== Registered lists ==

Mailing lists start out in a state called 'REGISTERED'.  These are mailing
lists that have been requested by team owners.  However before Mailman can
create the lists, they must be approved by a Launchpad administrator.  Before
that, there is nothing for Mailman to do.

    >>> mailinglist_api.getPendingActions()
    {}

Once a few lists have been approved by the Launchpad administrators (and one
of the lists has an initial welcome message)...

    >>> carlos = personset.getByName('carlos')
    >>> list_one.review(carlos, MailingListStatus.APPROVED)
    >>> list_two.review(carlos, MailingListStatus.APPROVED)
    >>> list_one.welcome_message = u'Welcome to Team One'
    >>> flush_database_updates()

...the next time Mailman polls XMLRPC, there will be things for it to do.

    >>> pending_actions = mailinglist_api.getPendingActions()
    >>> print_actions(pending_actions)
    team-one --> create, {'welcome_message': u'Welcome to Team One'}
    team-two --> create, {}


== Creating the mailing lists ==

Mailman will attempt to satisfy the requested creation.  This will either
succeed or fail, and this status is communicated back to Launchpad.  Let's say
that team-one was created succesfully, but the creation of team-two failed for
some reason.

    >>> mailinglist_api.reportStatus({
    ...     'team-one': 'success',
    ...     'team-two': 'failure',
    ...     })

We can see that the statuses of the mailing lists have been updated in the
database.

    >>> list_one.status.name
    'ACTIVE'
    >>> list_two.status.name
    'FAILED'

Once these actions have been taken, there are no more pending actions for
Mailman.

    >>> mailinglist_api.getPendingActions()
    {}


== Deactivating mailing lists ==

The other action that Mailman needs to take is to deactivate a list when the
team owner requests it.  These also show up as pending actions when Mailman
polls Launchpad.

Now, say team one's owner wants to deactive their list.

    >>> list_one.deactivate()
    >>> flush_database_updates()

This will show up in the actions pending for Mailman.

    >>> pending_actions = mailinglist_api.getPendingActions()
    >>> print_actions(pending_actions)
    team-one --> deactivate

Let's create another team mailing list and request its deactivation, to show
what happens if a deactivation fails.

    >>> team_three = personset.newTeam(ddaa, 'team-three', 'Team Three')
    >>> list_three = list_registry.register(team_three)
    >>> flush_database_updates()
    >>> mailinglist_api.reportStatus({'team-three': 'success'})
    >>> list_three.deactivate()
    >>> flush_database_updates()

We now have two active mailing lists for which deactivation has been
requested.

    >>> print_actions(mailinglist_api.getPendingActions())
    team-one --> deactivate
    team-three --> deactivate

Perhaps team one's list was successfully deactivated but team three's list
deactivation failed for some reason.

    >>> mailinglist_api.reportStatus({
    ...     'team-one': 'success',
    ...     'team-three': 'failed',
    ...     })
    >>> list_one.status.name
    'INACTIVE'
    >>> list_three.status.name
    'FAILED'


== Modifying mailing lists ==

Activate mailing lists can also be modified.  Currently the only modification
supported is changing the list's welcome message.  Because deactivated and
failed mailing lists cannot be re-activated without manual intervention, let's
create a couple more teams and mailing lists.

    >>> team_four = personset.newTeam(ddaa, 'team-four', 'Team Four')
    >>> list_four = list_registry.register(team_four)
    >>> team_five = personset.newTeam(ddaa, 'team-five, 'Team Five')
    >>> list_five = list_registry.register(team_five)
    >>> flush_database_updates()
    >>> mailinglist_api.reportStatus({
    ...     'team-four': 'success',
    ...     'team-five': 'success',
    ...     })
    >>> mailinglist_api.getPendingActions()
    {}

Now, when a mailing list's welcome message is changed, Mailman will see this
modification action the next time it polls.

    >>> list_four.welcome_message = u'Welcome to Team Four'
    >>> list_five.welcome_message = u'Welcome to Team Five'
    >>> flush_database_updates()
    >>> print_actions(mailinglist_api.getPendingActions())
    team-four --> modify, {'welcome_message': u'Welcome to Team Four'}

Let's say that the change was successful for one of the lists, but failed for
the other...

    >>> mailinglist_api.reportStatus({
    ...     'team-four': 'success',
    ...     'team-five': 'failed',
    ...     })

...this is reflected in the status of the mailing lists in the database.

    >>> list_four.status.name
    'ACTIVE'
    >>> list_five.status.name
    'FAILED'
