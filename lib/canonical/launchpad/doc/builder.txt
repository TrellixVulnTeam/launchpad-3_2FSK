= Builder Class =

This test aims to meet the requirements of
<https://launchpad.canonical.com/BasicTestCoverage> for the Builder class,
which represents the Buildd Slave entity.

Need auxiliar methods from zope toolchain:

    >>> from canonical.launchpad.webapp.testing import verifyObject
    >>> from zope.component import getUtility

Importing Builder content class and its interface:

    >>> from canonical.launchpad.database import Builder
    >>> from canonical.launchpad.interfaces import IBuilder

Get an instance of Builder from the current sampledata:

    >>> builder = Builder.get(1)

Test some attributes:

    >>> builder.id, builder.name
    (1, u'bob')

Test 'status' property:

    >>> builder.failnotes = 'Could not open Socket'
    >>> print builder.status
    Could not open Socket

    >>> builder.builderok = True
    >>> print builder.status
    Building i386 build of mozilla-firefox 0.9 in ubuntu hoary RELEASE

    >>> builder.manual = True
    >>> print builder.status
    Building i386 build of mozilla-firefox 0.9 in ubuntu hoary RELEASE

Confirm we can get the slave xmlrpc interface

    >>> s = builder.slave

Confirm that the urlbase is correct in that slave. (If the protocol changes,
this may change too)

    >>> s.urlbase == builder.url
    True

Check if the instance corresponds to the declared interface:

    >>> verifyObject(IBuilder, builder)
    True


== BuilderSet ==

Now perform the tests for the Builder ContentSet class, BuilderSet.

Check if it can be imported:

    >>> from canonical.launchpad.interfaces import IBuilderSet

Check we can use the set as a utility:

    >>> builderset = getUtility(IBuilderSet)

Check if the instance returned as utility corresponds to its
respective interface:

    >>> verifyObject(IBuilderSet, builderset)
    True

Check if the instance is iterable:

    >>> for b in builderset:
    ...     b.id
    1
    2

Check if the __getitem__ method:

    >>> builderset['bob'].name
    u'bob'

Check now the specific method in the utility as new():

    >>> bnew = builderset.new(1, 'http://dummy.com:8221/', 'dummy',
    ...	                   'Dummy Title', 'eh ?', 1)
    >>> bnew.name
    u'dummy'

Check get() which returns a correspondent Builder instance to a given id:

    >>> builderset.get(bnew.id).name
    u'dummy'

Or raises an SQLObjectNotFound exception:

    >>> builderset.get(100)
    Traceback (most recent call last):
    ...
    SQLObjectNotFound: Object not found

count() return the number of builder instance we have stored:

    >>> builderset.count()
    3

getBuilder() method returns all the builders available. It seems the
same than the own instance but we have plans to turn it aware of some
attributes of builder instance as: builderok and trust.

    >>> for b in builderset.getBuilders():
    ...     b.name
    u'bob'
    u'dummy'
    u'frog'

'getBuildQueueSizeForProcessor' returns the number of pending builds
for a given Processor. The callsites can also control which build-farm
they are interested via the 'virtualized' argument.

    >>> from canonical.launchpad.database.processor import Processor
    >>> p386 = Processor.selectOneBy(name='386')
    >>> amd64 = Processor.selectOneBy(name='amd64')

'virtualized' defaults to False, so if not passed, it will return the
size of the non-virtualized (trusted) build queue.

    >>> builderset.getBuildQueueSizeForProcessor(p386)
    1

The 'amd64' build queue is empty.

    >>> builderset.getBuildQueueSizeForProcessor(amd64)
    0

The virtualized build queue for 386 is also empty.

    >>> builderset.getBuildQueueSizeForProcessor(p386, virtualized=True)
    0


== Resuming buildd slaves ==

Virtual slaves are resumed using a command specified in the
configuration profile. Production configuration uses a SSH trigger
account accessed via a private key available in the builddmaster
machine (which used ftpmaster configuration profile) as in:

{{{
ssh ~/.ssh/ppa-reset-key ppa@%(vm_host)s
}}}

The test configuration uses a fake command that can be performed in
development machine and allow us to tests the important features used
in production, as 'vm_host' variable replacement.

    >>> from canonical.config import config
    >>> config.builddmaster.vm_resume_command
    'echo %(vm_host)s'

Before performing the command, it checks if the builder is indeed
virtual and raises CannotResumeHost if it isn't.

    >>> bob = getUtility(IBuilderSet)['bob']
    >>> bob.resumeSlaveHost()
    Traceback (most recent call last):
    ...
    CannotResumeHost: Builder is not virtualized.

For testing purposes resumeSlaveHost returns the stdout and stderr
buffer resulted from the command.

    >>> frog = getUtility(IBuilderSet)['frog']
    >>> out, err = frog.resumeSlaveHost()
    >>> print out.strip()
    localhost-host.ppa

If the specified command fails, resumeSlaveHost also raises
CannotResumeHost exception with the results stdout and stderr.

    # The command must have a vm_host dict key and when executed,
    # have a returncode that is not 0.
    >>> vm_resume_command = """
    ...     [builddmaster]
    ...     vm_resume_command: test "%(vm_host)s = 'false'"
    ...     """
    >>> config.push('vm_resume_command', vm_resume_command)
    >>> frog.resumeSlaveHost()
    Traceback (most recent call last):
    ...
    CannotResumeHost: Resuming failed:
    OUT:
    <BLANKLINE>
    ERR:
    <BLANKLINE>

Restore default value for resume command.

    >>> config_data = config.pop('vm_resume_command')

