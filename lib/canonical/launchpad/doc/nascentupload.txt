== The nascent uploads ==

(First some setup. We need a librarian for this test.)

  >>> from canonical.librarian.ftests.harness import LibrarianTestSetup
  >>> LibrarianTestSetup().setUp()

We also need to set up the OpenPGP key used to sign things so that we can
identify the upload signer later on.

  >>> from canonical.launchpad.interfaces import IGPGKeySet
  >>> from canonical.lp.dbschema import GPGKeyAlgorithm
  >>> discarded_key = getUtility(IGPGKeySet).new(26, '20687895',
  ...     '961F4EB829D7D304A77477822BC8401620687895', 1024, GPGKeyAlgorithm.D)

Next we import the test keys so we have them ready for verification

  >>> from canonical.launchpad.ftests import import_public_test_keys
  >>> import_public_test_keys()

We need to be logged into the security model in order to get any further

  >>> login('foo.bar@canonical.com')

For the purpose of this test, hoary needs to be an open (development)
distrorelease so that we can upload to it.

  >>> from canonical.launchpad.interfaces import IDistributionSet
  >>> ubuntu = getUtility(IDistributionSet)['ubuntu']
  >>> hoary = ubuntu['hoary']
  >>> from canonical.lp.dbschema import DistributionReleaseStatus
  >>> hoary.releasestatus = DistributionReleaseStatus.DEVELOPMENT

A nascent upload is a collection of files in a directory. They
represent what may turn out to be an acceptible upload to a launchpad
managed archive.

  >>> from canonical.archivepublisher.nascentupload import NascentUpload
  >>> from canonical.archivepublisher.uploadpolicy import findPolicyByName
  >>> from canonical.archivepublisher.tests import datadir

  >>> class MockLogger:
  ...     def debug(self, s):
  ...         print "DEBUG:", s

The policy we feed to to the nascent upload needs to have its command
line options passed in.

  >>> class MockOptions:
  ...     distro = "ubuntu"
  ...     distrorelease = "hoary"

  >>> class BuilddOptions(MockOptions):
  ...     buildid = 1

  >>> buildd_policy = findPolicyByName('buildd')
  >>> buildd_policy.setOptions(BuilddOptions())

When initially constructing a NascentUpload instance, it verifies that
the changes file specified exists, raising FileNotFound if it does not.

  >>> NascentUpload(buildd_policy, datadir(""), "DOES-NOT-EXIST",
  ...     MockLogger())
  Traceback (most recent call last):
  ...
  FileNotFound: DOES-NOT-EXIST
  >>> ed_upload = NascentUpload(findPolicyByName('insecure'),
  ...     datadir(''), "ed_0.2-20_i386.changes", MockLogger())
  >>> ed_upload.changes_filename == datadir("ed_0.2-20_i386.changes")
  True
  >>> ed_upload.policy.setOptions(MockOptions())

The nascent upload contains files (assuming it's sane) and as such we
have a NascentUploadedFile type to represent them.

  >>> from canonical.archivepublisher.nascentupload import NascentUploadedFile

To construct a nascentuploadedfile we need an fsroot and a line from a
Files section of a changes file.

  >>> nuf = NascentUploadedFile(
  ...     datadir(''),
  ...     ' 0c466ce6a160c62fa558fbbb46a4ea45 44718 editors important '
  ...     'ed_0.2-20_i386.deb')
  >>> nuf.filename
  'ed_0.2-20_i386.deb'
  >>> nuf._size
  44718
  >>> nuf._digest
  '0c466ce6a160c62fa558fbbb46a4ea45'
  >>> nuf.section
  'editors'
  >>> nuf.priority
  'important'

When we ask the object for its size or digest through the properties,
it will check them. If they're correct, no exception will be raised.

  >>> nuf.size
  44718
  >>> nuf.digest
  '0c466ce6a160c62fa558fbbb46a4ea45'
  >>> nuf.sha_digest
  'e5c467ca14ab67f73f8cbb9bb9016f670b14c8b7'
  >>> nuf._values_checked
  True

Going back to the upload itself, at a very basic level a NascentUpload
allows us to probe the contents of the changes file to see things like
the maintainer.

  >>> ed_upload.changes['maintainer']
  'James Troup <james@nocrew.org>'

We can also extract the list of files from the upload. If this raises
an exception then the file list is utterly broken.

  >>> for uploaded_file in ed_upload.files:
  ...     print uploaded_file.filename
  ed_0.2-20.dsc
  ed_0.2-20.diff.gz
  ed_0.2-20_i386.deb

The nascent upload can tell us if it is sourceful or not, (ditto binaryful)

  >>> ed_upload.sourceful
  True
  >>> ed_upload.binaryful
  True
  >>> ed_upload.archindep
  False
  >>> ed_upload.archdep
  True

  >>> ed_source_upload = NascentUpload(buildd_policy,
  ...     datadir(''), "ed_0.2-20_i386.source-only-unsigned-changes",
  ...     MockLogger)
  >>> ed_source_upload.sourceful
  True
  >>> ed_source_upload.binaryful
  False

  >>> ed_binary_upload = NascentUpload(buildd_policy,
  ...     datadir(''), "ed_0.2-20_i386.binary-only-unsigned-changes",
  ...     MockLogger)
  >>> ed_binary_upload.sourceful
  False
  >>> ed_binary_upload.binaryful
  True
  >>> ed_binary_upload.archdep
  True
  >>> ed_binary_upload.archindep
  False


If the Architecture line does not match then we get an exception.

  >>> ed_mismatched_upload = NascentUpload(buildd_policy,
  ...     datadir(''), "ed_0.2-20_i386.mismatched-arch-unsigned-changes",
  ...     MockLogger())
  >>> ed_mismatched_upload.sourceful
  True
  >>> ed_mismatched_upload.rejection_message
  'Mismatch in binaryfulness. (arch) False != (files) True\nOne or more files uploaded with specific architecture but changes file does not list it.'

We can distinguish between the arch-indep and arch-dep binary uploads.

  >>> quodlibet = NascentUpload(buildd_policy,
  ...     datadir(''), "quodlibet_0.13.1-1_i386.changes", MockLogger())
  >>> quodlibet.sourceful
  False
  >>> quodlibet.binaryful
  True
  >>> quodlibet.archdep
  True
  >>> quodlibet.archindep
  True

We can ask sourceful uploads if they are native or not. If they are
not native we can find out if they have an orig.tar.gz or not.

  >>> ed_upload.native
  False
  >>> ed_upload.hasorig
  False

If we ask a non-sourceful upload about its native or hasorig status it
should throw an exception because non-sourceful uploads have no
concept of nativeness.

  >>> ed_binary_upload.native
  Traceback (most recent call last):
  ...
  UploadError: Attempted to ask a non-sourceful upload if it is native or not.


We can parse addresses and look them up in launchpad.

  >>> addr = ed_upload.parse_address("Foo Bar <foo.bar@canonical.com>")
  >>> addr['person'].displayname
  u'Foo Bar'

If the address is unparsable, we get an error.

  >>> ed_upload.parse_address("Cannot Parse Me <FOOO>")
  Traceback (most recent call last):
  ...
  UploadError: Cannot Parse Me <FOOO>: no @ found in email address part.



The upload can extract distributions and distroreleases if it tries
  >>> ed_upload.distro.name
  u'ubuntu'
  >>> ed_upload.distrorelease.name
  u'hoary'

The policy we've used so far won't allow us to upload binary or
mixed-mode sets. We'll override this for our test set...

  >>> ed_upload.policy.can_upload_binaries = True
  >>> ed_upload.policy.can_upload_mixed = True

Finally we can ask the upload to process itself.
  >>> from canonical.launchpad.database import (
  ...     SourcePackageName, BinaryPackageName, DistroRelease)
  >>> hoary = DistroRelease.get(3)
  >>> saved_list = hoary.changeslist
  >>> hoary.changeslist = "dapper-announce@lists.ubuntu.com"
  >>> hoary.sync()
  >>> ed_upload.distrorelease.changeslist
  u'dapper-announce@lists.ubuntu.com'
  >>> ed_upload.process()
  DEBUG: Beginning processing.
  DEBUG: Checking signature on changes file.
  DEBUG: Verifying signature on ed_0.2-20_i386.changes
  DEBUG: Verifying the changes file.
  DEBUG: Verifying files in upload.
  DEBUG: Verifying source file ed_0.2-20.dsc
  DEBUG: Verifying signature on .../data/ed_0.2-20.dsc
  DEBUG: Verifying source file ed_0.2-20.diff.gz
  DEBUG: Verifying binary ed_0.2-20_i386.deb
  DEBUG: Performing overall file verification checks.
  DEBUG: Performing DSC verification.
  DEBUG: Verifying uploaded source package by unpacking it.
  DEBUG: Cleaning up source tree.
  DEBUG: Done
  DEBUG: Verifying timestamps in ed_0.2-20_i386.deb
  DEBUG: Finding and applying overrides.
  DEBUG: getPublishedReleases()
  DEBUG: 0 possible source(s)
  DEBUG: ed: (source) NEW
  DEBUG: Checking against i386 for ed
  DEBUG: getReleasedPackages() returned 0 possibilit{y,ies}
  DEBUG: ed: (binary) NEW
  DEBUG: Daniel Silverstone (26) is in main's uploaders.
  DEBUG: Daniel Silverstone (26) is in restricted's uploaders.
  DEBUG: Daniel Silverstone (26) is in universe's uploaders.
  DEBUG: Finished checking upload.
  >>> print ed_upload.rejection_message+"\nEND"
  END
  >>> ed_upload.rejected
  False
  >>> success, msgs = ed_upload.do_accept()
  DEBUG: Building recipients list.
  DEBUG: Attempting to decide if James Troup is in the keyring.
  DEBUG: Decision: False
  DEBUG: Build 13 created
  DEBUG: Creating a New queue entry
  >>> print success
  True
  >>> for msg in msgs:
  ...     print msg, "END"
  From: Root <root@localhost>
  To: Root <root@localhost>, Daniel Silverstone <daniel.silverstone@canonical.com>
  Precedence: bulk
  Subject: ed_0.2-20_i386.changes is NEW
  <BLANKLINE>
  NEW: ed_0.2-20.dsc
   OK: ed_0.2-20.diff.gz
  NEW: ed_0.2-20_i386.deb
  <BLANKLINE>
  -----BEGIN PGP SIGNED MESSAGE-----
  Hash: SHA1
  <BLANKLINE>
  Format: 1.7
  Date: Wed,  2 Apr 2003 17:19:47 +0100
  Source: ed
  Binary: ed
  Architecture: source i386
  Version: 0.2-20
  Distribution: unstable
  Urgency: low
  Maintainer: James Troup <james@nocrew.org>
  Changed-By: James Troup <james@nocrew.org>
  Description:
   ed         - The classic unix line editor
  Closes: 122517 130327 179957
  Changes:
   ed (0.2-20) unstable; urgency=low
   .
     * Move to dpatch; existing non-debian/ changes split into
       01_buf.c-tmpfile, 02_-Wall-cleanup, 03_ed.1-cleanup and
       04_Makfile.in-no-libed.
     * debian/rules: include /usr/share/dpatch/dpatch.make.
     * debian/rules (build): depend on patch-stamp.
     * debian/rules (clean): depend on unpatch.  Remove debian/patched.
     * debian/rules (.PHONY): add 'patch' and 'unpatch'.
     * debian/control (Build-Depends): add dpatch.
   .
     * debian/rules: update copyright.
     * debian/copyright: likewise and update upstream URL.
     * debian/changelog: remove local-variables stuff.
   .
     * debian/rules: use install_foo convenience variables.
     * debian/rules (clean): remove *~ in any subdirectory.
   .
     * debian/control (Standards-Version): bump to 3.5.8.0.
     * debian/postinst, debian/prerm: no longer do /usr/doc symlinks.
   .
     * config, test/*: unused aegis cruft; removed.
     * Undo s/%/$/ change in RCS keywords.
   .
     * debian/postinst: provide editor.1.gz alternative; thanks to Ben Harris
       <bjh21@cam.ac.uk> for the suggestion.  Closes: #122517
     * 05_ed.1-warning-fix.dpatch: new patch to avoid groff warnings.  Thanks
       to Colin Watson <cjwatson@debian.org>.  Closes: #179957
     * 06_testsuite-Makefile.dpatch: new patch to ensure the test suite bombs
       out on errors.  Thanks to Joel Baker <fenton@debian.org>.
       Closes: #130327
  Files:
   22beb6b9d1fe984cd3a20571a4e958ac 522 editors important ed_0.2-20.dsc
   f9e1e5f13725f581919e9bfd62272a05 8506 editors important ed_0.2-20.diff.gz
   0c466ce6a160c62fa558fbbb46a4ea45 44718 editors important ed_0.2-20_i386.deb
  <BLANKLINE>
  -----BEGIN PGP SIGNATURE-----
  Version: GnuPG v1.4.1 (GNU/Linux)
  <BLANKLINE>
  iD8DBQFDTWC+K8hAFiBoeJURAnA7AJ9i9ZjWjtqUQ+nFJfPnsjOmfUq6DQCffPZZ
  nwN7DFh8fuhURm3VCzcwIGc=
  =jANz
  -----END PGP SIGNATURE-----
  <BLANKLINE>
  <BLANKLINE>
  Your package contains new components which requires manual editing of
  the override file.  It is ok otherwise, so please be patient.  New
  packages are usually added to the overrides about once a week.
  <BLANKLINE>
  You may have gotten the distrorelease wrong.  If so, you may get warnings
  above if files already exist in other distroreleases.
  END

Retrive the just-inserted SourcePackageRelease correspondent to 'ed'
(it's the only one we have, the process to retrieve a non-published
SPR w/o at least and DRQ entry is quite unusual)

  >>> from canonical.launchpad.database import (
  ...     SourcePackageRelease, SourcePackageName)
  >>> ed_name = SourcePackageName.selectOneBy(name='ed')
  >>> ed_spr = SourcePackageRelease.selectBy(sourcepackagenameID=ed_name.id)[0]

Check if we have rebuid the change's author line properly (as
mentioned in bug # 30621)

  >>> print ed_spr.changelog
  ed (0.2-20) unstable; urgency=low
  ...
   -- James Troup <james@nocrew.org>  Wed,  2 Apr 2003 17:19:47 +0100

Roll back everything so that we can try again

  >>> import transaction
  >>> transaction.abort()

First up, construct an upload of just the ed source...

  >>> class MockMunchyLogger:
  ...     def debug(self, s):
  ...         pass

  >>> ed_src = NascentUpload(findPolicyByName('sync'), 
  ...          datadir('split-upload-test'), "ed_0.2-20_source.changes", 
  ...          MockMunchyLogger())
  >>> ed_src.policy.setOptions(MockOptions())
  >>> ed_src.process()
  >>> ed_src.rejected
  False
  >>> success, msgs = ed_src.do_accept()
  >>> success
  True

The ed source would be in NEW, so punt it into accepted.

  >>> from canonical.lp.dbschema import DistroReleaseQueueStatus
  >>> from canonical.launchpad.interfaces import QueueInconsistentStateError
  >>> new_queue = hoary.getQueueItems(DistroReleaseQueueStatus.NEW)
  >>> for item in new_queue:
  ...     try:
  ...         print "%s/%s" % (item.sourcepackagename.name, 
  ...                          item.sourceversion)
  ...         item.set_accepted()
  ...         item.sync()
  ...     except QueueInconsistentStateError, info:
  ...         print info
  ed/0.2-20


Next we send in the binaries, since the source should be in ACCEPTED the
binary should go straight there too.

  >>> ed_bin = NascentUpload(findPolicyByName('sync'), 
  ...          datadir('split-upload-test'), "ed_0.2-20_i386.changes", 
  ...          MockMunchyLogger())
  >>> ed_bin.policy.setOptions(MockOptions())
  >>> ed_bin.policy.can_upload_binaries = True
  >>> ed_bin.process()
  >>> ed_bin.rejected
  False
  >>> print ed_bin.rejection_message+"\nEND"
  END
  >>> success, msgs = ed_bin.do_accept()
  >>> success
  True

Chuck it all away again

  >>> transaction.abort()

And this time, try an upload to -updates, it'll have to be signed etc because
we're using the insecure policy to check everything in it end-to-end

  >>> ed_src = NascentUpload(findPolicyByName('sync'), 
  ...          datadir('updates-upload-test'), "ed_0.2-20_source.changes", 
  ...          MockMunchyLogger())
  >>> ed_src.policy.setOptions(MockOptions())
  >>> ed_src.policy.distrorelease = None # Override this by the changes
  >>> ed_src.process()
  >>> ed_src.rejected
  False
  >>> success, msgs = ed_src.do_accept()
  >>> success
  True
  >>> print ed_src.queue_root.pocket.name
  UPDATES

Even though this went to a pocket and thus would be unapproved rather
than accepted, the ed upload ought still make it to NEW instead of
unapproved.

  >>> print ed_src.queue_root.status.name
  NEW

Check the uploader behaviour against a missing orig.tar.gz file,
bug # 30741.

  >>> ed21_src = NascentUpload(findPolicyByName('sync'),
  ...          datadir('ed-0.2-21'), "ed_0.2-21_source.changes",
  ...          MockMunchyLogger())
  >>> ed21_src.policy.setOptions(MockOptions())
  >>> ed21_src.process()
  >>> ed21_src.rejected
  True
  >>> print ed21_src.rejection_message+"\nEND"
  Unable to find ed_0.2.orig.tar.gz in the distribution.
  END

Next let's throw the whole thing out again and try once more having purged
the ACLs for the uploader

  >>> transaction.abort()
  >>> from canonical.launchpad.database import DistroComponentUploader, Person
  >>> for x in DistroComponentUploader.select():
  ...     x.uploader = Person.get(1)

Ensure that the key is attached to the database...

  >>> discarded_key = getUtility(IGPGKeySet).new(26, '20687895',
  ...     '961F4EB829D7D304A77477822BC8401620687895', 1024, GPGKeyAlgorithm.D)

This time the upload should fail because the ACLs don't let person 26 upload

  >>> ed_src = NascentUpload(findPolicyByName('insecure'), 
  ...          datadir(''), "ed_0.2-20_i386.changes", 
  ...          MockMunchyLogger())
  >>> ed_src.policy.setOptions(MockOptions())
  >>> ed_src.policy.can_upload_binaries = True
  >>> ed_src.policy.can_upload_mixed = True
  >>> ed_src.process()
  >>> ed_src.rejected
  True
  >>> print ed_src.rejection_message+"\nEND"
  Signer has no upload rights at all to this distribution.
  END

(and some tear down)

  >>> transaction.abort()
  >>> LibrarianTestSetup().tearDown()
