= PO Imports =

The tale of a PO template and a PO file and how they get imported into
Rosetta.


== Test Setup ==

Here are some imports we need to get this test running.

    >>> from canonical.launchpad.ftests import syncUpdate
    >>> from canonical.launchpad.interfaces import (
    ...     ILanguageSet, ILaunchpadCelebrities, IPersonSet, IProductSet,
    ...     ITranslationImportQueue)
    >>> from canonical.launchpad.database import (
    ...     POTemplateSubset, SourcePackageName)
    >>> from canonical.launchpad.scripts.po_import import (
    ...     AutoApproveProcess, ImportProcess)
    >>> import datetime
    >>> import pytz
    >>> UTC = pytz.timezone('UTC')

We need this for the Librarian to work properly.

    >>> import transaction

And also, the DBSchema to change the imports status

    >>> from canonical.launchpad.interfaces import RosettaImportStatus

Here's a fake logger to capture any errors that happen.

    >>> from canonical.launchpad.scripts import FakeLogger

Login as an admin to be able to do changes to the import queue.

    >>> login('carlos@canonical.com')


== Importing a Template ==

Normal procedure is to import a template, followed by translations.
A template is created first.  After that, imports are done using the
POFile.importFromQueue and POTemplate.importFromQueue methods.

    >>> from canonical.launchpad.database import ProductRelease
    >>> release = ProductRelease.get(3)
    >>> release.productseries.product.name
    u'firefox'
    >>> series = release.productseries
    >>> subset = POTemplateSubset(productseries=series)

Here's the person who'll be doing the import.

    >>> person_set = getUtility(IPersonSet)
    >>> person = person_set.getByName('sabdfl')

And this is the POTemplate where the import will be done.

    >>> potemplate = subset.new(
    ...     name='firefox',
    ...     translation_domain='firefox',
    ...     path='po/firefox.pot',
    ...     owner=person)
    >>> potemplate_id = potemplate.id

This is the file that'll get imported.

    >>> potemplate_contents = r'''
    ... msgid ""
    ... msgstr ""
    ... "POT-Creation-Date: 2004-07-11 16:16+0900\n"
    ... "Content-Type: text/plain; charset=CHARSET\n"
    ... "Plural-Forms: nplurals=INTEGER; plural=EXPRESSION;\n"
    ... "X-Rosetta-Export-Date: %s\n"
    ...
    ... msgid "foo"
    ... msgstr ""
    ...
    ... msgid "bar"
    ... msgstr ""
    ...
    ... #: test.c:13
    ... msgid "baz"
    ... msgstr ""
    ...
    ... #, c-format
    ... msgid "Foo %%s"
    ... msgstr ""
    ...
    ... #, c-format
    ... msgid "Singular %%d"
    ... msgid_plural "Plural %%d"
    ... msgstr[0] ""
    ... msgstr[1] ""
    ...
    ... msgid "translator-credits"
    ... msgstr ""
    ... ''' % datetime.datetime.now(UTC).isoformat()

Attach the import to the translations import queue:

    >>> translation_import_queue = getUtility(ITranslationImportQueue)
    >>> entry = translation_import_queue.addOrUpdateEntry(
    ...     potemplate.path, potemplate_contents, True, potemplate.owner,
    ...     productseries=series, potemplate=potemplate)

The file data is stored in the Librarian, so we have to commit the
transaction to make sure it's stored properly.

    >>> transaction.commit()

The entry gets approved, so it can be imported.

    >>> entry.status = RosettaImportStatus.APPROVED

    >>> import datetime
    >>> import pytz
    >>> UTC = pytz.timezone('UTC')
    >>> saved_date = datetime.datetime.now(UTC)

Now, we tell the PO template to import from the file data it has.

    >>> (subject, body) = potemplate.importFromQueue(entry, FakeLogger())

Our request has now been serviced.

    >>> print entry.status.name
    IMPORTED

The last update date is the one we got.

    >>> potemplate.date_last_updated > saved_date
    True

A successful import is confirmed by email.

    >>> subject
    u'Translation template import - firefox in Mozilla Firefox trunk'
    >>> print body
    Hello Mark Shuttleworth,
    <BLANKLINE>
    On ..., you uploaded a translation
    template for firefox in Mozilla Firefox trunk in Launchpad.
    <BLANKLINE>
    The template has now been imported successfully.
    <BLANKLINE>
    Thank you,
    <BLANKLINE>
    The Launchpad team

The correct message IDs now show up in the template.

    >>> potmsgsets = list(potemplate.getPOTMsgSets())
    >>> [potmsgset.msgid_singular.msgid for potmsgset in potmsgsets]
    [u'foo', u'bar', u'baz', u'Foo %s', u'Singular %d', u'translator-credits']

The file references field should be there

    >>> potmsgsets[2].filereferences
    u'test.c:13'


=== Import Preconditions ===

The API for POTemplate.importFromQueue demands a translation import
queue entry to import.

    >>> potemplate.importFromQueue(None)
    Traceback (most recent call last):
    ...
    AssertionError: Attempt to import None entry.

The entry must have been approved for import.

    >>> potemplate.importFromQueue(entry)
    Traceback (most recent call last):
    ...
    AssertionError: Attempt to import non-approved entry.

The entry indicates what file it is to be imported to; importing it to
any other file would be an error.

    >>> entry.status = RosettaImportStatus.APPROVED
    >>> from canonical.launchpad.interfaces import IPOTemplateSet
    >>> other_product = getUtility(IProductSet).getByName('netapplet')
    >>> other_productseries = other_product.getSeries('trunk')
    >>> template_set = getUtility(IPOTemplateSet)
    >>> other_template = template_set.getPOTemplateByPathAndOrigin(
    ...     'po/netapplet.pot', productseries=other_productseries)
    >>> other_template.importFromQueue(entry)
    Traceback (most recent call last):
    ...
    AssertionError: Attempt to import entry to POTemplate it doesn't belong
    to.


== Importing a Translation ==

Now let's get a PO file to import.

    >>> pofile = potemplate.newPOFile('cy')
    >>> pofile_id = pofile.id

By default, we got a safe path to prevent collisions with other IPOFile.

    >>> pofile.path
    u'po/firefox-cy.po'

Let's override the default good path with one we know is the right one.

    >>> pofile.setPathIfUnique(u'po/cy.po')

It's newly created, so it has no translated messages yet.

    >>> pofile.getPOTMsgSetTranslated().count()
    0

And the statistics reflect it.

    >>> pofile.currentCount()
    0


=== Import With Errors ===

Here are the contents of the file we'll be importing. It has some
validation errors.

    >>> pofile_with_errors = r'''
    ... msgid ""
    ... msgstr ""
    ... "PO-Revision-Date: 2005-06-03 19:41+0100\n"
    ... "Last-Translator: Carlos Perello Marin <carlos@canonical.com>\n"
    ... "Content-Type: text/plain; charset=UTF-8\n"
    ... "Plural-Forms: nplurals=4; plural=n==1) ? "
    ...     "0 : n==2 ? 1 : (n != 8 || n != 11) ? 2 : 3;\n"
    ... "X-Rosetta-Export-Date: %s\n"
    ...
    ... msgid "foo"
    ... msgstr "blah"
    ...
    ... #, fuzzy
    ... msgid "bar"
    ... msgstr "heffalump"
    ...
    ... msgid "balloon"
    ... msgstr "blah"
    ...
    ... #, c-format
    ... msgid "Foo %%s"
    ... msgstr "blah %%i"
    ...
    ... #, c-format
    ... msgid "Singular %%d"
    ... msgid_plural "Plural %%d"
    ... msgstr[0] "Foos %%d"
    ... msgstr[1] "Bars %%d"
    ... msgstr[2] "Welsh power! %%d"
    ... msgstr[3] "We have four! %%d"
    ... ''' % datetime.datetime.now(UTC).isoformat()

This is the dbschema that controls the validation of a translation.

    >>> from canonical.launchpad.interfaces import TranslationValidationStatus

The process of importing a PO file is much like that of importing a PO
template. Remember, we need to tell the system that this po file is an
"imported" one.

    >>> entry = translation_import_queue.addOrUpdateEntry(
    ...     pofile.path, pofile_with_errors, True, person,
    ...     productseries=series, potemplate=potemplate)
    >>> transaction.commit()

The guess IPOFile should be the same we already had.

    >>> entry.getGuessedPOFile().id == pofile.id
    True

Set it as the place where the entry should be imported.

    >>> entry.pofile = entry.getGuessedPOFile()

We must approve the entry to be able to import it.

    >>> entry.status = RosettaImportStatus.APPROVED

And we do the import.

    >>> (subject, body) = pofile.importFromQueue(entry, FakeLogger())
    >>> flush_database_updates()

The status is now IMPORTED:

    >>> print entry.status.name
    IMPORTED

And the statistics reflect it.

    >>> pofile.currentCount()
    3

Here's a current message: i.e. it has a corresponding current message
set in the PO template.

    >>> message = pofile.translation_messages[0]
    >>> message.potmsgset.msgid_singular.msgid
    u'foo'

And should be accepted by our validator.

    >>> published = message.potmsgset.getImportedTranslationMessage(
    ...     pofile.language)
    >>> published.validation_status == TranslationValidationStatus.OK
    True

Fuzzy translations are ignored.

    >>> message = pofile[u'bar']
    >>> message.translations
    [None]

We can also get the ones that have validation errors.

    >>> potmsgsets = pofile.getPOTMsgSetWithErrors()
    >>> potmsgsets.count()
    1
    >>> for potmsgset in potmsgsets:
    ...     translationmessages = potmsgset.getLocalTranslationMessages(
    ...         pofile.language)
    ...     for translationmessage in translationmessages:
    ...         assert (
    ...             translationmessage.validation_status ==
    ...             TranslationValidationStatus.UNKNOWNERROR), (
    ...             "Doesn't have a validation error")

Check that the plural form was imported correctly.

    >>> potmsgset = pofile.potemplate.getPOTMsgSetByMsgIDText(
    ...     u'Singular %d', u'Plural %d')
    >>> imported_translationmessage = potmsgset.getImportedTranslationMessage(
    ...     pofile.language)
    >>> print imported_translationmessage.validation_status.name
    OK
    >>> imported_translationmessage.translations
    [u'Foos %d', u'Bars %d', u'Welsh power! %d', u'We have four! %d']

The owner for those translations should be Carlos, instead of the person
that did the upload, because the imported file states that Carlos is the
translator.

    >>> imported_translationmessage.submitter.displayname
    u'Carlos Perell\xf3 Mar\xedn'

The import process produces an email warning us of partial failure.

    >>> subject
    u'Translation problems - Welsh (cy) - firefox in Mozilla Firefox trunk'
    >>> print body
    Hello Mark Shuttleworth,
    <BLANKLINE>
    On ..., you uploaded 4
    Welsh (cy) translations for firefox in Mozilla Firefox trunk in Launchpad.
    <BLANKLINE>
    There were problems with 1 of these translations.
    <BLANKLINE>
    4. "format spec... 'msgid' and 'msgstr' for argument 1 are not the same":
    <BLANKLINE>
    #, c-format
    msgid "Foo %s"
    msgstr "blah %i"
    <BLANKLINE>
    <BLANKLINE>
    <BLANKLINE>
    The other 3 translations have been accepted.
    <BLANKLINE>
    ...


=== Import Without Errors ===

Now, let's import one without errors.

    >>> rosetta_experts = getUtility(ILaunchpadCelebrities).rosetta_experts
    >>> pofile_without_errors = r'''
    ... msgid ""
    ... msgstr ""
    ... "PO-Revision-Date: 2005-06-03 20:41+0100\n"
    ... "Last-Translator: Foo <no-priv@canonical.com>\n"
    ... "Content-Type: text/plain; charset=UTF-8\n"
    ... "Plural-Forms: nplurals=4; plural=n==1) ? "
    ...     "0 : n==2 ? 1 : (n != 8 || n != 11) ? 2 : 3;\n"
    ... "X-Rosetta-Export-Date: %s\n"
    ...
    ... msgid "foo"
    ... msgstr "blah"
    ...
    ... msgid "translator-credits"
    ... msgstr "helpful@example.com"
    ... ''' % datetime.datetime.now(UTC).isoformat()
    >>> entry = translation_import_queue.addOrUpdateEntry(
    ...     pofile.path, pofile_without_errors, True, rosetta_experts,
    ...     productseries=series, potemplate=potemplate)
    >>> transaction.commit()

The guess IPOFile should be the same we already had.

    >>> entry.getGuessedPOFile().id == pofile.id
    True

Set it as the place where the entry should be imported.

    >>> entry.pofile = entry.getGuessedPOFile()

We must approve the entry to be able to import it.

    >>> entry.status = RosettaImportStatus.APPROVED

At this point, the statistics note that we have 3 translations coming
from imported files (currentCount), and none updated or added in
Launchpad Translations.

    >>> pofile.currentCount()
    3
    >>> pofile.updatesCount()
    0
    >>> pofile.rosettaCount()
    0

We do the import.

    >>> (subject, body) = pofile.importFromQueue(entry, FakeLogger())

The status is now IMPORTED:

    >>> print entry.status.name
    IMPORTED

Now, the statistics note that we have two translations coming from
imported files (currentCount), which is the translation we just
imported, and the other two translation that was coming from imported
files are now counted as coming from Launchpad translations
(rosettaCount) because latest imported file doesn't have them anymore.

    >>> pofile.currentCount()
    2
    >>> pofile.updatesCount()
    0
    >>> pofile.rosettaCount()
    2

This time, our notification email reports complete success.

    >>> subject
    u'Translation import - Welsh (cy) - firefox in Mozilla Firefox trunk'
    >>> print body
    Hello Rosetta Administrators,
    <BLANKLINE>
    ...

The translation has been augmented with the strings from the imported
file.  The translation credits are special; upstream uploads can
"translate" credits messages to provide translator names, but since
credits for translations in Launchpad are generated automatically,
non-upstream translations for these messages are ignored.

    >>> pofile['foo'].msgstr0.translation
    u'blah'
    >>> pofile['translator-credits'].msgstr0.translation
    u'helpful@example.com'


=== Import Preconditions ===

The API for POFile.importFromQueue demands a translation import queue
entry to import.

    >>> pofile.importFromQueue(None)
    Traceback (most recent call last):
    ...
    AssertionError: Attempt to import None entry.

The entry must have been approved for import.

    >>> pofile.importFromQueue(entry)
    Traceback (most recent call last):
    ...
    AssertionError: Attempt to import non-approved entry.

The entry indicates what file it is to be imported to; importing it to
any other file would be an error.

    >>> entry.status = RosettaImportStatus.APPROVED
    >>> other_pofile = potemplate.newPOFile('de')
    >>> other_pofile.importFromQueue(entry)
    Traceback (most recent call last):
    ...
    AssertionError: Attempt to import entry to POFile it doesn't belong to.

Even importing a translation into its own template is wrong; it must be
the exact right POFile.

    >>> potemplate.importFromQueue(entry)
    Traceback (most recent call last):
    ...
    AssertionError: Attempt to import entry to POTemplate it doesn't belong
    to.


== Cron Scripts ==

We tested already that the functionality works. Now it's time to know
if the cronscript has any problem.

First, we are going to reactivate the entries that were already
imported or failed. Note that we'll only reactivate the entries we use
in this test; We don't touch entries that were in the queue previously.

    >>> for entry in translation_import_queue:
    ...     if (entry.status == RosettaImportStatus.IMPORTED or
    ...         entry.status == RosettaImportStatus.FAILED) and (
    ...         entry.productseries == series):
    ...         entry.status = RosettaImportStatus.APPROVED
    ...     syncUpdate(entry)
    >>> transaction.commit()

And run the import script.

    >>> import email
    >>> from canonical.launchpad.mail import stub
    >>> process = ImportProcess(transaction, FakeLogger())
    >>> process.run()
    INFO    Importing: Template "firefox" in Mozilla Firefox trunk
    INFO    Importing: Welsh (cy) ... of firefox in Mozilla Firefox trunk
    INFO    Got an old version for Welsh (cy) ... in Mozilla Firefox trunk
    INFO    Importing: Welsh (cy) ... of firefox in Mozilla Firefox trunk
    INFO    Import requests completed.

The import script also generates the emails similar to the ones we saw
composed before, but also sends them.

    >>> len(stub.test_emails)
    3
    >>> from_addr, to_addrs, raw_message = stub.test_emails.pop()
    >>> msg = email.message_from_string(raw_message)
    >>> msg["Subject"]
    'Translation import - Welsh (cy) - firefox in Mozilla Firefox trunk'
    >>> print msg.get_payload(decode=True)
    Hello Rosetta Administrators,
    <BLANKLINE>
    ...
    This mail is to notify you that all translations have now been imported.
    ...

    >>> from_addr, to_addrs, raw_message = stub.test_emails.pop()
    >>> msg = email.message_from_string(raw_message)
    >>> msg["Subject"]
    'Import problem - Welsh (cy) - firefox in Mozilla Firefox trunk'

    >>> print msg.get_payload(decode=True)
    Hello Mark Shuttleworth,
    <BLANKLINE>
    ...

    >>> from_addr, to_addrs, raw_message = stub.test_emails.pop()
    >>> msg = email.message_from_string(raw_message)
    >>> msg["Subject"]
    'Translation template import - firefox in Mozilla Firefox trunk'

    >>> print msg.get_payload(decode=True)
    Hello Mark Shuttleworth,
    <BLANKLINE>
    On ..., you uploaded a translation
    template for firefox in Mozilla Firefox trunk in Launchpad.
    <BLANKLINE>
    The template has now been imported successfully.
    <BLANKLINE>
    Thank you,
    <BLANKLINE>
    The Launchpad team

Now the auto-approval script runs. This can happen anytime, since it's
asynchronous to the po-import script. The script tries to approve any
entries that have not been approved, but look like they could be,
without human intervention. This involves a bit of guesswork about what
the imported file is and where it belongs. It similarly blocks entries
that it thinks should be blocked, and also purges deleted or completed
entries from the queue. Running at this point, all it does is purge the
two hand-approved Welsh translations that have just been imported.

    >>> process = AutoApproveProcess(transaction, FakeLogger())
    >>> process.run()
    INFO    Removed 2 entries from the queue.
    >>> transaction.commit()

If users upload two versions of the same file, they are imported in the
order in which they were uploaded.

    >>> first_pofile_content = r'''
    ... msgid ""
    ... msgstr ""
    ... "PO-Revision-Date: 2005-06-04 20:41+0100\n"
    ... "Last-Translator: Foo <no-priv@canonical.com>\n"
    ... "Content-Type: text/plain; charset=UTF-8\n"
    ... "X-Rosetta-Export-Date: %s\n"
    ...
    ... msgid "Foo %%s"
    ... msgstr "Bar"
    ...
    ... msgid "translator-credits"
    ... msgstr "The world will never know."
    ... ''' % datetime.datetime.now(UTC).isoformat()

    >>> second_pofile_content = r'''
    ... msgid ""
    ... msgstr ""
    ... "PO-Revision-Date: 2005-06-04 21:41+0100\n"
    ... "Last-Translator: Jordi Mallach <jordi@canonical.com>\n"
    ... "Content-Type: text/plain; charset=UTF-8\n"
    ... "X-Rosetta-Export-Date: %s\n"
    ...
    ... msgid "Foo %%s"
    ... msgstr "Bars"
    ...
    ... msgid "translator-credits"
    ... msgstr "I'd like to thank John, Kathy, my pot plants, and all the..."
    ... ''' % datetime.datetime.now(UTC).isoformat()

We flush the entry contents.

    >>> for entry in translation_import_queue:
    ...     translation_import_queue.remove(entry)
    >>> translation_import_queue.entryCount()
    0

Attach the first version of the file.

    >>> entry = translation_import_queue.addOrUpdateEntry(
    ...     pofile.path, first_pofile_content, False, rosetta_experts,
    ...     sourcepackagename=pofile.potemplate.sourcepackagename,
    ...     distroseries=pofile.potemplate.distroseries,
    ...     productseries=pofile.potemplate.productseries)
    >>> transaction.commit()

It's in the queue now.

    >>> translation_import_queue.entryCount()
    1

For the second version, we need a new importer, in this case, Jordi.

    >>> jordi = person_set.getByName('jordi')

Attach the second version of the file.

    >>> entry = translation_import_queue.addOrUpdateEntry(
    ...     pofile.path, second_pofile_content, False, jordi,
    ...     sourcepackagename=pofile.potemplate.sourcepackagename,
    ...     distroseries=pofile.potemplate.distroseries,
    ...     productseries=pofile.potemplate.productseries)
    >>> transaction.commit()

It's in the queue now.

    >>> translation_import_queue.entryCount()
    2
    >>> print entry.status.name
    NEEDS_REVIEW

The auto-approval script runs again. This time it sees the two
submitted translations and approves them for import based on some
heuristic intelligence.

    >>> process = AutoApproveProcess(transaction, FakeLogger())
    >>> process.run()
    INFO    The automatic approval system approved some entries.
    >>> print entry.status.name
    APPROVED
    >>> syncUpdate(entry)

Now that these submissions have been approved, the next run of the
import script picks them up and processes them.

    >>> process = ImportProcess(transaction, FakeLogger())
    >>> process.run()
    INFO    Importing: Welsh (cy) ... of firefox in Mozilla Firefox trunk
    INFO    Importing: Welsh (cy) ... of firefox in Mozilla Firefox trunk
    INFO    Import requests completed.

    >>> print entry.status.name
    IMPORTED
    >>> syncUpdate(entry)

And there are no more entries to import

    >>> translation_import_queue.getFirstEntryToImport() is None
    True

We've imported a new translation for "Foo %s."

    >>> welsh = getUtility(ILanguageSet).getLanguageByCode('cy')
    >>> foos = potemplate['Foo %s'].getLocalTranslationMessages(welsh)
    >>> sorted([foo.msgstr0.translation for foo in foos])
    [u'Bar', u'Bars']

Since this last upload was not the upstream one, however, its credits
message translations were ignored.

    >>> pofile['translator-credits'].msgstr0.translation
    u'helpful@example.com'
    >>> potemplate['translator-credits'].getLocalTranslationMessages(welsh)
    []

Imports so far have been associated with a product series. We can also
submit translations for a distroseries.

    >>> from canonical.launchpad.interfaces.distribution import (
    ...     IDistributionSet)
    >>> ubuntu = getUtility(IDistributionSet).getByName('ubuntu')
    >>> warty = ubuntu.getSeries('warty')
    >>> print warty.name
    warty
    >>> firefox_name = SourcePackageName.byName('mozilla-firefox')
    >>> subset = POTemplateSubset(sourcepackagename=firefox_name,
    ...     distroseries=warty)
    >>> potemplate = subset.new(
    ...     name='firefox-warty',
    ...     translation_domain='firefox-warty',
    ...     path='po/firefox.pot',
    ...     owner=person)

As it happens, the administrator has blocked imports to warty, e.g.
because an in-database update of its translations has been scheduled
and we don't want interference from queued imports while that happens.
It doesn't really matter whether entries still get auto-approved, but
we can't accept new translation imports just now.

    >>> warty.defer_translation_imports = True
    >>> syncUpdate(warty)

Nevertheless, someone submits an import request for warty, not knowing
or caring that imports are deferred. The entry still gets approved as
normal:

    >>> entry = translation_import_queue.addOrUpdateEntry(
    ...     potemplate.path, potemplate_contents, True, potemplate.owner,
    ...     sourcepackagename=firefox_name, distroseries=warty,
    ...     potemplate=potemplate)
    >>> entry.status = RosettaImportStatus.APPROVED
    >>> syncUpdate(entry)
    >>> transaction.commit()

Since imports for warty are suspended, and the only entry we happen to
have waiting right now is for warty, the queue has no importable
entries for us.

    >>> warty.getFirstEntryToImport() is None
    True

So if we try to import now, nothing happens. Our request remains on the
queue, but doesn't become a candidate for processing until warty
imports are resumed.

    >>> process = ImportProcess(transaction, FakeLogger())
    >>> process.run()
    INFO No requests pending.

    >>> print entry.status.name
    APPROVED

Once imports are allowed again, the import is done after all.

    >>> warty.defer_translation_imports = False
    >>> syncUpdate(warty)
    >>> (subject, body) = potemplate.importFromQueue(entry, FakeLogger())

    >>> print entry.status.name
    IMPORTED


== Plural forms handling ==

Apart from the basic plural form handling, which is documented above as
part of the import process, there are some peculiarities with importing
plural forms we want documented as well.

For a language such as Divehi, which has no plural forms defined, we
default to two plural forms (the most common value for the number of
plural forms).

    >>> divehi = getUtility(ILanguageSet)['dv']
    >>> print divehi.pluralforms
    None

    >>> firefox = getUtility(IProductSet).getByName('firefox')
    >>> firefox_trunk = firefox.getSeries('trunk')
    >>> firefox_potemplate = firefox_trunk.getPOTemplate('firefox')
    >>> firefox_dv = firefox_potemplate.newPOFile(divehi.code)
    >>> firefox_dv.plural_forms
    2

We'll import a POFile with 3 plural forms into Divehi POFile:

    >>> pofile_with_plurals = r'''
    ... msgid ""
    ... msgstr ""
    ... "PO-Revision-Date: 2005-06-03 19:41+0100\n"
    ... "Last-Translator: Carlos Perello Marin <carlos@canonical.com>\n"
    ... "Content-Type: text/plain; charset=UTF-8\n"
    ... "Plural-Forms: nplurals=3; plural=(n==0) ? 0 : ((n==1) ? 1 : 2);\n"
    ... "X-Rosetta-Export-Date: %s\n"
    ...
    ... #, c-format
    ... msgid "Singular %%d"
    ... msgid_plural "Plural %%d"
    ... msgstr[0] "First form %%d"
    ... msgstr[1] "Second form %%d"
    ... msgstr[2] "Third form %%d"
    ... ''' % datetime.datetime.now(UTC).isoformat()

We now import this POFile as Divehi translation of Firefox trunk:

    >>> entry = translation_import_queue.addOrUpdateEntry(
    ...     firefox_dv.path, pofile_with_plurals, True, person,
    ...     productseries=firefox_trunk, potemplate=firefox_potemplate)
    >>> # Allow Librarian to see the change.
    >>> transaction.commit()
    >>> entry.pofile = firefox_dv
    >>> entry.status = RosettaImportStatus.APPROVED
    >>> (subject, body) = firefox_dv.importFromQueue(entry, FakeLogger())
    >>> flush_database_updates()
    >>> print entry.status.name
    IMPORTED

If we get a current translation for this PO file, it will list only two
translations (which is a default when the language has no plural forms
specified):

    >>> potmsgset_plural = firefox_potemplate.getPOTMsgSetByMsgIDText(
    ...     u'Singular %d', u'Plural %d')
    >>> current_dv = potmsgset_plural.getCurrentTranslationMessage(divehi)
    >>> current_dv.translations
    [u'First form %d', u'Second form %d']

However, even the third form will be imported into database (this is
useful for when we finally define the number of plural forms for the
language, we should not have to reimport all translations):

    >>> current_dv.msgstr2.translation
    u'Third form %d'

