Person
======

The Person class is overloaded to represent both people and teams. Let's
log in as Robert Collins to ensure we have the privileges to do what
we're going to demonstrate.

>>> from zope.component import getUtility
>>> from zope.interface.verify import verifyObject
>>> from canonical.database.sqlbase import sqlvalues, flush_database_updates
>>> from canonical.launchpad.interfaces import (
...     IPersonSet, IPerson, IEmailAddressSet)
>>> from canonical.launchpad.ftests import login
>>> from canonical.launchpad.helpers import contactEmailAddresses
>>> from canonical.lp.dbschema import EmailAddressStatus

>>> login("robertc@robertcollins.net")

>>> personset = getUtility(IPersonSet)
>>> emailset = getUtility(IEmailAddressSet)


Verify that foobar (a Person object) correctly implements IPerson.

>>> foobar = personset.getByName('name16')
>>> verifyObject(IPerson, foobar)
True


Access to people (Persons or Teams) is done through the IPersonSet
utility:

You can create a new person using the createPersonAndEmail method of
IPersonSet. All you need for that is a valid email address. You can also 
hide the user email addresses.
>>> p, email = personset.createPersonAndEmail(
...     'randomuser@randomhost.com', hide_email_addresses=True)
>>> p.teamowner is None
True
>>> email.status == EmailAddressStatus.NEW
True
>>> p.is_valid_person # Not valid because no preferred email address
False
>>> p.hide_email_addresses
True

In case of failure of creating a new person or email the method returns 
(None, None). Let's demonstrate this trying to create a person with 
an invalid email.
>>> p2, invalid_email = personset.createPersonAndEmail(
...     'test#canonical.com')
>>> p2, invalid_email
(None, None)

And now with the same name of a existing account
>>> p3, invalid_email = personset.createPersonAndEmail(
...     'randomemail@randomhost.com', name='name12')
>>> p3, invalid_email
(None, None)

>>> vcs_imports = personset.getByName('vcs-imports')
>>> vcs_imports.teamowner is None
False
>>> vcs_imports.is_valid_person # Not valid person because it is a team
False
>>> lifeless = personset.getByName('lifeless')
>>> lifeless.teamowner is None
True

An IPerson has an inTeam method to allow us to easily check if a
person is a member of a team. It accepts an object implementing
IPerson, which is the common use case when checking permissions.

>>> ddaa = personset.getByName('ddaa')
>>> ddaa.is_valid_person
True
>>> lifeless.inTeam(vcs_imports) and ddaa.inTeam(vcs_imports)
True

The inTeam method is cached to avoid unnecessary database lookups - this
was a cause of a number of timeouts

>>> from zope.security.proxy import removeSecurityProxy
>>> naked_lifeless = removeSecurityProxy(lifeless)
>>> naked_lifeless._inTeam_cache[vcs_imports.id]
True
>>> naked_lifeless._inTeam_cache[vcs_imports.id] = False
>>> lifeless.inTeam(vcs_imports)
False
>>> naked_lifeless._inTeam_cache[vcs_imports.id] = True
>>> lifeless.inTeam(vcs_imports)
True

If a Person is not a Team then the Person object will not provide the
ITeam interface.

>>> from canonical.launchpad.interfaces import ITeam
>>> ITeam.providedBy(lifeless)
False

If a Person is a Team then the Person will provide the ITeam interface.

>>> ITeam.providedBy(vcs_imports)
True

If a team doesn't have a contact email address, all notifications we send to
the team will go to the preferred email of each member.

>>> contactEmailAddresses(vcs_imports)
set(['david.allouche@canonical.com', 'robertc@robertcollins.net',
     'foo.bar@canonical.com'])

We don't support changing a Person into a Team or a Team into a Person.

>>> vcs_imports.teamowner = None
>>> ITeam.providedBy(vcs_imports)
True


Renaming
--------

All persons have a unique name in launchpad, so to allow them to change their
names, we must make sure that name is not already in use by someone else.

>>> from canonical.launchpad.interfaces.person import PersonNameField
>>> field = PersonNameField(__name__='name', title=u'Unique name',
...                         description=u'', readonly=False, required=True)
>>> field = field.bind(lifeless)
>>> field.context == lifeless
True

You can always use your own name.
>>> field.validate(lifeless.name)

Or a name that is not already in use.
>>> field.validate(u'namenotinuse')

But you can't use Mark's name, of course. ;)
>>> field.validate(u'sabdfl')
Traceback (most recent call last):
  ...
LaunchpadValidationError: ...sabdfl is already in use by another person/team...


Merging
-------

The method to perform the low level merging of two Persons
should only be used by the one true account merge workflow.

>>> foo = personset.getByName('name16')
>>> sample = personset.getByName('name12')
>>> admins = personset.getByName('admins')

We can't merge teams

>>> personset.merge(admins, foo)
Traceback (most recent call last):
...
TypeError: ...

>>> personset.merge(foo, admins)
Traceback (most recent call last):
...
TypeError: ...

Nor can we merge an account that still has email addresses attached to it

>>> nonempty, email = personset.createPersonAndEmail('empty@somehost.com')
>>> rosetta_admins = personset.getByName('rosetta-admins')
>>> rosetta_admins.addMember(nonempty)
>>> personset.merge(nonempty, sample)
Traceback (most recent call last):
...
ValueError: ...

Now we remove the only email address nonempty had.

>>> email.destroySelf()
>>> empty = nonempty

Must login as 'sabdfl' cause he's the owner of the Ubuntu Team.

>>> login('mark@hbd.com')
>>> ubuntu_team = personset.getByName('ubuntu-team')
>>> ubuntu_translators = personset.getByName('ubuntu-translators')
>>> ubuntu_translators.addMember(empty)
>>> ubuntu_team.teamowner = empty
>>> foo = empty.assignKarma('bugfixed')
>>> flush_database_updates()

'Sample Person' is a deactivated member of the 'Ubuntu Translators' team,
while empty is an active member. After the merge, 'Sample Person' will be an
active member of that team.

>>> sample in ubuntu_translators.inactivemembers
True
>>> empty in ubuntu_translators.activemembers
True
>>> empty.karma
0
>>> sample.karma
91

Branches whose owner is being merged are uniquified by appending '-N' where N
is a unique integer. We create "peoplemerge" and "peoplemerge-1" branches owned
by empty, and a "peoplemerge" and "peoplemerge-1" branches owned by 'Sample
Person' to test that branch name uniquifying works.

Branches with smaller IDs will be processed first, so we create "peoplemerge"
first, and it will be renamed "peoplemerge-2". The extant "peoplemerge-1"
branch will be renamed "peoplemerge-1-1". The "peoplemerge-0" branch will not
be renamed since it will not conflict.

That is not a particularly sensible way of renaming branches, but it is simple
to implement, and it be should extremely rare for the case to occur.

>>> from canonical.launchpad.interfaces import IProductSet, IBranchSet
>>> branchset = getUtility(IBranchSet)
>>> peoplemerge = branchset.new('peoplemerge', sample, None, None)
>>> peoplemerge1 = branchset.new('peoplemerge-1', sample, None, None)
>>> peoplemerge0 = branchset.new('peoplemerge-0', empty, None, None)
>>> peoplemerge2 = branchset.new('peoplemerge', empty, None, None)
>>> peoplemerge11 = branchset.new('peoplemerge-1', empty, None, None)

>>> personset.merge(empty, sample)

Check that 'Sample Person' has indeed become an active member of 'Ubuntu
Translators'

>>> sample in ubuntu_translators.activemembers
True
>>> sample.inTeam(ubuntu_translators)
True

Check that the branches have been renamed properly.

>>> sample.getBranch(None, 'peoplemerge') == peoplemerge
True
>>> sample.getBranch(None, 'peoplemerge-0') == peoplemerge0
True
>>> sample.getBranch(None, 'peoplemerge-1') == peoplemerge1
True
>>> sample.getBranch(None, 'peoplemerge-2') == peoplemerge2
True
>>> sample.getBranch(None, 'peoplemerge-1-1') == peoplemerge11
True

Note that we don't bother migrating karma - it will just be reset next
time the caches are rebuilt.

>>> empty.karma
0
>>> sample.karma
91

>>> from canonical.launchpad.database import Person
>>> cur = Person._connection._connection.cursor()

A merged account gets a -merged suffix on its name.

>>> cur.execute("SELECT id FROM Person WHERE name='empty-merged'")
>>> cur.fetchone()[0] == empty.id
True


>>> cur.execute("select person, team, status from teammembership where "
...             "person = %s and team = %s"
...             % sqlvalues(sample.id, rosetta_admins.id))
>>> cur.fetchone()
[12, 30, 2]

>>> sample.inTeam(rosetta_admins)
True

>>> cur.execute("select p1.name from person as p1, person as p2 where "
...             "p1.id = p2.teamowner and p2.name = 'ubuntu-team'")
>>> cur.fetchone()[0]
u'name12'

The account that has been merged is flagged. We can use this to eliminate
merged accounts from lists etc.

>>> cur.execute("SELECT merged FROM Person WHERE name='empty-merged'")
>>> cur.fetchone()[0]
12

>>> cur.execute("SELECT merged FROM Person WHERE name='name12'")
>>> cur.fetchone()[0] is None
True

After the merging we could test the topPeople() method of the PersonSet
class. This methods returns a sliced list of 5 valid person accounts,
ordered by karma. A valid person account is any non-merged person with a
preferred email address.

>>> [(person.name, person.karma) for person in personset.topPeople()]
[(u'name12', 91), (u'name16', 40), (u'launchpad', 0), (u'jordi', 0), (u'marilize', 0)]


People can have karma in Launchpad
----------------------------------

Depending on the action a given person performs in Launchpad, that person can
earn some karma points. This is useful to know how active a user is in
Launchpad.

Salgado wrote the karma framework. Let's give him some karma points.

>>> salgado = personset.getByName('salgado')
>>> foo = salgado.assignKarma('bugfixed')
>>> salgado.karma
0

The value that you get through IPerson.karma is a cached value that's
calculated daily. That's why it still 0.


Searching
---------

You can search based on a person's name or displayname, or any of the email
addresses that belongs to a person using the methods provided by IPersonSet.

While we don't have Full Text Indexes in the emailaddress table, we'll be
trying to match the text only against the beginning of an email address:

>>> results = personset.find('ubuntu')
>>> for person in results:
...     emails = [email.email for email in emailset.getByPerson(person)]
...     (person.displayname, person.name, emails)
(u'Mirror Administrators', u'ubuntu-mirror-admins', [])
(u'Sigurd Gartmann', u'sigurd-ubuntu', [u'sigurd-ubuntu@brogar.org'])
(u'Ubuntu Gnome Team', u'name18', [])
(u'Ubuntu Team', u'ubuntu-team', [u'support@ubuntu.com'])
(u'Ubuntu Translators', u'ubuntu-translators', [])

>>> results = personset.find('steve.alexander')
>>> for person in results:
...     emails = [email.email for email in emailset.getByPerson(person)]
...     (person.displayname, person.name, emails)
(u'Steve Alexander', u'stevea', [u'steve.alexander@ubuntulinux.com'])


Searching only for People based on their names or email addresses:

>>> results = personset.findPerson('james.blackwell')
>>> for person in results:
...     emails = [email.email for email in emailset.getByPerson(person)]
...     (person.displayname, person.name, emails)
(u'James Blackwell', u'jblack', [u'james.blackwell@ubuntulinux.com'])

>>> results = personset.findPerson('dave')
>>> for person in results:
...     emails = [email.email for email in emailset.getByPerson(person)]
...     (person.displayname, person.name, emails)
(u'Dave Miller', u'justdave', [u'dave.miller@ubuntulinux.com', u'justdave@bugzilla.org'])


Searching only for Teams based on their names or email addresses:

>>> results = personset.findTeam('support')
>>> for person in results:
...     emails = [email.email for email in emailset.getByPerson(person)]
...     (person.displayname, person.name, emails)
(u'Ubuntu Team', u'ubuntu-team', [u'support@ubuntu.com'])

>>> results = personset.findTeam('translators')
>>> for person in results:
...     emails = [email.email for email in emailset.getByPerson(person)]
...     (person.displayname, person.name, emails)
(u'Ubuntu Translators', u'ubuntu-translators', [])


Packages related to a person
----------------------------

To obtain the packages a person is related to, we can use the
latestMaintainedPackages() and latestUploadedButNotMaintainedPackages()
methods of IPersonSet. The former will return the latest
SourcePackageReleases a person uploaded in which he is listed as the
Maintainer. The latter will return the latest SourcePackageReleases a
person uploaded (where he isn't the maintainer).

>>> sabdfl = personset.getByName('sabdfl')
>>> for sprelease in sabdfl.latestMaintainedPackages():
...     print (sprelease.name, sprelease.uploaddistrorelease.fullreleasename,
...            sprelease.version)
(u'alsa-utils', u'Debian Sid', u'1.0.9a-4')
(u'pmount', u'Ubuntu Hoary', u'0.1-2')
(u'netapplet', u'Ubuntu Warty', u'0.99.6-1')
(u'netapplet', u'Ubuntu Hoary', u'1.0-1')
(u'alsa-utils', u'Ubuntu Warty', u'1.0.8-1ubuntu1')
(u'mozilla-firefox', u'Ubuntu Hoary', u'0.9')
(u'evolution', u'Ubuntu Hoary', u'1.0')

>>> for sprelease in sabdfl.latestUploadedButNotMaintainedPackages():
...     print (sprelease.name, sprelease.uploaddistrorelease.fullreleasename,
...            sprelease.version)
(u'libstdc++', u'Ubuntu Hoary', u'b8p')
(u'cnews', u'Ubuntu Hoary', u'cr.g7-37')
(u'linux-source-2.6.15', u'Ubuntu Hoary', u'2.6.15.3')
(u'at', u'Ubuntu Hoary', u'0.00')
(u'alsa-utils', u'Ubuntu Hoary', u'1.0.9a-4ubuntu1')


Bug contact packages
--------------------

A person who chooses to receive all bugmail for a package is said to be
a "bug contact" for that package. A package may have zero, one, or more
bug contacts.

IPerson.getBugContactPackages returns this list of packages, sorted
alphabetically (A to Z) by package name.

>>> [package.name for package in foobar.getBugContactPackages()]
[u'mozilla-firefox', u'pmount']


Specification Lists
-------------------

We should be able to generate lists of specifications for people based on
certain criteria:

First, Carlos does not have any completed specifications assigned to him:

 >>> carlos = getUtility(IPersonSet).getByName('carlos')
 >>> from canonical.lp.dbschema import SpecificationFilter
 >>> carlos.specifications(filter=[
 ...     SpecificationFilter.ASSIGNEE, SpecificationFilter.COMPLETE]).count()
 0


Next, Carlos has three incomplete specs *related* to him:

 >>> filter = []
 >>> for spec in carlos.specifications(filter=filter):
 ...     print spec.name, spec.is_complete, spec.informational
 svg-support False False
 extension-manager-upgrades False True
 media-integrity-check False False

Carlos has 2 specifications assigned to him:

 >>> filter = [SpecificationFilter.ASSIGNEE]
 >>> for spec in carlos.specifications(filter=filter):
 ...     print spec.name
 svg-support
 extension-manager-upgrades

Just for fun, lets check the SAB. He should have one spec for which he
is the approver.

 >>> sabdfl = getUtility(IPersonSet).getByName('sabdfl')
 >>> filter = [SpecificationFilter.APPROVER]
 >>> for spec in sabdfl.specifications(filter=filter):
 ...     print spec.name
 extension-manager-upgrades


The Foo Bar person has a single spec which has feedback requested:

 >>> filter = [SpecificationFilter.FEEDBACK]
 >>> for spec in foobar.specifications(filter=filter):
 ...     print spec.name
 e4x


But has registered 5 of them:

 >>> filter = [SpecificationFilter.CREATOR]
 >>> print foobar.specifications(filter=filter).count()
 5


Now Celso, on the other hand, has 2 specs related to him:

 >>> cprov = personset.getByName('cprov')
 >>> cprov.specifications().count()
 2


On one of those, he is the approver:

 >>> filter = [SpecificationFilter.APPROVER]
 >>> for spec in cprov.specifications(filter=filter):
 ...     print spec.name
 svg-support


And on another one, he is the drafter

 >>> filter = [SpecificationFilter.DRAFTER]
 >>> for spec in cprov.specifications(filter=filter):
 ...     print spec.name
 e4x

We can filter for specifications that contain specific text:

 >>> for spec in cprov.specifications(filter=['svg']):
 ...     print spec.name
 svg-support


