= LAZR's field marshallers =

LAZR defines an interface for converting between the values that
come in on an HTTP request, and the object values appropriate for schema
fields. This is similar to Zope's widget interface, but much smaller.

To test the various marshallers we create a dummy request and
application root.

    >>> from canonical.lazr.testing.webservice import (
    ...     WebServiceTestRequest, WebServiceTestPublication)
    >>> from canonical.lazr.rest.example.root import (
    ...     CookbookServiceRootResource)
    >>> request = WebServiceTestRequest("", {'HTTP_HOST': 'cookbooks.dev'})
    >>> application = CookbookServiceRootResource()
    >>> request.setPublication(WebServiceTestPublication(application))
    >>> request.processInputs()


== IFieldMarshaller and SimpleFieldMarshaller ==

There is a SimpleFieldMarshaller class that provides a good base to
implement that interface.

    >>> from zope.interface.verify import verifyObject
    >>> from canonical.lazr.interfaces import IFieldMarshaller
    >>> from canonical.lazr.rest.marshallers import SimpleFieldMarshaller
    >>> from zope.schema import Text

    >>> field = Text(__name__='field_name')
    >>> marshaller = SimpleFieldMarshaller(field, request)
    >>> verifyObject(IFieldMarshaller, marshaller)
    True


=== representation_name ===

The representation_name attribute is used to retrieve the name under
which the field should be stored in the JSON representation. In the
simple case, it's the same name as the field.

    >>> marshaller.representation_name
    'field_name'


=== marshall_from_json_data() ===

The marshall_from_json_data() method is used during PUT and PATCH
requests to transform the value provided in the JSON representation to a
value in the underlying schema field. In SimpleFieldMarshaller
implementation, the value is returned unchanged.

    >>> marshaller.marshall_from_json_data("foo")
    'foo'
    >>> marshaller.marshall_from_json_data(4)
    4
    >>> marshaller.marshall_from_json_data(u"unicode\u2122")
    u'unicode\u2122'
    >>> marshaller.marshall_from_json_data("")
    ''
    >>> print marshaller.marshall_from_json_data(None)
    None


== marshall_from_request() ===

The marshall_from_request() method is used during operation invocation
to transform a value submitted via the query string or form-encoded POST
data into a value the will be accepted by the underlying schema field.

SimpleFieldMarshaller tries first to parse the value as a JSON-encoded
string, the resulting value is passed on to marshall_from_json_data().

    >>> print marshaller.marshall_from_request("null")
    None
    >>> marshaller.marshall_from_request("true")
    True
    >>> marshaller.marshall_from_request("false")
    False
    >>> marshaller.marshall_from_request('["True", "False"]')
    [u'True', u'False']
    >>> marshaller.marshall_from_request("1")
    1
    >>> marshaller.marshall_from_request("-10.5")
    -10.5
    >>> marshaller.marshall_from_request('"a string"')
    u'a string'
    >>> marshaller.marshall_from_request('"false"')
    u'false'
    >>> marshaller.marshall_from_request('"null"')
    u'null'

Invalid JSON-encoded strings are interpreted as string literals and
passed on directly to marshall_from_json_data(). That's for the
convenience of web clients, they don't need to encode string values in
quotes, or can pass lists using multiple key-value pairs.

    >>> marshaller.marshall_from_request(u"a string")
    u'a string'
    >>> marshaller.marshall_from_request('False')
    'False'
    >>> marshaller.marshall_from_request("")
    ''
    >>> marshaller.marshall_from_request(['value1', 'value2'])
    ['value1', 'value2']


=== unmarshall() ===

The unmarshall() method is used to convert the field's value to a value
that can be serialized to JSON as part of an entry representation.  The
first parameter is the entry that the value is part of. That is used by
fields that transform the value into a URL, see the CollectionField
marshaller for an example. The second one is the value to convert.  In
the SimpleFieldMarshaller implementation, the value is returned
unchanged.

    >>> marshaller.unmarshall(None, 'foo')
    'foo'
    >>> print marshaller.unmarshall(None, None)
    None


== Basic types marshallers ==

=== Bool ===

The marshaller for a Bool field checks that the JSON value is either
True or False. A ValueError is raised when its not the case.

    >>> from zope.configuration import xmlconfig
    >>> zcmlcontext = xmlconfig.string("""
    ... <configure xmlns="http://namespaces.zope.org/zope">
    ...   <include package="zope.app.component" file="meta.zcml"/>
    ...   <include package="canonical.lazr.rest" />
    ...   <include package="canonical.lazr.rest" file="ftesting.zcml" />
    ... </configure>
    ... """)

    >>> from zope.component import getMultiAdapter
    >>> from zope.schema import Bool
    >>> field = Bool()
    >>> marshaller = getMultiAdapter((field, request), IFieldMarshaller)
    >>> verifyObject(IFieldMarshaller, marshaller)
    True

    >>> marshaller.marshall_from_json_data(True)
    True
    >>> marshaller.marshall_from_json_data(False)
    False
    >>> marshaller.marshall_from_json_data("true")
    Traceback (most recent call last):
      ...
    ValueError: got 'str', expected bool: 'true'
    >>> marshaller.marshall_from_json_data(1)
    Traceback (most recent call last):
      ...
    ValueError: got 'int', expected bool: 1

None is passed through though.

    >>> print marshaller.marshall_from_json_data(None)
    None

Booleans are encoded using the standard JSON representation of 'true' or
'false'.

    >>> marshaller.marshall_from_request(u"true")
    True
    >>> marshaller.marshall_from_request(u"false")
    False

    >>> marshaller.marshall_from_request('True')
    Traceback (most recent call last):
      ...
    ValueError: got 'str', expected bool: 'True'


=== Int ===

The marshaller for an Int field checks that the JSON value is an
integer. A ValueError is raised when its not the case.

    >>> from zope.schema import Int
    >>> field = Int()
    >>> marshaller = getMultiAdapter((field, request), IFieldMarshaller)
    >>> verifyObject(IFieldMarshaller, marshaller)
    True

    >>> marshaller.marshall_from_json_data(-10)
    -10
    >>> marshaller.marshall_from_json_data("-10")
    Traceback (most recent call last):
      ...
    ValueError: got 'str', expected int: '-10'

None is passed through though.

    >>> print marshaller.marshall_from_json_data(None)
    None

Integers are encoded using strings when in a request.

    >>> marshaller.marshall_from_request("4")
    4
    >>> marshaller.marshall_from_request(u"-4")
    -4

It raises a ValueError if the value cannot be converted to an integer.

    >>> marshaller.marshall_from_request("foo")
    Traceback (most recent call last):
    ...
    ValueError: got 'str', expected int: 'foo'

    >>> marshaller.marshall_from_request("4.62")
    Traceback (most recent call last):
    ...
    ValueError:  got 'float', expected int: 4.62...

Note that python octal and hexadecimal syntax isn't supported.

(This would 13 in octal notation.)

    >>> marshaller.marshall_from_request(u"015")
    Traceback (most recent call last):
      ...
    ValueError: got 'unicode', expected int: u'015'

    >>> marshaller.marshall_from_request(u"0x04")
    Traceback (most recent call last):
      ...
    ValueError: got 'unicode', expected int: u'0x04'


=== Float ===

The marshaller for a Float field checks that the JSON value is indeed a
float.  A ValueError is raised when it's not the case.

    >>> from zope.schema import Float
    >>> field = Float()
    >>> marshaller = getMultiAdapter((field, request), IFieldMarshaller)
    >>> verifyObject(IFieldMarshaller, marshaller)
    True

    >>> marshaller.marshall_from_json_data(1.0)
    1.0
    >>> marshaller.marshall_from_json_data(-1.0)
    -1.0
    >>> marshaller.marshall_from_json_data("true")
    Traceback (most recent call last):
      ...
    ValueError: got 'str', expected float, int: 'true'

None is passed through though.

    >>> print marshaller.marshall_from_json_data(None)
    None

And integers are automatically converted to a float.

    >>> marshaller.marshall_from_json_data(1)
    1.0

Floats are encoded using the standard JSON representation.

    >>> marshaller.marshall_from_request(u"1.2")
    1.2
    >>> marshaller.marshall_from_request(u"-1.2")
    -1.2
    >>> marshaller.marshall_from_request(u"-1")
    -1.0

    >>> marshaller.marshall_from_request('True')
    Traceback (most recent call last):
      ...
    ValueError: got 'str', expected float, int: 'True'


=== Text ===

The marshaller for IText field checks that the value is a unicode
string. A ValueError is raised when that's not the case.

    >>> from zope.schema import Text
    >>> field = Text()
    >>> marshaller = getMultiAdapter((field, request), IFieldMarshaller)
    >>> verifyObject(IFieldMarshaller, marshaller)
    True

    >>> marshaller.marshall_from_json_data(u"Test")
    u'Test'
    >>> marshaller.marshall_from_json_data(1.0)
    Traceback (most recent call last):
      ...
    ValueError: got 'float', expected unicode: 1.0
    >>> marshaller.marshall_from_json_data('Test')
    Traceback (most recent call last):
      ...
    ValueError: got 'str', expected unicode: 'Test'

None is passed through though.

    >>> print marshaller.marshall_from_json_data(None)
    None

When coming from the request, everything is interpreted as a unicode
string:

    >>> marshaller.marshall_from_request('a string')
    u'a string'
    >>> marshaller.marshall_from_request(['a', 'b'])
    u"['a', 'b']"
    >>> marshaller.marshall_from_request('true')
    u'True'
    >>> marshaller.marshall_from_request('')
    u''

Except that 'null' still returns None.

    >>> print marshaller.marshall_from_request('null')
    None


=== Bytes ===

Since there is no way to represent a bytes string in JSON, all strings
are converted to a byte string using UTF-8 encoding. If the value isn't
a string, a ValueError is raised.

    >>> from zope.schema import Bytes
    >>> field = Bytes(__name__='data')
    >>> marshaller = getMultiAdapter((field, request), IFieldMarshaller)
    >>> verifyObject(IFieldMarshaller, marshaller)
    True

    >>> marshaller.marshall_from_json_data(u"Test")
    'Test'
    >>> marshaller.marshall_from_json_data(u'int\xe9ressant')
    'int\xc3\xa9ressant'
    >>> marshaller.marshall_from_json_data(1.0)
    Traceback (most recent call last):
      ...
    ValueError: got 'float', expected str: 1.0

Again, except for None which is passed through.

    >>> print marshaller.marshall_from_json_data(None)
    None

When coming over the request, the value is also converted into a UTF-8
encoded string.

    >>> marshaller.marshall_from_request(u"Test")
    'Test'
    >>> marshaller.marshall_from_request(u'int\xe9ressant')
    'int\xc3\xa9ressant'
    >>> marshaller.marshall_from_request('1.0')
    '1.0'

But again, None is returned as is.

    >>> print marshaller.marshall_from_request('null')
    None

Since multipart/form-data can be used to upload data, file-like objects
are read.

    >>> from cStringIO import StringIO
    >>> marshaller.marshall_from_request(StringIO('A line of data'))
    'A line of data'

Bytes field used in an entry are stored in the librarian, so their
representation name states that it's a link.

    >>> marshaller.representation_name
    'data_link'

And the unmarshall() method returns a link that will serve the file.

    >>> from canonical.lazr.rest import EntryResource
    >>> from canonical.lazr.rest.example.interfaces import ICookbookSet
    >>> from zope.component import getUtility
    >>> entry_resource = EntryResource(
    ...     getUtility(ICookbookSet).get('Everyday Greens'), request)

(The value would be the BytesStorage instance used to store the
content, but it's not needed.)

    >>> marshaller.unmarshall(entry_resource, None)
    'http://.../cookbooks/Everyday%20Greens/data'


==== ASCIILine ====

ASCIILine is a subclass of Bytes but is marshalled like text.

    >>> from zope.schema import ASCIILine
    >>> field = ASCIILine(__name__='field')
    >>> marshaller = getMultiAdapter((field, request), IFieldMarshaller)
    >>> verifyObject(IFieldMarshaller, marshaller)
    True

Unicode objects remain Unicode objects.

    >>> marshaller.marshall_from_json_data(u"Test")
    u'Test'

Note that the marshaller accepts character values where bit 7 is set.

    >>> marshaller.marshall_from_json_data(u'int\xe9ressant')
    u'int\xe9ressant'

Non-string alues like floats are rejected.

    >>> marshaller.marshall_from_json_data(1.0)
    Traceback (most recent call last):
      ...
    ValueError: got 'float', expected unicode: 1.0

None is passed through.

    >>> print marshaller.marshall_from_json_data(None)
    None

When coming from the request, everything is interpreted as a unicode
string:

    >>> marshaller.marshall_from_request('a string')
    u'a string'
    >>> marshaller.marshall_from_request(['a', 'b'])
    u"['a', 'b']"
    >>> marshaller.marshall_from_request('true')
    u'True'
    >>> marshaller.marshall_from_request('')
    u''
    >>> marshaller.marshall_from_request(u'int\xe9ressant')
    u'int\xe9ressant'
    >>> marshaller.marshall_from_request('1.0')
    u'1.0'

But again, 'null' is returned as None.

    >>> print marshaller.marshall_from_request('null')
    None

Unlike a Bytes field, an ASCIILine field used in an entry is stored
as an ordinary attribute, hence its representation name is the attribute
name itself.

    >>> marshaller.representation_name
    'field'


== Choice marshallers ==

The marshaller for a Choice is chosen based on the Choice's
vocabulary.

    >>> from zope.schema import Choice


=== Choice for IVocabularyTokenized ===

The default marshaller will use the vocabulary getTermByToken to
retrieve the value to use. It raises an error if the value isn't in the
vocabulary.

    >>> field = Choice(__name__='simple', values=[10, 'a value', True])
    >>> marshaller = getMultiAdapter((field, request), IFieldMarshaller)
    >>> verifyObject(IFieldMarshaller, marshaller)
    True
    >>> marshaller.marshall_from_json_data(10)
    10
    >>> marshaller.marshall_from_json_data("a value")
    'a value'
    >>> marshaller.marshall_from_json_data(True)
    True
    >>> marshaller.marshall_from_request('true')
    True
    >>> marshaller.marshall_from_request('a value')
    'a value'
    >>> marshaller.marshall_from_request('10')
    10

    >>> marshaller.marshall_from_json_data('100')
    Traceback (most recent call last):
      ...
    ValueError: '100' isn't a valid token

None is always returned unchanged.

    >>> print marshaller.marshall_from_json_data(None)
    None


=== Choice of EnumeratedTypes ===

The JSON representation of the enumerated value is its title.  A string
that corresponds to one of the values is marshalled to the appropriate
value. A string that doesn't correspond to any enumerated value results
in a helpful ValueError.

    >>> from canonical.launchpad.interfaces import BugTaskStatus
    >>> field = Choice(vocabulary=BugTaskStatus)
    >>> marshaller = getMultiAdapter((field, request), IFieldMarshaller)
    >>> verifyObject(IFieldMarshaller, marshaller)
    True

    >>> marshaller.marshall_from_json_data("Triaged")
    <DBItem BugTaskStatus.TRIAGED...>

    >>> marshaller.marshall_from_json_data("NoSuchStatus")
    Traceback (most recent call last):
    ...
    ValueError: Invalid value "NoSuchStatus". Acceptable values are: ...

    >>> marshaller.marshall_from_json_data("triaged")
    Traceback (most recent call last):
    ...
    ValueError: Invalid value "triaged". Acceptable values are: ...

None is returned unchanged:

    >>> print marshaller.marshall_from_json_data(None)
    None


== Objects ==

An object is marshalled to its URL.

    >>> from canonical.lazr.fields import Reference
    >>> from canonical.lazr.rest.example.interfaces import ICookbook
    >>> reference_field = Reference(schema=ICookbook)
    >>> reference_marshaller = getMultiAdapter(
    ...     (reference_field, request), IFieldMarshaller)
    >>> verifyObject(IFieldMarshaller, reference_marshaller)
    True

    >>> from canonical.lazr.rest.example.root import COOKBOOKS
    >>> cookbook = COOKBOOKS[0]
    >>> cookbook_url = reference_marshaller.unmarshall(None, cookbook)
    >>> print cookbook_url
    http://.../cookbooks/Mastering%20the%20Art%20of%20French%20Cooking

A URL is unmarshalled to the underlying object.

    >>> cookbook = reference_marshaller.marshall_from_json_data(cookbook_url)
    >>> cookbook.name
    u'Mastering the Art of French Cooking'


== Collections ==

The most complicated kind of marshaller is one that manages a
collection of objects associated with some other object. The generic
collection marshaller will take care of marshalling to the proper
collection type, and of marshalling the individual items using the
marshaller for its value_type.

    >>> from zope.schema import List, Tuple, Set
    >>> list_of_strings_field = List(value_type=Text())
    >>> from canonical.lazr.rest.example.interfaces import Cuisine
    >>> tuple_of_ints_field = Tuple(value_type=Int())
    >>> list_of_choices_field = List(
    ...     value_type=Choice(vocabulary=Cuisine))
    >>> set_of_choices_field = Set(
    ...  value_type=Choice(vocabulary=Cuisine)).bind(None)

    >>> list_marshaller = getMultiAdapter(
    ...     (list_of_strings_field, request), IFieldMarshaller)
    >>> verifyObject(IFieldMarshaller, list_marshaller)
    True

    >>> tuple_marshaller = getMultiAdapter(
    ...     (tuple_of_ints_field, request), IFieldMarshaller)
    >>> verifyObject(IFieldMarshaller, tuple_marshaller)
    True

    >>> choice_list_marshaller = getMultiAdapter(
    ...     (list_of_choices_field, request), IFieldMarshaller)
    >>> verifyObject(IFieldMarshaller, choice_list_marshaller)
    True

    >>> set_marshaller = getMultiAdapter(
    ...     (set_of_choices_field, request), IFieldMarshaller)
    >>> verifyObject(IFieldMarshaller, set_marshaller)
    True

The only JSON representation for the collection itself is a list, since
that's the only sequence type available in JSON. Anything else will
raise a ValueError.

    >>> list_marshaller.marshall_from_json_data([u"Test"])
    [u'Test']

    >>> list_marshaller.marshall_from_json_data(u"Test")
    Traceback (most recent call last):
      ...
    ValueError: got 'unicode', expected list: u'Test'

None is passed through though.

    >>> print list_marshaller.marshall_from_json_data(None)
    None

ValueError is also raised if one of the value in the list doesn't
validate against the more specific marshaller.

    >>> list_marshaller.marshall_from_json_data([u'Text', 1, 2])
    Traceback (most recent call last):
      ...
    ValueError: got 'int', expected unicode: 1

    >>> choice_list_marshaller.marshall_from_request(
    ...     [u'Vegetarian', u'NoSuchChoice'])
    Traceback (most recent call last):
    ...
    ValueError: Invalid value "NoSuchChoice"...

The return type is correctly typed to the concrete collection.

    >>> tuple_marshaller.marshall_from_json_data([1, 2, 3])
    (1, 2, 3)
    >>> marshalled_set = set_marshaller.marshall_from_json_data(
    ...     ['Vegetarian', 'Dessert'])
    >>> marshalled_set
    set([<Item Cuisine.DESSERT, ...>, <Item Cuisine.VEGETARIAN, ...>])

    >>> result = choice_list_marshaller.marshall_from_request(
    ...     [u'Vegetarian', u'General'])
    >>> type(result)
    <type 'list'>
    >>> [item.title for item in result]
    ['Vegetarian', 'General']


When coming from the request, either a list or a JSON-encoded
representation is accepted. The normal request rules for the
underlying type are then followed.

    >>> list_marshaller.marshall_from_request([u'1', u'2'])
    [u'1', u'2']
    >>> list_marshaller.marshall_from_request('["1", "2"]')
    [u'1', u'2']

    >>> tuple_marshaller.marshall_from_request([u'1', u'2'])
    (1, 2)

Except that 'null' still returns None.

    >>> print list_marshaller.marshall_from_request('null')
    None

Also, as a convenience for web client, so that they don't have to JSON
encode single-element list, non-list value are promoted into a
single-element list.

    >>> tuple_marshaller.marshall_from_request('1')
    (1,)

    >>> list_marshaller.marshall_from_request('test')
    [u'test']

The unmarshall() method will return a list containing the unmarshalled
representation of each its members.

    >>> sorted(set_marshaller.unmarshall(None, marshalled_set))
    ['Dessert', 'Vegetarian']


== CollectionField ==

Since CollectionField are really a list of references to other objects,
and they are exposed using a dedicated CollectionResource, the marshaller
for this kind of field is simpler.  Let's do an example with a
collection of IPerson objects associated with some IPerson. (This
might be the list of teams in which a person has a membership, or
something like that.)

    >>> from canonical.lazr.fields import CollectionField
    >>> from canonical.lazr.rest.example.interfaces import IRecipe
    >>> field = CollectionField(
    ...     __name__='recipes', value_type=Reference(schema=IRecipe))
    >>> marshaller = getMultiAdapter((field, request), IFieldMarshaller)
    >>> verifyObject(IFieldMarshaller, marshaller)
    True

Instead of serving the actual collection, collection marshallers serve
a URL to that collection.

    >>> marshaller.unmarshall(entry_resource, ["recipe 1", "recipe 2"])
    'http://.../cookbooks/Everyday%20Greens/recipes'

They also annotate the representation name of the field, so that
clients know this is a link to a collection-type resource.

    >>> marshaller.representation_name
    'recipes_collection_link'
