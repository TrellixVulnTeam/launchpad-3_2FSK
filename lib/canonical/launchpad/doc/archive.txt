= Personal Package Archives =

An Archive models a Debian Archive, providing operations like
publication lookups and the complete publishing-pipeline from database
records to disk, including configuration and indexes.

    >>> from canonical.launchpad.webapp.testing import verifyObject
    >>> from canonical.launchpad.interfaces import (
    ...     ArchivePurpose, IPersonSet, IArchiveSet, IArchive,
    ...     IDistributionSet)

    >>> cprov = getUtility(IPersonSet).getByName('cprov')
    >>> cprov_archive = cprov.archive

    >>> cprov_archive.owner.name
    u'cprov'
    >>> cprov_archive.distribution.name
    u'ubuntu'
    >>> cprov_archive.purpose.name
    'PPA'
    >>> cprov_archive.enabled
    True
    >>> cprov_archive.authorized_size
    1024
    >>> cprov_archive.whiteboard
    u'It is not my fault.'
    >>> cprov_archive.private
    False

Useful properties:

    >>> cprov_archive.title
    u'PPA for Celso Providelo'

    >>> cprov_archive.archive_url
    u'http://ppa.launchpad.dev/cprov/ubuntu'

Inquire what Distribution Series this archive has published sources to:

    >>> [s.name for s in cprov_archive.series_with_sources]
    [u'breezy-autotest', u'warty']


== Published Source and Binary Lookup ==

IArchive implements a published source & binary lookup methods,
returning I{Source, Binary}PackagePublishingHistory objects.

    >>> cprov_archive.getPublishedSources().count()
    3

    >>> cprov_archive.getPublishedOnDiskBinaries().count()
    3

    >>> cprov_archive.getAllPublishedBinaries().count()
    4

This lookup also supports optional filters:

 * 'name': as in SQL "LIKE '%%' || NAME || '%%'");
 * 'version': exact version string matching;
 * 'status': a item or a list of PackagePublishingStatus.

    >>> from canonical.launchpad.interfaces import PackagePublishingStatus

    >>> active_status = [PackagePublishingStatus.PENDING,
    ...                  PackagePublishingStatus.PUBLISHED]

    >>> inactive_status = [PackagePublishingStatus.SUPERSEDED,
    ...                    PackagePublishingStatus.DELETED]

Let's inspect source publications in Cprov PPA:

    >>> all_sources = cd_lookup = cprov_archive.getPublishedSources()
    >>> for pub in all_sources:
    ...     title = pub.sourcepackagerelease.title
    ...     pub_ds = pub.distroseries.name
    ...     print "%s -> %s" % (title, pub_ds)
    cdrkit - 1.0 -> breezy-autotest
    iceweasel - 1.0 -> warty
    pmount - 0.1-1 -> warty

Using 'name' filter:

    >>> cprov_archive.getPublishedSources(name='cd').count()
    1

    >>> cprov_archive.getPublishedSources(name='ice').count()
    1

Combining 'name' filter and 'exact_match' flag:

    >>> cprov_archive.getPublishedSources(
    ...     name='iceweasel', exact_match=True).count()
    1
    >>> cprov_archive.getPublishedSources(
    ...     name='ice', exact_match=True).count()
    0

Using 'version' filter:

    >>> ice_version_lookup = cprov_archive.getPublishedSources(
    ...     version='1.0')
    Traceback (most recent call last):
    ...
    AssertionError: 'version' can be only used when name is set

    >>> ice_version_lookup = cprov_archive.getPublishedSources(
    ...     name='ice', version='1.0')
    >>> ice_version_lookup.count()
    1

    >>> cprov_archive.getPublishedSources(
    ...     name='ice', version='666').count()
    0

Using 'status' filter:

    >>> cprov_archive.getPublishedSources(
    ...     status=PackagePublishingStatus.PUBLISHED).count()
    3

    >>> cprov_archive.getPublishedSources(
    ...     status=active_status).count()
    3

    >>> cprov_archive.getPublishedSources(
    ...     status=inactive_status).count()
    0

Using 'distroseries' filter:

    >>> warty = cprov_archive.distribution['warty']
    >>> hoary = cprov_archive.distribution['hoary']
    >>> breezy_autotest = cprov_archive.distribution['breezy-autotest']

    >>> cprov_archive.getPublishedSources(
    ...     distroseries=warty).count()
    2
    >>> cprov_archive.getPublishedSources(
    ...     distroseries=hoary).count()
    0
    >>> cprov_archive.getPublishedSources(
    ...     distroseries=breezy_autotest).count()
    1

Using 'pocket' filter:

    >>> from canonical.launchpad.interfaces import PackagePublishingPocket
    >>> cprov_archive.getPublishedSources(
    ...     distroseries=warty,
    ...     pocket=PackagePublishingPocket.RELEASE).count()
    2

    >>> cprov_archive.getPublishedSources(
    ...     distroseries=warty,
    ...     pocket=PackagePublishingPocket.UPDATES).count()
    0

Combining 'name' and 'distroseries' filters:

    >>> cprov_archive.getPublishedSources(
    ...     name='ice', distroseries=warty).count()
    1
    >>> cprov_archive.getPublishedSources(
    ...     name='ice', distroseries=breezy_autotest).count()
    0

    >>> cprov_archive.getPublishedSources(
    ...     name='cd', distroseries=warty).count()
    0
    >>> cprov_archive.getPublishedSources(
    ...     name='cd', distroseries=breezy_autotest).count()
    1


=== Binary publication lookups ===

'getPublishedOnDiskBinaries' returns only unique publications, i.e., it
excludes architecture-independent duplications which is necessary for
having correct publication counters and archive size.

    >>> def check_bin_pubs(pubs):
    ...     """Print binary publication details."""
    ...     for pub in pubs:
    ...         title = pub.binarypackagerelease.title
    ...         arch_spec = pub.binarypackagerelease.architecturespecific
    ...         pub_arch = pub.distroarchseries.architecturetag
    ...         print "%s (%s) -> %s" % (title, arch_spec, pub_arch)

The PPA for cprov contains only 4 binary publications, however 'pmount' is
'architecture independent', which means that the same binary (DB) is
published for all available architectures, i386 & hppa:

    >>> all_cprov_bin_pubs = cprov_archive.getAllPublishedBinaries()

    >>> check_bin_pubs(all_cprov_bin_pubs)
    mozilla-firefox-1.0 (True) -> hppa
    mozilla-firefox-1.0 (True) -> i386
    pmount-0.1-1 (False) -> hppa
    pmount-0.1-1 (False) -> i386

'getPublishedOnDiskBinaries' automatically filters multiple publications of
'pmount' considering only the publication to the 'nominatedarchindep'
(defined for each distroseries).

    >>> unique_cprov_bin_pubs = cprov_archive.getPublishedOnDiskBinaries()

    >>> check_bin_pubs(unique_cprov_bin_pubs)
    mozilla-firefox-1.0 (True) -> i386
    pmount-0.1-1 (False) -> i386
    mozilla-firefox-1.0 (True) -> hppa

'name' filter supporting partial string matching and 'not-found':

    >>> cprov_archive.getPublishedOnDiskBinaries(name='pmou').count()
    1
    >>> cprov_archive.getAllPublishedBinaries(name='pmou').count()
    2
    >>> cprov_archive.getPublishedOnDiskBinaries(name='foo').count()
    0
    >>> cprov_archive.getAllPublishedBinaries(name='foo').count()
    0

Combining 'name' filter and 'exact_match' flag:

    >>> cprov_archive.getAllPublishedBinaries(
    ...     name='pmou', exact_match=True).count()
    0
    >>> cprov_archive.getAllPublishedBinaries(
    ...     name='pmount', exact_match=True).count()
    2
    >>> cprov_archive.getPublishedOnDiskBinaries(
    ...     name='pmou', exact_match=True).count()
    0
    >>> cprov_archive.getPublishedOnDiskBinaries(
    ...     name='pmount', exact_match=True).count()
    1

It's possible to associate 'name' and 'version' filters:

    >>> cprov_archive.getPublishedOnDiskBinaries(
    ...     name='moz', version='1.0').count()
    2

    >>> cprov_archive.getAllPublishedBinaries(
    ...     name='moz', version='1.0').count()
    2

    >>> cprov_archive.getPublishedOnDiskBinaries(
    ...     name='moz', version='666').count()
    0

    >>> cprov_archive.getAllPublishedBinaries(
    ...     name='moz', version='666').count()
    0

Both methods do not support passing the 'version' filter if the 'name'
filter is not passed too.

    >>> moz_version_lookup = cprov_archive.getAllPublishedBinaries(
    ...     version='1.0')
    Traceback (most recent call last):
    ...
    AssertionError: 'version' can be only used when name is set

    >>> moz_version_lookup = cprov_archive.getPublishedOnDiskBinaries(
    ...     version='1.0')
    Traceback (most recent call last):
    ...
    AssertionError: 'version' can be only used when name is set

Both methods support 'status' filter:

    >>> cprov_archive.getPublishedOnDiskBinaries(
    ...     status=PackagePublishingStatus.PUBLISHED).count()
    3

    >>> cprov_archive.getAllPublishedBinaries(
    ...     status=PackagePublishingStatus.PUBLISHED).count()
    4

    >>> cprov_archive.getPublishedOnDiskBinaries(
    ...     status=active_status).count()
    3

    >>> cprov_archive.getAllPublishedBinaries(
    ...     status=active_status).count()
    4

    >>> cprov_archive.getPublishedOnDiskBinaries(
    ...     status=inactive_status).count()
    0

    >>> cprov_archive.getAllPublishedBinaries(
    ...     status=inactive_status).count()
    0

Using 'distroarchseries' filter:

    >>> warty_i386 = warty['i386']
    >>> warty_hppa = warty['hppa']

    >>> cprov_archive.getAllPublishedBinaries(
    ...     distroarchseries=warty_i386).count()
    2
    >>> cprov_archive.getAllPublishedBinaries(
    ...     distroarchseries=warty_hppa).count()
    2

    >>> cprov_archive.getPublishedOnDiskBinaries(
    ...     distroarchseries=warty_i386).count()
    2
    >>> cprov_archive.getPublishedOnDiskBinaries(
    ...     distroarchseries=warty_hppa).count()
    1

    >>> cprov_archive.getAllPublishedBinaries(
    ...     distroarchseries=[warty_i386, warty_hppa]).count()
    4
    >>> cprov_archive.getPublishedOnDiskBinaries(
    ...     distroarchseries=[warty_i386, warty_hppa]).count()
    3

Using 'pocket' filter:

    >>> cprov_archive.getAllPublishedBinaries(
    ...     distroarchseries=warty_i386,
    ...     pocket=PackagePublishingPocket.RELEASE).count()
    2
    >>> cprov_archive.getPublishedOnDiskBinaries(
    ...     distroarchseries=warty_i386,
    ...     pocket=PackagePublishingPocket.RELEASE).count()
    2

    >>> cprov_archive.getAllPublishedBinaries(
    ...     distroarchseries=warty_i386,
    ...     pocket=PackagePublishingPocket.UPDATES).count()
    0
    >>> cprov_archive.getPublishedOnDiskBinaries(
    ...     distroarchseries=warty_i386,
    ...     pocket=PackagePublishingPocket.UPDATES).count()
    0

Associating 'name' and 'status' filters:

    >>> status_lookup = cprov_archive.getPublishedOnDiskBinaries(
    ...     name='pmount', status=active_status)
    >>> status_lookup.count()
    1

    >>> status_lookup = cprov_archive.getAllPublishedBinaries(
    ...     name='pmount', status=active_status)
    >>> status_lookup.count()
    2

    >>> status_lookup = cprov_archive.getPublishedOnDiskBinaries(
    ...     name='foo', status=active_status)
    >>> status_lookup.count()
    0

    >>> status_lookup = cprov_archive.getAllPublishedBinaries(
    ...     name='foo', status=active_status)
    >>> status_lookup.count()
    0

Associating 'name', 'version' and 'status' filters:

    >>> status_lookup = cprov_archive.getPublishedOnDiskBinaries(
    ...     name='pmount', version='0.1-1', status=active_status)
    >>> status_lookup.count()
    1

    >>> status_lookup = cprov_archive.getAllPublishedBinaries(
    ...     name='pmount', version='0.1-1', status=active_status)
    >>> status_lookup.count()
    2

    >>> status_lookup = cprov_archive.getPublishedOnDiskBinaries(
    ...     name='pmount', version='666', status=active_status)
    >>> status_lookup.count()
    0

    >>> status_lookup = cprov_archive.getAllPublishedBinaries(
    ...     name='pmount', version='666', status=active_status)
    >>> status_lookup.count()
    0

Associating 'name', 'version', 'status' and 'distroarchseries' filters
and 'exact_match' flag:

    >>> status_lookup = cprov_archive.getAllPublishedBinaries(
    ...     name='pmount', version='0.1-1', distroarchseries=warty_i386,
    ...     status=active_status, exact_match=True)
    >>> status_lookup.count()
    1

    >>> status_lookup = cprov_archive.getAllPublishedBinaries(
    ...     name='pmount', version='0.1-1',
    ...     distroarchseries=[warty_i386, warty_hppa],
    ...     status=active_status, exact_match=True)
    >>> status_lookup.count()
    2


== Package Counters ==

IArchive provides properties to calculate the number and the size of
the packages (sources and binaries) currently published in the
archive. They are based in the publication lookup methods.

    >>> cprov_archive.number_of_sources
    3
    >>> cprov_archive.number_of_binaries
    3
    >>> cprov_archive.sources_size
    9923399
    >>> cprov_archive.binaries_size
    3

Additionally we have another property to sum up the sources and the
binaries size and a pre-defined increment related to the files created
in the archive (+1kbytes for each publication)

    >>> pool_size = (
    ...     cprov_archive.sources_size + cprov_archive.binaries_size)

    >>> number_of_publications = (
    ...     cprov_archive.number_of_sources +
    ...     cprov_archive.number_of_binaries)
    >>> indexes_size = number_of_publications * 1024

    >>> estimated_size = cprov_archive.estimated_size
    >>> estimated_size
    9929546

    >>> estimated_size == pool_size + indexes_size
    True

The 'estimated_size' property automatically excludes duplicated published
files as it happens in the archive filesystem (pool/):

    >>> def print_published_files(archive):
    ...     pub_sources = archive.getPublishedSources()
    ...     for pub_source in pub_sources:
    ...         for src_file in pub_source.sourcepackagerelease.files:
    ...             print '%s: %s (%s, %d bytes)' % (
    ...                 src_file.sourcepackagerelease.title,
    ...                 src_file.libraryfile.filename,
    ...                 src_file.filetype.name,
    ...                 src_file.libraryfile.content.filesize)

First, let's print the currently published files in cprov's PPA:

    >>> print_published_files(cprov_archive)
    cdrkit - 1.0: foobar-1.0.dsc (DSC, 716 bytes)
    iceweasel - 1.0: firefox-0.9.2.orig.tar.gz (ORIG, 9922560 bytes)
    iceweasel - 1.0: iceweasel-1.0.dsc (DSC, 123 bytes)

Now we will emulate a duplicated reference to the same 'orig.tar.gz',
upstream tarball, as if it was part of two different SourcePackageRelease.

    >>> from canonical.launchpad.interfaces import ILibraryFileAliasSet
    >>> huge_firefox_orig_file = getUtility(ILibraryFileAliasSet)[3]
    >>> cprov_cdrkit_src = cprov_archive.getPublishedSources(
    ...     name='cdrkit')[0]
    >>> unused_src_file = cprov_cdrkit_src.sourcepackagerelease.addFile(
    ...     huge_firefox_orig_file)

As we see below, now we have two references to
'firefox-0.9.2.orig.tar.gz' file.

    >>> print_published_files(cprov_archive)
    cdrkit - 1.0: firefox-0.9.2.orig.tar.gz (ORIG, 9922560 bytes)
    cdrkit - 1.0: foobar-1.0.dsc (DSC, 716 bytes)
    iceweasel - 1.0: firefox-0.9.2.orig.tar.gz (ORIG, 9922560 bytes)
    iceweasel - 1.0: iceweasel-1.0.dsc (DSC, 123 bytes)

Similarly to what happen in the archive disk 'pool', where already
published files satisfy the new reference, the file size is not
computed again in the archive total size.

    >>> estimated_size == cprov_archive.estimated_size
    True

As mentioned before the package counters do not include non-PUBLISHED
packages, to verify this we will mark some package as SUPERSEDED and
see if the counter decreases.

    >>> from canonical.database.sqlbase import flush_database_updates

Superseding a source package and verifying that the source counter
decreases.

    >>> cprov_archive.number_of_sources
    3
    >>> unused = cprov_archive.getPublishedSources(
    ...     name='cdrkit')[0].supersede()
    >>> flush_database_updates()
    >>> cprov_archive.number_of_sources
    2

Superseding a binary package and verifying that the binary counter
decreases.

    >>> cprov_archive.number_of_binaries
    3
    >>> unused = cprov_archive.getAllPublishedBinaries(
    ...     name='mozilla-firefox')[0].supersede()
    >>> flush_database_updates()
    >>> cprov_archive.number_of_binaries
    2


== Build Lookup ==

It also implements a build lookup method, which supports, 'name',
'status' and 'pocket'.

This method can return build records for sources matching the given
'name' as in SQL LIKE:

    >>> cd_lookup = cprov_archive.getBuildRecords(name='cd')
    >>> cd_lookup.count()
    1
    >>> cd_lookup[0].sourcepackagerelease.name
    u'cdrkit'

    >>> ice_lookup = cprov_archive.getBuildRecords(name='ice')
    >>> ice_lookup.count()
    1
    >>> ice_lookup[0].sourcepackagerelease.name
    u'iceweasel'

    >>> cprov_archive.getBuildRecords(name='foo').count()
    0

Or return build records in a specific status:

    >>> from canonical.launchpad.interfaces import BuildStatus
    >>> cprov_archive.getBuildRecords(
    ...     build_state=BuildStatus.FULLYBUILT).count()
    3

    >>> cprov_archive.getBuildRecords(
    ...     build_state=BuildStatus.FAILEDTOBUILD).count()
    1

    >>> cprov_archive.getBuildRecords(
    ...     build_state=BuildStatus.NEEDSBUILD).count()
    0

And finally build records target to a given pocket:

    >>> cprov_archive.getBuildRecords(
    ...     pocket=PackagePublishingPocket.RELEASE).count()
    4

    >>> cprov_archive.getBuildRecords(
    ...     pocket=PackagePublishingPocket.UPDATES).count()
    0

All the attributes can be combined in order to refine the result:

    >>> cprov_archive.getBuildRecords(
    ...     name='ice',
    ...     build_state=BuildStatus.FULLYBUILT,
    ...     pocket=PackagePublishingPocket.RELEASE).count()
    1


== Publisher configuration provider ==

IArchive has a method to provide a modified Publisher Configuration (see
lib/archivepublisher/config.py), which provides the right paths for its
publication according to the given distribution:

    >>> # cprov 20061127: We should *never* be able to change a PPA
    >>> # distribution, however 'ubuntu' is not prepared for publication, thus
    >>> # we have to override the PPA to 'ubuntutest' in order to perform the
    >>> # tests.

    >>> from zope.security.proxy import removeSecurityProxy
    >>> ubuntutest = getUtility(IDistributionSet)['ubuntutest']

    >>> naked_cprov_archive = removeSecurityProxy(cprov_archive)
    >>> naked_cprov_archive.distribution = ubuntutest
    >>> pubconfig = naked_cprov_archive.getPubConfig()

The base Archive publication location is set in the current Launchpad
configuration file:

    >>> from canonical.config import config
    >>> pubconfig.distroroot == config.personalpackagearchive.root
    True

Then, the archive topology will follow:

<PPA_BASE_DIR>/<PERSONNAME>/<DISTRIBUTION>

    >>> pubconfig.archiveroot
    u'/var/tmp/ppa.test/cprov/ubuntutest'

    >>> pubconfig.poolroot
    u'/var/tmp/ppa.test/cprov/ubuntutest/pool'

    >>> pubconfig.distsroot
    u'/var/tmp/ppa.test/cprov/ubuntutest/dists'

Path not used in *personal* archives publication workflow are set to
None, so they won't get created:

    >>> pubconfig.overrideroot is None
    True
    >>> pubconfig.cacheroot is None
    True
    >>> pubconfig.miscroot is None
    True

Usual methods from Publisher Configuration are preserved:

    >>> pubconfig.distroSeriesNames()
    ['breezy-autotest', 'hoary-test']

    >>> pubconfig.archTagsForSeries('breezy-autotest')
    []

    >>> pubconfig.componentsForSeries('breezy-autotest')
    ['main', 'restricted', 'universe', 'multiverse']


== Archive dependencies ==

An Archive can depend on one or more other archives, such
relationships affects mainly its builds, which will be querying build
dependencies also in dependent archives, and its client system which
will have to enable apt to look for package dependencies in the
dependent archive as well.

Currently only one level of dependency is supported, i.e., PPA X
depends on PPA Y, if PPA W wants to use packages of PPA X it will have
to depend also on PPA Y, otherwise it won't be able to install all the
required dependencies when building.

    >>> def print_dependencies(archive):
    ...     dependencies = archive.dependencies
    ...     if not dependencies:
    ...         print "No dependencies recorded."
    ...         return
    ...     for dep in dependencies:
    ...         print dep.dependency.title

Celso's PPA has no dependencies stored in the sampledata.

    >>> print_dependencies(cprov.archive)
    No dependencies recorded.

We will make Celso's PPA to depend on Mark's PPA.

    >>> sabdfl = getUtility(IPersonSet).getByName('sabdfl')
    >>> archive_dependency = cprov.archive.addArchiveDependency(
    ...     sabdfl.archive)

The `IArchiveDependency` object simply maps the desired relationship.

    >>> print archive_dependency.archive.title
    PPA for Celso Providelo

    >>> print archive_dependency.dependency.title
    PPA for Mark Shuttleworth

The archive dependency is immediately recorded on Celso's PPA.

    >>> print_dependencies(cprov.archive)
    PPA for Mark Shuttleworth

'getArchiveDependency' returns the corresponding `IArchiveDependency`
for a give 'dependency' if it exists, otherwise it returns None.

    >>> print cprov.archive.getArchiveDependency(
    ...     sabdfl.archive).dependency.title
    PPA for Mark Shuttleworth

    >>> no_priv = getUtility(IPersonSet).getByName('no-priv')
    >>> print cprov.archive.getArchiveDependency(no_priv.archive)
    None

As mentioned above, the archive dependency engine doesn't follow
cross dependencies. When a PPA depends only on Celso's PPA it might
result in issues while building package if a required package
dependency is published in Mark's PPA.

    >>> print_dependencies(no_priv.archive)
    No dependencies recorded.

    >>> archive_dependency = no_priv.archive.addArchiveDependency(
    ...     cprov.archive)

    >>> print_dependencies(no_priv.archive)
    PPA for Celso Providelo

`IArchive.addArchiveDependency` raises an error if the given
'dependency' violates the system overall constraints.

'dependency' is already records (duplicated).

    >>> no_priv.archive.addArchiveDependency(cprov.archive)
    Traceback (most recent call last):
    ...
    AssertionError: This dependency is already recorded.

'dependency' and target archive are the same.

    >>> no_priv.archive.addArchiveDependency(no_priv.archive)
    Traceback (most recent call last):
    ...
    AssertionError: An archive should not depend on itself.

A 'dependency' must be a PPA, other archives (PRIMARY, PARTNER or
EMBARGOED) are explicitly forbidden because we want to analyse the
impacts carefully when it's time.

    >>> ubuntu = no_priv.archive.distribution
    >>> no_priv.archive.addArchiveDependency(ubuntu.main_archive)
    Traceback (most recent call last):
    ...
    AssertionError: Archive dependencies only applies to PPAs.

'removeArchiveDependency' allow us to purge a recorded 'dependency'.

    >>> print_dependencies(no_priv.archive)
    PPA for Celso Providelo

    >>> no_priv.archive.removeArchiveDependency(cprov.archive)

    >>> print_dependencies(no_priv.archive)
    No dependencies recorded.


== IArchiveSet Utility ==

This utility provides useful methods to deal with IArchive in other
parts of the system.

    >>> archive_set = getUtility(IArchiveSet)

A new Archive can be created by passing a name and an owner

    >>> name16 = getUtility(IPersonSet).getByName('name16')
    >>> sandbox_archive = archive_set.new(
    ...    purpose=ArchivePurpose.PPA, owner=name16)

    >>> verifyObject(IArchive, sandbox_archive)
    True

    >>> sandbox_archive.owner == name16
    True

We can take the opportunity to check if the default 'authorized_size'
corresponds to what we state in our policy, 1024 MiB:

    >>> name16.archive.authorized_size
    1024

IArchiveSet.ensure will either return an existing archive, or make a new
one if there is no existing one.

    >>> name12 = getUtility(IPersonSet).getByName('name12')
    >>> name12_archive = archive_set.ensure(
    ...     owner=name12, distribution=None, purpose=ArchivePurpose.PPA,
    ...     description="Holy mackerel")
    >>> name12_archive.description
    u'Holy mackerel'

Repeating this call with a different description results in the archive
created above returned instead of a new one:

    >>> name12_archive = archive_set.ensure(
    ...     owner=name12, distribution=None, purpose=ArchivePurpose.PPA,
    ...     description="Flaming trousers")
    >>> name12_archive.description
    u'Holy mackerel'

An archive is also associated with a distribution.  This can be found on
the distribution property.  The default distribution is "ubuntu":

     >>> sandbox_archive.distribution.name
     u'ubuntu'

An Archive can be retrieved via IPerson.archive property:

    >>> name16.archive == sandbox_archive
    True

IArchiveSet.getByDistroPurpose retrieves an IArchive given a distribution
and an ArchivePurpose:

    >>> from canonical.launchpad.interfaces import ArchivePurpose
    >>> partner_archive = getUtility(IArchiveSet).getByDistroPurpose(
    ...     ubuntutest, ArchivePurpose.PARTNER)
    >>> partner_archive.description
    u'Partner archive'

IArchive.archive_url will return a URL for the archive that the builder can
use to retrieve files from it.

    >>> partner_archive.archive_url
    u'http://launchpad.dev/ubuntutest-partner'

    >>> sandbox_archive.archive_url
    u'http://ppa.launchpad.dev/name16/ubuntu'

    >>> getUtility(IArchiveSet).getByDistroPurpose(
    ...     ubuntutest, ArchivePurpose.PRIMARY).archive_url
    u'http://launchpad.dev/ubuntutest'

The publisher config for PARTNER contains only 'partner' in its
components.  This prevents non-partner being published in the partner
archive.

    >>> comm_pubconf = removeSecurityProxy(
    ...     partner_archive.getPubConfig())
    >>> for distroseries in comm_pubconf._distroserieses.keys():
    ...     print set(
    ...         comm_pubconf._distroserieses[distroseries]['components'])
    set(['partner'])
    set(['partner'])

IArchive.allowUpdatesToReleasePocket returns whether the archive is allowed
to publish to the RELEASE pocket no matter what state the distroseries is in.

    >>> partner_archive.allowUpdatesToReleasePocket()
    True

    >>> cprov_archive.allowUpdatesToReleasePocket()
    True

    >>> getUtility(IArchiveSet).getByDistroPurpose(
    ...     ubuntutest, ArchivePurpose.PRIMARY).allowUpdatesToReleasePocket()
    False

getPPAByDistributionAndOwnerName method allow PPA lookups based on a
distribution and a person name. This method is used in
`PackageLocation` to provide a homogeneous way to refer to a Location
(archive, distribution, distroseries, pocket).

    >>> ubuntu = getUtility(IDistributionSet)['ubuntu']
    >>> cprov_archive == archive_set.getPPAByDistributionAndOwnerName(
    ...     ubuntu, 'cprov')
    True

    >>> sabdfl = getUtility(IPersonSet).getByName('sabdfl')
    >>> sabdfl.archive == archive_set.getPPAByDistributionAndOwnerName(
    ...     ubuntu, 'sabdfl')
    True

Iteration over the own utility is performed against all archives,
including the *main_archives*:

    >>> main_archives = 0
    >>> ppas = 0
    >>> for archive in archive_set:
    ...     if archive.owner is None:
    ...         main_archives += 1
    ...     else:
    ...         ppas += 1
    >>> main_archives, ppas
    (9, 5)
