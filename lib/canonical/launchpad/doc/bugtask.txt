Introduction
============

Bugs are problems in software. When a bug gets assigned to a specific
upstream or distro/sourcepackagename/binarypackagename, a bug /task/ is
created. In essence, a bug task is a bug that needs to be fixed in a specific
place. Where a bug has things like a title, comments and subscribers, it's
the bug task that tracks priority, severity, assignee, etc.

Working with Bug Tasks in Launchpad
===================================

Creating Bug Tasks
------------------

All BugTask creation and retrieval is done through an IBugTaskSet utility.

    >>> from zope.component import getUtility
    >>> import transaction
    >>> from canonical.launchpad.interfaces import IBugTaskSet
    >>> bugtaskset = getUtility(IBugTaskSet)

To create a bug task, you have to be logged in:

    >>> from canonical.launchpad.ftests import login, ANONYMOUS
    >>> login('foo.bar@canonical.com')

There are three kinds of bug tasks. We need to pass the bug task creation
methods some other objects to create a task, so lets get the utilities we need
to access those other objects:

    >>> from canonical.launchpad.interfaces import (IBugSet, IPersonSet,
    ...     IProductSet, IDistributionSet, IDistroReleaseSet)
    >>> productset = getUtility(IProductSet)
    >>> distroset = getUtility(IDistributionSet)
    >>> distoreleaseset = getUtility(IDistroReleaseSet)
    >>> bugset = getUtility(IBugSet)
    >>> personset = getUtility(IPersonSet)
    >>> bug_one = bugset.get(1)
    >>> sabdfl = personset.get(1)

Next, we need to grab some values to provide for priority, severity and status.

    >>> from canonical.lp.dbschema import (BugTaskStatus, BugTaskSeverity,
    ...     BugTaskPriority)
    >>> STATUS_NEW = BugTaskStatus.NEW
    >>> STATUS_ACCEPTED = BugTaskStatus.ACCEPTED
    >>> STATUS_FIXED = BugTaskStatus.FIXED
    >>> SEVERITY_NORMAL = BugTaskSeverity.NORMAL
    >>> PRIORITY_MEDIUM = BugTaskPriority.MEDIUM

  i. Upstream -- a bug that has to be fixed in an upstream product

    >>> evolution = productset.get(5)
    >>> upstream_task = bugtaskset.createTask(
    ...     bug=bug_one, product=evolution, owner=sabdfl,
    ...     status=STATUS_NEW, priority=PRIORITY_MEDIUM,
    ...     severity=SEVERITY_NORMAL)
    >>> upstream_task.product == evolution
    True

    >>> from canonical.launchpad.interfaces import IUpstreamBugTask
    >>> IUpstreamBugTask.providedBy(upstream_task)
    True

  ii. Distro -- a bug that has to be fixed in a specific distro

    >>> ubuntu = distroset.get(1)
    >>> distro_task = bugtaskset.createTask(
    ...     bug=bug_one, distribution=ubuntu, owner=sabdfl,
    ...     status=STATUS_NEW, priority=PRIORITY_MEDIUM,
    ...     severity=SEVERITY_NORMAL)
    >>> distro_task.distribution == ubuntu
    True

    >>> from canonical.launchpad.interfaces import IDistroBugTask
    >>> IDistroBugTask.providedBy(distro_task)
    True

  ii. Distro Release -- a bug that has to be fixed in a specific distro
  release. This primary use case for distro release bug tasks is for backporting
  fixes (e.g. for security bugs or bugs causing critical data loss.)

    >>> hoary = distoreleaseset.get(3)
    >>> distro_release_task = bugtaskset.createTask(
    ...     bug=bug_one, distrorelease=hoary, owner=sabdfl,
    ...     status=STATUS_NEW, priority=PRIORITY_MEDIUM,
    ...     severity=SEVERITY_NORMAL)
    >>> distro_release_task.distrorelease == hoary
    True

    >>> from canonical.launchpad.interfaces import IDistroReleaseBugTask
    >>> IDistroReleaseBugTask.providedBy(distro_release_task)
    True

XXX: Brad Bollenbach, 2005-02-24: See the bottom of this file for a chunk of
test documentation that is missing from here, due to problems with resetting
the connection after a ProgrammingError is raised. ARGH.

Retrieving and Searching for Bug Tasks
--------------------------------------

To retrieve a specific BugTask, use IBugTaskSet.get. As an example, interacting
with the system as an anonymous (i.e. unauthenticated) user:

    >>> from canonical.launchpad.interfaces import IPerson
    >>> from canonical.launchpad.database import Person
    >>> login(ANONYMOUS)

let's fetch the BugTask with ID 1:

    >>> bugtask = bugtaskset.get(1)
    >>> bugtask.bug.title
    u'Firefox does not support SVG'

If you pass an ID for which no object exists, you'll get a
zope.exceptions.NotFoundError:

    >>> bugtask = bugtaskset.get(-1)
    Traceback (most recent call last):
      ...
    NotFoundError: 'BugTask with ID -1 does not exist'

Bug Task Targets
----------------

The "target" of an IBugTask is one of the following things:

 * an upstream product

    >>> upstream_task.target == evolution
    True

  * a distribution

    >>> distro_task.target == ubuntu
    True

  * a distrorelease

    >>> distro_release_task.target == hoary
    True

  * a distribution sourcepackage

    >>> from canonical.launchpad.database.sourcepackage import DistroSourcePackage
    >>> from canonical.launchpad.interfaces import IDistroSourcePackage
    >>> distro_sp_task = bugtaskset.get(4)
    >>> expected_target = DistroSourcePackage(
    ...     distribution=distro_sp_task.distribution,
    ...     sourcepackagename=distro_sp_task.sourcepackagename)
    >>> got_target = distro_sp_task.target
    >>> IDistroSourcePackage.providedBy(distro_sp_task.target)
    True
    >>> got_target.distribution == expected_target.distribution
    True
    >>> got_target.sourcepackagename == expected_target.sourcepackagename
    True

  * a distrorelease sourcepackage

    >>> from canonical.launchpad.database import SourcePackage
    >>> from canonical.launchpad.interfaces import ISourcePackage
    >>> distro_release_sp_task = bugtaskset.get(16)
    >>> expected_target = SourcePackage(
    ...     distrorelease=distro_release_sp_task.distrorelease,
    ...     sourcepackagename=distro_release_sp_task.sourcepackagename)
    >>> got_target = distro_release_sp_task.target
    >>> ISourcePackage.providedBy(distro_release_sp_task.target)
    True
    >>> got_target.distrorelease == expected_target.distrorelease
    True
    >>> got_target.sourcepackagename == expected_target.sourcepackagename
    True

Each task has a "targetname", a string describing the site of the
task. It concatenates the display names of the distribution,

    >>> bugtask = bugtaskset.get(1)
    >>> bugtask.targetname
    u'upstream ubuntu'

distro release, or product;

    >>> bugtask = bugtaskset.get(2)
    >>> bugtask.targetname
    u'upstream firefox'

the name of the source package (if any); and the name of the binary
package (but only if it's named differently from the source
package).

Let's thoroughly test BugTask.targetname.  We'll set up a dummy bugtask
class into which we put a copy of the targetname method, so we can test
it in isolation.

    >>> from canonical.launchpad.database import BugTask
    >>> class DummyBugTask:
    ...     distribution = None
    ...     distrorelease = None
    ...     sourcepackagename = None
    ...     binarypackagename = None
    ...     product = None
    ...
    ...     # This next line is a hack to take a copy of the method and
    ...     # add it to this class.
    ...     targetname = BugTask.targetname.fget
    >>> class NamedThing:
    ...     def __init__(self, name):
    ...         self.name = '[%s.name]' % name
    ...         self.displayname = '[%s.displayname]' % name

When all the important attributes are None, then the bugtask is in an invalid
state.

    >>> bugtask = DummyBugTask()
    >>> bugtask.targetname()
    Traceback (most recent call last):
    ...
    AssertionError: ...

Product alone:

    >>> bugtask.product = NamedThing('product')
    >>> bugtask.targetname()
    'upstream [product.name]'

Put things back the way they were.

    >>> bugtask.product = None

Distribution alone.

    >>> bugtask.distribution = NamedThing('distribution')
    >>> bugtask.targetname()
    '[distribution.displayname]'

Distribution and sourcepackagename.

    >>> bugtask.sourcepackagename = NamedThing('spn')
    >>> bugtask.targetname()
    '[distribution.displayname] [spn.name]'

Distribution and sourcepackagename and binarypackagename.

    >>> bugtask.binarypackagename = NamedThing('bpn')
    >>> bugtask.targetname()
    '[distribution.displayname] [spn.name] [bpn.name]'

Reset the state of our bugtask.

    >>> bugtask.binarypackagename = None
    >>> bugtask.sourcepackagename = None
    >>> bugtask.distribution = None

Just a distrorelease.

    >>> bugtask.distrorelease = NamedThing('distrorelease')
    >>> bugtask.distrorelease.distribution = NamedThing('distribution')
    >>> bugtask.targetname()
    '[distribution.displayname] [distrorelease.displayname]'

Distrorelease and sourcepackagename.

    >>> bugtask.sourcepackagename = NamedThing('spn')
    >>> bugtask.targetname()
    '[distribution.displayname] [distrorelease.displayname] [spn.name]'

Distrorelease, sourcepackagename and binarypackagename.

    >>> bugtask.binarypackagename = NamedThing('bpn')
    >>> bugtask.targetname()
    '[distribution.displayname] [distrorelease.displayname] [spn.name] [bpn.name]'

Note that we haven't tested any combinations that shouldn't occur, except
for the case when everything is None.

To retrieve a set of bug tasks matching a set of search criteria, use
the searchTasks method of the IBugTarget interface. Here's how you'd
grab all the NEW and ACCEPTED tasks:

For upstream:

    >>> from canonical.launchpad.searchbuilder import any
    >>> from canonical.lp.dbschema import BugTaskStatus
    >>> from canonical.launchpad.database import Product
    >>> from canonical.launchpad.interfaces import BugTaskSearchParams
    >>> upstream_mozilla = Product.get(4)
    >>> params = BugTaskSearchParams(status=any(BugTaskStatus.NEW,
    ...                                         BugTaskStatus.ACCEPTED),
    ...                              orderby="id", user=None)
    >>> bugtasks = upstream_mozilla.searchTasks(params)
    >>> print bugtasks.count()
    4
    >>> bugtask_ids = [bt.id for bt in bugtasks]
    >>> print bugtask_ids
    [2, 13, 14, 15]

For a distribution:

    >>> debian = distroset.get(3)
    >>> sample_person = personset.get(12)
    >>> params = BugTaskSearchParams(status=any(BugTaskStatus.NEW,
    ...                                         BugTaskStatus.ACCEPTED),
    ...                              orderby="id", user=None,
    ...                              assignee=sample_person)
    >>> bugtasks = debian.searchTasks(params)
    >>> print bugtasks.count()
    1
    >>> bugtasks[0].id
    5

To provide null-matching search criteria, use canonical.launchpad.searchbuilder.NULL:

    >>> from canonical.launchpad.searchbuilder import NULL
    >>> params = BugTaskSearchParams(assignee=NULL, user=None)
    >>> bugtasks = upstream_mozilla.searchTasks(params)
    >>> print bugtasks.count()
    2
    >>> print [bugtask.bug.id for bugtask in bugtasks]
    [4, 6]

There's also support for searching tasks based on a string of text, e.g.:

    >>> params = BugTaskSearchParams(searchtext="instructions", user=None)
    >>> bugtasks = upstream_mozilla.searchTasks(params)
    >>> print bugtasks.count()
    1
    >>> print [bugtask.bug.id for bugtask in bugtasks]
    [5]

It's also possible to iterate over all the bug tasks:

    >>> bugtasks = [bugtask for bugtasks in bugtaskset]
    >>> len(bugtasks)
    17

Bug Task Maintainers
--------------------

The upcoming sections mention bug task maintainers, so we should
probably clarify that before going any further. IBugTask provides a
maintainer attribute, and a maintainer_displayname attribute; the
latter is mainly for use in ZCML configuration on add/editforms where
you want to show the maintainer's name. maintainer_displayname will
probably go away in the future and be replaced by a smarter display
widget for the maintainer name.

The maintainer of an upstream task is simply the Product.owner:

    >>> bugtask = bugtaskset.get(1)
    >>> bugtask.maintainer.id
    17

The maintainer of a distribution task is the source package maintainer:

    >>> bugtask = bugtaskset.get(4)
    >>> bugtask.maintainer.id
    1

or None, if the task is not yet assigned to a specific source
package. So, borrowing the distro task we filed earlier:

    >>> print distro_task.maintainer
    None
    >>> print distro_task.maintainer_displayname
    None

Editing Bug Tasks
-----------------

Upstream Bug Tasks
^^^^^^^^^^^^^^^^^^

To edit an upstream task, you must be logged in. Anonymous users
cannot edit upstream tasks.

    >>> login(ANONYMOUS)
    >>> upstream_task.status = STATUS_ACCEPTED
    Traceback (most recent call last):
      ...
    Unauthorized: ('status', 'launchpad.Edit')

Now let's login as a maintainer and try again.

    >>> login('test@canonical.com')
    >>> upstream_task.status = STATUS_FIXED

Again, this time as someone other than the maintainer:

    >>> login('jeff.waugh@ubuntulinux.com')
    >>> upstream_task.status = STATUS_FIXED

Distro and Distro Release Bug Tasks
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Any logged-in user can edit tasks filed on distros as long as the bug
is not marked private. So, as an anonymous user, we can edit anything:

    >>> login(ANONYMOUS)
    >>> distro_task.status = STATUS_FIXED
    Traceback (most recent call last):
      ...
    Unauthorized: ('status', 'launchpad.Edit')

    >>> distro_release_task.assignee = sample_person
    Traceback (most recent call last):
      ...
    Unauthorized: ('assignee', 'launchpad.Edit')

But once authenticated:

    >>> login('test@canonical.com')

We can edit the task:

    >>> distro_task.status = STATUS_FIXED
    >>> distro_release_task.assignee = sample_person

Null Bug Tasks
--------------

Sometimes we need to be able to render a page for a bug in a context,
when the bug hasn't actually been filed yet in that context. For cases
like these, use the NullBugTask object.

    >>> from canonical.launchpad.components.bugtask import NullBugTask

    >>> netapplet = productset.get(11)
    >>> null_bugtask = NullBugTask(bug=bug_one, product=netapplet)
    >>> IUpstreamBugTask.providedBy(null_bugtask)
    True

    >>> null_bugtask.id is None
    True
    >>> null_bugtask.product is netapplet
    True
    >>> null_bugtask.bug == bug_one
    True
    >>> null_bugtask.datecreated is None
    True
    >>> null_bugtask.dateassigned is None
    True
    >>> null_bugtask.age is None
    True
    >>> null_bugtask.status is None
    True
    >>> null_bugtask.priority is None
    True
    >>> null_bugtask.sourcepackagename is None
    True
    >>> null_bugtask.distribution is None
    True
    >>> null_bugtask.distrorelease is None
    True
    >>> null_bugtask.milestone is None
    True
    >>> null_bugtask.statusexplanation is None
    True
    >>> null_bugtask.severity is None
    True
    >>> null_bugtask.assignee is None
    True
    >>> null_bugtask.binarypackagename is None
    True
    >>> null_bugtask.bugwatch is None
    True
    >>> null_bugtask.owner is None
    True
    >>> null_bugtask.maintainer == netapplet.owner
    True
    >>> null_bugtask.maintainer_displayname == netapplet.owner.displayname
    True
    >>> null_bugtask.target == netapplet
    True
    >>> null_bugtask.targetname
    u'upstream netapplet'
    >>> expected_related_task_ids = [
    ...     task.id for task in null_bugtask.related_tasks]
    >>> actual_related_task_ids = [task.id for task in bug_one.bugtasks]
    >>> expected_related_task_ids.sort()
    >>> actual_related_task_ids.sort()
    >>> expected_related_task_ids == actual_related_task_ids
    True
    >>> null_bugtask.statusdisplayhtml
    u'Not reported in upstream netapplet'
    >>> null_bugtask.statuselsewhere
    'Fixed in 2 of 7 places'

The astute reader will have noticed that NullBugTask automatically
"marked" itself as providing the correct IBugTask interface. Let's see
two more examples:

    >>> ubuntu_null_bugtask = NullBugTask(bug=bug_one, distribution=ubuntu)
    >>> IDistroBugTask.providedBy(ubuntu_null_bugtask)
    True

    >>> hoary_null_bugtask = NullBugTask(bug=bug_one, distrorelease=hoary)
    >>> IDistroReleaseBugTask.providedBy(hoary_null_bugtask)
    True

Bug Privacy
===========

A bug is either private or public. Private bugs are only visible (e.g. in
search listings) to explicit subscribers. Public bugs are visible to
anyone.

    >>> from zope.event import notify
    >>> from zope.publisher.browser import TestRequest
    >>> from canonical.launchpad.event.sqlobjectevent import (
    ...     SQLObjectToBeModifiedEvent, SQLObjectModifiedEvent)

Let's log in as the user Foo Bar (to be allowed to edit bugs):

    >>> login('foo.bar@canonical.com')
    >>> foobar = getUtility(ILaunchBag).user

and mark one of the Firefox bugs private:

    >>> bug_firefox_no_svg_support = bugtaskset.get(2)
    >>> notify(SQLObjectToBeModifiedEvent(
    ...     bug_firefox_no_svg_support.bug, {'private' : True}))

    >>> def capture_state(obj, *fields):
    ...     class State: pass
    ...     state = State()
    ...     for field in fields:
    ...         setattr(state, field, getattr(obj, field))
    ...     return state
    >>> old_state = capture_state(
    ...     bug_firefox_no_svg_support.bug, "id", "title",
    ...     "summary", "description", "private", "name",
    ...     "duplicateof")
    >>> bug_firefox_no_svg_support.bug.private = True
    >>> bug_set_private = SQLObjectModifiedEvent(
    ...     bug_firefox_no_svg_support.bug, old_state,
    ...     ["id", "title", "private"])
    >>> notify(bug_set_private)
    >>> transaction.commit()

Because Foo Bar is a member of the Ubuntu Team, and the Ubuntu Team is
one of the maintainers on this bug report, Foo Bar will see the bug in
searches:

    >>> firefox = productset.get(4)
    >>> params = BugTaskSearchParams(status=any(STATUS_NEW,
    ...                                         STATUS_ACCEPTED),
    ...                              user=foobar)
    >>> firefox_bugtasks = firefox.searchTasks(params)
    >>> [bugtask.bug.id for bugtask in firefox_bugtasks]
    [1, 4, 5, 6]

If logged in as Foo Bar we query for all bugtasks reported on all
packages/products he maintains, we'll see that bug 1 is there (we'll
not see it if we query logged in as a user who can't see that bug).

    >>> foobar_maintained_tasks = bugtaskset.maintainedBugTasks(
    ...     foobar, user=foobar)
    >>> [bugtask.bug.id for bugtask in foobar_maintained_tasks]
    [1, 2]

Now, if we log in as David Allouche:

    >>> login("david.allouche@canonical.com")
    >>> ddaa = getUtility(ILaunchBag).user

The same search as above yields only three bugs, because David
Allouche can't see the private bug.

    >>> params = BugTaskSearchParams(status=any(STATUS_NEW,
    ...                                         STATUS_ACCEPTED),
    ...                              orderby="id", user=ddaa)
    >>> bugtasks = upstream_mozilla.searchTasks(params)
    >>> print bugtasks.count()
    3
    >>> bugtask_ids = [bt.id for bt in bugtasks]
    >>> print bugtask_ids
    [13, 14, 15]

If logged in as David Allouche we query for all bugtasks reported on
packages/products Foo Bar is the maintainer, we'll not see bug 1 there
because it's a private bug.

    >>> foobar_maintained_tasks = bugtaskset.maintainedBugTasks(
    ...     foobar, user=ddaa)
    >>> [bugtask.bug.id for bugtask in foobar_maintained_tasks]
    [2]

Trying to retrieve the bug directly will work fine:

    >>> bug_firefox_no_svg_support = bugtaskset.get(2)

But attribute access on the IBugTask will raise an authorization
exception:

    >>> bug_firefox_no_svg_support.bug
    Traceback (most recent call last):
      ...
    Unauthorized: ('bug', 'launchpad.View')

Logging in as a member of the illustrious Launchpad admin team will
still not allow viewing of this private bug:

    >>> login("carlos@canonical.com")

    >>> bug_firefox_no_svg_support.bug
    Traceback (most recent call last):
      ...
    Unauthorized: ('bug', 'launchpad.View')

The same is true for carlos trying to edit an upstream task, e.g. the
one we created earlier on:

    >>> upstream_task.status = STATUS_ACCEPTED
    Traceback (most recent call last):
      ...
    Unauthorized: ('status', 'launchpad.Edit')

Trying to edit a distro task as David Allouche will raise an
Unauthorized exception:

    >>> login("david.allouche@canonical.com")

    >>> bug_debian_firefox_no_svg_support = bugtaskset.get(4)
    >>> bug_debian_firefox_no_svg_support.status = BugTaskStatus.FIXED
    Traceback (most recent call last):
      ...
    Unauthorized: ('status', 'launchpad.Edit')

Same, again, for an LP admin:

    >>> login("carlos@canonical.com")

    >>> bug_debian_firefox_no_svg_support.status = BugTaskStatus.FIXED
    Traceback (most recent call last):
      ...
    Unauthorized: ('status', 'launchpad.Edit')

But, logged in as the Firefox maintainer:

    >>> login('test@canonical.com')
    >>> sample_person = getUtility(ILaunchBag).user

We'll find all four IBugTasks that match the search criteria, as the maintainer
is also an explicit subscriber in this case.

    >>> params = BugTaskSearchParams(status=any(STATUS_NEW,
    ...                                         STATUS_ACCEPTED),
    ...                              orderby="id", user=sample_person)
    >>> bugtasks = upstream_mozilla.searchTasks(params)
    >>> print bugtasks.count()
    4
    >>> bugtask_ids = [bt.id for bt in bugtasks]
    >>> print bugtask_ids
    [2, 13, 14, 15]

And, as you would expect, we'll also be able to access it directly:

    >>> bug_firefox_no_svg_support = bugtaskset.get(2)
    >>> bug_firefox_no_svg_support.bug.title
    u'Firefox does not support SVG'

Sorting Bug Tasks
-----------------

Bug tasks need to sort in a very particular order. We want product tasks
first, then ubuntu tasks, then other distro-related tasks. In the
distro-related tasks we want a distribution-task first, then
distrorelease-tasks for that same distribution. The distrorelease tasks
should be sorted by distrorelease version.

Phew.

Let's just make sure that the tasks on bug_one sort correctly.

    >>> tasks = bug_one.bugtasks
    >>> for task in tasks:
    ...     print task.targetname
    upstream evolution
    upstream firefox
    upstream ubuntu
    ubuntu
    ubuntu mozilla-firefox
    ubuntu hoary
    debian mozilla-firefox

BugTask Adaptation
------------------

An IBugTask can be adapted to an IBug.

   >>> from canonical.launchpad.interfaces import IBug

   >>> bugtask_four = bugtaskset.get(4)
   >>> bug = IBug(bugtask_four)
   >>> bug.title
   u'Firefox does not support SVG'

Handling IntegrityError and ProgrammingError
--------------------------------------------

XXX: Brad Bollenbach, 2005-02-24: This bit testing the IntegrityError should be
higher up in the file (under the explanation about creating tasks), but I can't
figure out how to reset the connection properly after an IntegrityError is
raised. ARGH.

Note that a task filed on a specific distro release does *not* have its
distribution column set. In fact, a task must have exactly one of its product,
distribution or distrorelease fields set, otherwise the database integrity
constraints will be violated.

note that DatabaseError is a superclass of both IntegrityError and
ProgrammingError

    >>> from psycopg import DatabaseError
    >>> import sys
    >>> try: bad_task = bugtaskset.createTask(
    ...     bug=bug_one, distribution=ubuntu, distrorelease=hoary,
    ...     owner=sabdfl, status=STATUS_NEW, priority=PRIORITY_MEDIUM,
    ...     severity=SEVERITY_NORMAL)
    ... except DatabaseError: print sys.exc_value
    ERROR:  new row for relation "bugtask" violates check constraint "bugtask_assignment_checks"
    <BLANKLINE>
    INSERT INTO BugTask ...



