= Queue Notify =

DistroReleaseQueue has a notify() method to send emails.
We need to be logged into the security model in order to get any further

  >>> login('foo.bar@canonical.com')

Get a distroreleasequeue:

  >>> from canonical.launchpad.interfaces import IDistroReleaseQueueSet
  >>> drq = getUtility(IDistroReleaseQueueSet)[3]
  >>> print drq.displayname
  netapplet

The notify() method generates one email here on this unsigned package:

  >>> from canonical.archiveuploader.tests import (datadir, mock_logger)
  >>> changesfilepath = datadir(
  ...     'suite/netapplet_1.0-1/netapplet_1.0-1_source.changes')
  >>> changesfile = open(changesfilepath,'r')
  >>> drq.notify(
  ...     announcelist="announcelist@canonical.com", 
  ...     changesfileobject=changesfile, logger=mock_logger)
  DEBUG: Building recipients list.
  DEBUG: Changes file is unsigned, adding changer as recipient
  ...
  DEBUG: Sent a mail:
  ...
  DEBUG:     Recipients: Daniel Silverstone <daniel.silverstone@canonical.com>
  ...
  DEBUG: above if files already exist in other distroreleases.

Helper functions to examine emails that were sent:

  >>> import email
  >>> from canonical.launchpad.mail import stub
  >>> def by_to_addrs(a, b):
  ...     return cmp(a[1], b[1])
  >>> def pop_notifications():
  ...     stub.test_emails.sort(by_to_addrs)
  ...     notifications = [
  ...         email.message_from_string(raw_message)
  ...         for fromaddr, toaddrs, raw_message in stub.test_emails]
  ...     stub.test_emails = []
  ...     return notifications

There's only one email generated from the preceding upload:

  >>> transaction.commit()
  >>> len(stub.test_emails)
  1

The mail headers contain our To: as set on the notify() call.  The
subject contains "Accepted", the package name, its version and whether it's
source or binary.

  >>> [notification] = pop_notifications()
  >>> notification['To']
  'Daniel Silverstone <daniel.silverstone@canonical.com>'
  >>> notification['Subject']
  'netapplet-1.0.0.tar.gz is NEW'

The mail body contains a list of files that were accepted:

  >>> print notification.get_payload() # doctest: -NORMALIZE_WHITESPACE
  NEW: netapplet_1.0-1.dsc
  NEW: netapplet_1.0.orig.tar.gz
  NEW: netapplet_1.0-1.diff.gz
  <BLANKLINE>
  ...
  You may have gotten the distrorelease wrong.  If so, you may get warnings
  above if files already exist in other distroreleases.
  <BLANKLINE>

Now we will process a signed package.  First, we need to make the DRQ think
that it's signed:

  >>> from canonical.launchpad.interfaces import IGPGKeySet
  >>> gpgkey = getUtility(IGPGKeySet).get(1)
  >>> drq.signing_key = gpgkey

Now request the email:

  >>> changesfilepath = datadir(
  ...     'suite/netapplet_1.0-1-signed/netapplet_1.0-1_source.changes')
  >>> changesfile = open(changesfilepath,'r')
  >>> drq.notify(
  ...     announcelist="announcelist@canonical.com", 
  ...     changesfileobject=changesfile, logger=mock_logger)
  DEBUG: Building recipients list.
  ...
  DEBUG: Sent a mail:
  ...
  DEBUG:     Recipients: Foo Bar <foo.bar@canonical.com>, Daniel Silverstone <daniel.silverstone@canonical.com>
  ...
  DEBUG: above if files already exist in other distroreleases.

Again, there is only one email:

  >>> transaction.commit()
  >>> len(stub.test_emails)
  1

The mail headers are the same as before:

  >>> [notification] = pop_notifications()
  >>> notification['To']
  'Foo Bar <foo.bar@canonical.com>,\n\tDaniel Silverstone <daniel.silverstone@canonical.com>'
  >>> notification['Subject']
  'netapplet-1.0.0.tar.gz is NEW'

The mail body contains the same list of files again:

  >>> print notification.get_payload() # doctest: -NORMALIZE_WHITESPACE
  NEW: netapplet_1.0-1.dsc
  NEW: netapplet_1.0.orig.tar.gz
  NEW: netapplet_1.0-1.diff.gz
  <BLANKLINE>
  ...
  You may have gotten the distrorelease wrong.  If so, you may get warnings
  above if files already exist in other distroreleases.
  <BLANKLINE>

notify() will also work without passing the changesfileobject parameter
provided that everything is already committed to the database (which is not
the case when nascent upload runs).  This example demonstrates this usage:

  >>> from canonical.librarian.ftests.harness import (
  ...     fillLibrarianFile, cleanupLibrarianFiles)
  >>> changesfile = open(changesfilepath,"r")
  >>> fillLibrarianFile(1, content=changesfile.read())
  >>> changesfile.close()
  >>> drq.notify(announcelist="announcelist@canonical.com", logger=mock_logger)
  DEBUG: Building recipients list.
  ...
  DEBUG: Sent a mail:
  ...
  DEBUG:     Recipients: Foo Bar <foo.bar@canonical.com>, Daniel Silverstone <daniel.silverstone@canonical.com>
  ...
  DEBUG: above if files already exist in other distroreleases.

Only one email is generated:

  >>> transaction.commit()
  >>> len(stub.test_emails)
  1

The mail headers are the same as before:

  >>> [notification] = pop_notifications()
  >>> notification['To']
  'Foo Bar <foo.bar@canonical.com>,\n\tDaniel Silverstone <daniel.silverstone@canonical.com>'
  >>> notification['Subject']
  'netapplet-1.0.0.tar.gz is NEW'

The mail body contains the same list of files again:

  >>> print notification.get_payload() # doctest: -NORMALIZE_WHITESPACE
  NEW: netapplet_1.0-1.dsc
  NEW: netapplet_1.0.orig.tar.gz
  NEW: netapplet_1.0-1.diff.gz
  <BLANKLINE>
  ...
  You may have gotten the distrorelease wrong.  If so, you may get warnings
  above if files already exist in other distroreleases.
  <BLANKLINE>


notify() will also generate rejection notices if the upload failed:

  >>> drq.setRejected()
  >>> drq.notify(summary_text="Testing rejection message", 
  ...            logger=mock_logger)
  DEBUG: Building recipients list.
  ...
  DEBUG: Sending rejection email.
  ...
  DEBUG:     Subject: netapplet-1.0.0.tar.gz Rejected
  DEBUG:     Recipients: Foo Bar <foo.bar@canonical.com>, Daniel Silverstone <daniel.silverstone@canonical.com>
  DEBUG:     Body:
  DEBUG: Rejected:
  DEBUG: Testing rejection message
  ...
  DEBUG: If you don't understand why your files were rejected, or if the
  DEBUG: override file requires editing, reply to this email.

Only one email is generated:

  >>> transaction.commit()
  >>> len(stub.test_emails)
  1

