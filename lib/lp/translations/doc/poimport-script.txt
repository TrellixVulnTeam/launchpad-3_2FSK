Import Script
=============

The imports are performed by a dedicated cron script.

A template and two pofile will be imported.

    >>> potemplate_header = r"""
    ... msgid ""
    ... msgstr ""
    ... "POT-Creation-Date: 2004-07-11 16:16+0900\n"
    ... "Content-Type: text/plain; charset=CHARSET\n"
    ... "Plural-Forms: nplurals=INTEGER; plural=EXPRESSION;\n"
    ...
    ... """

    >>> pofile_header = r"""
    ... msgid ""
    ... msgstr ""
    ... "PO-Revision-Date: 2005-06-03 20:41+0100\n"
    ... "Last-Translator: Foo <no-priv@canonical.com>\n"
    ... "Content-Type: text/plain; charset=UTF-8\n"
    ... "Plural-Forms: nplurals=2; plural=(n!=1);\n"
    ...
    ... """

    >>> po_content = r"""
    ... #: test.c:13
    ... msgid "baz"
    ... msgstr "%s"
    ...
    ... #, c-format
    ... msgid "Foo %%s"
    ... msgstr "%s"
    ...
    ... #, c-format
    ... msgid "Singular %%d"
    ... msgid_plural "Plural %%d"
    ... msgstr[0] "%s"
    ... msgstr[1] "%s"
    ...
    ... msgid "translator-credits"
    ... msgstr "%s"
    ... """

    >>> potemplate_content = potemplate_header + po_content % (('',) * 5)
    >>> pofile_eo_content = pofile_header + po_content % (
    ...     "baz eo", "Foo eo %s", "Singular eo %s", "Plural eo %s",
    ...     "helpful-eo@example.com")
    >>> pofile_nl_content = pofile_header + po_content % (
    ...     "baz nl", "Foo nl %s", "Singular nl %s", "Plural nl %s",
    ...     "helpful-nl@example.com")

There is annoying sample data in the queue that needs to be removed.

    >>> from lp.translations.interfaces.translationimportqueue import (
    ...     ITranslationImportQueue, RosettaImportStatus)
    >>> queue = getUtility(ITranslationImportQueue)
    >>> for entry in queue:
    ...     queue.remove(entry)

The files have been uploaded to the queue for a source package and have
already been approved.

    >>> from zope.security.proxy import removeSecurityProxy
    >>> distroseries = factory.makeUbuntuDistroSeries()
    >>> naked_distroseries = removeSecurityProxy(distroseries)
    >>> naked_distroseries.distribution.official_rosetta = True
    >>> sourcepackagename = factory.makeSourcePackageName()
    >>> potemplate = factory.makePOTemplate(
    ...     distroseries=distroseries, sourcepackagename=sourcepackagename)
    >>> pofile_eo = potemplate.newPOFile('eo')
    >>> pofile_nl = potemplate.newPOFile('nl')

    >>> from canonical.launchpad.interfaces.launchpad import (
    ...     ILaunchpadCelebrities)
    >>> rosetta_experts = getUtility(ILaunchpadCelebrities).rosetta_experts

    >>> template_entry = queue.addOrUpdateEntry(
    ...     potemplate.path, potemplate_content, True, potemplate.owner,
    ...     distroseries=distroseries, sourcepackagename=sourcepackagename,
    ...     potemplate=potemplate)
    >>> pofile_eo_entry = queue.addOrUpdateEntry(
    ...     'eo.po', pofile_eo_content, True, potemplate.owner,
    ...     distroseries=distroseries, sourcepackagename=sourcepackagename,
    ...     potemplate=potemplate, pofile=pofile_eo)
    >>> pofile_nl_entry = queue.addOrUpdateEntry(
    ...     'nl.po', pofile_nl_content, True, potemplate.owner,
    ...     distroseries=distroseries, sourcepackagename=sourcepackagename,
    ...     potemplate=potemplate, pofile=pofile_nl)
    >>> transaction.commit()

    >>> for entry in queue:
    ...     entry.setStatus(RosettaImportStatus.APPROVED, rosetta_experts)
    >>> transaction.commit()

As it happens, the administrator has blocked imports to the distroseries, e.g.
because an in-database update of its translations has been scheduled
and we don't want interference from queued imports while that happens.
It doesn't really matter whether entries still get auto-approved, but
we can't accept new translation imports just now.

    >>> distroseries.defer_translation_imports
    True

    >>> from canonical.launchpad.scripts import FakeLogger
    >>> from lp.translations.scripts.po_import import TranslationsImport
    >>> import email
    >>> from lp.services.mail import stub
    >>> process = TranslationsImport('poimport', test_args=[])
    >>> process.logger = FakeLogger()
    >>> process.main()
    DEBUG   Starting the import process.
    INFO No requests pending.

When imports are allowed, the import script can do its work.

    >>> naked_distroseries.defer_translation_imports = False

    >>> process = TranslationsImport('poimport', test_args=[])
    >>> process.logger = FakeLogger()
    >>> process.main()
    DEBUG   Starting the import process.
    INFO    Importing: Template ...
    INFO    Importing: Esperanto (eo) ... of ...
    INFO    Importing: Dutch (nl) ... of ...
    INFO    Import requests completed.
    DEBUG   Finished the import process.

The import script also generates an email similar to the ones we saw
composed before, but also sends it.

    >>> len(stub.test_emails)
    1

    >>> from_addr, to_addrs, raw_message = stub.test_emails.pop()
    >>> msg = email.message_from_string(raw_message)
    >>> print msg["Subject"]
    Translation template import - ...

    >>> print msg.get_payload(decode=True)
    Hello ...,
    <BLANKLINE>
    On ..., you uploaded a translation
    template for ... in Launchpad.
    <BLANKLINE>
    The template has now been imported successfully.
    <BLANKLINE>
    Thank you,
    <BLANKLINE>
    The Launchpad team

The entries that remain in the queue as "imported" age over time.

    >>> import datetime
    >>> for entry in queue:
    ...     removeSecurityProxy(entry).date_status_changed -= (
    ...         datetime.timedelta(days=30))


Now the queue gardener runs. This can happen anytime, since it's
asynchronous to the po-import script. The script tries to approve any
entries that have not been approved, but look like they could be,
without human intervention. This involves a bit of guesswork about what
the imported file is and where it belongs. It similarly blocks entries
that it thinks should be blocked, and also purges deleted or completed
entries from the queue. Running at this point, all it does is purge the
two hand-approved Welsh translations that have just been imported.

    >>> import logging
    >>> from lp.testing.logger import MockLogger
    >>> from lp.translations.scripts.import_queue_gardener import (
    ...     ImportQueueGardener)
    >>> process = ImportQueueGardener('approver', test_args=[])
    >>> process.logger = MockLogger()
    >>> process.logger.setLevel(logging.INFO)
    >>> process.main()
    log>    Removed 3 entries from the queue.
    >>> transaction.commit()

If users upload two versions of the same file, they are imported in the
order in which they were uploaded.

    >>> import pytz
    >>> UTC = pytz.timezone('UTC')
    >>> first_pofile_content = r'''
    ... msgid ""
    ... msgstr ""
    ... "PO-Revision-Date: 2005-06-04 20:41+0100\n"
    ... "Last-Translator: Foo <no-priv@canonical.com>\n"
    ... "Content-Type: text/plain; charset=UTF-8\n"
    ... "X-Rosetta-Export-Date: %s\n"
    ...
    ... msgid "Foo %%s"
    ... msgstr "Bar"
    ...
    ... msgid "translator-credits"
    ... msgstr "The world will never know."
    ... ''' % datetime.datetime.now(UTC).isoformat()

    >>> second_pofile_content = r'''
    ... msgid ""
    ... msgstr ""
    ... "PO-Revision-Date: 2005-06-04 21:41+0100\n"
    ... "Last-Translator: Jordi Mallach <jordi@canonical.com>\n"
    ... "Content-Type: text/plain; charset=UTF-8\n"
    ... "X-Rosetta-Export-Date: %s\n"
    ...
    ... msgid "Foo %%s"
    ... msgstr "Bars"
    ...
    ... msgid "translator-credits"
    ... msgstr "I'd like to thank John, Kathy, my pot plants, and all the..."
    ... ''' % datetime.datetime.now(UTC).isoformat()

Attach the first version of the file.

    >>> entry = queue.addOrUpdateEntry(
    ...     pofile_eo.path, first_pofile_content, False, rosetta_experts,
    ...     sourcepackagename=sourcepackagename, distroseries=distroseries)
    >>> transaction.commit()

It's in the queue now.

    >>> queue.countEntries()
    1

For the second version, we need a new importer.

    >>> importer_person = factory.makePerson()

Attach the second version of the file.

    >>> entry = queue.addOrUpdateEntry(
    ...     pofile_eo.path, second_pofile_content, False, importer_person,
    ...     sourcepackagename=sourcepackagename, distroseries=distroseries)
    >>> transaction.commit()

It's in the queue now.

    >>> queue.countEntries()
    2
    >>> print entry.status.name
    NEEDS_REVIEW

The queue gardener runs again. This time it sees the two submitted
translations and approves them for import based on some heuristic
intelligence.

    >>> process = ImportQueueGardener('approver', test_args=[])
    >>> process.logger = MockLogger()
    >>> process.logger.setLevel(logging.INFO)
    >>> process.main()
    log>    The automatic approval system approved some entries.
    >>> print entry.status.name
    APPROVED
    >>> from canonical.launchpad.ftests import syncUpdate
    >>> syncUpdate(entry)

Now that these submissions have been approved, the next run of the
import script picks them up and processes them.

    >>> process = TranslationsImport('poimport', test_args=[])
    >>> process.logger = FakeLogger()
    >>> process.main()
    DEBUG   Starting the import process.
    INFO    Importing: Esperanto (eo) ... of ...
    INFO    Importing: Esperanto (eo) ... of ...
    INFO    Import requests completed.
    DEBUG   Finished the import process.

    >>> print entry.status.name
    IMPORTED
    >>> syncUpdate(entry)

And there are no more entries to import

    >>> queue.getFirstEntryToImport() is None
    True

We've imported a new translation for "Foo %s."

    >>> from lp.services.worlddata.interfaces.language import ILanguageSet
    >>> esperanto = getUtility(ILanguageSet).getLanguageByCode('eo')
    >>> suggestions = potemplate['Foo %s'].getLocalTranslationMessages(
    ...     potemplate, esperanto)
    >>> sorted([sugg.msgstr0.translation for sugg in suggestions])
    [u'Bar', u'Bars']

Since this last upload was not the upstream one, however, its credits
message translations were ignored.

    >>> potmsgset = pofile_eo.potemplate.getPOTMsgSetByMsgIDText(
    ...     u'translator-credits')
    >>> message =  potmsgset.getCurrentTranslationMessage(
    ...     pofile_eo.potemplate, pofile_eo.language)
    >>> message.msgstr0.translation
    u'helpful-eo@example.com'
    >>> list(potemplate['translator-credits'].getLocalTranslationMessages(
    ...     potemplate, esperanto))
    []


No Contact Address
------------------

Not every user has a valid email address.  For instance, Kermit the
Hermit has none at the moment.

    >>> from canonical.launchpad.interfaces.emailaddress import (
    ...     EmailAddressStatus)
    >>> from canonical.launchpad.helpers import get_contact_email_addresses
    >>> hermit = factory.makePerson(
    ...     name='hermit', email_address_status=EmailAddressStatus.OLD)

    >>> len(get_contact_email_addresses(hermit))
    0

Kermit uploads a translation, which gets approved.

    >>> pofile = factory.makePOFile('lo', potemplate)
    >>> entry = queue.addOrUpdateEntry(
    ...     'lo.po', 'Invalid content', True, hermit,
    ...     pofile=pofile, potemplate=potemplate,
    ...     distroseries=distroseries, sourcepackagename=sourcepackagename)
    >>> entry.setStatus(RosettaImportStatus.APPROVED, rosetta_experts)
    >>> transaction.commit()

The import fails.  The importer would like to send Kermit an email about
this, but is unable to.  This is unfortunate, but does not faze the
importer.  It completes normally.

    >>> process = TranslationsImport('poimport', test_args=[])
    >>> process.logger = FakeLogger()
    >>> process.main()
    DEBUG Starting the import process.
    INFO Importing: Lao ...
    INFO Import requests completed.
    DEBUG Finished the import process.

    >>> print entry.status.name
    FAILED
