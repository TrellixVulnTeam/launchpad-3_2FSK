Support Tracker Email Interface
===============================

The support tracker has an email interface, although it's quite limited
at the moment. The only thing you can do is post new messages on the
ticket. This is an important feature, though, since it ensures that if a
user decides to reply to a ticket notification, his email won't be lost,
it will be added to the ticket.

Incoming emails for the support tracker are processed by the
SupportTrackerHandler.

    (Define a time generator to ensure ordering of the messages. That is
    necessary because the date of the messages created from an email has
    only resolution to the second whereas the ones created by the DB API
    have microseconds resolution. This means that it would be possible
    for a message created using the DB API before one created by
    the email interface to sort after.)
    >>> from datetime import datetime, timedelta
    >>> from pytz import UTC
    >>> def now_generator(now_ref):
    ...     now = now_ref
    ...     while True:
    ...         yield now
    ...         now += timedelta(seconds=1)

    (We are using a date in the past because MessageSet disallows the
    creation of email message with a future date.)
    >>> now = now_generator(datetime.now(UTC) - timedelta(hours=24))

    (Define a helper function to send email to the support tracker handler)
    >>> from canonical.launchpad.mail.handlers import SupportTrackerHandler
    >>> from email.Utils import formatdate, make_msgid, mktime_tz
    >>> from canonical.launchpad.mail import signed_message_from_string
    >>> handler = SupportTrackerHandler()
    >>> def send_support_email(ticket_id, from_addr, subject, body):
    ...     login(from_addr)
    ...     lines = ['From: %s' % from_addr]
    ...     to_addr = 'ticket%s@support.launchpad.net' % ticket_id
    ...     lines.append('To: %s' % to_addr)
    ...     date = mktime_tz(now.next().utctimetuple() + (0, ))
    ...     lines.append('Date: %s' % formatdate(date))
    ...     msgid = make_msgid()
    ...     lines.append('Message-Id: %s' % msgid)
    ...     lines.append('Subject: %s' % subject)
    ...     lines.append('')
    ...     lines.append(body)
    ...     raw_msg = '\n'.join(lines)
    ...     msg = signed_message_from_string(raw_msg)
    ...     if handler.process(msg, msg['To']):
    ...         return msgid
    ...     else:
    ...         return None

It only processes emails which are sent to an address of the form
'ticket<ID>@support.launchpad.net', where <ID> is the ticket id. (The
domain is configured through the config.tickettracker.email_domain
configuration variable.)

All other email addresses are ignored:

    >>> raw_msg = """From: test@canonical.com
    ... To: foo@support.launchpad.net
    ... Subject: Hello
    ...
    ... Hello there."""
    >>> msg = signed_message_from_string(raw_msg)
    >>> handler.process(msg, msg['To'])
    False


The message will also be ignored if no ticket with the addressed ID
can be found:

    >>> comment_msgid = send_support_email(
    ...     1234, 'foo.bar@canonical.com', 'Hey', 'This is another comment.')
    >>> comment_msgid is None
    True

Incoming Email and Workflow
---------------------------

With the way the support tracker workflow is modelled (see
support-tracker-workflow.txt for the details), adding a message will
usually also change the status of the request. But currently, there is
no way to specify the exact workflow action accomplished by a given
message. (That will probably change in the near future when we add the
possibility to embed commands in the message body.) So, a default action
is chosen based on who is sending the message and the current state of
the request. There is the possibility that the default action is wrong,
but we chose the defaults based on what we assume is the common case
and by trying to minimize the impact of that error on future
possibilities for the user.

    (We will use a new ticket on the Ubuntu distribution in these
    examples. We also use two actors, No Privileges Person which will
    be the ticket owner and Sample Person who will play the role of
    support contact. Foo Bar is used to change the status of the
    ticket.)
    >>> from canonical.launchpad.interfaces import (
    ...     IDistributionSet, IPersonSet)
    >>> login('no-priv@canonical.com')
    >>> personset = getUtility(IPersonSet)
    >>> sample_person = personset.getByEmail('test@canonical.com')
    >>> no_priv = personset.getByEmail('no-priv@canonical.com')
    >>> foo_bar = personset.getByEmail('foo.bar@canonical.com')

    >>> ubuntu = getUtility(IDistributionSet)['ubuntu']
    >>> ticket = ubuntu.newTicket(
    ...     no_priv, 'Unable to boot installer',
    ...     "I've tried installing Ubuntu on a Mac. But the installer never "
    ...     "boots.", datecreated=now.next())

    (Define an helper to change the ticket status easily.)
    >>> def setTicketStatus(ticket, new_status):
    ...     login('foo.bar@canonical.com')
    ...     msg = ticket.setStatus(foo_bar, new_status, 'Status Change',
    ...                            datecreated=now.next())
    ...     login('no-priv@canonical.com')

Message From the Request Owner
------------------------------

When the owner sends a message on the support request, the message
is interpretated in three different manners based on the current ticket
state.

Open and Needs Information
~~~~~~~~~~~~~~~~~~~~~~~~~~

In the Open and Needs Information states, we assume the message provides
more information on the problem.

For example, from the Open state:

    >>> msgid = send_support_email(
    ...     ticket.id, 'no-priv@canonical.com', 'PowerMac 7200',
    ...     "I forgot to specify that I'm installing on a PowerMac 7200.")
    >>> message = ticket.messages[-1]
    >>> message.rfc822msgid == msgid
    True
    >>> print message.action.title
    Give more information
    >>> print message.subject
    PowerMac 7200
    >>> print message.text_contents
    I forgot to specify that I'm installing on a PowerMac 7200.
    >>> print message.owner.displayname
    No Privileges Person

And from the Needs information state:

    >>> from canonical.lp.dbschema import TicketStatus
    >>> setTicketStatus(ticket, TicketStatus.NEEDSINFO)

    >>> msgid =  send_support_email(
    ...     ticket.id, 'no-priv@canonical.com', 'Re: What model?',
    ...     'A PowerMac 7200.')
    >>> message = ticket.messages[-1]
    >>> message.rfc822msgid == msgid
    True
    >>> print message.action.title
    Give more information

In these states, the other possibility would be that the message is
really stating the owner solved his own problem. This is a less likely
scenario, since it would mean that the owner is replying to one of his
own message. And if that was the case, it is easy for the owner to
correct our bad decision, since the support request will stay on his
list of open requests.

Answered and Expired
~~~~~~~~~~~~~~~~~~~~

When the request is in the Answered or Expired states, we assume that
the email is reopening the request with more information.

    >>> setTicketStatus(ticket, TicketStatus.ANSWERED)

    >>> msgid = send_support_email(
    ...     ticket.id, 'no-priv@canonical.com', 'Re: BootX',
    ...     "I installed BootX, but I must have made a mistake somewhere "
    ...     "because it still doesn't boot. I have a dialog which says "
    ...     "cannot find any kernel images.")
    >>> message = ticket.messages[-1]
    >>> message.rfc822msgid == msgid
    True
    >>> print message.action.title
    Reopen

From the Open state, the other possibilities for the owner email would
be that it was confirming that the provided answer work. We minimize the
chance of this happening by adding an explanation message in the footer
of the notification containing the answer. The other possibility is that
the user sent a message to explain that he solved his problem. We do
support this use case yet.

From the Expired state:

    >>> setTicketStatus(ticket, TicketStatus.EXPIRED)

    >>> msgid =  send_support_email(
    ...     ticket.id, 'no-priv@canonical.com', 'Need Help',
    ...     "I still cannot install on my PowerMac.")
    >>> message = ticket.messages[-1]
    >>> message.rfc822msgid == msgid
    True
    >>> print message.action.title
    Reopen

From the Expired state, the other possibility is the less probable message
explaining that the owner solved his problem. Again, to minimize
confusion, the outoing notification contain a footer explaining what will
happen if one reply to the message.

Solved and Invalid
~~~~~~~~~~~~~~~~~~

When the support request is in the Solved or Invalid state, we interpret
the message as a comment.

    >>> setTicketStatus(ticket, TicketStatus.SOLVED)

    >>> msgid =  send_support_email(
    ...     ticket.id, 'no-priv@canonical.com', "Thanks",
    ...     "Thanks for helping me make BootX work.")
    >>> message = ticket.messages[-1]
    >>> message.rfc822msgid == msgid
    True
    >>> print message.action.title
    Comment

The other alternative is that the owner wanted to reopen the request.
But it is more likely that an email after he marked the problem as
solved would come as a reply to another comment, so it is safer to
assume it was a comment.

And from the Invalid:

    >>> setTicketStatus(ticket, TicketStatus.INVALID)

    >>> msgid =  send_support_email(
    ...     ticket.id, 'no-priv@canonical.com', 'Come on!',
    ...     "Trying to install on an old machine shouldn't be considered "
    ...     "an invalid request!")
    >>> message = ticket.messages[-1]
    >>> message.rfc822msgid == msgid
    True
    >>> print message.action.title
    Comment

That is the only possibility on an Invalid request. From the 'Invalid'
state, there is no normal transition. The only possibility is that an
admin comes to change the status of the request.

Message From Another User
-------------------------

It is simpler when a user other than the owner sends an email. When
the request is in the Open or Needs information state, there are only two
choices: either a request for more information or an answer. We will
assume it is an answer because it gives the opportunity for the owner to
confirm that the problem is solved. If it was really a request for more
information, the user can reply and the resulting state will be fine. So
it is the safest thing to assume.

    >>> setTicketStatus(ticket, TicketStatus.OPEN)

    >>> msgid =  send_support_email(
    ...     ticket.id, 'test@canonical.com', 'BootX',
    ...     "You need to install and configure BootX to boot the installer "
    ...     "CD.")
    >>> message = ticket.messages[-1]
    >>> message.rfc822msgid == msgid
    True
    >>> print message.action.title
    Answer
    >>> print message.owner.displayname
    Sample Person

Needs information example:

    >>> setTicketStatus(ticket, TicketStatus.NEEDSINFO)

    >>> msgid =  send_support_email(
    ...     ticket.id, 'test@canonical.com', 'What model?',
    ...     "What Mac model are you trying to install on?")
    >>> message = ticket.messages[-1]
    >>> message.rfc822msgid == msgid
    True
    >>> print message.action.title
    Answer

Answered example:

    >>> print ticket.status.title
    Answered

    >>> msgid =  send_support_email(
    ...     ticket.id, 'test@canonical.com', 'More info on BootX',
    ...     "You can find instructions on BootX installation at that URL: "
    ...     "https://help.ubuntu.com/community/Installation/OldWorldMacs")
    >>> message = ticket.messages[-1]
    >>> message.rfc822msgid == msgid
    True
    >>> print message.action.title
    Answer


Solved, Invalid and Expired
~~~~~~~~~~~~~~~~~~~~~~~~~~~

When another user than the owner sends a message to a support request
in the Solved, Invalid or Expired states, the only possible
interpretation is that it is a comment.

    >>> setTicketStatus(ticket, TicketStatus.SOLVED)

    >>> msgid =  send_support_email(
    ...     ticket.id, 'test@canonical.com', 'RAM',
    ...     "You will probably need to install some RAM to make this usable "
    ...     "though.")
    >>> message = ticket.messages[-1]
    >>> message.rfc822msgid == msgid
    True
    >>> print message.action.title
    Comment

    >>> setTicketStatus(ticket, TicketStatus.EXPIRED)

    >>> msgid =  send_support_email(
    ...     ticket.id, 'test@canonical.com', 'How weird',
    ...     "Is somebody really trying to install Ubuntu on such obsolete "
    ...     "hardware?")
    >>> message = ticket.messages[-1]
    >>> message.rfc822msgid == msgid
    True
    >>> print message.action.title
    Comment

    >>> setTicketStatus(ticket, TicketStatus.INVALID)

    >>> msgid =  send_support_email(
    ...     ticket.id, 'test@canonical.com', 'Error?',
    ...     "I think the rejection was an error.")
    >>> message = ticket.messages[-1]
    >>> message.rfc822msgid == msgid
    True
    >>> print message.action.title
    Comment


SupportTrackerHandler Integration
---------------------------------

The general mail processor delegates all emails to the
config.tickettracker.email_domain to the SupportTrackerHandler.

    >>> from canonical.config import config
    >>> to_addr = 'ticket1@%s' % config.tickettracker.email_domain
    >>> raw_msg = """From: test@canonical.com
    ... X-Original-To: %(to_addr)s
    ... Subject: A new comment
    ... Message-Id: <comment1@localhost>
    ... Date: Mon, 02 Jan 2006 15:42:07 -0000
    ...
    ... This is a new comment.
    ... """ % {'to_addr': to_addr}
    >>> from canonical.launchpad.interfaces import ITicketSet
    >>> from canonical.launchpad.mail.stub import test_emails
    >>> test_emails.append(('test@canonical.com', [to_addr], raw_msg))

    >>> from canonical.launchpad.mail.incoming import handleMail
    >>> handleMail()

    >>> ticket_one = getUtility(ITicketSet).get(1)
    >>> '<comment1@localhost>' in [
    ...     comment.rfc822msgid for comment in ticket_one.messages]
    True
