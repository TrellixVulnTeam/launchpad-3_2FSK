= Archive View Classes and Pages =

    >>> from zope.component import getMultiAdapter
    >>> from canonical.launchpad.webapp.servers import LaunchpadTestRequest

Let's use Celso's PPA for the tests.

    >>> from canonical.launchpad.interfaces import IPersonSet
    >>> cprov = getUtility(IPersonSet).getByName('cprov')


== ArchiveSourceSelectionFormView ==

The ArchiveSourceSelectionFormView defines two members that subclasses
must define to use.

    >>> from canonical.launchpad.browser.archive import (
    ...      ArchiveSourceSelectionFormView)

    >>> class BadView(ArchiveSourceSelectionFormView):
    ...     pass

    >>> empty_request = LaunchpadTestRequest(form={})
    >>> bad_view = BadView(None, empty_request)

    >>> bad_view.default_status_filter
    Traceback (most recent call last):
    ...
    NotImplementedError: Default status_filter should be defined by
    callsites.

    >>> bad_view.getSources()
    Traceback (most recent call last):
    ...
    NotImplementedError: Source lookup should be implemented by callsites.


== ArchivePackageDeletionView ==

We use ArchivePackageDeletionView to provide the mechnisms used to
delete packages from a PPA via the UI.

This view is only accessible by users with 'launchpad.Edit' permission
in the archive, that would be only the PPA owner (or administrators of
the Team owning the PPA) and Launchpad administrators. See further
tests in pagetests/xx-delete-packages.txt.

We will use the PPA owner, Celso user, to satisfy the references
required for deleting packages.

    >>> login('celso.providelo@canonical.com')

Issuing a empty request we can inspect the internal attributes used to
build the page.

    >>> view = getMultiAdapter(
    ...     (cprov.archive, empty_request), name="+delete-packages")
    >>> view.initialize()

We query the available PUBLISHED sources and use them to build the
'selected_sources' widget.

    >>> [pub.id for pub in view.sources]
    [27, 28, 29]

    >>> view.has_sources
    True

    >>> view.available_sources_size
    3

    >>> len(view.widgets.get('selected_sources').vocabulary)
    3

The 'selected_sources' widget has a limit controlled via a hard-coded
view attribute. We only present up to 'max_sources_presented' options
and if the available number options exceed this number, we present a
warning message to the user. The local limit is 20.

    >>> view.max_sources_presented
    20

    >>> view.has_undisplayed_sources
    False

Using a lower limit we can see the described mechanism working.

    >>> view.max_sources_presented = 2
    >>> view.initialize()

    >>> view.available_sources_size
    3

    >>> view.has_undisplayed_sources
    True

    >>> len(view.widgets.get('selected_sources').vocabulary)
    2

Restoring the default widget limit.

    >>> view.max_sources_presented = 50
    >>> view.initialize()

This view also provides package filtering by source package name, so
the user can refine the available options presented. By default all
available sources are presented with empty filter.

    >>> for pub in view.sources:
    ...     print pub.displayname
    cdrkit 1.0 in breezy-autotest
    iceweasel 1.0 in warty
    pmount 0.1-1 in warty

Whatever is passed as 'name_filter' results in a corresponding set of
filtered results.

    >>> name_filter_request = LaunchpadTestRequest(
    ...     form={'field.name_filter': 'pmount'})
    >>> view = getMultiAdapter(
    ...    (cprov.archive, name_filter_request), name="+delete-packages")
    >>> view.initialize()

    >>> for pub in view.sources:
    ...     print pub.displayname
    pmount 0.1-1 in warty

When submitted, deletions immediately take effect resulting in a page
which the available options already exclude the deleted items.

    >>> delete_all_request = LaunchpadTestRequest(
    ...    form={'field.actions.delete': 'Delete Packages',
    ...          'field.name_filter': '',
    ...          'field.status_filter': 'any',
    ...          'field.deletion_comment': 'Go away',
    ...          'field.selected_sources': ['27', '28', '29'],
    ...          'field.selected_sources-empty-marker': 1})
    >>> delete_all_request.method = 'POST'

    >>> view = getMultiAdapter(
    ...     (cprov.archive, delete_all_request), name="+delete-packages")
    >>> view.initialize()

    >>> view.available_sources_size
    0
    >>> view.has_sources
    False

    >>> import transaction
    >>> transaction.commit()

If by any chance, the form containing already deleted items, is
re-POSTed to the page, the code is able to identify such invalid
situation and ignore it. See bug #185922 for reference.

    >>> view = getMultiAdapter(
    ...     (cprov.archive, delete_all_request), name="+delete-packages")
    >>> view.initialize()
    >>> view.available_sources_size
    0
    >>> view.has_sources
    False
    >>> len(view.errors)
    2

== ArchiveEditDependenciesView ==

We use ArchiveEditDependenciesView to provide the mechnisms used to
add and/or remove archive dependencies for a PPA via the UI.

This view is only accessible by users with 'launchpad.Edit' permission
in the archive, that would be only the PPA owner (or administrators of
the Team owning the PPA) and Launchpad administrators. See further
tests in pagetests/xx-edit-dependencies.txt.

We will use the PPA owner, Celso user, to play with edit-dependencies
corner-cases.

    >>> login('celso.providelo@canonical.com')

Issuing a empty request we can inspect the internal attributes used to
build the page.

    >>> empty_request = LaunchpadTestRequest(form={})
    >>> view = getMultiAdapter(
    ...     (cprov.archive, empty_request), name="+edit-dependencies")
    >>> view.initialize()

There is a property indicating whether or not the context PPA has
recorded dependencies.

    >>> view.has_dependencies
    False

Also the 'selected_dependencies' form field is present, even if it is empty.

    >>> len(view.widgets.get('selected_dependencies').vocabulary)
    0

When there is no dependencies the form focus is set to the
'dependency_candidate' input field. Where the user can directly type
the owner of the PPA he wants to mark as dependency.

    >>> print view.focusedElementScript()
    <!--
    setFocusByName('field.dependency_candidate');
    // -->

Let's emulate a dependency addition. Note that the form contains, a
empty 'selected_dependencies' (as it was rendered in the empty
request) and 'dependency_candidate' contains a valid PPA owner name.
Validation checks are documented in
pagetests/ppa/xx-edit-dependencies.txt.

    >>> add_dependency_request = LaunchpadTestRequest(
    ...     form={
    ...         'field.selected_dependencies': [],
    ...         'field.dependency_candidate': 'sabdfl',
    ...         'field.actions.add': 'Add Dependency',
    ...         })
    >>> add_dependency_request.method = 'POST'
    >>> view = getMultiAdapter(
    ...     (cprov.archive, add_dependency_request),
    ...     name="+edit-dependencies")
    >>> view.initialize()
    >>> transaction.commit()

Now we can see that the view properties correctly indicates the
presence of a PPA dependency.

    >>> view.has_dependencies
    True

The 'selected_dependencies' widget has on element representing a PPA
dependency. Each element has:

 * value: dependency IArchive,
 * token: dependency IArchive.owner,
 * title: link to the dependency IArchive in Launchpad redered as the
          dependency title.

    >>> [dependency] = view.widgets.get('selected_dependencies').vocabulary

    >>> print dependency.value.title
    PPA for Mark Shuttleworth

    >>> print dependency.token
    sabdfl

    >>> print dependency.title
    <a href="http://launchpad.dev/~sabdfl/+archive">PPA for Mark Shuttleworth</a>

The form focus, now that we have a recorded dependencies, is set to the
first listed dependency.

    >>> print view.focusedElementScript()
    <!--
    setFocusByName('field.selected_dependencies');
    // -->

We warn the user when a malformed request does not include selected
dependencies for a removal.

    >>> broken_request = LaunchpadTestRequest(
    ...     form={'field.actions.remove': 'Remove Dependencies',})
    >>> broken_request.method = 'POST'
    >>> view = getMultiAdapter(
    ...     (cprov.archive, broken_request), name="+edit-dependencies")
    >>> view.initialize()
    >>> for message in view.errors:
    ...     print message
    ...
    No dependencies selected.

If we remove the just-added dependency, the view gets back to its
initial/empty state.

    >>> remove_dependency_request = LaunchpadTestRequest(
    ...     form={
    ...         'field.selected_dependencies': ['sabdfl'],
    ...         'field.dependency_candidate': '',
    ...         'field.actions.remove': 'Remove Dependencies',
    ...         })
    >>> remove_dependency_request.method = 'POST'
    >>> view = getMultiAdapter(
    ...     (cprov.archive, remove_dependency_request),
    ...     name="+edit-dependencies")
    >>> view.initialize()

    >>> view.has_dependencies
    False

    >>> len(view.widgets.get('selected_dependencies').vocabulary)
    0

    >>> print view.focusedElementScript()
    <!--
    setFocusByName('field.dependency_candidate');
    // -->


== ArchivePackageCopyingView ==

This class extends ArchiveSourceSelectionFormView, and thus uses the
same mechanisms for presenting and filtering available sources for
copying, the 'selected_sources' widget. Related features don't need to
be re-tested.

    >>> login('celso.providelo@canonical.com')

Issuing a empty request we can inspect the internal attributes used to
build the page.

    >>> view = getMultiAdapter(
    ...     (cprov.archive, empty_request), name="+copy-packages")
    >>> view.initialize()

The main difference for ArchivePackageDeletionView  is that this uses a
different 'source' provider, which may include deleted sources, and a
different default status filter (only published sources are presented
by default).

    >>> [pub.status.name for pub in view.sources]
    []

All sources in Celso's PPA were just-deleted, so we have to tweak the
'status_filter' to see them.

    >>> any_state_request = LaunchpadTestRequest(
    ...     form={'field.status_filter': 'any'})
    >>> any_state_request.method = 'POST'

    >>> view = getMultiAdapter(
    ...     (cprov.archive, any_state_request), name="+copy-packages")
    >>> view.initialize()

    >>> [pub.status.name for pub in view.sources]
    ['DELETED', 'DELETED', 'DELETED']

This view contains three properties. The first is a list of the PPAs
in which the current user has upload/copy rights (see
`IArchiveSet.getPPAsForUser`).

    >>> [ppa.owner.name for ppa in view.ppas_for_user]
    [u'cprov']

The second shows whether or not the current user is allowed to perform
copies. They must participate in at least one PPA for this to be True.

    >>> view.can_copy
    True

And finally if the user has the right to upload/copy to the context
PPA.

    >>> view.can_copy_to_context_ppa
    True

Lets exercise the properties. 'No Privileges Person' user has his own
PPA, thus he can copy to it, but not to Celso's PPA.

    >>> login('no-priv@canonical.com')
    >>> view = getMultiAdapter(
    ...     (cprov.archive, empty_request), name="+copy-packages")
    >>> view.initialize()

    >>> [ppa.owner.name for ppa in view.ppas_for_user]
    [u'no-priv']

    >>> view.can_copy
    True

    >>> view.can_copy_to_context_ppa
    False

'Foo Bar' user has no PPA, so he cannot perform copies at all.

    >>> login('foo.bar@canonical.com')
    >>> view = getMultiAdapter(
    ...     (cprov.archive, empty_request), name="+copy-packages")
    >>> view.initialize()

    >>> [ppa.owner.name for ppa in view.ppas_for_user]
    []

    >>> view.can_copy
    False

    >>> view.can_copy_to_context_ppa
    False

When we activate the Ubuntu team PPA, in which Celso participates,
he will be able to copy not only to his PPA but also to the PPA for a
team he is member of.

    >>> ubuntu_team = getUtility(IPersonSet).getByName('ubuntu-team')

    >>> from canonical.launchpad.interfaces import (
    ...     ArchivePurpose, IArchiveSet)
    >>> ubuntu_team_ppa = getUtility(IArchiveSet).new(
    ...     owner=ubuntu_team, distribution=None, purpose=ArchivePurpose.PPA,
    ...     description="Don't we have a distribution ?")

    >>> login('celso.providelo@canonical.com')
    >>> view = getMultiAdapter(
    ...     (cprov.archive, empty_request), name="+copy-packages")
    >>> view.initialize()

    >>> [ppa.owner.name for ppa in view.ppas_for_user]
    [u'cprov', u'ubuntu-team']

    >>> view.can_copy
    True

    >>> view.can_copy_to_context_ppa
    True

We will prepare a empty POST and inspect the default form values.

    >>> empty_post = LaunchpadTestRequest(
    ...    form={'field.destination_archive': '',
    ...          'field.destination_series': ''})
    >>> empty_post.method = 'POST'
    >>> view = getMultiAdapter(
    ...     (cprov.archive, empty_post), name="+copy-packages")
    >>> view.initialize()

The 'destination_archive' widget contents are directly based on the
'ppas_for_user', but it excludes the context PPA from the list of
options making it the default option, 'This PPA' rendered option.

    >>> archive_widget = view.widgets['destination_archive']

    >>> archive_widget.required
    False

    >>> print archive_widget.translate(archive_widget._messageNoValue)
    This PPA

    >>> for item in archive_widget.vocabulary:
    ...     print item.title
    PPA for Ubuntu Team

    >>> print archive_widget.getInputValue() == cprov.archive
    True

The 'destination_series' widget behaves similarly, it contains all
series available for the PPA distribution and default to 'The same
series', which ends up being None in the browser domain.

    >>> series_widget = view.widgets['destination_series']

    >>> series_widget.required
    False

    >>> print archive_widget.translate(series_widget._messageNoValue)
    The same series

    >>> for item in series_widget.vocabulary:
    ...     print item.title
    Breezy Badger Autotest
    Grumpy
    Hoary
    Warty

    >>> print series_widget.getInputValue()
    None

The 'destination_archive' widget behaves different depending on
whether or not the user has permission to perform copies to the
context PPA.

No Privileges user can't copy package to the Celso's PPA, thus
'destination' widget will become required and will fail if an empty
value is submitted.

    >>> login('no-priv@canonical.com')

    >>> view = getMultiAdapter(
    ...     (cprov.archive, empty_post), name="+copy-packages")
    >>> view.initialize()

    >>> archive_widget = view.widgets['destination_archive']
    >>> archive_widget.required
    True

    >>> for item in archive_widget.vocabulary:
    ...     print item.title
    PPA for No Privileges Person

    >>> print archive_widget.getInputValue()
    Traceback (most recent call last):
    ...
    WidgetInputError: ('destination_archive', u'Destination PPA', )
