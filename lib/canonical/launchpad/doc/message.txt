Messages
========

The Message table is a central message spool that can be used by
various parts of launchpad. Currently, it is used by Malone for comments
on bugs. Bugs are linked to Messages via the BugMessage table.

The BugMessageFactory determines the Bug using the LaunchBag

>>> from canonical.launchpad.database import Bug
>>> from canonical.launchpad.database.bugmessage import BugMessageFactory
>>> login('foo.bar@canonical.com')
>>> launchbag = getUtility(ILaunchBag)
>>> launchbag.bug = Bug.get(1)
>>> bmsg = BugMessageFactory(title='The Title', content='The Content')
>>> msg = bmsg.message
>>> msg.title
u'The Title'

We can retrieve the full contents as plain text. (However, note that
if generating HTML you should use the MessageChunks detailed below
to handle attachments correctly)

>>> msg.contents
u'The Content'

Messages are threaded, although this is not necessarily displayed in the
UI. Each message has a parent attribute

>>> msg.parent is None
True

Messages always have a unique message id, which is used when notifications
of this message are sent out. The message id is generated by the system
if not provided

>>> isinstance(msg.rfc822msgid, basestring)
True
>>> bool(msg.rfc822msgid)
True

A Message is made up of one or more chunks. The chunks are stored in the
MessageChunk table. The majority of messages will have a single chunk
representing the text body of the message. More complex messages, such as
an email with attachments, will contain multiple chunks. A chunk may be a
piece of text, or a reference to an object stored in the Librarian. Chunks
may be accessed using the chunks attribute, or simply by iterating over
the Message.

>>> for chunk in msg:
...     print repr([chunk.sequence, chunk.content, chunk.blob])
[1, u'The Content', None]
>>> msg.chunks[0].message == msg
True

You can build a Message from an email easily. This stuffs the original,
unadulterated, email into the Librarian and builds all the MessageChunks.

>>> from canonical.launchpad.interfaces import IMessageSet
>>> msgset = getUtility(IMessageSet)
>>> raw_msg = u"""\
... Content-Type: multipart/mixed; charset="latin-1";
...               boundary="===============0294339828=="
... MIME-Version: 1.0
... Subject: =?utf-8?q?Unicode=E2=84=A2?=
... From: foo.bar@canonical.com
... Message-Id: <20050405054002.22134.71562@localhost.localdomain>
... To: cabal@ubuntu.com
... 
... The preamble is included, including Unicode\N{COPYRIGHT SIGN}
... --===============0294339828==
... Content-Type: text/plain; charset="us-ascii"
... MIME-Version: 1.0
... Content-Transfer-Encoding: 7bit
... 
... Plain text
... --===============0294339828==
... Content-Type: executable/virus
... MIME-Version: 1.0
... Content-Transfer-Encoding: base64
... Content-Disposition: attachment; filename="anna.jpg.exe"
... X-Comment: A trivial binary containing bytes 0x00 0x01 0x02 0x03
... X-Comment: This also tests embedded NULLs in the blobs
... X-Comment: Note we store all attachment types - filtering should
... X-Comment: be done *before* launchpad is reached. Launchpad is not
... X-Comment: a virus checker.
... 
... AAECAw==
... --===============0294339828==
... Content-Type: text/plain; charset="utf8"
... MIME-Version: 1.0
... Content-Transfer-Encoding: base64
... X-Comment: bas64 encoded text saying 'Unicode(tm)'
... 
... VW5pY29kZeKEoiB0ZXh0
... 
... --===============0294339828==
... Content-Type: application/xml; charset="utf16"
... MIME-Version: 1.0
... Content-Transfer-Encoding: quoted-printable
... X-Comment: quoted printable binary with a charset - probably illegal
... X-Comment: but we still can cope with it.
...
... =FF=FE<=00?=00x=00m=00l=00=20=00v=00e=00r=00s=00i=00o=00n=00=3D=00"=001=00.=
... =000=00"=00=20=00e=00n=00c=00o=00d=00i=00n=00g=00=3D=00"=00u=00t=00f=001=00=
... 6=00"=00?=00>=00
... =00<=00u=00n=00i=00c=00o=00d=00e=00>=00"!<=00/=00u=00n=00i=00c=00o=00d=00e=
... =00>=00
... --===============0294339828==--
... The epilogue is included, including Unicode\N{COPYRIGHT SIGN}
... """.encode('latin1')
>>> msg = msgset.fromEmail(raw_msg)

Once the email is stuffed into the Message and MessageChunk tables and 
relevant bits stuffed into the Librarian, you can deal with them as
normal.

>>> msg_set = getUtility(IMessageSet)
>>> msg = msg_set.get(
...     rfc822msgid="<20050405054002.22134.71562@localhost.localdomain>"
...     )
>>> msg.title
u'Unicode\u2122'
>>> chunks = msg.chunks
>>> for chunk in chunks:
...     if chunk.content:
...         print '%2d - %r' % (chunk.sequence, chunk.content)
 1 - u'The preamble is included, including Unicode\xa9'
 2 - u'Plain text'
 4 - u'Unicode\u2122 text'
 6 - u'The epilogue is included, including Unicode\xa9'

Note that the third and fifth chunks were not of type text/plain,
so are stored as blobs.

>>> chunks[2].sequence
3
>>> chunks[2].content is None
True
>>> blob = chunks[2].blob
>>> blob.filename
u'anna.jpg.exe'
>>> blob.url.startswith(u'http://localhost:58000/')
True
>>> blob.url.endswith(u'/anna.jpg.exe')
True

>>> blob2 = chunks[4].blob
>>> blob2.filename
u'unnamed'
>>> blob2.mimetype
u'application/xml; charset="utf16"'

As per normal, we can't access the blobs in the same transaction
as the request. I don't think this is important outside of tests.

>>> import transaction
>>> transaction.commit()
>>> blob.read()
'\x00\x01\x02\x03'

>>> blob2.read().decode('utf16')
u'<?xml version="1.0" encoding="utf16"?>\n<unicode>\u2122</unicode>'


We can also retrieve a byte-identical copy of the original message
from the Librarian. This is required for allowing people to verify
the integrity of GPG signed messages.

>>> msg.raw.read() == raw_msg
True

The fromEmail method handles non-multipart and minimalist messages 
quite happily.

>>> msg = msgset.fromEmail('''\
... From: foo.bar@canonical.com
... Subject: Test
... Message-Id: <fnord>
... 
... Foo Bar
... ''')
>>> msg.title
u'Test'
>>> chunks = list(msg.chunks)
>>> len(chunks)
1
>>> chunks[0].content
u'Foo Bar\n'

