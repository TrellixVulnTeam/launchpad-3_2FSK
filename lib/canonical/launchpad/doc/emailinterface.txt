Malone's Email Interface
========================

Malone has an email interface, with which you may submit new bugs, add
comments, and edit bugs. The email interface has a number of different
commands. Commands can be interleaved within a comment, so in order to
distinguish them from the comment, the commands have to be indented with
at least one space or tab character. The available commands are
described later on.

Submit a new bug
----------------

To report a bug, you send an OpenPGP-signed e-mail message to
new@malone-domain. You must have registered your key in
Launchpad as well. The subject of the email will be used as the summary
of the bug, and the body will be used as the description. In the body of
the email you have tell on what you file a bug, either a product or a
distribution. You do so by issuing an 'affects' command. The simplest
case is either:

    affects /products/$product_name

to file a bug on a product, or:

    affects /distros/$distribution_name

to file a bug on a distribution. And if you want to file a bug on a
specific source package in a distribution:

    affects /distros/$distribution_name/$sourcepackage_name

But if you want you can use any of the available commands as well.

Let's take an example where we file a bug on Firefox:

    >>> submit_mail = """From: Foo Bar <foo.bar@canonical.com>
    ... To: new@bugs.launchpad.ubuntu.com
    ... Date: Fri Jun 17 10:20:23 BST 2005
    ... Subject: A bug in Firefox
    ...
    ... There is a bug in Firefox.
    ...
    ...  affects /products/firefox"""

Now, in order to really submit the bug, this email would have to be PGP
signed, so that the system can verify the sender. But to avoid having
to sign each email, we'll create a class which fakes a signed email:

    >>> import email
    >>> import email.Utils
    >>> class MockSignedMessage(email.Message.Message):
    ...     @property
    ...     def signedMessage(self):
    ...         return self
    ...     signature = object()

And since we'll pass the email directly to the correct handler,
we'll have to authenticate the user manually:

    >>> from canonical.launchpad.ftests import login
    >>> login('foo.bar@canonical.com')

Now if we pass the message to the Malone handler, we can see that the
bug got submitted correctly:

    >>> from canonical.librarian.ftests.harness import LibrarianTestSetup
    >>> from canonical.launchpad.mail.handlers import MaloneHandler
    >>> handler = MaloneHandler()
    >>> def process_email(raw_mail):
    ...     msg = email.message_from_string(raw_mail, _class=MockSignedMessage)
    ...     if not msg.has_key('Message-Id'):
    ...         msg['Message-Id'] = email.Utils.make_msgid()
    ...     handler.process(msg, msg['To'])
    >>> LibrarianTestSetup().setUp()

    >>> process_email(submit_mail)

    >>> import transaction
    >>> from canonical.launchpad.interfaces import IBugSet
    >>> from canonical.launchpad.mail import stub
    >>> bugset = getUtility(IBugSet)
    >>> def get_latest_added_bug():
    ...     transaction.commit() # Need to commit for the email to be sent.
    ...     from_addr, to_addrs, raw_message = stub.test_emails[-1]
    ...     msg = email.message_from_string(raw_message)
    ...     bug_nr = int(msg['Subject'].split()[1][:-1])
    ...     return bugset.get(bug_nr)
    >>> bug = get_latest_added_bug()

    >>> print bug.title
    A bug in Firefox
    >>> print bug.description
    There is a bug in Firefox.
    <BLANKLINE>
     affects /products/firefox

Also, an upstream bug task was added to it:

    >>> len(bug.bugtasks)
    1
    >>> upstream_task = bug.bugtasks[0]
    >>> print upstream_task.product.name
    firefox

And the entire body of the email was added as a comment:

    >>> len(bug.messages)
    1
    >>> comment = bug.messages[0]
    >>> print comment.title
    A bug in Firefox
    >>> print comment.text_contents
    There is a bug in Firefox.
    <BLANKLINE>
     affects /products/firefox

The owner of the bug was set to the submitter:

    >>> print bug.owner.displayname
    Foo Bar

A notification was sent to dilys, Foo Bar and Sample Person. Sample
Person got notified since he's the owner of the product:

    >>> len(stub.test_emails)
    3
    >>> dilys_msg, foo_bar_msg, sample_person_msg = [
    ...     email.message_from_string(raw_message)
    ...     for from_addr, to_addrs, raw_message in sorted(stub.test_emails)
    ...     ]
    >>> dilys_msg['To']
    'dilys@muse.19inch.net'
    >>> foo_bar_msg['To']
    'foo.bar@canonical.com'
    >>> sample_person_msg['To']
    'test@canonical.com'
    >>> print sample_person_msg.get_payload()
    Public bug reported:
    ...
    Affects: firefox (upstream)
    ...
    There is a bug in Firefox.
    ...

    >>> stub.test_emails = []

If we would file a bug on Ubuntu instead, we would submit a mail like
this:

    >>> login('test@canonical.com')
    >>> submit_mail = """From: Sample Person <test@canonical.com>
    ... To: new@bugs.canonical.com
    ... Date: Fri Jun 17 10:20:23 BST 2005
    ... Subject: A bug in Ubuntu's Mozilla package
    ...
    ... There's a bug in Ubuntu.
    ...  affects /distros/ubuntu/mozilla-firefox
    ... """
    >>> process_email(submit_mail)
    >>> bug = get_latest_added_bug()

    >>> print bug.title
    A bug in Ubuntu's Mozilla package

    >>> distrotask = bug.bugtasks[0]
    >>> print distrotask.distribution.name
    ubuntu
    >>> print distrotask.sourcepackagename.name
    mozilla-firefox

A notification was sent to dilys, Foo Bar and Sample Person. Foo
Bar got notified since he's a bug contact for the mozilla package:

    >>> len(stub.test_emails)
    3
    >>> dilys_msg, foo_bar_msg, sample_person_msg = [
    ...     email.message_from_string(raw_message)
    ...     for from_addr, to_addrs, raw_message in sorted(stub.test_emails)
    ...     ]
    >>> dilys_msg['To']
    'dilys@muse.19inch.net'
    >>> foo_bar_msg['To']
    'foo.bar@canonical.com'
    >>> sample_person_msg['To']
    'test@canonical.com'
    >>> print sample_person_msg.get_payload()
    Public bug reported:
    ...
    Affects: mozilla-firefox (Ubuntu)
    ...
    There's a bug in Ubuntu.
    ...

    >>> stub.test_emails = []

It's possible to file a bug on more than product/package at once:

    >>> submit_mail = """From: Sample Person <test@canonical.com>
    ... To: new@bugs.canonical.com
    ... Date: Fri Jun 17 10:20:23 BST 2005
    ... Subject: Affects many packages
    ...
    ... A widespread bug.
    ...  affects /distros/debian/evolution
    ...  affects /distros/debian/mozilla-firefox
    ...  affects /products/evolution
    ...  affects /products/firefox
    ... """
    >>> process_email(submit_mail)
    >>> bug = get_latest_added_bug()

    >>> print bug.title
    Affects many packages

    >>> for bugtask in bug.bugtasks:
    ...     print bugtask.targetname
    evolution (upstream)
    firefox (upstream)
    evolution (Debian)
    mozilla-firefox (Debian)


Add a comment
-------------

After a bug has been submitted a notification is sent out. The reply-to
address is set to the bug address, $bugid@malone-domain. We can send
emails to this address in order to add new comments to the bug. Note
that we can interleave commands in the comment as well. If the comment
includes commands, the email has to be OpenPGP-signed.

    >>> comment_mail = """From: test@canonical.com
    ... To: 1@malone-domain
    ... Date: Fri Jun 17 10:20:23 BST 2005
    ... Message-Id: <yada-yada-test1>
    ... Subject: New comment to bug 1
    ...
    ... Adding a comment via the email system. Let's change the summary
    ... as well:
    ...     summary "Better summary"
    ...
    ... /Sample Person
    ... """

    >>> process_email(comment_mail)
    >>> transaction.commit()

    >>> from canonical.launchpad.interfaces import IMessageSet
    >>> bug_one = bugset.get(1)
    >>> added_message = getUtility(IMessageSet).get('<yada-yada-test1>')[0]
    >>> added_message in bug_one.messages
    True
    >>> print bug_one.title
    Better summary

If the message doesn't have a Reference or In-Reply-To header, the
parent will be set to the bug's initial message.

    >>> added_message.parent == bug_one.initial_message
    True


Edit bugs
---------

Sometimes you may want to simply edit a bug, without adding a comment.
For that you can send mails to edit@malone-domain.

    >>> bug_four = bugset.get(4)
    >>> bug_five = bugset.get(5)
    >>> bug_four_comments = len(bug_four.messages)
    >>> bug_five_comments = len(bug_five.messages)
    >>> edit_mail = """From: test@canonical.com
    ... To: edit@malone-domain
    ... Date: Fri Jun 17 10:10:23 BST 2005
    ... Subject: Not important
    ...
    ...     bug 4
    ...     summary "Changed summary"
    ...
    ... It won't break if we write some stuff here.
    ...
    ...     bug 5
    ...     summary "Nicer summary"
    ... """

    >>> process_email(edit_mail)
    >>> transaction.commit()

No comments were added to the bugs:

    >>> len(bug_four.messages) == bug_four_comments
    True
    >>> len(bug_five.messages) == bug_five_comments
    True

And the summaries were changed:

    >>> print bug_four.title
    Changed summary
    >>> print bug_five.title
    Nicer summary

GPG signing and adding comments
-------------------------------

In order to include commands in the comment, the email has to be GPG
signed. The key used to sign the email has to be associated with the
authenticated person in Launchpad. It happens quite often, though, that
people who haven't registered their key in Launchpad sign their emails
even though the only want to add a comment. These comments should of
course not be rejected just because their key wasn't registered in
Launchpad.

To make a difference between if an email was signed with a key
registered in Launchpad or not, we can look at which interfaces the
currently authenticated principal provides. If the email used for
authentication was unsigned or signed with a key, which isn't
associated with the authenticated Person in Launchpad, the principal
will provide IWeaklyAuthenticatedPrincipal. Let's mark the current
principal with that.

    >>> from canonical.launchpad.interfaces import IWeaklyAuthenticatedPrincipal
    >>> from zope.interface import directlyProvides, directlyProvidedBy
    >>> from zope.security.management import queryInteraction
    >>> participations = queryInteraction().participations
    >>> len(participations)
    1
    >>> current_principal = participations[0].principal
    >>> directlyProvides(
    ...     current_principal, directlyProvidedBy(current_principal),
    ...     IWeaklyAuthenticatedPrincipal)


Now we send a comment containing commands.

    >>> comment_mail = """From: test@canonical.com
    ... To: 1@malone-domain
    ... Date: Fri Dec 17 10:20:23 BST 2005
    ... Message-Id: <yada-yada-test2>
    ... Subject: Change the summary
    ...
    ... Adding a comment via the email system. Let's change the summary
    ... as well:
    ...     summary "New summary"
    ...
    ... /Sample Person
    ... """
    >>> process_email(comment_mail)
    >>> transaction.commit()

The Malone handler saw that this email was signed, but since
IWeaklyAuthenticatedPrincipal was provided by the current principal, no
changes was made to the bug, and the comment wasn't added.

    >>> added_message = getUtility(IMessageSet).get('<yada-yada-test2>')[0]
    Traceback (most recent call last):
    ...
    NotFoundError:...

    >>> bug_one = bugset.get(1)
    >>> print bug_one.title
    Better summary

And an error message was sent to the Sample Person, telling him what's
wrong.

    >>> def print_latest_email():
    ...     transaction.commit()
    ...     from_addr, to_addrs, raw_message = stub.test_emails[-1]
    ...     error_mail = email.message_from_string(raw_message)
    ...     print "Subject: %s" % error_mail['Subject']
    ...     print "To: %s" % ', '.join(to_addrs)
    ...     print
    ...     print error_mail.get_payload(decode=True)
    >>> print_latest_email()
    Subject: Submit Request Failure
    To: test@canonical.com
    <BLANKLINE>
    ...
    The message you sent included commands to modify the bug report, but
    your OpenPGP key isn't imported into Launchpad. Please go to
    http://localhost:8086/people/name12/+editpgpkeys to import your key.
    ...

The same will happen if we send the same email without signing it:

    >>> class MockUnsignedMessage(email.Message.Message):
    ...     signedMessage = None
    ...     signature = None
    >>> msg = email.message_from_string(
    ...     comment_mail, _class=MockUnsignedMessage)
    >>> handler.process(msg, msg['To'])
    True
    >>> transaction.commit()

    >>> added_message = getUtility(IMessageSet).get('<yada-yada-test2>')[0]
    Traceback (most recent call last):
    ...
    NotFoundError:...

    >>> bug_one = bugset.get(1)
    >>> print bug_one.title
    Better summary

A different error message is sent, though:

    >>> print_latest_email()
    Subject: Submit Request Failure
    To: test@canonical.com
    <BLANKLINE>
    ...
    The message you sent included commands to modify the bug report, but you
    didn't sign the message with your OpenPGP key.
    ...


If we don't include any commands in the comment, it will be added
to the bug:

    >>> comment_mail = """From: test@canonical.com
    ... To: 1@malone-domain
    ... Date: Fri Dec 17 10:20:23 BST 2005
    ... Message-Id: <yada-yada-test3>
    ... Subject: Change the summary
    ...
    ... Adding a comment via the email system.
    ...
    ... /Sample Person
    ... """
    >>> process_email(comment_mail)
    >>> transaction.commit()

    >>> added_message = getUtility(IMessageSet).get('<yada-yada-test3>')[0]
    >>> bug_one = bugset.get(1)
    >>> added_message in bug_one.messages
    True

Unmark the principal:

    >>> provided_interfaces = directlyProvidedBy(current_principal)
    >>> directlyProvides(
    ...     current_principal,
    ...     provided_interfaces - IWeaklyAuthenticatedPrincipal)

Commands
--------

Now let's take a closer look at all the commands that are available for
us to play with. First we define a function to easily submit commands
to edit bug 4:

    >>> def submit_commands(bug, *commands):
    ...     edit_mail = ("From: test@canonical.com\n"
    ...                  "To: edit@malone-domain\n"
    ...                  "Date: Fri Jun 17 10:10:23 BST 2005\n"
    ...                  "Subject: Not important\n"
    ...                  "\n"
    ...                  " bug %d\n" % bug.id)
    ...     edit_mail += ' ' + '\n '.join(commands)
    ...     process_email(edit_mail)
    ...     transaction.commit()

We define a function which makes it easier to look at the error
messages as well:

    >>> def print_latest_email():
    ...     transaction.commit()
    ...     from_addr, to_addrs, raw_message = stub.test_emails[-1]
    ...     error_mail = email.message_from_string(raw_message)
    ...     print "Subject: %s" % error_mail['Subject']
    ...     print "To: %s" % ', '.join(to_addrs)
    ...     print
    ...     print error_mail.get_payload(decode=True)



bug $bugid
^^^^^^^^^^
Switches what bug you want to edit. Example:

    bug 42

If we specify a bug number that doesn't exist, an error message is
returned:

    >>> submit_commands(bug_four, 'bug 42')
    >>> print_latest_email()
    Subject: Submit Request Failure
    To: test@canonical.com
    <BLANKLINE>
    ...
    Failing command:
        bug 42
    ...
    There is no such bug in Launchpad: 42
    ...

And if we specify neither 'new' or an integer:

    >>> submit_commands(bug_four, 'bug foo')
    >>> print_latest_email()
    Subject: Submit Request Failure
    To: test@canonical.com
    <BLANKLINE>
    ...
    Failing command:
        bug foo
    ...
    The 'bug' command expects either 'new' or a bug id.
    <BLANKLINE>
    For example, to create a new bug:
    <BLANKLINE>
        bug new
    <BLANKLINE>
    To edit or comment on an existing bug:
    <BLANKLINE>
        bug 1
    ...


summary "$summary"
^^^^^^^^^^^^^^^^^^
Changes the summary of the bug. The title has to be enclosed in
quotes. Example:

    >>> submit_commands(bug_four, 'summary "New summary"')
    >>> print bug_four.title
    New summary

Whitespace will be preserved in the title:

    >>> submit_commands(bug_four, 'summary "New             summary"')
    >>> print bug_four.title #doctest: -NORMALIZE_WHITESPACE
    New             summary

If we omit the quotes, there will be an error:

    >>> submit_commands(bug_four, 'summary New summary')
    >>> print_latest_email()
    Subject: Submit Request Failure
    To: test@canonical.com
    <BLANKLINE>
    ...
    Failing command:
        summary New summary
    ...
    Please enclose the new summary within quotes. For example:
    <BLANKLINE>
        summary "This is a new summary"
    ...


private yes|no
^^^^^^^^^^^^^^
Changes the visibility of the bug. Example:

(We'll subscribe Sample Person to this bug before marking it private, otherwise
permission to complete the operation will be denied.)

    >>> subscription = bug_four.subscribe(bug_four.owner)

    >>> submit_commands(bug_four, 'private yes')
    >>> bug_four.private
    True

    >>> submit_commands(bug_four, 'private no')
    >>> bug_four.private
    False

Specifying something else than 'yes' or 'no' produces an error:

    >>> submit_commands(bug_four, 'private whatever')
    >>> print_latest_email()
    Subject: Submit Request Failure
    To: test@canonical.com
    <BLANKLINE>
    ...
    Failing command:
        private whatever
    ...
    The 'private' command expects either 'yes' or 'no'.
    <BLANKLINE>
    For example:
    <BLANKLINE>
        private yes
    ...

subscribe [$name|$email]
^^^^^^^^^^^^^^^^^^^^^^^^
Subscribes yourself or someone else to the bug. All arguments are
optional. If you don't specify a name, the sender of the email will
be subscribed. Examples:

    >>> subscriptions = [subscription.person.name
    ...                  for subscription in bug_four.subscriptions]
    >>> subscriptions.sort()
    >>> subscriptions
    [u'name12']


    >>> submit_commands(bug_four, 'subscribe')
    >>> 'Sample Person' in [subscription.person.displayname
    ...                     for subscription in bug_four.subscriptions]
    True
    >>> submit_commands(bug_four, 'subscribe foo.bar@canonical.com')
    >>> 'Foo Bar' in [subscription.person.displayname
    ...               for subscription in bug_four.subscriptions]
    True
    >>> submit_commands(bug_four, 'subscribe sabdfl')
    >>> 'Mark Shuttleworth' in [subscription.person.displayname
    ...                         for subscription in bug_four.subscriptions]
    True

If we specify a non-existant user, an error message will be sent:

    >>> submit_commands(bug_four, 'subscribe non_existant@canonical.com')
    >>> print_latest_email()
    Subject: Submit Request Failure
    To: test@canonical.com
    <BLANKLINE>
    ...
    Failing command:
        subscribe non_existant@canonical.com
    ...
    There's no such person with the specified name or email:
    non_existant@canonical.com
    ...

unsubscribe [$name|$email]
^^^^^^^^^^^^^^^^^^^^^^^^^^
Unsubscribes yourself or someone else from the bug.
If you don't specify a name or email, the sender of the email will be
unsubscribed. Examples:

    >>> submit_commands(bug_four, 'unsubscribe sabdfl')
    >>> 'Mark Shuttleworth' in [subscription.person.displayname
    ...                         for subscription in bug_four.subscriptions]
    False
    >>> submit_commands(bug_four, 'unsubscribe foo.bar@canonical.com')
    >>> 'Foo Bar' in [subscription.person.displayname
    ...               for subscription in bug_four.subscriptions]
    False
    >>> submit_commands(bug_four, 'unsubscribe')
    >>> 'Sample Person' in [subscription.person.displayname
    ...                     for subscription in bug_four.subscriptions]
    False

If we specify a non-existant user, an error message will be sent:

    >>> submit_commands(bug_four, 'unsubscribe non_existant')
    >>> print_latest_email()
    Subject: Submit Request Failure
    To: test@canonical.com
    <BLANKLINE>
    ...
    Failing command:
        unsubscribe non_existant
    ...
    There's no such person with the specified name or email: non_existant
    ...

Let's subscribe Sample Person to the bug again, so that it has at least
one subscriber:

    >>> submit_commands(bug_four, 'subscribe test@canonical.com')


affects $path [assignee $name|$email]
              [status $status]
              [severity $severity]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Change the state of a bug in a specific context. $path can be of
the following form:

    /products/$productname
    /distros/$distroname
    /distros/$distroname/$sourcepackagename

If there is no task with the specified $path target, a new task is
created:

    >>> stub.test_emails = []
    >>> len(bug_four.bugtasks)
    1
    >>> 'debian' in [bugtask.target.name for bugtask in bug_four.bugtasks]
    False
    >>> submit_commands(bug_four, 'affects /distros/debian')
    >>> len(bug_four.bugtasks)
    2
    >>> 'debian' in [bugtask.target.name for bugtask in bug_four.bugtasks]
    True

A notification was sent to all the bug's subscribers, and to dilys:

    >>> len(stub.test_emails)
    2
    >>> dilys_msg, sample_person_msg = [
    ...     email.message_from_string(raw_message)
    ...     for from_addr, to_addrs, raw_message in sorted(stub.test_emails)
    ...     ]
    >>> dilys_msg['To']
    'dilys@muse.19inch.net'
    >>> sample_person_msg['To']
    'test@canonical.com'
    >>> print sample_person_msg.get_payload()
    Public bug report changed:
    ...
    Also affects: Debian
    ...


Submitting the same thing again doesn't do anything, since the task
already exists:

    >>> submit_commands(bug_four, 'affects /distros/debian')
    >>> len(bug_four.bugtasks)
    2

We can change the assignee, status, and severity using the sub
commands. It's possible to have these sub commands on separate lines:

    >>> submit_commands(
    ...     bug_four, 'affects /distros/debian severity critical',
    ...     'status confirmed', 'assignee test@canonical.com', 'priority high')

    >>> len(bug_four.bugtasks)
    2
    >>> debian_task = bug_four.bugtasks[-1]
    >>> print debian_task.severity.name
    CRITICAL
    >>> print debian_task.status.name
    CONFIRMED
    >>> print debian_task.assignee.displayname
    Sample Person
    >>> print debian_task.priority.name
    HIGH

To set which source package the bug affects, we use:

    >>> submit_commands(bug_four, 'affects /distros/debian/mozilla-firefox')
    >>> len(bug_four.bugtasks)
    2
    >>> debian_task = bug_four.bugtasks[-1]
    >>> print debian_task.sourcepackagename.name
    mozilla-firefox

If we specify another source package in the same distribution, a new
task will be created:

    >>> submit_commands(bug_four, 'affects /distros/debian/evolution')
    >>> len(bug_four.bugtasks)
    3
    >>> evolution_task = bug_four.bugtasks[-2]
    >>> print evolution_task.sourcepackagename.name
    evolution

Let's take on the upstream task as well. This time we'll sneak in a
'subscribe' command between the 'affects' and the other commands, to
show that the commands acting on the bug task don't have to be grouped
together:

    >>> submit_commands(
    ...     bug_four,
    ...     'affects /products/firefox severity critical',
    ...     'subscribe no-priv',
    ...     'status confirmed', 'assignee test@canonical.com',
    ...     'priority high')

    >>> len(bug_four.bugtasks)
    3
    >>> upstream_task = bug_four.bugtasks[0]
    >>> print upstream_task.severity.name
    CRITICAL
    >>> print upstream_task.status.name
    CONFIRMED
    >>> print upstream_task.assignee.displayname
    Sample Person
    >>> print upstream_task.priority.name
    HIGH

Let's take a look at all the error messages that the sub commands can
produce.

Invalid status:

    >>> submit_commands(bug_four, 'status foo')
    >>> print_latest_email()
    Subject: Submit Request Failure
    To: test@canonical.com
    <BLANKLINE>
    ...
    Failing command:
        status foo
    ...
    The 'status' command expects any of the following arguments:
    unconfirmed, needsinfo, rejected, confirmed, inprogress, fixcommitted, fixreleased
    <BLANKLINE>
    For example:
    <BLANKLINE>
        status unconfirmed
    ...

Invalid severity:

    >>> submit_commands(bug_four, 'severity foo')
    >>> print_latest_email()
    Subject: Submit Request Failure
    To: test@canonical.com
    <BLANKLINE>
    ...
    Failing command:
        severity foo
    ...
    The 'severity' command expects any of the following arguments:
    wishlist, minor, normal, major, critical
    <BLANKLINE>
    For example:
    <BLANKLINE>
        severity wishlist
    ...

Invalid priority:

    >>> submit_commands(bug_four, 'affects /products/firefox', 'priority foo')
    >>> print_latest_email()
    Subject: Submit Request Failure
    To: test@canonical.com
    <BLANKLINE>
    ...
    Failing command:
        priority foo
    ...
    The 'priority' command expects any of the following arguments:
    wontfix, low, medium, high
    <BLANKLINE>
    For example:
    <BLANKLINE>
        priority wontfix
    ...

Invalid assignee:

    >>> submit_commands(bug_four, 'assignee foo')
    >>> print_latest_email()
    Subject: Submit Request Failure
    To: test@canonical.com
    <BLANKLINE>
    ...
    Failing command:
        assignee foo
    ...
    There's no such person with the specified name or email: foo
    ...


    >>> stub.test_emails = []

Default 'affects' target
------------------------

Most of the time it's not necessary to give the 'affects' command. If
you omit it, the email interface  tries to guess which bug task you
wanted to edit.

If there's only one task, that task will be edited. So if we simply send
a 'status' command to bug seven, the single upstream task will be
edited:

    >>> login('foo.bar@canonical.com')
    >>> bug_seven = getUtility(IBugSet).get(7)
    >>> len(bug_seven.bugtasks)
    1
    >>> submit_commands(bug_seven, 'status confirmed')
    >>> evolution_task = bug_seven.bugtasks[0]
    >>> print evolution_task.status.name
    CONFIRMED

    >>> from_addr, to_addrs, raw_message = stub.test_emails.pop()
    >>> msg = email.message_from_string(raw_message)
    >>> print msg['Subject']
    [Bug 7]...
    >>> print msg.get_payload(decode=True)
    Public bug report changed:
    ...
        Status: Unconfirmed => Confirmed

If the bug has more than one bug task, we try to guess which bug task
the user wanted to edit. We apply the following heuristics for choosing
which bug task to edit:

The user is a bug contact of the upstream product
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    >>> login('test@canonical.com')
    >>> bug_one = getUtility(IBugSet).get(1)
    >>> submit_commands(
    ...     bug_one, 'status confirmed', 'assignee test@canonical.com')
    >>> for bugtask in bug_one.bugtasks:
    ...     print '%s: %s, assigned to %s' % (
    ...         bugtask.targetname, bugtask.status.title,
    ...         getattr(bugtask.assignee, 'displayname', 'no one'))
    firefox (upstream): Confirmed, assigned to Sample Person
    mozilla-firefox (ubuntu): Unconfirmed, assigned to no one
    mozilla-firefox (debian): Confirmed, assigned to no one

    >>> from_addr, to_addrs, raw_message = stub.test_emails.pop()
    >>> msg = email.message_from_string(raw_message)
    >>> print msg['Subject']
    [Bug 1]...
    >>> print msg.get_payload(decode=True)
    Public bug report changed:
    ...
        Status: Unconfirmed => Confirmed

The user is a package bug contact
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    >>> from canonical.launchpad.interfaces import (
    ...     IDistributionSet, ISourcePackageNameSet, IPersonSet)
    >>> from canonical.launchpad.database.packagebugcontact import (
    ...     PackageBugContact)
    >>> ubuntu = getUtility(IDistributionSet).getByName('ubuntu')
    >>> mozilla_name = getUtility(ISourcePackageNameSet)['mozilla-firefox']
    >>> helge = getUtility(IPersonSet).getByName('kreutzm')
    >>> mozilla_pkg_bug_contact = PackageBugContact(
    ...     distribution=ubuntu, sourcepackagename=mozilla_name,
    ...     bugcontact=helge)


    >>> login('kreutzm@itp.uni-hannover.de')
    >>> submit_commands(
    ...     bug_one, 'status confirmed', 'assignee no-priv@canonical.com')
    >>> for bugtask in bug_one.bugtasks:
    ...     print '%s: %s, assigned to %s' % (
    ...         bugtask.targetname, bugtask.status.title,
    ...         getattr(bugtask.assignee, 'displayname', 'no one'))
    firefox (upstream): Confirmed, assigned to Sample Person
    mozilla-firefox (Ubuntu): Confirmed, assigned to No Privileges Person
    mozilla-firefox (debian): Confirmed, assigned to no one

    >>> from_addr, to_addrs, raw_message = stub.test_emails.pop()
    >>> msg = email.message_from_string(raw_message)
    >>> print msg['Subject']
    [Bug 1]...
    >>> print msg.get_payload(decode=True)
    Public bug report changed:
    ...
        Assignee: (unassigned) => No Privileges Person
    ...

The user is a bug contact of a distribution
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

XXX: TBD after InitialBugContacts is implemented.
     -- Bjorn Tillenius, 2005-11-30

The user is a distribution member
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

    >>> login('foo.bar@canonical.com')
    >>> submit_commands(
    ...     bug_one, 'status unconfirmed', 'assignee test@canonical.com')
    >>> for bugtask in bug_one.bugtasks:
    ...     print '%s: %s, assigned to %s' % (
    ...         bugtask.targetname, bugtask.status.title,
    ...         getattr(bugtask.assignee, 'displayname', 'no one'))
    firefox (upstream): Confirmed, assigned to Sample Person
    mozilla-firefox (Ubuntu): Unconfirmed, assigned to Sample Person
    mozilla-firefox (debian): Confirmed, assigned to no one

    >>> from_addr, to_addrs, raw_message = stub.test_emails.pop()
    >>> msg = email.message_from_string(raw_message)
    >>> print msg['Subject']
    [Bug 1]...
    >>> print msg.get_payload(decode=True)
    Public bug report changed:
    ...
        Assignee: No Privileges Person => Sample Person
    ...


No matching bug task
^^^^^^^^^^^^^^^^^^^^

If none of the bug tasks can be chosen, an error message is sent to the
user, telling him that he has to use the 'affects' command.

    >>> login('stuart.bishop@canonical.com')
    >>> submit_commands(
    ...     bug_one, 'status new', 'assignee foo.bar@canonical.com')
    >>> for bugtask in bug_one.bugtasks:
    ...     print '%s: %s, assigned to %s' % (
    ...         bugtask.targetname, bugtask.status.title,
    ...         getattr(bugtask.assignee, 'displayname', 'no one'))
    firefox (upstream): Confirmed, assigned to Sample Person
    mozilla-firefox (Ubuntu): Unconfirmed, assigned to Sample Person
    mozilla-firefox (debian): Confirmed, assigned to no one

    >>> transaction.commit()
    >>> from_addr, to_addrs, raw_message = stub.test_emails[-1]
    >>> error_mail = email.message_from_string(raw_message)
    >>> print to_addrs
    ['stuart.bishop@canonical.com']

    >>> print error_mail.get_payload() #doctest: -NORMALIZE_WHITESPACE
    An error...
    ...
    You tried to edit bug 1 via email, but it couldn't be determined in
    which context you wanted the changes to occur. The bug is reported in 3
    different contexts, and you have to specify which one by using the
    affects command.
    ...

More About Error Handling
-------------------------

If an error is encountered, an email is sent to the sender informing
him about the error. Let's start with trying to submit a bug without
signing the mail:

    >>> login('test@canonical.com')

    >>> from canonical.launchpad.mail import signed_message_from_string
    >>> msg = signed_message_from_string(submit_mail)
    >>> msg['Message-Id'] = email.Utils.make_msgid()
    >>> handler.process(msg, msg['To'])
    True
    >>> print_latest_email()
    Subject: Submit Request Failure
    To: test@canonical.com
    <BLANKLINE>
    ...
    To report bugs by e-mail, you need to sign the message with an OpenPGP key
    that is registered in Launchpad.
    ...

A submit without specifying on what we want to file the bug on:

    >>> submit_mail_no_bugtask = """From: test@canonical.com
    ... To: new@malone
    ... Date: Fri Jun 17 10:20:23 BST 2005
    ... Subject: A bug without a product or distribution
    ...
    ... There's a nasty bug in Evolution."""
    >>> process_email(submit_mail_no_bugtask)
    >>> print_latest_email() #doctest: -NORMALIZE_WHITESPACE
    Subject: Submit Request Failure
    To: test@canonical.com
    <BLANKLINE>
    ...
    You didn't specify on what you want to file a bug on. A new bug has to
    affect either a product or a distribution. Please use the 'affects'
    command in order to specify on what you want to file a bug on. For
    example, in order to file a bug on Launchpad itself, use:
    ...


Submit a bug on a distribution that doesn't exist:

    >>> submit_mail_distro_not_found = """From: test@canonical.com
    ... To: new@malone
    ... Date: Fri Jun 17 10:20:23 BST 2005
    ... Subject: A bug with a non existing distribution
    ...
    ... There's a nasty bug in Foo.
    ...  affects /distros/foo"""
    >>> process_email(submit_mail_distro_not_found)
    >>> print_latest_email() #doctest: -NORMALIZE_WHITESPACE
    Subject: Submit Request Failure
    To: test@canonical.com
    <BLANKLINE>
    ...
    Failing command:
        affects /distros/foo
    ...
    The path you specified isn't valid. 'foo' in the path '/distros/foo'
    couldn't be found.
    ...


An empty unsigned mail to new@malone:

    >>> submit_empty = """From: test@canonical.com
    ... To: new@malone
    ... Date: Fri Jun 17 10:20:27 BST 2005
    ... Subject: An empty mail
    ...
    ... """
    >>> process_email(submit_empty)
    >>> print_latest_email() #doctest: -NORMALIZE_WHITESPACE
    Subject: Submit Request Failure
    To: test@canonical.com
    <BLANKLINE>
    ...
    You didn't specify on what you want to file a bug on. A new bug has to
    affect either a product or a distribution. Please use the 'affects'
    command in order to specify on what you want to file a bug on. For
    example, in order to file a bug on Launchpad itself, use:
    ...


    >>> LibrarianTestSetup().tearDown()


XXX: Add tests for non-ascii mails.
     -- Bjorn Tillenius, 2005-05-20

