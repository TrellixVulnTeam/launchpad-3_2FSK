= OpenID = 

== Introduction ==

Launchpad is an OpenID provider. If the URL is accessed by a web browser,
an informative message is displayed as per the OpenID spec.

>>> anon_browser.open('http://openid.launchpad.dev')
>>> print anon_browser.headers
Status: 200 Ok
...
Content-Type: text/html;charset=utf-8
...

>>> print '\n' + anon_browser.contents
<BLANKLINE>
...
This is an OpenID server endpoint. For more information,
see http://openid.net/
...


We are going to fake a consumer for these examples. In order to ensure
that the consumer is being fed the correct replies, we register a view
that renders the parameters in the response in an easily testable format.

>>> from StringIO import StringIO
>>> from canonical.launchpad.webapp.publisher import LaunchpadView
>>> from zope.publisher.interfaces.browser import IBrowserPublisher
>>> from zope.interface import implements
>>> class ConsumerView(LaunchpadView):
...     implements(IBrowserPublisher)
...     def render(self):
...         out = StringIO()
...         print >> out, 'Consumer received %s' % self.request.method
...         keys = sorted(self.request.form.keys())
...         for key in keys:
...             print >> out, '%s:%s' % (key, self.request.form[key])
...         return out.getvalue()
...     def browserDefault(self, request):
...         return self, ()
...
>>> from zope.security.checker import defineChecker, Checker, CheckerPublic
>>> defineChecker(ConsumerView, Checker({
...     '__call__': CheckerPublic,
...     'browserDefault': CheckerPublic,
...     'render': CheckerPublic,
...     }))
>>> from zope.app.testing.ztapi import browserView
>>> browserView(None, '+openid-consumer', ConsumerView)

NB. The plus is in the query to ensure this test is running with an up to
date enough Zope3

>>> anon_browser.open('http://launchpad.dev/+openid-consumer?foo=%2Bbar')
>>> print anon_browser.contents
Consumer received GET
foo:+bar


== OpenID Server Discovery ==

A Launchpad user's home page contains the required <link rel="openid.server" />
tag to allow OpenID consumers to determine the URL of the OpenID server to
be contacted.

>>> anon_browser.open('http://launchpad.dev/~sabdfl')
>>> print '\n' + anon_browser.contents
<BLANKLINE>
...
<head>
...
<link rel="openid.server" href="http://openid.launchpad.dev/" />
</head>
...

Teams do not have this tag of course.

>>> anon_browser.open('http://launchpad.dev/~admins')
>>> 'openid' in anon_browser.contents
False


== associate Mode ==

Establish a shared secret between Consumer and Identity Provider.

After determining the URL of the OpenID server, the next thing a consumer
needs to do is associate with the server and get a shared secret via a
POST request.

>>> from urllib import urlencode
>>> anon_browser.open('http://openid.launchpad.dev/', data=urlencode({
...     'openid.mode': 'associate',
...     'openid.assoc_type': 'HMAC-SHA1',
...     }))
>>> print anon_browser.headers
Status: 200 Ok
...
Content-Type: text/plain
...
>>> print anon_browser.contents
assoc_handle:{HMAC-SHA1}{...}{...}
assoc_type:HMAC-SHA1
expires_in:1209...
mac_key:...
<BLANKLINE>

Get the association handle, which we will need for later tests.

>>> import re
>>> [assoc_handle] = re.findall('assoc_handle:(.*)', anon_browser.contents)

== checkid_immediate Mode ==

Ask an Identity Provider if a End User owns the Claimed Identifier,
getting back an immediate "yes" or "can't say" answer.

Once the shared secret is negotiated, the consumer can send
checkid_immediate and checkid_setup GET requests.checkid_immediate requests
will currently return "can't say" as we are not yet logged into Launchpad.

>>> args = urlencode({
...     'openid.mode': 'checkid_immediate',
...     'openid.identity': 'https://launchpad.dev/~sabdfl',
...     'openid.assoc_handle': assoc_handle,
...     'openid.return_to': 'http://launchpad.dev/+openid-consumer',
...     })
>>> anon_browser.open('http://openid.launchpad.dev/?%s' % args)
>>> print anon_browser.contents
Consumer received GET
openid.mode:id_res
openid.user_setup_url:http://openid.launchpad.dev/?...
<BLANKLINE>


An error is returned to the consumer if an attempt to login as a team is
made.

>>> args = urlencode({
...     'openid.mode': 'checkid_immediate',
...     'openid.identity': 'https://launchpad.dev/~admins',
...     'openid.assoc_handle': assoc_handle,
...     'openid.return_to': 'http://launchpad.dev/+openid-consumer',
...     })
>>> user_browser.open('http://openid.launchpad.dev/?%s' % args)
>>> print user_browser.contents
Consumer received GET
openid.mode:id_res
openid.user_setup_url:http://openid.launchpad.dev/?...
<BLANKLINE>

An error is returned to the consumer if an attempt to login as an invalid
user.

>>> args = urlencode({
...     'openid.mode': 'checkid_immediate',
...     'openid.identity': 'https://launchpad.dev/~limi',
...     'openid.assoc_handle': assoc_handle,
...     'openid.return_to': 'http://launchpad.dev/+openid-consumer',
...     })
>>> user_browser.open('http://openid.launchpad.dev/?%s' % args)
>>> print user_browser.contents
Consumer received GET
openid.mode:id_res
openid.user_setup_url:http://openid.launchpad.dev/?...
<BLANKLINE>

We test a success below in the 'Sticky Authorization' section.


== checkid_setup Mode ==

checkid_setup is interactive with the user. We can extract the
URL for the checkid_setup from the result of the previous test.

>>> [setup_url] = re.findall(
...     '(?m)^openid.user_setup_url:(.*)$', anon_browser.contents
...     )


To proceed, the user will need to login.

>>> sabdfl_browser = setupBrowser()
>>> sabdfl_browser.handleErrors = True
>>> sabdfl_browser.open(setup_url)
>>> print sabdfl_browser.url
http://openid.launchpad.dev/+openid/+login?...
>>> sabdfl_browser.handleErrors = False
>>> sabdfl_browser.getControl('E-mail address', index=0).value = 'mark@hbd.com'
>>> sabdfl_browser.getControl('Password', index=0).value = 'test'
>>> sabdfl_browser.getControl('Log In', index=0).click()


Once logged in, the user is redirected to the 'decide' page, where the
user is informed about what is going on and they are given the oppertunity
to allow authorization or decline.

>>> print '\n' + sabdfl_browser.contents
<BLANKLINE>
...
    <form method="get" action=".">
        <input type="hidden" name="token"
            value="..." />
        <select name="allow_duration">
            <option value="once">Once only</option>
            ...
            <option value="10800">3 hours</option>
            ...
            <option value="forever">Forever</option>
        </select>
        <input type="submit" name="action_allow" value="Allow" />
        <input type="submit" name="action_deny" value="Deny" />
    </form>
...


Lets deny the request. This will return us to the consumer without
authentication.

>>> sabdfl_browser.getControl('Deny').click()
>>> print sabdfl_browser.url
http://launchpad.dev/+openid-consumer?openid.mode=cancel
>>> print sabdfl_browser.contents
Consumer received GET
openid.mode:cancel
<BLANKLINE>


Now, lets do that again but allow the request. This will require us
to log in to Launchpad before being redirected back to the consumer
informing it that the request is valid.

>>> sabdfl_browser.open(setup_url)
>>> sabdfl_browser.getControl('Allow').click()
>>> print sabdfl_browser.url
http://launchpad.dev/+openid-consumer?...
>>> print sabdfl_browser.contents
Consumer received GET
openid.assoc_handle:...
openid.identity:https://launchpad.dev/~sabdfl
openid.mode:id_res
openid.return_to:http://launchpad.dev/+openid-consumer
openid.sig:...
openid.signed:return_to,mode,identity
<BLANKLINE>

Grab some results for the later check_authentication tests.

>>> [sig] = re.findall('sig:(.*)', sabdfl_browser.contents)

Note that the return_to URL must be in the trust_root, or an error is
returned.

>>> args = urlencode({
...     'openid.mode': 'checkid_setup',
...     'openid.identity': 'http://launchpad.dev/~sabdfl',
...     'openid.return_to': 'http://launchpad.dev/+openid-consumer',
...     'openid.trust_root': 'http://com',
...     'whatever': 'blah',
...     })
>>> sabdfl_browser.handleErrors = True
>>> sabdfl_browser.open('http://openid.launchpad.dev/?%s' % args)
>>> print sabdfl_browser.contents
Consumer received GET
openid.error:...
openid.mode:error
<BLANKLINE>


== check_authentication Mode ==

Ask an Identity Provider if a message is valid. For dumb, stateless
Consumers or when verifying an invalidate_handle response. 


If an association handle is stateful (genereted using the associate Mode),
check_authentication will fail.

>>> args = urlencode({
...     'openid.mode': 'check_authentication',
...     'openid.assoc_handle': assoc_handle,
...     'openid.sig': sig,
...     'openid.signed':  'return_to,mode,identity',
...     'openid.identity': 'https://launchpad.dev/~sabdfl',
...     'openid.return_to': 'http://launchpad.dev/+openid-consumer',
...     })
>>> sabdfl_browser.open('http://openid.launchpad.dev/?%s' % args)
>>> print sabdfl_browser.contents
is_valid:false
<BLANKLINE>


If we are a dumb consumer though, we must invoke the check_authentication
Mode.

>>> args = urlencode({
...     'openid.mode': 'checkid_setup',
...     'openid.identity': 'https://launchpad.dev/~sabdfl',
...     'openid.return_to': 'http://launchpad.dev/+openid-consumer',
...     })
>>> sabdfl_browser.open('http://openid.launchpad.dev/?%s' % args)
>>> sabdfl_browser.getControl('Allow').click()
>>> print sabdfl_browser.contents
Consumer received GET
openid.assoc_handle:...
openid.identity:https://launchpad.dev/~sabdfl
openid.mode:id_res
openid.return_to:http://launchpad.dev/+openid-consumer
openid.sig:...
openid.signed:return_to,mode,identity
<BLANKLINE>

>>> [stateless_assoc_handle] = re.findall(
...     'assoc_handle:(.*)', sabdfl_browser.contents
...     )
>>> [sig] = re.findall('sig:(.*)', sabdfl_browser.contents)
>>> args = urlencode({
...     'openid.mode': 'check_authentication',
...     'openid.assoc_handle': stateless_assoc_handle,
...     'openid.sig': sig,
...     'openid.signed': 'return_to,mode,identity',
...     'openid.return_to': 'http://launchpad.dev/+openid-consumer',
...     'openid.identity': 'https://launchpad.dev/~sabdfl',
...     })
>>> sabdfl_browser.open('http://openid.launchpad.dev/?%s' % args)
>>> print sabdfl_browser.contents
is_valid:true
<BLANKLINE>


If the consumer sends through the identity URL using %7E notation instead
of ~, that is also supported. I think this might actually break the spec
or be unnecessary, but I can't see any harm being done.

>>> args = urlencode({
...     'openid.mode': 'checkid_setup',
...     'openid.identity': 'https://launchpad.dev/%7Esabdfl',
...     'openid.return_to': 'http://launchpad.dev/+openid-consumer',
...     })
>>> sabdfl_browser.open('http://openid.launchpad.dev/?%s' % args)
>>> sabdfl_browser.getControl('Allow').click()
>>> print sabdfl_browser.contents
Consumer received GET
...
openid.identity:https://launchpad.dev/%7Esabdfl
...

>>> [pstateless_assoc_handle] = re.findall(
...     'assoc_handle:(.*)', sabdfl_browser.contents
...     )
>>> [psig] = re.findall('sig:(.*)', sabdfl_browser.contents)
>>> args = urlencode({
...     'openid.mode': 'check_authentication',
...     'openid.assoc_handle': pstateless_assoc_handle,
...     'openid.sig': psig,
...     'openid.signed': 'return_to,mode,identity',
...     'openid.return_to': 'http://launchpad.dev/+openid-consumer',
...     'openid.identity': 'https://launchpad.dev/%7Esabdfl',
...     })
>>> sabdfl_browser.open('http://openid.launchpad.dev/?%s' % args)
>>> print sabdfl_browser.contents
is_valid:true
<BLANKLINE>


== Sticky Authorization ==

Users can select how long our OpenID server will continue to authorize
them to a particular consumer.

>>> sabdfl_browser.open(setup_url)
>>> sabdfl_browser.getControl(name='allow_duration').value=['3600']
>>> sabdfl_browser.getControl('Allow').click()
>>> print sabdfl_browser.contents
Consumer received GET
...
openid.identity:https://launchpad.dev/~sabdfl
openid.mode:id_res
openid.return_to:http://launchpad.dev/+openid-consumer
...

Now that we have authorized for 1 hour, further auth requests
automatically succeed without user intervention.

>>> sabdfl_browser.open(setup_url)
>>> print sabdfl_browser.contents
Consumer received GET
...
openid.identity:https://launchpad.dev/~sabdfl
openid.mode:id_res
openid.return_to:http://launchpad.dev/+openid-consumer
...


== Identity Ownership ==

You cannot log in as someone elses identity. If you try to, you will be
prompted with a login screen to connect as the correct user.

Immediate mode:

>>> args = urlencode({
...     'openid.mode': 'checkid_immediate',
...     'openid.identity': 'https://launchpad.dev/~stub',
...     'openid.assoc_handle': assoc_handle,
...     'openid.return_to': 'http://launchpad.dev/+openid-consumer',
...     })
>>> sabdfl_browser.open('http://openid.launchpad.dev/?%s' % args)
>>> print sabdfl_browser.contents
Consumer received GET
openid.mode:id_res
openid.user_setup_url:http://openid.launchpad.dev/?...
<BLANKLINE>

Interactive mode:

>>> [setup_url] = re.findall(
...     '(?m)^openid.user_setup_url:(.*)$', sabdfl_browser.contents
...     )
>>> sabdfl_browser.handleErrors = False
>>> sabdfl_browser.open(setup_url)
Traceback (most recent call last):
...
Unauthorized: You are not authorized to use this OpenID identifier.
>>> sabdfl_browser.handleErrors = True

== Invalid identities ==

If you attempt interactive authentication with an invalid OpenID
identifier, you get a nice error page.

>>> args = urlencode({
...     'openid.mode': 'checkid_immediate',
...     'openid.identity': 'https://launchpad.dev/~limi',
...     'openid.assoc_handle': assoc_handle,
...     'openid.return_to': 'http://launchpad.dev/+openid-consumer',
...     })
>>> sabdfl_browser.open('http://openid.launchpad.dev/?%s' % args)
>>> [setup_url] = re.findall(
...     '(?m)^openid.user_setup_url:(.*)$', sabdfl_browser.contents
...     )
>>> sabdfl_browser.open(setup_url)
>>> print '\n' + sabdfl_browser.contents
<BLANKLINE>
...
that is not a valid Launchpad OpenID identity URL, such as
<strong>http://launchpad.dev/~sabdfl</strong>
...
<form action="http://launchpad.dev/+openid-consumer?openid.mode=cancel">
<input type="submit" value="Continue" />
</form>
...

== Broken Consumers ==

Really bad requests might trigger a protocol error

>>> args = urlencode({
...     'openid.mode': 'whoops',
...     })
>>> sabdfl_browser.handleErrors = True
>>> sabdfl_browser.open('http://openid.launchpad.dev/?%s' % args)
>>> print sabdfl_browser.contents
error:No decoder for mode 'whoops'
mode:error
<BLANKLINE>

If there is a valid return_to, then the consumer gets notified.

>>> args = urlencode({
...     'openid.mode': 'whoops',
...     'openid.return_to': 'http://launchpad.dev/+openid-consumer',
...     })
>>> sabdfl_browser.open('http://openid.launchpad.dev/?%s' % args)
>>> print sabdfl_browser.contents
Consumer received GET
openid.error:No decoder for mode 'whoops'
openid.mode:error
<BLANKLINE>

