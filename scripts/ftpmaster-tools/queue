#!/usr/bin/python

# Copyright 2005 Canonical Ltd

"""Queue management script

XXX: This is a temporary measure until queue visualisation and manipulation
is migrated into the launchpad web-UI. Don't look too closely at it thus.

Yes the script is vile, yes it is nasty, no I'm not going to make it less
vile until we migrate the functionality into the UI whereupon this script
can be removed :-)
"""

import _pythonpath

import os
import sys
from fnmatch import fnmatch

from optparse import OptionParser
from zope.component import getUtility

from canonical.lp import initZopeless
from canonical.config import config
from canonical.launchpad.scripts import (execute_zcml_for_scripts,
                                         logger, logger_options)

from canonical.launchpad.interfaces import (
    IDistributionSet, QueueInconsistentStateError)
from canonical.lp.dbschema import (
    DistroReleaseQueueStatus, PackagePublishingPriority)
from canonical.launchpad.webapp.tales import DurationFormatterAPI

name_queue_map = {
    "new": DistroReleaseQueueStatus.NEW,
    "unapproved": DistroReleaseQueueStatus.UNAPPROVED,
    "accepted": DistroReleaseQueueStatus.ACCEPTED,
    "done": DistroReleaseQueueStatus.DONE,
    "rejected": DistroReleaseQueueStatus.REJECTED
    }

queue_name_map = dict((v, k) for (k, v) in name_queue_map.items())

name_priority_map = {
    'required': PackagePublishingPriority.REQUIRED,
    'important': PackagePublishingPriority.IMPORTANT,
    'standard': PackagePublishingPriority.STANDARD,
    'optional': PackagePublishingPriority.OPTIONAL,
    'extra': PackagePublishingPriority.EXTRA,
    '': None
    }

def compare_queue_by_date(a, b):
    return cmp(a.datecreated, b.datecreated)

def filechunks(file, chunk_size=256*1024):
    """Return an iterator which reads chunks of the given file."""
    # We use the two-arg form of the iterator here to form an iterator
    # which reads chunks from the given file.
    return iter(lambda: file.read(chunk_size), '')

def filter_queue(queue, must_filter=False):
    """Filter the queue, if must_filter is False then we return the entire
    queue should no filter be supplied.
    """
    if not must_filter and len(args) < 2:
        return queue

    if len(args) < 2:
        print "Unable to filter queue. No filter provided. If you really meant"
        print "to act on everything then provide the filter '*'"
        sys.exit(1)

    full_filter = args[1]

    if full_filter == "*":
        return queue

    if "/" in full_filter:
        (spn_filter, vers_filter) = full_filter.split("/")
    else:
        (spn_filter, vers_filter) = (full_filter, "*")

    if spn_filter.isdigit():
        for queue_item in queue:
            if queue_item.id == int(spn_filter):
                return [queue_item]
        print "Unable to find queue item %d" % int(spn)
        sys.exit(1)

    ret_queue = []
    for queue_item in queue:
        if (fnmatch(queue_item.sourcepackagename.name, spn_filter) and
            fnmatch(queue_item.sourceversion, vers_filter)):
            ret_queue.append(queue_item)
    if len(ret_queue) == 0:
        print "Unable to find any queue items matching filter %s" % full_filter
        sys.exit(1)

    return ret_queue

def visualise_item(queue_item):
    """Print out a one line summary of the queue item provided."""
    spn = queue_item.sourcepackagename.name
    sourceful = len(queue_item.sources) > 0
    binaryful = len(queue_item.builds) > 0
    sourcever = queue_item.sourceversion
    age = DurationFormatterAPI(queue_item.age).approximateduration()
    vis_item = "%8d | " % queue_item.id
    if sourceful:
        vis_item += "S"
    else:
        vis_item += "-"
    if binaryful:
        vis_item += "B | "
    else:
        vis_item += "- | "
    if len(spn) > 20:
        spn = spn[:20]
    else:
        spn += " " * (20 - len(spn))
    vis_item += spn + " | "
    sourcever = str(sourcever)
    if len(sourcever) > 20:
        sourcever = sourcever[:20]
    else:
        sourcever += " " * (20 - len(sourcever))
    vis_item += sourcever + " | " + age
    print vis_item

def action_LIST(distro, distrorelease, queue):
    """List the queue in date order, oldest first."""
    print "Listing %s/%s (%s)" % (options.distro, options.distrorelease,
                                  options.queue)
    print "-" * 9 + "|----|" + "-" * 22 + "|" + "-" * 22 + "|" + "-" * 15
    filtered_queue = filter_queue(queue)
    for queue_item in filtered_queue:
        visualise_item(queue_item)
    print "-" * 9 + "|----|" + "-" * 22 + "|" + "-" * 22 + "|" + "-" * 15
    print " " * (9+6+1+22+1+22+2) + "%d/%d total" % (
        len(filtered_queue), len(queue))

def action_FETCH(distro, distrorelease, queue):
    """Fetch the items (by filter) to CWD"""
    filtered_queue = filter_queue(queue, True)
    print "Fetching from %s/%s (%s) filtering on %s" % (
        options.distro, options.distrorelease, options.queue, args[1])
    print "Downloading %d/%d items from the queue." % (
        len(filtered_queue), len(queue))
    for queue_item in filtered_queue:
        print "Constructing %s" % queue_item.changesfilename
        changes_file_alias = queue_item.changesfile
        changes_file_alias.open()
        changes_file = open(queue_item.changesfilename, "w")
        changes_file.write(changes_file_alias.read())
        changes_file.close()
        changes_file_alias.close()
        L = []
        for source in queue_item.sources:
            L.extend(source.sourcepackagerelease.files)
        for build in queue_item.builds:
            for bpr in build.build.binarypackages:
                L.extend(bpr.files)
        for file_ref in L:
            libfile = file_ref.libraryfile
            print "Constructing %s" % libfile.filename
            libfile.open()
            out_file = open(libfile.filename, "w")
            for chunk in filechunks(libfile):
                out_file.write(chunk)
            out_file.close()
            libfile.close()

def action_ACCEPT(distro, distrorelease, queue):
    """Move the specified queue items to the accepted state."""
    filtered_queue = filter_queue(queue, True)
    print "Accepting %d/%d items from %s/%s (%s)" % (
        len(filtered_queue), len(queue), options.distro, options.distrorelease,
        options.queue)
    for queue_item in filtered_queue:
        try:
            queue_item.set_accepted()
        except QueueInconsistentStateError, info:
            print ('** %s could not be accepted due %s'
                   % (queue_item.sourcepackagename.name, info))
        # XXX: Send accept and announce mails here. May not commit without
        # fixing this.

    return True # Tell the main loop to commit.

def action_REJECT(distro, distrorelease, queue):
    """Move the specified queue items to the accepted state."""
    filtered_queue = filter_queue(queue, True)
    if len(args) < 3:
        print "Need a rejection message as arg 3"
        sys.exit(1)
    print "Rejecting %d/%d items from %s/%s (%s)" % (
        len(filtered_queue), len(queue), options.distro, options.distrorelease,
        options.queue)
    for queue_item in filtered_queue:
        try:
            queue_item.set_rejected()
        except QueueInconsistentStateError, info:
            print ('** %s could not be rejected due %s'
                   % (queue_item.sourcepackagename.name, info))

        # XXX: Send reject mails here. May not commit without fixing this.

    return True # Tell the main loop to commit.

def action_INFO(distro, distrorelease, queue):
    """Display information about a queue item."""
    filtered_queue = filter_queue(queue, True)
    for queue_item in filtered_queue:
        visualise_item(queue_item)
        for source in queue_item.sources:
            spr = source.sourcepackagerelease
            print "Source: %s/%s Component: %s Section: %s" % (
                spr.sourcepackagename.name, spr.version, spr.component.name,
                spr.section.name)
        for build in queue_item.builds:
            for bpr in build.build.binarypackages:
                print ("Binary: %s/%s/%s Component: %s Section: %s "
                       "Priority: %s") % (
                    bpr.binarypackagename.name, bpr.version,
                    build.build.distroarchrelease.architecturetag,
                    bpr.component.name, bpr.section.name, bpr.priority.name)

def invalid_overrides():
    """Explain the override usage."""
    print """Override usage:

queue override <filter> override_stanza [override_stanza*]

Where override_stanza is one of:
    source [<component>]/[<section>]
    binary <binaryname> [<component>]/[<section>]/[<priority>]

In each case, when you want to leave an override alone leave it blank.

So, to set the binary 'ed' to have section 'editors' but leave the component
and priority alone, do:

queue override <filter> binary ed /editors/

Or, to set ed's source's section to editors, do:

queue override <filter> source /editors
"""
    sys.exit(1)

def parse_overrides(distrorelease):
    """Parse the argument vector for overrides."""
    if len(args) < 4:
        invalid_overrides()
    ret = {}
    chompy_args = list(args[2:])
    while len(chompy_args):
        override_type = chompy_args.pop(0)
        if 'source'.startswith(override_type):
            pkg_name = "_source"
            ret[pkg_name] = chompy_args.pop(0).split("/")
            if len(ret[pkg_name]) != 2:
                print "Incorrect number of elements for source overrides."
                print "Expected 2, got %d" % len(ret[pkg_name])
                invalid_overrides()
            found=ret[pkg_name][0] == ''
            for comp in distrorelease.components:
                if comp.name == ret[pkg_name][0]:
                    ret[pkg_name][0] = comp
                    found=True
            if not found:
                print "Unknown component: %s" % ret[pkg_name][0]
                sys.exit(1)
            found=ret[pkg_name][1] == ''
            for section in distrorelease.sections:
                if section.name == ret[pkg_name][1]:
                    ret[pkg_name][1] = section
                    found = True
            if not found:
                print "Unknown section: %s" % ret[pkg_name][1]
                sys.exit(1)
        elif 'binary'.startswith(override_type):
            pkg_name = chompy_args.pop(0)
            ret[pkg_name] = chompy_args.pop(0).split("/")
            if len(ret[pkg_name]) != 3:
                print "Incorrect number of elements for binary overrides."
                print "Expected 3, got %d" % len(ret[pkg_name])
                invalid_overrides()
            found=ret[pkg_name][0] == ''
            for comp in distrorelease.components:
                if comp.name == ret[pkg_name][0]:
                    found=True
                    ret[pkg_name][0] = comp
            if not found:
                print "Unknown component: %s" % ret[pkg_name][0]
                sys.exit(1)
            found=ret[pkg_name][1] == ''
            for section in distrorelease.sections:
                if section.name == ret[pkg_name][1]:
                    ret[pkg_name][1] = section
                    found = True
            if not found:
                print "Unknown section: %s" % ret[pkg_name][1]
                sys.exit(1)
            if ret[pkg_name][2] not in name_priority_map:
                print "Unknown priority: %s" % ret[pkg_name][2]
                sys.exit(1)
            ret[pkg_name][2] = name_priority_map[ret[pkg_name][2]]
        else:
            print "Unknown override type: %s" % override_type
            print "Override types known: source, binary"
            invalid_overrides()
    return ret

def _update_source_overrides(spr, parsed_overrides):
    """Update the overrides on *this* source package release"""
    if "_source" not in parsed_overrides:
        return
    overrides = parsed_overrides["_source"]
    if overrides[0] != '':
        spr.component = overrides[0]
    if overrides[1] != '':
        spr.section = overrides[1]

def _update_binary_overrides(bpr, parsed_overrides):
    """Update the overrides on *this* binary package release"""
    if str(bpr.binarypackagename.name) not in parsed_overrides:
        return
    overrides = parsed_overrides[str(bpr.binarypackagename.name)]
    if overrides[0] != '':
        bpr.component = overrides[0]
    if overrides[1] != '':
        bpr.section = overrides[1]
    if overrides[2] is not None:
        bpr.priority = overrides[2]
    
def action_OVERRIDE(distro, distrorelease, queue):
    """Alter queued overrides."""
    filtered_queue = filter_queue(queue, True)
    parsed_overrides = parse_overrides(distrorelease)
    # XXX: dsilvers: 20051115: Should not need this, but until ZCML makes more
    # sense to me, it's quicker than fighting the security model.
    from zope.security.proxy import removeSecurityProxy
    print "Altering overrides on %d/%d items from %s/%s (%s)" % (
        len(filtered_queue), len(queue), options.distro, options.distrorelease,
            options.queue)
    for queue_item in filtered_queue:
        for source in queue_item.sources:
            _update_source_overrides(
                removeSecurityProxy(source.sourcepackagerelease),
                parsed_overrides)
        for build in queue_item.builds:
            for bpr in build.build.binarypackages:
                _update_binary_overrides(removeSecurityProxy(bpr),
                                         parsed_overrides)

    print "Running INFO for results"
    action_INFO(distro, distrorelease, queue)
    return True

def main():
    # Parse command-line arguments
    parser = OptionParser()
    logger_options(parser)

    parser.add_option("-Q", "--queue",
                      dest="queue", metavar="QUEUE", default="new",
                      help="Which queue to consider")
    parser.add_option("-D", "--distro",
                      dest="distro", metavar="DISTRO", default="ubuntu",
                      help="Which distro to look in")
    parser.add_option("-R", "--distrorelease",
                      dest="distrorelease", metavar="DISTRORELEASE",
                      default="dapper",
                      help="Which distrorelease to look in")

    parser.add_option("-A", "--announcelist",
                      dest="announcelist", metavar="ANNOUNCELIST",
                      default=None,
                      help="Overrides the announcement list for accepts.")
    
    global options
    global args
    (options, args) = parser.parse_args()

    global log
    log = logger(options, "queue")

    if len(args) == 0:
        log.error("Action not supplied.")
        log.info("Valid actions are:")
        for action_func_name, body in [(fname, func) for (fname, func) in
                                       globals().items()
                                       if fname.startswith("action_")]:
            action = action_func_name.split("_",1)[1]
            what_it_does = body.__doc__.split("\n")[0]
            log.info("%s: %s" % (action.lower(), what_it_does))
        return 1

    action = args[0].upper()

    if "action_" + action not in globals():
        log.error("Unable to map action %s" % action)
        return 1

    if options.queue not in name_queue_map:
        log.error("Unable to map queue name %s" % options.queue)
        return 1

    log.debug("Initialising connection to queue %s/%s" % (
        options.distro, options.distrorelease))

    global ztm
    ztm = initZopeless(dbuser=config.uploadqueue.dbuser)

    execute_zcml_for_scripts()

    distro = getUtility(IDistributionSet).getByName(options.distro)
    distrorelease = distro[options.distrorelease]
    queue = distrorelease.getQueueItems(name_queue_map[options.queue])

    actualised_queue = list(queue)
    actualised_queue.sort(cmp=compare_queue_by_date)

    if globals()["action_"+action](distro, distrorelease, actualised_queue):
        ztm.commit()
    
if __name__ == '__main__':
    sys.exit(main())

