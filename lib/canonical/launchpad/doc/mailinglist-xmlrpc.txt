= XML-RPC integration for mailing lists =

Team mailing lists are requested in Launchpad, but the lists actually live in
an external system running GNU Mailman.  The communication pattern is
initiated by Mailman in all cases; in other words, Mailman polls Launchpad to
see if there is any work for Mailman to do.

    >>> # Note that this test is run multiple times, with the harness
    >>> # providing the `mailinglist_api` object to make the calls against.
    >>> from zope.interface.verify import verifyObject


== Set up ==

Let's start by seeding the database with some sample teams and their mailing
lists.

    >>> from canonical.lp.dbschema import MailingListStatus
    >>> from canonical.launchpad.ftests import login, ANONYMOUS
    >>> from canonical.launchpad.interfaces import IMailingListSet, IPersonSet
    >>> login(ANONYMOUS)
    >>> personset = getUtility(IPersonSet)
    >>> ddaa = personset.getByName('ddaa')
    >>> from canonical.lp.dbschema import TeamSubscriptionPolicy
    >>> def new_team(team_name):
    ...     displayname = ' '.join(word.capitalize()
    ...                            for word in team_name.split('-'))
    ...     # XXX BarryWarsaw Set the team's subscription policy to OPEN
    ...     # because of bug 125505.  See related comment below.
    ...     policy = TeamSubscriptionPolicy.OPEN
    ...     return personset.newTeam(ddaa, team_name, displayname,
    ...                              subscriptionpolicy=policy)

    >>> team_one = new_team('team-one')
    >>> team_two = new_team('team-two')
    >>> commit()

    >>> list_set = getUtility(IMailingListSet)
    >>> list_one = list_set.new(team_one)
    >>> list_one.welcome_message = u'Welcome to Team One'
    >>> list_two = list_set.new(team_two)
    >>> commit()


Here's a helper function for printing the pending actions data structure.

    >>> def print_actions(pending_actions):
    ...     for action in sorted(pending_actions):
    ...         for team in sorted(pending_actions[action]):
    ...             if action in ('create', 'modify'):
    ...                 team, modification = team
    ...                 # Further, we must coerce all values in the
    ...                 # modification dict to unicode, so as to handle the
    ...                 # fact that this doctest is called both via an
    ...                 # internal view and through an XMLRPC proxy.  The
    ...                 # former returns unicode values natively, the latter
    ...                 # strs.  The keys are the same in both cases.
    ...                 modification = dict((k, unicode(v))
    ...                                     for k, v in modification.items())
    ...                 print team, '-->', action, modification
    ...             else:
    ...                 print team, '-->', action


== Registered lists ==

Mailing lists start out in a state called 'REGISTERED'.  These are mailing
lists that have been requested by team owners.  However before Mailman can
create the lists, they must be approved by a Launchpad administrator.  Before
that, there is nothing for Mailman to do.

    >>> mailinglist_api.getPendingActions()
    {}

Once a few lists have been approved by the Launchpad administrators (and one
of the lists has an initial welcome message)...

    >>> carlos = personset.getByName('carlos')
    >>> list_one.review(carlos, MailingListStatus.APPROVED)
    >>> list_two.review(carlos, MailingListStatus.APPROVED)
    >>> commit()

...the next time Mailman polls XMLRPC, there will be things for it to do.

    >>> pending_actions = mailinglist_api.getPendingActions()
    >>> commit()
    >>> print_actions(pending_actions)
    team-one --> create {'welcome_message': u'Welcome to Team One'}
    team-two --> create {}

In the database, the state of both lists should now be CONSTRUCTING to
indicate that Mailman is in the process of creating the lists.

    >>> list_one.status.name
    'CONSTRUCTING'
    >>> list_two.status.name
    'CONSTRUCTING'


== Creating the mailing lists ==

Mailman will attempt to satisfy the requested creation.  This will either
succeed or fail, and this status is communicated back to Launchpad.  Let's say
that team-one was created succesfully, but the creation of team-two failed for
some reason.

    >>> mailinglist_api.reportStatus({
    ...     'team-one': 'success',
    ...     'team-two': 'failure',
    ...     })
    True
    >>> commit()

We can see that the statuses of the mailing lists have been updated in the
database.

    >>> list_one.status.name
    'ACTIVE'
    >>> list_two.status.name
    'FAILED'

Once these actions have been taken, there are no more pending actions for
Mailman.

    >>> mailinglist_api.getPendingActions()
    {}


== Deactivating mailing lists ==

The other action that Mailman needs to take is to deactivate a list when the
team owner requests it.  These also show up as pending actions when Mailman
polls Launchpad.

Now, say team one's owner wants to deactive their list.

    >>> list_one.deactivate()
    >>> commit()

This will show up in the actions pending for Mailman.

    >>> pending_actions = mailinglist_api.getPendingActions()
    >>> print_actions(pending_actions)
    team-one --> deactivated

Let's create another team mailing list and request its deactivation, to show
what happens if a deactivation fails.  First, set things up behind the
scenes.

    >>> team_three = personset.newTeam(ddaa, 'team-three', 'Team Three')
    >>> list_three = list_set.new(team_three)
    >>> list_three.review(carlos, MailingListStatus.APPROVED)
    >>> commit()
        
    >>> pending_actions = mailinglist_api.getPendingActions()
    >>> commit()
    >>> print_actions(pending_actions)
    team-three --> create {}
    team-one --> deactivated
    >>> mailinglist_api.reportStatus({'team-three': 'success'})
    True
    >>> list_three.deactivate()
    >>> commit()

We now have two active mailing lists for which deactivation has been
requested.

    >>> print_actions(mailinglist_api.getPendingActions())
    team-one --> deactivated
    team-three --> deactivated

Perhaps team one's list was successfully deactivated but team three's list
deactivation failed for some reason.

    >>> mailinglist_api.reportStatus({
    ...     'team-one': 'success',
    ...     'team-three': 'failure',
    ...     })
    True
    >>> list_one.status.name
    'INACTIVE'
    >>> list_three.status.name
    'FAILED'


== Modifying mailing lists ==

Activate mailing lists can also be modified.  Currently the only modification
supported is changing the list's welcome message.  Because deactivated and
failed mailing lists cannot be re-activated without manual intervention, let's
create a couple more teams and mailing lists.

    >>> team_four = personset.newTeam(ddaa, 'team-four', 'Team Four')
    >>> list_four = list_set.new(team_four)
    >>> list_four.review(carlos, MailingListStatus.APPROVED)
    >>> team_five = personset.newTeam(ddaa, 'team-five', 'Team Five')
    >>> list_five = list_set.new(team_five)
    >>> list_five.review(carlos, MailingListStatus.APPROVED)
    >>> commit()
    >>> pending_actions = mailinglist_api.getPendingActions()
    >>> print_actions(pending_actions)
    team-five --> create {}
    team-four --> create {}
    >>> mailinglist_api.reportStatus({
    ...     'team-four': 'success',
    ...     'team-five': 'success',
    ...     })
    True
    >>> commit()
    >>> mailinglist_api.getPendingActions()
    {}

Now, when a mailing list's welcome message is changed, Mailman will see this
modification action the next time it polls.

    >>> list_four.welcome_message = u'Welcome to Team Four'
    >>> list_five.welcome_message = u'Welcome to Team Five'
    >>> commit()
    >>> print_actions(mailinglist_api.getPendingActions())
    team-five --> modify {'welcome_message': u'Welcome to Team Five'}
    team-four --> modify {'welcome_message': u'Welcome to Team Four'}

Let's say that the change was successful for one of the lists, but failed for
the other...

    >>> mailinglist_api.reportStatus({
    ...     'team-four': 'success',
    ...     'team-five': 'failure',
    ...     })
    True

...this is reflected in the status of the mailing lists in the database.

    >>> list_four.status.name
    'ACTIVE'
    >>> list_five.status.name
    'FAILED'


== Error conditions ==

Although we control both ends of this XMLRPC interface, it might still be
possible to pass bad input, due to bugs and such.  The XMLRPC interface is
resilient enough to handle this sanely.  The getPendingActions() interface of
course takes no input so you can't mess it up.  Not so with the reportStatus()
method.

One possibility is that a bad team name is passed in the statuses dictionary.

    >>> # Note that if we were going through the XMLRPC server instead of
    >>> # talking to the view directly, the Fault instances returned here
    >>> # would be turned into tracebacks by the XMLRPC machinery.

    >>> mailinglist_api.reportStatus({'bogus team': 'success'})
    Traceback (most recent call last):
    ...
    Fault: <Fault 110: 'No such team: bogus team'>

Similarly we could pass in the name of a person that is not a team.

    >>> mailinglist_api.reportStatus({'carlos': 'success'})
    Traceback (most recent call last):
    ...
    Fault: <Fault 110: 'No such team: carlos'>

We could also pass in a success or failure status to a list that is not
expecting it.  In this case, list_four is active so it is not expecting a
status report, either success...

    >>> mailinglist_api.reportStatus({'team-four': 'success'})
    Traceback (most recent call last):
    ...
    Fault: <Fault 120: 'Unexpected status report "success" for team: team-four'>

...or failure.

    >>> mailinglist_api.reportStatus({'team-four': 'failure'})
    Traceback (most recent call last):
    ...
    Fault: <Fault 120: 'Unexpected status report "failure" for team: team-four'>

This is also true of lists in the failed state.

    >>> mailinglist_api.reportStatus({'team-five': 'success'})
    Traceback (most recent call last):
    ...
    Fault: <Fault 120: 'Unexpected status report "success" for team: team-five'>

    >>> mailinglist_api.reportStatus({'team-five': 'failure'})
    Traceback (most recent call last):
    ...
    Fault: <Fault 120: 'Unexpected status report "failure" for team: team-five'>

Finally, for a list that is expecting a status report, we could pass in a
bogus status string.  To illustrate, let's begin the process of deactivating
an active list.

    >>> list_four.deactivate()
    >>> commit()
    >>> pending_actions = mailinglist_api.getPendingActions()
    >>> print_actions(pending_actions)
    team-four --> deactivated

Status strings are case-sensitive.

    >>> mailinglist_api.reportStatus({'team-four': 'SUCCESS'})
    Traceback (most recent call last):
    ...
    Fault: <Fault 130: 'Bad status string "SUCCESS" for team: team-four'>

And of course, entirely bogus status strings aren't accepted either.

    >>> mailinglist_api.reportStatus({'team-four': 'entirely-bogus'})
    Traceback (most recent call last):
    ...
    Fault: <Fault 130: 'Bad status string "entirely-bogus" for team: team-four'>
