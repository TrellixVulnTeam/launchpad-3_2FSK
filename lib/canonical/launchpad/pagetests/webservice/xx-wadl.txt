= Launchpad's WADL documents =


== Hosted file resources ==

A hosted file resource is the web service's access point for a binary
file hosted elsewhere. Examples of hosted files include a person's
mugshot image and a project's icon.

A hosted file resource responds to GET requests by redirecting the
client to the externally hosted file. It responds to PUT or DELETE
requests by updating or deleting the underlying binary file.

The behavior laid out in the previous paragraph is also defined in the
WADL documents served by the web service itself. You can use content
negotiation to get a WADL description of any hosted file resource.

The 'salgado' user starts out with no hosted mugshot, and an ordinary
GET to the place where the mugshot would be results in a 404 error.

    >>> print webservice.get('/~salgado/mugshot')
    HTTP/1.1 404 Not Found
    ...

But if the client is interested in learning how to create a mugshot at
/~salgado/mugshot, it can use content negotiation to get a WADL
description of the resource-to-be.

    >>> wadl = webservice.get(
    ...     '/~salgado/mugshot',
    ...     'application/vd.sun.wadl+xml').getBody()
    >>> wadl_schema.validate(wadl)
    True
    >>> wadl_schema.error_log
    ''

    >>> tree = etree.fromstring(wadl)

Just like with the WADL description of an entry or collection
resource, the WADL representation of a hosted file resource is not
much more than a reference to a big WADL file at the service root. To
find out about the capabilities of the resource-to-be, the client
needs to fetch the WADL representation of
http://.../ and look for the XML element with the
ID "HostedFile".

    >>> tree.tag
    '...application'

    >>> resources = single_list_value(tree)
    >>> resources.tag
    '...resources'
    >>> resources.attrib['base']
    'http://.../~salgado/mugshot'

    >>> resource = single_list_value(resources)
    >>> resource.tag
    '...resource'
    >>> resource.attrib['path']
    ''
    >>> resource.attrib['type']
    'http://.../#HostedFile'


== The service root ==

All the WADL documents we've seen so far have been very simple,
describing a single resource and describing it by reference to another
WADL document. That other document is the WADL representation of the
service root. It describes the capabilities of every kind of resource
the service offers. It also describes the JSON representations those
resources serve, and any custom methods invokable on those
resources. It's a big document.

Because it is so big, it is cached.  Because it only changes when the
Launchpad software changes, it is cached to a file.  Right now, our
webservice will return a special test file:
canonical/launchpad/apidoc/wadl-testrunner.xml.  It was loaded on module
import using the canonical.config.config.instance_name, so a development
instance will use the file canonical/launchpad/apidoc/wadl-development.xml.

    >>> test_wadl = webservice.get(
    ...     '/', 'application/vd.sun.wadl+xml').getBody()
    >>> print test_wadl
    <?xml version="1.0"?>
    <wadl:application xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                      xmlns="http://research.sun.com/wadl/2006/10"
                      xmlns:wadl="http://research.sun.com/wadl/2006/10"
                      xsi:schemaLocation="http://research.sun.com/wadl/2006/10/wadl.xsd">
    <BLANKLINE>
      <!--This file is for testing purposes only.  See
          canonical/launcpad/pagetests/webservice/xx-wadl.txt -->
    <BLANKLINE>
    </wadl:application>
    <BLANKLINE>

Let's use the real contents, though.  To do this, we need to do what
utilities/create-lp-wadl.py does: clear out the cache on the class.

    >>> from canonical.launchpad.systemhomes import WebServiceApplication
    >>> WebServiceApplication.cached_wadl = None

    >>> wadl = webservice.get(
    ...     '/', 'application/vd.sun.wadl+xml').getBody()
    >>> wadl = wadl.decode('UTF-8')

    >>> len(wadl) > len(test_wadl)
    True

The new output is cached on the class now.  After verifying, we'll reinstate
the testing version so other tests have a clean slate.

    >>> WebServiceApplication.cached_wadl == wadl
    True
    >>> WebServiceApplication.cached_wadl = test_wadl

We can examine the real wadl now.

    # We need to replace the nbsp entity, because the validator
    # doesn't support embedded definition.
    >>> wadl_schema.validate(
    ...     wadl.replace('&nbsp;', '&#160;').encode('UTF-8'))
    True
    >>> wadl_schema.error_log
    ''
    >>> tree = etree.fromstring(wadl)

Like all WADL documents, the WADL representation of the service root
is rooted at an <application> tag.

    >>> tree.tag
    '...application'

As with the WADL descriptions of collection and entry resources, this
<application> tag describes the capabilities of the server root
resource. But that <application> tag also contains all the information
referenced by all the other WADL documents in the system. #PersonEntry
is here, as is #people and #ScopedCollection and
many other targets of a <resource> tag's 'resource_type' attribute. Also
located here are the descriptions of the JSON representations those
resources serve.


-------------


Most <param> tags don't tell the client much beyond where to find a
certain parameter, but some of our parameters take values from a
proscribed vocabulary. These parameters correspond to Choice fields
who take their vocabulary from an EnumeratedValue. For these
parameters, the server provides the client with information about the
possible values.

    >>> status_param = single_list_value(
    ...     [param for param in full_params
    ...      if param.attrib['name'] == 'status'])
    >>> status_options = status_param.getchildren()
    >>> status_options[0].tag
    '...doc'
    >>> status_options[1].tag
    '...option'
    >>> sorted(status.attrib['value'] for status in status_options[1:])
    ['Confirmed', 'Fix Committed', ... "Won't Fix"]


== Hosted binary files ==

One interesting type of parameter not shown above is a link to a
binary file managed by the web service, such as a person's mugshot.

    >>> person_desc = single_list_value(
    ...     [entry for entry in entry_resource_descriptions
    ...      if entry[0].attrib['id'] == 'person'])
    >>> (person_entry_type, person_full_rep, person_diff_rep,
    ...  person_page_collection_type, person_collection_rep) = person_desc
    >>> mugshot_param = single_list_value(
    ...     [param for param in person_full_rep
    ...      if param.attrib['name'] == 'mugshot_link'])
    >>> doc, mugshot_link = mugshot_param
    >>> mugshot_link.attrib['resource_type']
    'http://.../#HostedFile'

What can the client do to this binary file resource?

    >>> get, put, delete = list(hosted_binary_resource_type)

The client can send GET to the resource, and be redirected to a binary
file hosted externally.

    >>> get.tag
    '...method'
    >>> get.attrib['name']
    'GET'
    >>> get_response = single_list_value(get)
    >>> get_representation = single_list_value(get_response)
    >>> get_representation.attrib['status']
    '303'
    >>> redirect_param = single_list_value(get_representation)
    >>> redirect_param.tag
    '...param'
    >>> redirect_param.attrib['style']
    'header'
    >>> redirect_param.attrib['name']
    'Location'

The client can PUT a binary file:

    >>> put.tag
    '...method'
    >>> put.attrib['name']
    'PUT'

The client can DELETE an existing file:

    >>> delete.tag
    '...method'
    >>> delete.attrib['name']
    'DELETE'


== A non-top-level collection resource type ==

We're almost done with our in-depth look at the WADL description of
bug tasks. Now we need to consider a page of bug tasks, like you'd see
from a scoped collection. There's no top-level collection of bug tasks
(only a collection of bugs), but any given bug will have a collection
of associated bug tasks, and this collection will have its own
URL. This <resource_type> describes the collection at that URL.

    >>> collection_type.tag
    '...resource_type'
    >>> collection_type.attrib['id']
    'bug_task-page-resource'

A top-level collection can have custom operations, but all other
collection resources only support the standard GET operation. This
includes scoped collections like the collection of tasks for a bug. It
also includes the second and subsequent pages of a top-level
collection.

    >>> get = single_list_value(collection_type)
    >>> get.attrib['id']
    'bug_task-page-resource-get'

In response to the standard GET operation, collection resources will
serve a JSON representation, described immediately below.

    >>> get_response = single_list_value(get)
    >>> json_representation = single_list_value(get_response)
    >>> json_representation.attrib['href']
    '#bug_task-page'


== The representation of a collection ==

The representation of one type of entry (say, a person) looks very
different from the representation of another type (say, a bug), but
all collections look pretty much the same, no matter what kind of
entries they contain. In fact, a top-level collection (say, the
collection of bugs) references the same <representation> tag as a
corresponding scoped collection (say, the bugs assigned to a person)
or any other collection (say, the second page of the top-level bug
collection).

    >>> collection_rep.tag
    '...representation'
    >>> collection_rep.attrib['mediaType']
    'application/json'

All collection representations have the same five <param> tags.

    >>> [param.attrib['name'] for param in collection_rep]
    ['resource_type_link', 'total_size', 'start', 'next_collection_link',
     'prev_collection_link', 'entries', 'entry_links']
    >>> (type_link, size, start, next, prev, entries,
    ...  entry_links) = collection_rep

So what's the difference between a collection of people and a
collection of bug tasks? Well, the ID is different, but that's just a
name.

    >>> collection_rep.attrib['id']
    'bug_task-page'

No, the real difference is the 'entry_links' parameter. It tells the
client that this particular collection contains links to objects of
type BugTaskEntry.

    >>> entry_links.attrib['path']
    "$['entries'][*]['self_link']"
    >>> link = single_list_value(entry_links)
    >>> link.attrib['resource_type']
    'http://.../#bug_task'

This tells the client that a 'collection of bug tasks' resource
contains lots of links to 'bug task' resources.

The 'next_collection_link' and 'prev_collection_link' parameters are
also links to other resources. What are these other resources? Other
pages of the same collection!

    >>> next_type = single_list_value(next)
    >>> next_type.attrib['resource_type']
    '#bug_task-page-resource'

    >>> prev_type = single_list_value(prev)
    >>> prev_type.attrib['resource_type']
    '#bug_task-page-resource'
