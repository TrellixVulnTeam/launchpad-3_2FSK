== Get an existing merge proposal ==

Branch merge proposals can be fetched through the API.

    >>> from canonical.launchpad.interfaces.codereviewcomment import (
    ...     CodeReviewVote)

    >>> login('foo.bar@canonical.com')
    >>> fixit_proposal = factory.makeBranchMergeProposal()
    >>> fixit_proposal.source_branch.owner.name = 'source'
    >>> fixit_proposal.source_branch.name = 'fix-it'
    >>> fixit_proposal.source_branch.product.name = 'fooix'
    >>> fixit_proposal.target_branch.owner.name = 'target'
    >>> fixit_proposal.target_branch.name = 'trunk'
    >>> fixit_proposal.target_branch.product.name = 'fooix'
    >>> comment = factory.makeCodeReviewComment(
    ...     subject='Looks good', body='This is great work',
    ...     vote=CodeReviewVote.APPROVE, vote_tag='code',
    ...     merge_proposal=fixit_proposal)
    >>> comment2 = factory.makeCodeReviewComment(
    ...     subject='Not really', body='This is mediocre work.',
    ...     vote=CodeReviewVote.ABSTAIN, parent=comment,
    ...     merge_proposal=fixit_proposal)

    >>> proposal_url = canonical_url(fixit_proposal, rootsite='api')
    >>> logout()

    >>> merge_proposal = webservice.get(proposal_url).jsonBody()
    >>> from canonical.lazr.testing.webservice import pprint_entry
    >>> pprint_entry(merge_proposal)
    all_comments_collection_link: u'http://.../~source/fooix/fix-it/+merge/1/all_comments'
    commit_message: None
    date_created: ...
    date_merged: None
    date_queued: None
    date_review_requested: None
    date_reviewed: None
    dependent_branch_link: None
    merge_reporter_link: None
    merged_revno: None
    preview_diff_link: None
    queue_position: None
    queue_status: u'Work in progress'
    queued_revision_id: None
    queuer_link: None
    registrant_link: u'http://.../~person-name13'
    resource_type_link: u'http://.../#branch_merge_proposal'
    reviewer_link: None
    self_link: u'http://.../~source/fooix/fix-it/+merge/...'
    source_branch_link: u'http://.../~source/fooix/fix-it'
    superseded_by_link: None
    supersedes_link: None
    target_branch_link: u'http://.../~target/fooix/trunk'


== Read the comments ==

The comments on a branch merge proposal are exposed through the API.

    >>> all_comments = webservice.get(
    ...     merge_proposal['all_comments_collection_link']).jsonBody()
    >>> print len(all_comments['entries'])
    2
    >>> pprint_entry(all_comments['entries'][0])
    branch_merge_proposal_link: u'http://.../~source/fooix/fix-it/+merge/1'
    id: 1
    message_body: u'This is great work'
    resource_type_link: u'http://.../#code_review_comment'
    self_link: u'http://.../~source/fooix/fix-it/+merge/1/comments/1'
    title: u'Comment on proposed merge of ~source/fooix/fix-it into ~target/fooix/trunk'
    vote: u'Approve'
    vote_tag: u'code'

    >>> comment_2 = webservice.named_get(
    ...     merge_proposal['self_link'], 'getComment', id=2).jsonBody()
    >>> pprint_entry(comment_2)
    branch_merge_proposal_link: u'http://.../~source/fooix/fix-it/+merge/1'
    id: 2
    message_body: u'This is mediocre work.'
    resource_type_link: u'http://.../#code_review_comment'
    self_link: u'http://.../~source/fooix/fix-it/+merge/1/comments/2'
    title: u'Comment on proposed merge of ~source/fooix/fix-it into ~target/fooix/trunk'
    vote: u'Abstain'
    vote_tag: None


== Performing a Review ==

A review can be performed through the API.

    >>> person = webservice.get('/~salgado').jsonBody()
    >>> is_valid = webservice.named_get(
    ...     merge_proposal['self_link'], 'isPersonValidReviewer',
    ...     reviewer=person['self_link']).jsonBody()
    >>> print is_valid
    True


A review can be requested of the salgado, since he's a valid reviewer.

    >>> reviewer = webservice.named_post(
    ...     merge_proposal['self_link'], 'nominateReviewer',
    ...     reviewer=person['self_link'], review_type='code')
    >>> print reviewer
    HTTP/1.1 200 Ok ...
    >>> pprint_entry(reviewer.jsonBody())
    branch_merge_proposal_link: u'http://.../~source/fooix/fix-it/+merge/1'
    comment_link: None
    date_created: u'...'
    registrant_link: u'http://.../~salgado'
    resource_type_link: u'http://.../#code_review_vote_reference'
    review_type: u'code'
    reviewer_link: u'http://.../~salgado'
    self_link: u'http://.../~source/fooix/fix-it/+merge/1/+review/3'

Now the code review should be made.

    >>> comment = webservice.named_post(
    ...     merge_proposal['self_link'], 'createComment',
    ...     subject='Great work', content='This is great work',
    ...     vote=CodeReviewVote.APPROVE.title, review_type='code').jsonBody()
    >>> pprint_entry(comment)
    branch_merge_proposal_link: u'http://.../~source/fooix/fix-it/+merge/1'
    id: 3
    message_body: u'This is great work'
    resource_type_link: u'http://.../#code_review_comment'
    self_link: u'http://.../~source/fooix/fix-it/+merge/1/comments/3'
    title: u'Comment on proposed merge of ~source/fooix/fix-it into ~target/fooix/trunk'
    vote: u'Approve'
    vote_tag: u'code'


== Updating the preview diff ==

The merge proposal can now be updated with the diff that reflects what the
merge would look like if the source branch was merged into the target branch.

    >>> diff_content = '''\
    ... === modified file 'fooix.txt'
    ... --- fooix.txt 2009-01-01 12:00:00 +0000
    ... +++ fooix.txt 2009-02-02 12:34:56 +0000
    ... @@ some numbers @@
    ...  original
    ... -removed
    ... +added
    ... '''
    >>> response = webservice.named_post(
    ...     merge_proposal['self_link'], 'updatePreviewDiff',
    ...     diff_content=diff_content,
    ...     diff_stat='M fooix.txt', source_revision_id='rev-a',
    ...     target_revision_id='rev-b', conflicts='oh, no conflicts')
    >>> print response.getOutput()
    HTTP/1.1 200 Ok
    Content-Length: ...
    Content-Type: application/json
    Vary: ...
    ...

The diff is now visible through the merge proposal.

    >>> merge_proposal = webservice.get(proposal_url).jsonBody()
    >>> preview_diff = webservice.get(
    ...     merge_proposal['preview_diff_link']).jsonBody()
    >>> pprint_entry(preview_diff)
    added_lines_count: None
    branch_merge_proposal_link:
      u'http://.../~source/fooix/fix-it/+merge/1'
    conflicts: u'oh, no conflicts'
    dependent_revision_id: u'OOPS'
    diff_lines_count: 7
    diff_text_link:
      u'http://.../~source/fooix/fix-it/+merge/1/+preview-diff/diff_text'
    diffstat: u'M fooix.txt'
    removed_lines_count: None
    resource_type_link: u'http://.../#preview_diff'
    self_link:
      u'http://.../~source/fooix/fix-it/+merge/1/+preview-diff'
    source_revision_id: u'rev-a'
    stale: True
    target_revision_id: u'rev-b'


== Getting a Project's Pending Merge Proposals ==

It is possible to view all of a project's merge proposals or filter the
proposals by their status.

    >>> def print_proposal(proposal):
    ...     print proposal['self_link'] + ' - ' + \
    ...         proposal['queue_status']


    >>> proposals = webservice.named_get(
    ...     '/fooix', 'getMergeProposals').jsonBody()
    >>> for proposal in proposals['entries']:
    ...     print_proposal(proposal)
    http://.../~source/fooix/fix-it/+merge/1 - Work in progress


Or I can look for anything that is approved.

    >>> login('foo.bar@canonical.com')
    >>> from zope.component import getUtility
    >>> from canonical.launchpad.interfaces.branchmergeproposal import (
    ...     BranchMergeProposalStatus)
    >>> from canonical.launchpad.interfaces.person import IPersonSet
    >>> sample_person = getUtility(IPersonSet).getByEmail(
    ...     'foo.bar@canonical.com')
    >>> fixit_proposal.approveBranch(sample_person, '1')
    >>> logout()

    >>> proposals = webservice.named_get(
    ...     '/fooix', 'getMergeProposals',
    ...     status=[BranchMergeProposalStatus.CODE_APPROVED.title]).jsonBody()
    >>> for proposal in proposals['entries']:
    ...     print_proposal(proposal)
    http://.../~source/fooix/fix-it/+merge/1 - Approved

