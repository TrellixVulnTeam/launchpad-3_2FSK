Messages
========

The Message table is a central message spool that can be used by
various parts of launchpad. Currently, it is used by Malone for comments
on bugs. Bugs are linked to Messages via the BugMessage table.

>>> from canonical.launchpad.interfaces import (
...     IBugMessageSet, IBugSet, IOpenLaunchBag)
>>> login('foo.bar@canonical.com')
>>> bugmessageset = getUtility(IBugMessageSet)
>>> bug_one = getUtility(IBugSet).get(1)
>>> current_user = getUtility(IOpenLaunchBag).user
>>> bmsg = bugmessageset.createMessage(
...     subject='The Title', content='The Content', bug=bug_one,
...     owner=current_user)
>>> msg = bmsg.message
>>> msg.subject
u'The Title'

We can retrieve the full contents as plain text. (However, note that
if generating HTML you should use the MessageChunks detailed below
to handle attachments correctly)

>>> msg.contents
u'The Content'

Messages are threaded, although this is not necessarily displayed in the
UI. Each message has a parent attribute. If the message was created via
IBugMessageSet, the parent gets set to the bug's initial message.

>>> msg.parent == bug_one.initial_message
True

Messages always have a message id, which is used when notifications
of this message are sent out. The message id is generated by the system
if not provided

>>> isinstance(msg.rfc822msgid, basestring)
True
>>> bool(msg.rfc822msgid)
True

A Message is made up of one or more chunks. The chunks are stored in the
MessageChunk table. The majority of messages will have a single chunk
representing the text body of the message. More complex messages, such as
an email with attachments, will contain multiple chunks. A chunk may be a
piece of text, or a reference to an object stored in the Librarian. Chunks
may be accessed using the chunks attribute, or simply by iterating over
the Message.

>>> for chunk in msg:
...     print repr([chunk.sequence, chunk.content, chunk.blob])
[1, u'The Content', None]
>>> msg.chunks[0].message == msg
True

You can build a Message from an email easily. This stuffs the original,
unadulterated, email into the Librarian and builds all the MessageChunks.

>>> from canonical.launchpad.interfaces import IMessageSet
>>> msgset = getUtility(IMessageSet)
>>> raw_msg = u"""\
... Content-Type: multipart/mixed; charset="latin-1";
...               boundary="===============0294339828=="
... MIME-Version: 1.0
... Subject: =?utf-8?q?Unicode=E2=84=A2?=
... From: foo.bar@canonical.com
... Message-Id: <20050405054002.22134.71562@localhost.localdomain>
... Date: Thu Jun 16 14:12:54 BST 2005
... To: cabal@ubuntu.com
...
... The preamble is not included, including Unicode\N{COPYRIGHT SIGN}
... --===============0294339828==
... Content-Type: text/plain; charset="us-ascii"
... MIME-Version: 1.0
... Content-Transfer-Encoding: 7bit
...
... Plain text
... --===============0294339828==
... Content-Type: executable/virus
... MIME-Version: 1.0
... Content-Transfer-Encoding: base64
... Content-Disposition: attachment; filename="anna.jpg.exe"
... X-Comment: A trivial binary containing bytes 0x00 0x01 0x02 0x03
... X-Comment: This also tests embedded NULLs in the blobs
... X-Comment: Note we store all attachment types - filtering should
... X-Comment: be done *before* launchpad is reached. Launchpad is not
... X-Comment: a virus checker.
...
... AAECAw==
... --===============0294339828==
... Content-Type: text/plain; charset="utf8"
... MIME-Version: 1.0
... Content-Transfer-Encoding: base64
... X-Comment: bas64 encoded text saying 'Unicode(tm)'
...
... VW5pY29kZeKEoiB0ZXh0
...
... --===============0294339828==
... Content-Type: application/xml; charset="utf16"
... MIME-Version: 1.0
... Content-Transfer-Encoding: quoted-printable
... X-Comment: quoted printable binary with a charset - probably illegal
... X-Comment: but we still can cope with it.
...
... =FF=FE<=00?=00x=00m=00l=00=20=00v=00e=00r=00s=00i=00o=00n=00=3D=00"=001=00.=
... =000=00"=00=20=00e=00n=00c=00o=00d=00i=00n=00g=00=3D=00"=00u=00t=00f=001=00=
... 6=00"=00?=00>=00
... =00<=00u=00n=00i=00c=00o=00d=00e=00>=00"!<=00/=00u=00n=00i=00c=00o=00d=00e=
... =00>=00
... --===============0294339828==--
... The epilogue is not included, including Unicode\N{COPYRIGHT SIGN}
... """.encode('latin1')
>>> msg = msgset.fromEmail(raw_msg)

Once the email is stuffed into the Message and MessageChunk tables and
relevant bits stuffed into the Librarian, you can deal with them as
normal.

>>> msg_set = getUtility(IMessageSet)
>>> msg = msg_set.get(
...     rfc822msgid="<20050405054002.22134.71562@localhost.localdomain>"
...     )[0]
>>> msg.title
u'Unicode\u2122'
>>> chunks = msg.chunks
>>> for chunk in chunks:
...     if chunk.content:
...         print '%2d - %r' % (chunk.sequence, chunk.content)
 1 - u'Plain text'
 3 - u'Unicode\u2122 text'

Note that the second and forth chunks were not of type text/plain,
so are stored as blobs.

>>> chunks[1].sequence
2
>>> chunks[1].content is None
True
>>> blob = chunks[1].blob
>>> blob.filename
u'anna.jpg.exe'
>>> blob.url.startswith(u'http://localhost:58000/')
True
>>> blob.url.endswith(u'/anna.jpg.exe')
True

>>> blob2 = chunks[3].blob
>>> blob2.filename
u'unnamed'
>>> blob2.mimetype
u'application/xml; charset="utf16"'

As per normal, we can't access the blobs in the same transaction
as the request. I don't think this is important outside of tests.

>>> import transaction
>>> transaction.commit()
>>> blob.read()
'\x00\x01\x02\x03'

>>> blob2.read().decode('utf16')
u'<?xml version="1.0" encoding="utf16"?>\n<unicode>\u2122</unicode>'


We can also retrieve a byte-identical copy of the original message
from the Librarian. This is required for allowing people to verify
the integrity of GPG signed messages.

>>> msg.raw.read() == raw_msg
True

If you attempt to stuff the same email in again, you get the same
Message back out (but we have to check with == rather than is, as
SQLObject doesn't necessarily give us the same intance back)

>>> msg2 = msgset.fromEmail(raw_msg)
>>> msg == msg2
True


fromEmail will set the parent of the message as well. We can only set
the parent if it's already in the database, though. To ensure that
threads aren't broken, if the direct parent of the message isn't in the
database, the next parent will be used.

>>> foo_msg = msgset.fromEmail('''\
... From: foo.bar@canonical.com
... Subject: Test
... Date: Fri, 17 Jun 2005 10:45:13 +0100
... Message-Id: <foo>
...
... Foo Bar
... ''')

>>> baz_msg = msgset.fromEmail('''\
... From: foo.bar@canonical.com
... Subject: Test
... Date: Fri, 17 Jun 2005 10:45:13 +0100
... Message-Id: <baz>
... References: <foo> <bar1> <bar2>
...
... Foo Bar
... ''')

Since <bar1> and <bar2> aren't in the database, the parent will be
set to <foo>

>>> baz_msg.parent == foo_msg
True

We can specify a parent to be used, if no parent could be found for the
message. This is useful for bugs, where we want all messages except for
the first one to have a parent.

>>> bar_msg = msgset.fromEmail('''\
... From: foo.bar@canonical.com
... Subject: Test
... Date: Fri, 17 Jun 2005 10:45:13 +0100
... Message-Id: <bar>
...
... Bar Baz
... ''', fallback_parent=foo_msg)
>>> bar_msg.parent == foo_msg
True

The fromEmail method handles non-multipart and minimalist messages
quite happily.

>>> msg = msgset.fromEmail('''\
... From: foo.bar@canonical.com
... Subject: Test
... Date: Fri, 17 Jun 2005 10:45:13 +0100
... Message-Id: <fnord>
...
... Foo Bar
... ''')
>>> msg.title
u'Test'
>>> chunks = list(msg.chunks)
>>> len(chunks)
1
>>> chunks[0].content
u'Foo Bar\n'


However, there are some things it refuses to deal with. In particular, it
will not create Messages if it cannot determine the owner unless it is
explicitly told to do so:

>>> msg = msgset.fromEmail('''\
... From: invalid@example.com
... Date: Fri, 17 Jun 2005 10:45:13 +0100
... Message-Id: <fnord3>
... Subject: Foo
...
... Foo Bar
... ''')
Traceback (most recent call last):
    [...]
UnknownSender: u'invalid@example.com'

>>> msg = msgset.fromEmail('''\
... From: invalid@example.com
... Date: Fri, 17 Jun 2005 10:45:13 +0100
... Message-Id: <fnord3>
... Subject: Foo Bar Bazarooney!
...
... Foo Bar
... ''', create_missing_persons=True)
>>> msg.subject
u'Foo Bar Bazarooney!'

It also will refuse to deal with messages without a From: or Reply-To:
header, or a missing Message-Id: or Date: header. These are required, and if
they are missing then the email was sent from a broken email client or
passed through a broken MTA and we have no choice but to bounce them.

>>> msg = msgset.fromEmail('''\
... From: foo.bar@canonical.com
... Date: Thu, 16 Jun 2005 14:12:54 +0100
... Subject: Dud
...
... Moo
... ''')
Traceback (most recent call last):
    [...]
InvalidEmailMessage: Missing Message-Id

>>> msg = msgset.fromEmail('''\
... Date: Fri, 17 Jun 2005 10:45:13 +0100
... Subject: Re: Dud
... Message-Id: <fnord6>
...
... Moo
... ''')
Traceback (most recent call last):
    [...]
InvalidEmailMessage: No From: or Reply-To: header

Also, we generally insist that a message has a date associated with it.

>>> msg = msgset.fromEmail('''\
... From: foo.bar@canonical.com
... Subject: Dud without a date!
... Message-Id: <fnord6>
...
... Moo
... ''')
Traceback (most recent call last):
    [...]
InvalidEmailMessage: Invalid date...

But, we make sure that we don't create a message with a date that is
futuristic:

>>> from datetime import datetime
>>> import pytz
>>> msg = msgset.fromEmail('''\
... From: foo.bar@canonical.com
... Date: Fri, 17 Jun 2016 10:45:13 +0100
... Subject: Re: Back to the future
... Message-Id: <fnord19>
...
... Moo
... ''')
>>> msg.datecreated > datetime.now(tz=pytz.timezone('UTC'))
False

And similarly, we will consider any message that claims to be older than
1990 to have been created right now:

>>> msg = msgset.fromEmail('''\
... From: foo.bar@canonical.com
... Date: Tue, 17 Jun 1986 10:45:13 +0100
... Subject: Re: Back to the future, again
... Message-Id: <fnord221>
...
... Moo
... ''')
>>> thedistantpast = datetime(1990, 1, 1, tzinfo=pytz.timezone('UTC'))
>>> msg.datecreated < thedistantpast
False

Finally, let's test the goldilocks message, where the date is just right:

>>> msg = msgset.fromEmail('''\
... From: foo.bar@canonical.com
... Date: Fri, 17 Jun 2005 10:45:13 +0100
... Subject: Re: Smells like the present to me
... Message-Id: <fnord1221>
...
... Moo
... ''')
>>> print msg.datecreated
2005-06-17 09:45:13+00:00

