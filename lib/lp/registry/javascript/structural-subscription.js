/* Copyright 2011 Canonical Ltd.  This software is licensed under the
 * GNU Affero General Public License version 3 (see the file LICENSE).
 *
 * Form overlay widgets and subscriber handling for structural subscriptions.
 *
 * @module registry
 * @submodule structural_subscription
 */

YUI.add('lp.registry.structural_subscription', function(Y) {

var namespace = Y.namespace('lp.registry.structural_subscription');

var EXPANDER_COLLAPSED = '/@@/treeCollapsed',
    EXPANDER_EXPANDED = '/@@/treeExpanded',
    INNER_HTML = 'innerHTML',
    VALUE = 'value',
    SRC = 'src';

var FILTER_COMMENTS = 'filter-comments',
    FILTER_WRAPPER = 'filter-wrapper',
    ACCORDION_WRAPPER = 'accordion-wrapper',
    ADDED_OR_CLOSED = 'added-or-closed',
    ADDED_OR_CHANGED = 'added-or-changed',
    ADVANCED_FILTER = 'advanced-filter',
    MATCH_ALL = 'match-all',
    MATCH_ANY = 'match-any',
    SS_COLLAPSIBLE = 'ss-collapsible'
    ;

var add_subscription_overlay;
namespace.lp_client = undefined;

/*
 * An object representing the global actions portlet.
 *
 */
var PortletTarget = function() {};
Y.augment(PortletTarget, Y.Event.Target);
namespace.portlet = new PortletTarget();

function subscription_success() {
    // TODO Should there be some success notification?
    add_subscription_overlay.hide();
}

function failure_handler(something, xhr) {
    // TODO Do something nicer.
    alert("it didn't work: " + xhr.responseText);
}

/**
 * Does the list contain the target?
 * information from the user request.
 *
 * @private
 * @method list_contains
 * @param {List} list The list to search.
 * @param {String} target The target of interest.
 */
function list_contains(list, target)
{
    return list.indexOf(target) != -1;
}
namespace.list_contains = list_contains;

/**
 * Given a minimally populated bug filter, patch it to add additional
 * information from the user request.
 *
 * @private
 * @method patch_bug_filter
 * @param {Object} bug_filter The incomplete bug filter.
 * @param {Object} form_data The data returned from the form submission.
 */
function patch_bug_filter(bug_filter, form_data) {
    var config = {
        on: {
            success: subscription_success,
            failure: failure_handler
            }
        };

    var patch_data = {
        'description': form_data.name[0]
    };

    // Set the notification level.
    var added_or_closed = list_contains(form_data.events, ADDED_OR_CLOSED);
    var filter_comments = list_contains(form_data.filters, FILTER_COMMENTS);

    // Chattiness: Lifecycle < Details < Discussion.
    if (added_or_closed) {
        patch_data.bug_notification_level = 'Lifecycle';
    } else if (!filter_comments) {
        patch_data.bug_notification_level = 'Discussion';
    } else {
        patch_data.bug_notification_level = 'Details';
    }

    // Set the tags.
    var advanced_filter = list_contains(form_data.filters, ADVANCED_FILTER);
    if (advanced_filter) {
        // Tags are a list with one element being a space-separated string.
        var tags = form_data.tags[0];
        if (Y.Lang.isValue(tags) && tags != '') {
            var match_all = list_contains(form_data.tag_match, MATCH_ALL);
            if (match_all) {
                patch_data.find_all_tags = true;
            }
            patch_data.tags = tags.toLowerCase().split(' ');
        }
        if (form_data.importances.length > 0) {
            patch_data.importances = form_data.importances;
        }
        if (form_data.statuses.length > 0) {
            patch_data.statuses = form_data.statuses;
        }
    }
    namespace.lp_client.patch(bug_filter.lp_original_uri, patch_data, config);
}
namespace.patch_bug_filter = patch_bug_filter;


/**
 * Create a new structural subscription filter.
 *
 * @method create_structural_subscription filter
 * @param {Object} who Link to the user or team to be subscribed.
 * @param {Object} form_data The data returned from the form submission.
 */
function add_bug_filter(who, form_data) {
    var config = {
        on: {
            success: function (bug_filter) {
                    patch_bug_filter(bug_filter, form_data);
                },
            failure: failure_handler
            },
        parameters: {
            subscriber: who,
            }
        };

    namespace.lp_client.named_post(LP.cache.context.self_link,
        'addBugSubscriptionFilter', config);
}

/**
 * Given the form data from a user, save the subscription.
 *
 * @private
 * @method save_subscription
 * @param {Object} form_data The data generated by the form submission.
 */

function save_subscription(form_data) {
    var who;
    if (form_data.recipient[0] == 'user') {
        who = LP.links.me;
    } else {
        // There can be only one.
        who = form_data.team[0];
    }
    add_bug_filter(who, form_data);
}
namespace.save_subscription = save_subscription;

function edit_subscription_handler(form_data) {
    // TODO make work
}

function create_overlay(content_box_id, overlay_id, submit_button,
        submit_callback) {
    // Create the overlay.
    add_subscription_overlay = new Y.lazr.FormOverlay({
        headerContent: '<h2>Add a mail subscription for ' +
            LP.cache.context.title + ' bugs</h2>',
        form_content: Y.one(overlay_id),
        centered: true,
        visible: false,
        form_submit_button: submit_button,
        form_submit_callback: submit_callback
    });
    add_subscription_overlay.render(content_box_id);
    // Prevent cruft from hanging around upon closing.
    function clean_up(e) {
        var filter_wrapper = Y.one('#' + FILTER_WRAPPER);
        filter_wrapper.hide();
        collapse_node(filter_wrapper);
    }
    add_subscription_overlay.get('form_cancel_button').on(
        'click', clean_up);
    add_subscription_overlay.get('form_submit_button').on(
        'click', clean_up);
    add_subscription_overlay.on('cancel', clean_up);
}

/*
 * Modify the DOM to insert a link or two into the global actions portlet.
 * If structural subscriptions already exist then a 'modify' link is
 * added.  Otherwise, just the 'add' link is put into the portlet.
 *
 * @method setup_subscription_links
 * @param {String} overlay_id Id of the overlay element.
 * @param {String} content_box_id Id of the element on the page where
 *     the overlay is anchored.
 */
function setup_subscription_links(overlay_id, content_box_id) {
    // Create a new link in the global actions portlet.
    var link = Y.Node.create('<a href="#">Subscribe to bug mail</a>');
    // Add a class denoting them as js-action links with add sprite.
    link.addClass('sprite add js-action');
    var portlet = Y.one('#global-actions');
    // TODO decouple this from the project page
    portlet.appendChild(link);
    // Intercept clicks on the new link.
    link.on('click', function(e) {
        // Only proceed if the form content is already available.
        if (add_subscription_overlay) {
            e.preventDefault();
            // If the overlay had been opened and closed, the
            // individual elements display must match the state of the selectors.
            events_state_handler();
            add_subscription_overlay.show();
        }
    });
}                               // setup_subscription_links


/**
 * Make a table cell.
 *
 * @private
 * @method make_cell
 * @param {Object} item Item to be placed in the cell.
 * @param {String} name Name of the control.
 */
function make_cell(item, name) {
    return '<td style="padding-left:3px"><label><input type="checkbox" ' +
        'name="' + name +'" ' +
        'value="' + item + '" checked="checked">' +
        item + '</label><td>';
}
/**
 * Make a table.
 *
 * @private
 * @method make_table
 * @param {Object} list List of items to be put in the table.
 * @param {String} name Name of the control.
 * @param {Int} num_cols The number of columns for the table to use.
 */
function make_table(list, name, num_cols) {
    var html = '<table>';
    for (i in list) {
        i = parseInt(i); // JavaScript, you so crazy!
        if (i % num_cols == 0) {
            if (i != 0) {
                html += '</tr>';
            }
            html += '<tr>';
        }
        html += make_cell(list[i], name);
    }
    html += '</tr></table>';
    return html;
}

/**
 * Make selector controls, the links for 'Select all' and
 * 'Select none' that appear within elements with many checkboxes.
 *
 * @private
 * @method make_selector_controls
 * @param {String} parent Name of the parent.
 * @return {Object} Hash with 'all_name', 'none_name', and 'html' keys.
 */
function make_selector_controls(parent) {
    var rv = {};
    rv['all_name'] = parent + '-select-all';
    rv['none_name'] = parent + '-select-none';
    rv['html'] = '<div id="'+ parent + '-selectors" style="margin-bottom: 10px">' +
                 '  <a href="#" id="' + rv['all_name'] + '">Select all</a> &nbsp;' +
                 '  <a href="#" id="' + rv['none_name'] + '">Select none</a>' +
                 '</div>';

    return rv;
}
namespace.make_selector_controls = make_selector_controls;

function make_select_handler(node, all, checked_value) {
    return function(e) {
        e.preventDefault();
        Y.each(all, function(value) {
            get_input_by_value(node, value).set('checked', checked_value);
        });
    };
}

/**
 * Create the accordion.
 *
 * @method create_accordion
 * @param {String} overlay_id Id of the overlay element.
 * @param {Object} content_node Node where the overlay is anchored.
 * @return {Object} accordion The accordion just created.
 */
function create_accordion(overlay_id, content_node) {
    var accordion = new Y.Accordion({
          useAnimation: true,
          collapseOthersOnExpand: true,
          visible: false
    });

    accordion.render(overlay_id);

    var statuses_ai,
        importances_ai,
        tags_ai;

    // Build tags pane.
    tags_ai = new Y.AccordionItem( {
        label: "Tags",
        expanded: false,
        alwaysVisible: false,
        id: "tags_ai",
        contentHeight: {method: "auto"}
    } );

    tags_ai.set("bodyContent",
        '<div>\n' +
        '<div>\n' +
        '    <input type="radio" name="tag_match" value="' + MATCH_ALL + '" checked> Match all tags\n' +
        '    <input type="radio" name="tag_match" value="' + MATCH_ANY + '"> Match any tags\n' +
        '</div>\n' +
        '<div style="padding-bottom:10px;">\n' +
        '    <input type="text" name="tags" size="60"/>\n' +
        '    <a target="help" href="/+help/structural-subscription-tags.html" ' +
        '        class="sprite maybe">&nbsp;<span class="invisible-link">Structural subscription tags help</span></a>\n ' +
        '</div>\n' +
        '</div>\n');

    accordion.addItem(tags_ai);

    // Build importances pane.
    importances_ai = new Y.AccordionItem( {
        label: "Importances (Any)",
        expanded: false,
        alwaysVisible: false,
        id: "importances_ai",
        contentHeight: {method: "auto"}
    } );
    var importances = LP.cache['importances'];
    var selectors = make_selector_controls('importances');
    var importances_html = '<div id="importances-wrapper">' +
                           selectors['html'] + make_table(importances, 'importances', 4) +
                           '</div>';
    importances_ai.set("bodyContent", importances_html);
    accordion.addItem(importances_ai);
    // Wire up the 'all' and 'none' selectors.
    var all_link = content_node.one('#' + selectors['all_name']);
    var none_link = Y.one('#' + selectors['none_name']);
    var node = content_node.one('#importances-wrapper');
    var select_all_handler = make_select_handler(node, importances, true);
    var select_none_handler = make_select_handler(node, importances, false);
    all_link.on('click', select_all_handler);
    none_link.on('click', select_none_handler);

    // Build statuses pane.
    statuses_ai = new Y.AccordionItem( {
        label: "Statuses (Any)",
        expanded: false,
        alwaysVisible: false,
        id: "statuses_ai",
        contentHeight: {method: "auto"}
    } );
    var statuses = LP.cache['statuses'];
    selectors = make_selector_controls('statuses');
    var status_html = '<div id="statuses-wrapper">' +
                      selectors['html'] + make_table(statuses, 'statuses', 3) +
                      '</div>';
    statuses_ai.set("bodyContent", status_html);
    accordion.addItem(statuses_ai);
    all_link = content_node.one('#' + selectors['all_name']);
    none_link = Y.one('#' + selectors['none_name']);
    node = content_node.one('#statuses-wrapper');
    select_all_handler = make_select_handler(node, statuses, true);
    select_none_handler = make_select_handler(node, statuses, false);
    all_link.on('click', select_all_handler);
    none_link.on('click', select_none_handler);

    return accordion;
}

/**
 * Collapse the node and set its arrow to 'collapsed'
 * @param node The node to collapse.
 */
function collapse_node(node) {
    var anim = Y.lazr.effects.slide_in(node);
    // XXX: BradCrittenden 2011-03-03 bug=728457 : This fix for
    // resizing needs to be incorporated into lazr.effects.  When that
    // is done it should be removed from here.
    anim.on("start", function() {
        node.setStyles({
            visibility: 'visible'
        });
    });
    anim.on("end", function() {
        node.setStyles({
            height: 0,
            visibility: 'hidden'
        });
        node.set(SRC, EXPANDER_COLLAPSED);
    });
    anim.run();
}

/**
 * Expand the node and set its arrow to 'collapsed'
 * @param node The node to collapse.
 */
function expand_node(node) {
    // Set the node to 'hidden' so that the proper size can be found.
    node.setStyles({
        visibility: 'hidden'
    });
    var anim = Y.lazr.effects.slide_out(node);
    // XXX: BradCrittenden 2011-03-03 bug=728457 : This fix for
    // resizing needs to be incorporated into lazr.effects.  When that
    // is done it should be removed from here.
    anim.on("start", function() {
        // Set the node to 'visible' for the beginning of the animation.
        node.setStyles({
            visibility: 'visible'
        });
    });
    anim.on("end", function() {
        // Change the height to auto when the animation completes.
        node.setStyles({
            height: 'auto'
        });
        node.set(SRC, EXPANDER_EXPANDED);
    });
    anim.run();
}

/**
 * Modify the DOM to insert a link or two into the global actions portlet.
 * If structural subscriptions already exist then a 'modify' link is
 * added.  Otherwise, just the 'add' link is put into the portlet.
 *
 * @method setup_overlay
 * @param {String} content_box_id Id of the element on the page where
 *     the overlay is anchored.
 * @return {String} overlay_id Id of the constructed overlay element.
 */
function setup_overlay(content_box_id) {
    var content_node = Y.one(content_box_id);
    var container = Y.Node.create('<div id="overlay-container"></div>');
    var accordion_overlay_id = 'accordion-overlay';
    var control_code =
        '<dl>\n' +
        '    <dt>Bug mail recipient</dt>\n' +
        '    <dd>\n' +
        '      <input type="radio" name="recipient" value="user"\n' +
        '      checked> Yourself<br>\n' +
        '      <input type="radio" name="recipient" value="team"> One of the\n' +
        '      teams you administer<br>\n' +
        '      <dl style="margin-left:25px;">\n' +
        '        <dt></dt>\n' +
        '        <dd>\n' +
        '          <select name="team" id="structural-subscription-teams">\n' +
        '          </select>\n' +
        '        </dd>\n' +
        '      </dl>\n' +
        '    </dd>\n' +
        '  <dt>Subscription name</dt>\n' +
        '  <dd>\n' +
        '    <input type="text" name="name">\n' +
        '    <a target="help" href="/+help/structural-subscription-name.html" ' +
        '        class="sprite maybe">&nbsp;\n' +
        '        <span class="invisible-link">Structural subscription description help</span></a>\n ' +
        '  </dd>\n' +
        '  <dt>Receive mail for bugs affecting ' + LP.cache.context.title + ' that</dt>\n' +
        '  <dd>\n' +
        '    <div id="events">\n' +
        '    <input type="radio" name="events"\n' +
        '        value="' + ADDED_OR_CLOSED + '" id="' + ADDED_OR_CLOSED + '"\n' +
        '        checked> are added or closed<br>\n' +
        '    <input type="radio" name="events" value="' + ADDED_OR_CHANGED + '"\n' +
        '        id="' + ADDED_OR_CHANGED + '"> are added or changed in any way\n' +
        '    </div>\n' +
        '    <div id="' + FILTER_WRAPPER + '" class="ss-collapsible">\n' +
        '    <dl style="margin-left:25px;">\n' +
        '      <dt></dt>\n' +
        '      <dd>\n' +
        '        <input type="checkbox" name="filters"\n' +
        '            value="' + FILTER_COMMENTS + '" checked>\n' +
        '        filter out comments<br>\n' +
        '        <input type="checkbox" name="filters"\n' +
        '            value="' + ADVANCED_FILTER + '"\n' +
        '            id="' + ADVANCED_FILTER + '">\n' +
        '        bugs must match this filter<br>\n' +
        '        <div id="' + ACCORDION_WRAPPER + '" \n' +
        '            class="' + SS_COLLAPSIBLE + '">\n' +
        '            <dl>\n' +
        '                <dt></dt>\n' +
        '                <dd style="margin-left:25px;">\n' +
        '                    <div id="' + accordion_overlay_id + '"\n' +
        '                        style="position:relative; overflow:hidden;"></div>\n' +
        '                </dd>\n' +
        '            </dl>\n' +
        '        </div> \n' +
        '      </dd>\n' +
        '    </dl>\n' +
        '    </div> \n' +
        '  </dd>\n' +
        '  <dt></dt>\n' +
        '</dl>';

    content_node.appendChild(container);
    container.appendChild(Y.Node.create(control_code));

    var accordion = create_accordion('#' + accordion_overlay_id, content_node);

    Y.each(Y.all('div.ss-collapsible'), function(div) {
        collapse_node(div);
    });

    // Set up click handlers for the events radio buttons.
    var radio_group = Y.all('#events input');
    radio_group.on('change', events_state_handler);

    // And a listener for advanced filter selection.
    var advanced_filter = Y.one('#' + ADVANCED_FILTER);
    advanced_filter.on('change', function(e) {
        var div = Y.one('#' + ACCORDION_WRAPPER);
        var checked = e.currentTarget.get('checked');
        if (checked) {
            expand_node(div);
        }
        else
            collapse_node(div);
    });

    // Set the project name.
    // Populate the team drop down from LP.cache data.
    var teams = LP.cache['administratedTeams'];
    var select = Y.one('#structural-subscription-teams');
    for (i in teams) {
        team = teams[i];
        var option = Y.Node.create('<option></option>');
        option.set(INNER_HTML, team.title);
        option.set(VALUE, team.link);
        select.appendChild(option);
    }
    return '#' + container._node.id;
}                               // setup_overlay


function events_state_handler() {
    var ctl = Y.one('#' + ADDED_OR_CHANGED);
    var div = Y.one('#' + FILTER_WRAPPER);
    var checked = ctl.get('checked');
    if (checked)
        expand_node(div);
    else
        collapse_node(div);
}

/*
 * Create the LP client.
 *
 * @method setup_client
 */
function setup_client() {
    namespace.lp_client = new Y.lp.client.Launchpad();
}                               // setup_client

/*
 * External entry point for configuring the structual subscription.
 * @method setup_bug_subscriptions
 * @param {Object} config Object literal of config name/value pairs.
 *     config.content_box is the name of an element on the page where
 *         the overlay will be anchored.
 */
namespace.setup_bug_subscriptions = function(config) {
    Y.on('domready', function() {
        if (Y.UA.ie) {
            return;
        }

        var overlay_id = setup_overlay(config.content_box);
        var submit_button = Y.Node.create(
            '<input type="submit" name="field.actions.create" ' +
            'value="Save Changes"/>');
        create_overlay(config.content_box, overlay_id, submit_button,
            edit_subscription_handler);
        fill_in_bug_subscriptions(config);
    }, window);
};

function get_input_by_value(node, value) {
    return node.one('input[value="'+value+'"]');
}

function set_checkboxes(node, all, checked) {
    // Clear all the checkboxes.
    Y.each(all, function (value) {
            get_input_by_value(node, value).set('checked', false);
    });
    // Check the checkboxes that are supposed to be checked.
    Y.each(checked, function (value) {
        get_input_by_value(node, value).set('checked', true);
    });
}

function set_options(node, name, value) {
    var select = node.one('select[name="team"]');
    Y.each(select.get('options'), function (option) {
            option.set('selected', option.get('value')==value);
        });
}

function set_radio_buttons(node, all, value) {
    set_checkboxes(node, all, [value]);
}

function set_recipient(node, is_team, team_link) {
    get_input_by_value(node, 'user').set('checked', !is_team);
    get_input_by_value(node, 'team').set('checked', is_team);
    // TODO why the team title, shouldn't it be the value?
    set_options(node, 'teams', team_link);
}

function make_edit_handler(filter, subscriber_is_team, team_link, config) {
    return function(e) {
        // Only proceed if the form content is already available.
        if (add_subscription_overlay) {
            e.preventDefault();

            // TODO fill in the rest of the form values
            var content_node = Y.one(config.content_box);
            set_recipient(
                content_node, subscriber_is_team, team_link);
            content_node.one('[name="name"]').set('value',
                filter.description);
            set_checkboxes(
                content_node,
                LP.cache['statuses'],
                filter.statuses);
            set_checkboxes(
                content_node,
                LP.cache['importances'],
                filter.importances);

            add_subscription_overlay.show();
        }
    };
}

function wire_up_edit_links(config) {
    var listing = Y.one('#subscription-listing');
    var subscription_info = LP.cache['subscription_info'];

    for (i in subscription_info) {
        var sub = subscription_info[i];
        var link_id = 0;
        for (j in sub.filters) {
            var filter = sub.filters[j].filter;
            var subscriber_is_team = sub.filters[j].subscriber_is_team;
            var team_link = sub.filters[j].subscriber_link;
            var edit_link = Y.one('#edit-'+link_id.toString());
            var edit_handler = make_edit_handler(
                filter, subscriber_is_team, team_link, config);
            edit_link.on('click', edit_handler);
            link_id += 1;
        }
    }
}

function fill_in_bug_subscriptions(config) {
    validate_config(config);

    var listing = Y.one('#subscription-listing');
    var subscription_info = LP.cache['subscription_info'];
    var html = '<div class="yui-g"><div id="structural-subscriptions">';

    for (i in subscription_info) {
        var sub = subscription_info[i];
        var link_id = 0;
        html +=
            '<div style="margin-top: 2em; padding: 0 1em 1em 1em; '+
            '      border: 1px solid #ddd;">'+
            '  <span style="float: left; margin-top: -0.6em; padding: 0 1ex;'+
            '      background-color: #fff;">Subscriptions to'+
            '    <a href="'+sub.target_url+'">'+sub.target_title+'</a>'+
            '  </span>'+
            '  <div style="margin: 1em 0em 0em 1em">';

        for (j in sub.filters) {
            var filter = sub.filters[j].filter;

            if (filter.description) {
                var description = '"'+filter.description+'"';
            } else {
                var description = '(unnamed)';
            }

            html += '<div style="margin-top: 1em"><strong>';
            if (sub.filters[j].subscriber_is_team) {
                html += sub.filters[j].subscriber_title +
                    " subscription: " + description;
            } else {
                html += 'Your subscription: ' + description;
            }

            html += '</strong><span style="float: right">'+
                '<a href="#" class="sprite modify edit js-action"'+
                '    id="edit-'+link_id.toString()+'">'+
                '  Edit this subscription</a> or '+
                '<a href="#" class="sprite modify remove js-action"'+
                '    id="unsubscribe-'+link_id.toString()+'">'+
                '  Unsubscribe</a></span></div>'+
                '<div style="padding-left: 1em">';

            var filter_items = '';
            // Format status conditions.
            if (filter.statuses.length != 0) {
                filter_items += '<li> have status ' +
                    filter.statuses.join(', ');
            }

            // Format importance conditions.
            if (filter.importances.length != 0) {
                filter_items += '<li> are of importance ' +
                    filter.importances.join(', ');
            }

            // Format tag conditions.
            if (filter.tags.length != 0) {
                filter_items += '<li> is tagged with ';
                if (filter.find_all_tags) {
                    filter_items += '<strong>all</strong>';
                } else {
                    filter_items += '<strong>any</strong>';
                }
                filter_items += ' of these tags: ' +
                    filter.tags.join(', ');
            }

            // If there were any conditions to list, stich them in with an
            // intro.
            if (filter_items != '') {
                html += 'You are subscribed to bugs which:'+
                    '<ul class="bulleted">'+filter_items+'</ul>';
            }

            // Format event details.
            if (filter.bug_notification_level == 'Discussion') {
                html += 'You will recieve an email when any change '+
                    'is made or a comment is added.';
            } else if (filter.bug_notification_level == 'Details') {
                html += 'You will recieve an email when any changes '+
                    'are made to the bug.  Bug comments will not be sent.';
            } else if (filter.bug_notification_level == 'Lifecycle') {
                html += 'You will recieve an email when bugs are '+
                    'opened or closed.';
            }

            html += '</div>';
            link_id += 1;
        }

        // We can remove this once we enforce at least one filter per
        // subscription.
        if (subscription_info[i].filters.length == 0) {
            html += '<strong>All messages</strong>';
        }
        html += '</div></div>';
    }
    html += '</div></div>';
    listing.appendChild(Y.Node.create(html));

    wire_up_edit_links(config);
}

function validate_config(config) {
    if (! Y.Lang.isValue(config)) {
        throw new Error(
            'Missing config for structural_subscription.');
    }
    if (!Y.Lang.isValue(config.content_box)) {
            throw new Error(
                'Structural_subscription configuration has ' +
                'undefined properties.');
    }
}

/*
 * External entry point for configuring the structual subscription.
 * @method setup
 * @param {Object} config Object literal of config name/value pairs.
 *     config.content_box is the name of an element on the page where
 *         the overlay will be anchored.
 */
namespace.setup = function(config) {
    validate_config(config);

    if (Y.UA.ie) {
        return;
    }

    // If the user is not logged in, then we need to defer to the
    // default behaviour.
    if (LP.links.me === undefined) {
        return;
    }
    if (Y.Lang.isValue(config.lp_client)) {
        // Tests can specify an lp_client if they want to.
        namespace.lp_client = config.lp_client;
    } else {
        // Setup the Launchpad client.
        setup_client();
    }
    // Create the overlay.
    var overlay_id = setup_overlay(config.content_box);
    // Create the subscription links on the page.
    setup_subscription_links(overlay_id, config.content_box);

    var submit_button = Y.Node.create(
        '<input type="submit" name="field.actions.create" ' +
        'value="Create Subscription"/>');
    create_overlay(config.content_box, overlay_id, submit_button,
        save_subscription);

};               // setup

}, '0.1', {requires: [
        'dom', 'node', 'lazr.formoverlay', 'lazr.overlay', 'lazr.effects',
        'lp.client', 'gallery-accordion'
    ]});
