Batch Navigation
================

Batch navigation provides a way to navigate batch results in a web
page by providing URL links to the next, previous and numbered pages
of results.

Imports:

  >>> from canonical.launchpad.webapp.batching import BatchNavigator
  >>> from canonical.launchpad.webapp.servers import LaunchpadTestRequest

  >>> def build_request(arg=None):
  ...   # XXX: this is a big fat hack; see bug XXX for details 
  ...   #      -- kiko, 2006-03-13
  ...   if arg is None:
  ...       arg = {}
  ...   else:
  ...       query = "&".join(["%s=%s" % (k,v) for k,v in arg.items()])
  ...       arg["QUERY_STRING"] = query
  ...   request = LaunchpadTestRequest(SERVER_URL='http://www.example.com/foo',
  ...                                  environ=arg)
  ...   return request

A dummy request object:

Some sample data.

  >>> reindeer = ['Dasher', 'Dancer', 'Prancer', 'Vixen', 'Comet',
  ...     'Cupid', 'Donner', 'Blitzen', 'Rudolph']

You can create a batch and a batch navigator like so:

  >>> reindeer_batch_navigator = BatchNavigator(
  ...     reindeer, build_request(), size=3)

You can ask the navigator for the chunk of results currently being shown (e.g.
to iterate over them for rendering in ZPT):

  >>> list(reindeer_batch_navigator.currentBatch())
  ['Dasher', 'Dancer', 'Prancer']

You can ask for the previous and next results' links:

  >>> reindeer_batch_navigator.prevBatchURL()
  ''
  >>> reindeer_batch_navigator.nextBatchURL()
  'http://www.example.com/foo?start=3'

The next link will be empty when there are no further results:

  >>> request = build_request({"start": "3", "batch": "20"})
  >>> last_reindeer_batch_navigator = BatchNavigator(reindeer, request=request)
  >>> last_reindeer_batch_navigator.nextBatchURL()
  ''

The previous link should appear even when we start at a point between 0
and the batch size:

  >>> request = build_request({"start": "2", "batch": "3"})
  >>> last_reindeer_batch_navigator = BatchNavigator(reindeer, request=request)
  >>> last_reindeer_batch_navigator.prevBatchURL()
  'http://www.example.com/foo?start=0&batch=3'

This all works with query strings in the URLs, too:

  >>> request = build_request({'fnorb': 'bar',
  ...                          'start': '3',
  ...                          'batch': '3'})
  >>> reindeer_batch_navigator_with_qs = BatchNavigator(
  ...     reindeer, request, size=3)
  >>> reindeer_batch_navigator_with_qs.prevBatchURL()
  'http://www.example.com/foo?fnorb=bar&start=0'
  >>> reindeer_batch_navigator_with_qs.nextBatchURL()
  'http://www.example.com/foo?fnorb=bar&start=6'

Finally, you can ask for the links for each of the result pages:

  >>> links = reindeer_batch_navigator.batchPageURLs()
  >>> for link in links:
  ...     label, url = link.items()[0]
  ...     print label, url
  [1] http://www.example.com/foo?start=0
  2 http://www.example.com/foo?start=3
  3 http://www.example.com/foo?start=6
  _last_ http://www.example.com/foo?start=6

Empty Batches
-------------

You can also create an empty batch that will not have any items:

  >>> null_batch_navigator = BatchNavigator(
  ...     None, build_request(), size=3)
  >>> null_batch_navigator.nextBatchURL()
  ''
  >>> null_batch_navigator.prevBatchURL()
  ''

  >>> null_batch_navigator = BatchNavigator(
  ...     [], build_request(), size=3)
  >>> null_batch_navigator.nextBatchURL()
  ''
  >>> null_batch_navigator.prevBatchURL()
  ''

TODO:

  - blowing up when start is beyond end
  - orphans
  - overlap

Performance with SQLObject
--------------------------

This section demonstrates that batching generates sensible SQL queries when used
with SQLObject, i.e. that it puts appropriate LIMIT clauses on queries.

Imports and database setup:

  >>> from canonical.launchpad.ftests.harness import LaunchpadTestSetup
  >>> from canonical.launchpad.database import EmailAddress
  >>> from canonical.ftests.pgsql import CursorWrapper
  >>> LaunchpadTestSetup().setUp()
  >>> CursorWrapper.record_sql = True

Prepare a query, and create a batch of the results:

  >>> select_results = EmailAddress.select(orderBy='id')
  >>> batch_nav = BatchNavigator(select_results, build_request(),
  ...                            size=10)
  >>> email_batch = batch_nav.currentBatch()
  >>> batch_items = list(email_batch)

Because we're only looking at the first batch, the database is only asked for
the number of rows, and the first 10 rows:

  >>> len(CursorWrapper.last_executed_sql)
  2
  >>> print CursorWrapper.last_executed_sql[0]
  SELECT COUNT(*) FROM EmailAddress WHERE 1 = 1
  >>> CursorWrapper.last_executed_sql[1].endswith('LIMIT 10')
  True

Get the next 10.  The database is only asked for the next 10 rows -- no further
COUNTs are issued:

  >>> CursorWrapper.last_executed_sql = []
  >>> email_batch2 = email_batch.nextBatch()
  >>> batch_items = list(email_batch2)
  >>> len(CursorWrapper.last_executed_sql)
  1
  >>> CursorWrapper.last_executed_sql[0].endswith('LIMIT 10 OFFSET 10')
  True

  >>> LaunchpadTestSetup().tearDown()

