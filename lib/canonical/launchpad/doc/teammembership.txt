= Team Membership/Participation =

When a person joins a team, we store the relationship in the TeamMembership
table. In this table we store the membership status, the join date and the
expiry date. TeamMembership stores only direct members. However, when a 
member of a team is in fact another team (in the case of Team Y is a member
of Team X), the membership is transitive (members of Team Y are also a 
member of team X). For this reason the TeamParticipation table exists: it
represents all the people who are /effective members/ of the team.

First of all, create some teams:

    >>> import pytz
    >>> from datetime import datetime, timedelta
    >>> from canonical.lp.dbschema import (
    ...     TeamSubscriptionPolicy, TeamMembershipStatus)

XXX: This doctest needs a lot of cleanups!
-- Guilherme Salgado, 2006-12-15

    >>> from zope.component import getUtility
    >>> from canonical.launchpad.interfaces import IPersonSet
    >>> personset = getUtility(IPersonSet)
    >>> foobar = personset.getByName('name16')
    >>> reviewer = foobar
    >>> t1 = personset.newTeam(
    ...     foobar, 't1', 't1',
    ...     subscriptionpolicy=TeamSubscriptionPolicy.OPEN)
    >>> t2 = personset.newTeam(
    ...     foobar, 't2', 't2',
    ...     subscriptionpolicy=TeamSubscriptionPolicy.OPEN)
    >>> t3 = personset.newTeam(
    ...     foobar, 't3', 't3',
    ...     subscriptionpolicy=TeamSubscriptionPolicy.MODERATED)
    >>> t4 = personset.newTeam(
    ...     foobar, 't4', 't4',
    ...     subscriptionpolicy=TeamSubscriptionPolicy.OPEN)
    >>> t5 = personset.newTeam(
    ...     foobar, 't5', 't5',
    ...     subscriptionpolicy=TeamSubscriptionPolicy.OPEN)

== Adding new members ==

One way of adding new members to a team is by having the user himself join the
team he wants.

    >>> salgado = personset.getByName('salgado')
    >>> salgado.join(t3)
    >>> salgado.join(t4)

Note that since t3 is a MODERATED team, Salgado is not really added as a
member of that team --somebody has to approve his membership first:

    >>> [m.displayname for m in t4.allmembers]
    [u'Foo Bar', u'Guilherme Salgado']

    >>> [m.displayname for m in t3.allmembers]
    [u'Foo Bar']
    >>> t3.setMembershipData(salgado, TeamMembershipStatus.APPROVED, reviewer)
    >>> [m.displayname for m in t3.allmembers]
    [u'Foo Bar', u'Guilherme Salgado']

The join() method is not allowed for teams whose subscription policy is
RESTRICTED. And it'll be a no-op in case the user has already joined the
given team.

    >>> launchpad = personset.getByName('launchpad')
    >>> launchpad.subscriptionpolicy == TeamSubscriptionPolicy.RESTRICTED
    True
    >>> salgado.join(launchpad)
    Traceback (most recent call last):
    ...
    JoinNotAllowed: This is a restricted team

    >>> salgado.join(t3)
    >>> salgado in t3.activemembers
    True
    >>> salgado.join(t4)
    >>> salgado in t4.activemembers
    True

Also note that the join() method must only be called from an person object;
never from a team, because teams can't perform actions in launchpad, so it
doesn't make sense to have a team joining another one. (Hint: see below a way
to add a team as a member of another one)

    >>> t2.join(t3)
    Traceback (most recent call last):
    ...
    AssertionError: Teams take no actions in Launchpad...

Another API for adding members is ITeam.addMember(), which ensures the given
person has a membership entry for that team, regardless of whether the person
was already an active/inactive member or has never been a member before.

    >>> sabdfl = personset.getByName('sabdfl')
    >>> t2.addMember(t3, reviewer=sabdfl)

    >>> t3.addMember(
    ...     salgado, reviewer=sabdfl, status=TeamMembershipStatus.ADMIN)
    >>> from canonical.database.sqlbase import flush_database_updates
    >>> from canonical.launchpad.interfaces import ITeamMembershipSet
    >>> membershipset = getUtility(ITeamMembershipSet)
    >>> flush_database_updates()
    >>> membership = membershipset.getByPersonAndTeam(salgado, t3)
    >>> membership.reviewer == sabdfl
    True
    >>> membership.status == TeamMembershipStatus.ADMIN
    True
    >>> salgado in t3.activemembers
    True

    >>> marilize = personset.getByName('marilize')
    >>> t3.addMember(
    ...     marilize, reviewer=sabdfl, status=TeamMembershipStatus.PROPOSED)
    >>> flush_database_updates()
    >>> marilize in t3.activemembers
    False

By making t3 a member of t2, it means that all members of t3 will also be
added as members of t2.

    >>> [m.displayname for m in t2.allmembers]
    [u'Foo Bar', u'Guilherme Salgado', u't3']

Can we add t2 as a member of t3? No, we prevent this kind of loop, and users
can't do this because our vocabularies won't allow members that would cause
loops.

    >>> t3.addMember(t2, reviewer)
    Traceback (most recent call last):
    ...
    AssertionError: Team 't3' is a member of 't2'. As a consequence, 't2' can't be added as a member of 't3'

Adding t2 as a member of t1 will add all t2 members as t1 members too.

    >>> t1.addMember(t2, reviewer)
    >>> [m.displayname for m in t1.allmembers]
    [u'Foo Bar', u'Guilherme Salgado', u't2', u't3']

Adding t2 as a member of t5 will add all t2 members as t5 members too.

    >>> t5.addMember(t2, reviewer)
    >>> [m.displayname for m in t5.allmembers]
    [u'Foo Bar', u'Guilherme Salgado', u't2', u't3']

Adding t5 and t1 as members of t4 will add all t5 and t1 members as t4 
members too.

    >>> t4.addMember(t5, reviewer)
    >>> t4.addMember(t1, reviewer)
    >>> [m.displayname for m in t4.allmembers]
    [u'Foo Bar', u'Guilherme Salgado', u't1', u't2', u't3', u't5']

    >>> flush_database_updates()

After adding all this mess, this is what we have:

(This table doesn't include the team owner (Foo Bar), but since he's the
owner he's also a direct member of all teams)
=============================================================
||  Team      ||  Direct Members   ||  Indirect Members    ||
=============================================================
||   T1       ||  T2               ||  T3, Salgado         ||
||   T2       ||  T3               ||  Salgado             ||
||   T3       ||  Salgado          ||                      ||
||   T4       ||  T5, T1, Salgado  ||  T2, T3              ||
||   T5       ||  T2               ||  T3, Salgado         ||


We can use IPerson.findPathToTeam() to check some of the relationships drawn
above. Note that because of https://launchpad.net/bugs/30789 we can't use it
to check the path from a team to another one.

    >>> [team.name for team in salgado.findPathToTeam(t1)]
    [u't3', u't2', u't1']
    >>> [team.name for team in salgado.findPathToTeam(t5)]
    [u't3', u't2', u't5']
    >>> [team.name for team in salgado.findPathToTeam(t3)]
    [u't3']


t2 can't use its leave() method to leave t5 because it's a team and teams
take no actions. One of t5 administrators have to go and remove t2 from t5
if t2 shouldn't be a member of t5 anymore.

    >>> t5.setMembershipData(t2, TeamMembershipStatus.DEACTIVATED, reviewer)

Removing t2 from t5 will have implications in all teams that have t5 as a
(direct or indirect) member.

t5 had only one member and two other indirect members. Now that t2 is not its
member anymore, it doesn't have any members apart from its owner.

    >>> [m.displayname for m in t5.allmembers]
    [u'Foo Bar']

Removing t2 from t5 won't remove it from t4, because t2 is also a member of
t1, which is a member of t4.
    >>> [m.displayname for m in t4.allmembers]
    [u'Foo Bar', u'Guilherme Salgado', u't1', u't2', u't3', u't5']

Nothing changes in t1, because t5 wasn't one of its members.
    >>> [m.displayname for m in t1.allmembers]
    [u'Foo Bar', u'Guilherme Salgado', u't2', u't3']

If 'Guilherme Salgado' decides to leave t3, he'll also be removed from t1
and t2, but not from t4, because he's a direct member of t4.
    >>> salgado.leave(t3)
    >>> salgado in t1.allmembers
    False
    >>> salgado in t2.allmembers 
    False
    >>> salgado in t4.allmembers
    True


This is what we have now, after removing t2 from t5 and Salgado from t3.

(This table doesn't include the team owner (Foo Bar), but since he's the
owner he's also a direct member of all teams)
=============================================================
||  Team      ||  Members          ||  Indirect Members    ||
=============================================================
||   T1       ||  T2               ||  T3                  ||
||   T2       ||  T3               ||                      ||
||   T3       ||                   ||                      ||
||   T4       ||  T5, T1, Salgado  ||  T2, T3              ||
||   T5       ||                   ||                      ||


Now, if I add a new member to t3, will it be added to t2, t1 and t4 as well?
Let's see...

    >>> cprov = getUtility(IPersonSet).getByName('cprov')
    >>> t3.addMember(cprov, reviewer)
    >>> [m.displayname for m in t3.allmembers]
    [u'Celso Providelo', u'Foo Bar']

    >>> [m.displayname for m in t2.allmembers]
    [u'Celso Providelo', u'Foo Bar', u't3']

    >>> [m.displayname for m in t1.allmembers]
    [u'Celso Providelo', u'Foo Bar', u't2', u't3']

    >>> [m.displayname for m in t4.allmembers]
    [u'Celso Providelo', u'Foo Bar', u'Guilherme Salgado', u't1', u't2',
     u't3', u't5']


It's important to note that even if Foo Bar leaves the team he's the owner,
he'll retains his rights over the team because he's the team's owner. This
ensures we'll never have teams which can't be managed.

    >>> foobar.leave(t5)
    >>> flush_database_updates()
    >>> [m.displayname for m in t5.allmembers]
    []
    >>> foobar.inTeam(t5)
    True


== Changing membership statuses ==

TeamMembership.status is a read only attribute, so all status changes must be
made using the setStatus() method.

    # Foo Bar is a launchpad admin, but even so he can't change a membership's
    # status by hand.
    >>> from canonical.launchpad.ftests import login
    >>> login('foo.bar@canonical.com')
    >>> membership = foobar.myactivememberships[0]
    >>> membership.status = None
    Traceback (most recent call last):
    ...
    ForbiddenAttribute: ...

Foo Bar asked to join Warty Security Team on 2006-01-26 and he's been doing
good work, so we'll approve his membership.

    >>> warty_team = getUtility(IPersonSet).getByName('name20')
    >>> membership = membershipset.getByPersonAndTeam(foobar, warty_team)
    >>> print membership.status.title
    Proposed
    >>> print membership.datejoined.strftime("%Y-%m-%d")
    2006-01-26

When we approve his membership, the datejoined will contain the date that it
was approved.

    >>> membership.setStatus(TeamMembershipStatus.APPROVED, reviewer=foobar)
    >>> print membership.status.title
    Approved
    >>> utc_now = datetime.now(pytz.timezone('UTC'))
    >>> membership.datejoined.date() == utc_now.date()
    True 

On the other hand, when we deactivate an active membership, the datejoined is
not changed.

    >>> buildd_admins = getUtility(IPersonSet).getByName(
    ...     'launchpad-buildd-admins')
    >>> membership = membershipset.getByPersonAndTeam(foobar, buildd_admins)
    >>> print membership.status.title
    Administrator
    >>> print membership.datejoined.strftime("%Y-%m-%d")
    2006-05-15

    >>> membership.setStatus(TeamMembershipStatus.DEACTIVATED, reviewer=foobar)
    >>> print membership.status.title
    Deactivated
    >>> print membership.datejoined.strftime("%Y-%m-%d")
    2006-05-15

Finally, if we reactivate his membership, the datejoined will once again be
updated.

    >>> membership.setStatus(TeamMembershipStatus.APPROVED, reviewer=foobar)
    >>> print membership.status.title
    Approved
    >>> membership.datejoined.date() == utc_now.date()
    True 


== Flagging expired memberships ==

The expired memberships are flagged by a cronscript that runs daily. This
script simply flags all active memberships which reached their expiry date as
expired.

To find out which memberships are already expired, we use
TeamMembershipSet.getMembershipsToExpire(). As you can see, we don't have any
membership to expire right now.

    >>> [(membership.person.name, membership.team.name)
    ...  for membership in membershipset.getMembershipsToExpire()]
    []

Let's change the expiry date of an active membership, so we have something
that should be expired.

    >>> foobar_on_admins = membershipset.getByPersonAndTeam(
    ...     personset.getByName('name16'), personset.getByName('admins'))
    >>> foobar_on_admins.dateexpires is None
    True
    >>> foobar_on_admins.status.title
    'Administrator'
    >>> login('foo.bar@canonical.com')
    >>> one_day_ago = datetime.now(pytz.timezone('UTC')) - timedelta(days=1)
    >>> foobar_on_admins.dateexpires = one_day_ago
    >>> flush_database_updates()

    >>> [(membership.person.name, membership.team.name)
    ...  for membership in membershipset.getMembershipsToExpire()]
    [(u'name16', u'admins')]

And here we change the expiry date of a membership that's already
deactivated, so it should not be flagged as expired.

    >>> sp_on_ubuntu_translators = membershipset.getByPersonAndTeam(
    ...     personset.getByName('name12'),
    ...     personset.getByName('ubuntu-translators'))
    >>> sp_on_ubuntu_translators.dateexpires is None
    True
    >>> sp_on_ubuntu_translators.status.title
    'Deactivated'
    >>> sp_on_ubuntu_translators.dateexpires = one_day_ago
    >>> flush_database_updates()

    >>> [(membership.person.name, membership.team.name)
    ...  for membership in membershipset.getMembershipsToExpire()]
    [(u'name16', u'admins')]

The getMembershipsToExpire() method also accepts an optional 'when' argument.
When that argument is provided, we get the memberships that are supposed to
expire on that date or before.

    >>> sabdfl_on_ubuntu_team = membershipset.getByPersonAndTeam(
    ...     personset.getByName('sabdfl'),
    ...     personset.getByName('ubuntu-team'))
    >>> sabdfl_on_ubuntu_team.dateexpires is not None
    True
    >>> sabdfl_on_ubuntu_team.status.title
    'Administrator'

    >>> when = sabdfl_on_ubuntu_team.dateexpires + timedelta(days=1)
    >>> [(membership.person.name, membership.team.name)
    ...  for membership in membershipset.getMembershipsToExpire(when=when)]
    [(u'sabdfl', u'ubuntu-team'), (u'name16', u'admins'),
     (u'ubuntu-team', u'guadamen')]

Now we commit the changes and run the cronscript.
XXX: flush_database_updates() shouldn't be needed. This seems to be
Bug 3989 -- StuarBishop 20060713

    >>> flush_database_updates()
    >>> transaction.commit()

    >>> import subprocess
    >>> process = subprocess.Popen(
    ...     'cronscripts/flag-expired-memberships.py -q', shell=True,
    ...     stdin=subprocess.PIPE, stdout=subprocess.PIPE, 
    ...     stderr=subprocess.PIPE)
    >>> (out, err) = process.communicate()
    >>> out, err
    ('', '')
    >>> process.returncode
    0

Here we can see that the membership that was active is now flagged as expired
while the one that was inactive hasn't changed.

    # These two objects were updated in another transaction, so we need to
    # expire them.
    >>> from zope.security.proxy import removeSecurityProxy
    >>> removeSecurityProxy(foobar_on_admins).expire()
    >>> removeSecurityProxy(sp_on_ubuntu_translators).expire()

    >>> foobar_on_admins = membershipset.getByPersonAndTeam(
    ...     personset.getByName('name16'), personset.getByName('admins'))
    >>> foobar_on_admins.status.title
    'Expired'
    >>> foobar_on_admins.reviewer.name
    u'team-membership-janitor'

    >>> sp_on_ubuntu_translators = membershipset.getByPersonAndTeam(
    ...     personset.getByName('name12'),
    ...     personset.getByName('ubuntu-translators'))
    >>> sp_on_ubuntu_translators.status.title
    'Deactivated'


== Querying team memberships ==

You can check a person's direct memberships by using myactivememberships:

    >>> [(membership.team.name, membership.status.title)
    ...  for membership in salgado.myactivememberships]
    [(u'admins', 'Administrator'), (u't4', 'Approved')]

And you can check which direct memberships a team has by using activememberships:

    >>> [(membership.person.name, membership.status.title)
    ...  for membership in t3.activememberships]
    [(u'cprov', 'Approved'), (u'name16', 'Administrator')]

A team has a number of other methods that return the people which are members
of it, all based on Person.getMembersByStatus:

    >>> [person.unique_displayname for person in t3.approvedmembers]
    [u'Celso Providelo (cprov)']

(which is the same as saying

    >>> [person.unique_displayname
    ...  for person in t3.getMembersByStatus(TeamMembershipStatus.APPROVED)]
    [u'Celso Providelo (cprov)']

except shorter)

We can also change the sort order of the results of getMembersByStatus.

    >>> cprov.leave(t3)
    >>> flush_database_updates()

    >>> deactivated = TeamMembershipStatus.DEACTIVATED
    >>> [person.unique_displayname
    ...  for person in t3.getMembersByStatus(deactivated)]
    [u'Celso Providelo (cprov)', u'Guilherme Salgado (salgado)']

    >>> orderBy = '-TeamMembership.datejoined'
    >>> [person.unique_displayname
    ...  for person in t3.getMembersByStatus(deactivated, orderBy=orderBy)]
    [u'Guilherme Salgado (salgado)', u'Celso Providelo (cprov)']

Another convenient method is getEffectiveAdministrators(), which returns the
admin members plus the owner in case he is not one of the admin members.

    >>> [admin.unique_displayname for admin in t3.adminmembers]
    [u'Foo Bar (name16)']
    >>> list(t3.getEffectiveAdministrators()) == list(t3.adminmembers)
    True

    >>> shipit_admins = personset.getByName('shipit-admins')
    >>> shipit_admins.adminmembers.count() == 0
    True
    >>> owner = shipit_admins.teamowner
    >>> list(shipit_admins.getEffectiveAdministrators()) == [owner]
    True
    
== Querying a person for team participation ==

Team membership is direct; team participation is indirect, people being
participants of teams by virtue of being members of other teams which are in
turn members of these teams.

We can ask a person what teams they participate in. The
teams_participated_in attribute works recursively, listing all teams the
person is an active member of as well as teams those teams are an active
member of.

    >>> print '\n'.join(team.name for team in salgado.teams_participated_in)
    admins
    t4

Adding admins as a member of t1 will make Salgado a member of t1 as well.

    >>> admins = getUtility(IPersonSet).getByName('admins')
    >>> t1.addMember(admins, reviewer=t1.teamowner)
    >>> flush_database_updates()
    >>> print '\n'.join(team.name for team in salgado.teams_participated_in)
    admins
    t1
    t4

On the other hand, making t2 a member of admins won't change anything
for Salgado.

    >>> admins.addMember(t2, reviewer=admins.teamowner)
    >>> flush_database_updates()
    >>> print '\n'.join(team.name for team in salgado.teams_participated_in)
    admins
    t1
    t4

