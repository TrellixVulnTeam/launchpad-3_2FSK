Memcache with TALES
===================

We have extended TALES with a cache: expression to allow chunks of
rendered page templates to be cached in Memcached.


    >>> template = TestPageTemplate(dedent("""\
    ...     <div tal:content="cache:public">
    ...         <span tal:content="param">placeholder</span>
    ...     </div>"""))


The first time we render the page template, there is no information
in the cache. The cachable section is interpreted and stored in the cache
for next time.

    >>> print template(param='first')
    <div>
        <span>first</span>
    </div>


The second time we render the page template, the cached information
is used. We prove this here by changing our parameters, which would
cause this template to render differently.

    >>> print template(param='second')
    <div><!-- Cache hit: memcache expression (public) -->
        <span>first</span>
    <!-- End cache hit: memcache expression (public) --></div>

We also see some comments showing that we had a cache hit, and what the
configuration was for it ("public").  These comments are only present
when Launchpad's config is not configured as edge or production (``is_edge``
or ``is_lpnet``, respectively).

If we clear the cache, it will be rendered as expected.

    >>> MemcachedLayer.purge()
    >>> print template(param='third')
    <div>
        <span>third</span>
    </div>


Expiry
------

We can specify how long cached information is considered valid. If
this is not set, the information may be cached indefinitely. Note
that memcache may evict information sooner if it runs low on storage
space.

One interesting technique is to specify a lengthy expiry, but to
refresh the information asynchronously using an AJAX request. This
is good enough for bots and improves the initial page load time, but
care will be needed to avoid 'popping'.

    >>> template = TestPageTemplate(dedent("""\
    ...     <body tal:omit-tag="">
    ...         <div tal:content="cache:public,30 seconds" tal:omit-tag="">
    ...             This bit cached up to 30 seconds.
    ...         </div>
    ...         <div tal:content="cache:public,1 minute" tal:omit-tag="">
    ...             This bit cached up to 1 minute.
    ...         </div>
    ...         <div tal:content="cache:public,6 hours" tal:omit-tag="">
    ...             This bit cached up to 6 hours.
    ...         </div>
    ...         <tal:cached content="cache:public,3 days">
    ...             This bit cached up to 3 days.
    ...         </tal:cached>
    ...     </body>"""))
    >>> print template()
    This bit cached up to 30 seconds.
    This bit cached up to 1 minute.
    This bit cached up to 6 hours.
    This bit cached up to 3 days.


Visibility
----------

We define 4 different types of 'visibility':

    public

        The cached information is shared by everyone. These sections
        should not be personalized. They can contain private information
        if the page itself is protected.

    private

        Unauthenticated users share cached information, but
        authenticated users do not share with anyone else. A list on a
        publicly accessible page that might contain private information
        should use this visibility.

    anonymous

        Unauthenticated users share cached information, but
        authenticated users do not use the cache at all. This can
        be used to feed bots cached information quicky, while giving
        authenticated users up to date information. In practice, this
        might not make much difference as reverse proxies should
        already be caching the entire page for unauthenticated users.

    authenticated

        Unauthenticated users share cached information, and all
        authenticated users share a different cache. This is used
        when information is being hidden from unauthenticated users,
        for example when we hide email addresses from unauthenticated
        users to help protect against email address harvesters.

    >>> template = TestPageTemplate(dedent("""\
    ...     <div tal:omit-tag="">
    ...         <tal:cache content="cache:public">
    ...             Public: <tal:x content="username" />
    ...         </tal:cache>
    ...         <tal:cache content="cache:private">
    ...             Private: <tal:x content="username" />
    ...         </tal:cache>
    ...         <tal:cache content="cache:anonymous">
    ...             Anonymous: <tal:x content="username" />
    ...         </tal:cache>
    ...         <tal:cache content="cache:authenticated">
    ...             Authenticated: <tal:x content="username" />
    ...         </tal:cache>
    ...     </div>"""))

Here we populate all caches.

    >>> login(ANONYMOUS)
    >>> print template(username="Anonymous")
    Public:        Anonymous
    Private:       Anonymous
    Anonymous:     Anonymous
    Authenticated: Anonymous

Here we reuse the public cache, populate foo's private cache,
and populate the authenticated cache. The anonymous section is
uncached.

    >>> login('foo.bar@canonical.com')
    >>> print template(username='Foo Bar')
    <!-- Cache hit: memcache expression (public) -->
    Public:        Anonymous
    <!-- End cache hit: memcache expression (public) -->
    Private:       Foo Bar
    Anonymous:     Foo Bar
    Authenticated: Foo Bar

Here we reuse the public cache, populate test's private cache, and
reuse the authenticated cache. The anonymous section is uncached.

    >>> login('test@canonical.com')
    >>> print template(username='Test')
    <!-- Cache hit: memcache expression (public) -->
    Public:        Anonymous
    <!-- End cache hit: memcache expression (public) -->
    Private:       Test
    Anonymous:     Test
    <!-- Cache hit: memcache expression (authenticated) -->
    Authenticated: Foo Bar
    <!-- End cache hit: memcache expression (authenticated) -->


Nesting & Loops
---------------

Cached chunks can contain other cached chunks, useful for specifying
different timeouts of different visibilities.

We will disable the cache hit comments by claiming to be in production.

    >>> from canonical.config import config
    >>> original_instance_name = config.instance_name
    >>> config.push('is_production', """
    ...     [launchpad]
    ...     is_lpnet: True
    ... """)
    >>> template = TestPageTemplate(dedent("""\
    ...     <body tal:content="cache:private,25 seconds" tal:omit-tag="">
    ...         This bit is private to <span tal:replace="username" />
    ...         and cached up to 25 seconds, but contains
    ...         <span tal:content="cache:public,3 days" tal:omit-tag="">
    ...             this bit cached by <span tal:replace="username" />
    ...             which is public and cached up to 3 days.
    ...         </span>
    ...     </body>"""))

    >>> login('foo.bar@canonical.com')
    >>> print template(username="Foo Bar")
    This bit is private to Foo Bar and cached up to 25 seconds, but
    contains this bit cached by Foo Bar which is public and cached up
    to 3 days.

    >>> login('test@canonical.com')
    >>> print template(username="Test")
    This bit is private to Test and cached up to 25 seconds, but
    contains this bit cached by Foo Bar which is public and cached up
    to 3 days.


tal:repeat loops are fully supported. Each iteration of the loop gets
a different cache.

    >>> template = TestPageTemplate(dedent("""\
    ...     <body>
    ...         <div tal:repeat="i python:range(1,3)">
    ...             <div tal:replace="cache:public">
    ...                 <span tal:replace="param" />
    ...                 <span tal:replace="repeat/i/index" />
    ...             </div>
    ...         </div>
    ...     </body>"""))
    >>> print template(param='first')
    <body>
        <div> first 0 </div>
        <div> first 1 </div>
    </body>

    >>> print template(param='second')
    <body>
        <div> first 0 </div>
        <div> first 1 </div>
    </body>

Note that the default syntax isn't useful when you are looping over
a changeable list. For example, let's say we have a list of comments.
The basic syntax lets us cache the first comment, the second comment,
the third comment etc.

    >>> comments = ["Today's comment", "Yesterday's comment"]
    >>> template = TestPageTemplate(dedent("""\
    ...     <body>
    ...         <div tal:omit-tag="" tal:repeat="comment comments">
    ...             <div tal:replace="cache:public">
    ...                 <span tal:replace="comment" />
    ...             </div>
    ...         </div>
    ...     </body>"""))
    >>> print template(comments=comments)
    <body>
    Today's comment
    Yesterday's comment
    </body>

However, if we now insert a new comment at the front of the list, the
first comment has now become the second comment and our caches are
incorrect.

    >>> updated_comments = ['New comment'] + comments
    >>> print template(comments=updated_comments)
    <body>
    Today's comment
    Yesterday's comment
    Yesterday's comment
    </body>

To correct this, we need to manually specify part of the key using
a tales path expression. This path expression can be anything
that can be cast to a string.

    >>> template = TestPageTemplate(dedent("""\
    ...     <body>
    ...         <div tal:omit-tag="" tal:repeat="comment comments">
    ...             <div tal:replace="cache:
    ...                 public,1 hour,comment/comment_num">
    ...                 <span tal:replace="comment/comment" />
    ...             </div>
    ...         </div>
    ...     </body>"""))
    >>> comments = [
    ...     {'comment_num': 42, 'comment': "Today's comment"},
    ...     {'comment_num': 12, 'comment': "Yesterday's comment"}]
    >>> print template(comments=comments)
    <body>
    Today's comment
    Yesterday's comment
    </body>

    >>> comments.insert(0, {'comment_num': 'foo', 'comment': 'New comment'})
    >>> print template(comments=comments)
    <body>
    New comment
    Today's comment
    Yesterday's comment
    </body>

If we mutate the comments list without flushing the cache, we can
demonstrate that the cached values are being correctly used in the loop.

    >>> comments[2]['comment'] = 'Mutated comment'
    >>> print template(comments=comments)
    <body>
    New comment
    Today's comment
    Yesterday's comment
    </body>

    >>> MemcachedLayer.purge()
    >>> print template(comments=comments)
    <body>
    New comment
    Today's comment
    Mutated comment
    </body>

    >>> ignore = config.pop('is_production')

