= Code Import Machines =

There is a simple CodeImportMachine table in the database that records
the machines that can perform imports and whether they are online (that
is, currently capable of performing imports).

    >>> from canonical.launchpad.interfaces import (
    ...     ICodeImportMachine, ICodeImportMachineSet, CodeImportMachineState)


== Creating CodeImportMachine ==

Adding new machines is considered an admin task, so requires that we
switch to a database administrator.

Adding a machine is very simple SQL, for which there will probably be a
shell script.

    >>> from canonical.database.sqlbase import connect, quote
    >>> connection = connect('testadmin')
    >>> cur = connection.cursor()
    >>> cur.execute("""
    ...     INSERT INTO CodeImportMachine (hostname, state)
    ...     VALUES ('frobisher.example.com', %s)
    ...     """ % quote(CodeImportMachineState.OFFLINE))
    >>> connection.commit()


== Retrieving CodeImportMachine ==

The webapp only has rights to examine, not modify, the CodeImportMachine
table.  The table is represented by an utility that provides the
ICodeImportMachineSet interface.  Currently we hide all aspects of the
new system from anonymous and regular users.

    >>> machine_set = getUtility(ICodeImportMachineSet)
    >>> machine_set.getAll()
    Traceback (most recent call last):
      ...
    Unauthorized: ...

    >>> login('test@canonical.com')
    >>> machine_set = getUtility(ICodeImportMachineSet)
    >>> machine_set.getAll()
    Traceback (most recent call last):
      ...
    Unauthorized: ...

Once we've logged in as David Allouche, a member of vcs-imports, the
object that provides ICodeImportMachineSet allows access to machines by
hostname and to all machines.

    >>> login('david.allouche@canonical.com')
    >>> from canonical.launchpad.interfaces import ILaunchpadCelebrities
    >>> ddaa = getUtility(ILaunchBag).user
    >>> ddaa.inTeam(getUtility(ILaunchpadCelebrities).vcs_imports)
    True

    >>> machine_set = getUtility(ICodeImportMachineSet)
    >>> from canonical.launchpad.webapp.testing import verifyObject
    >>> from zope.security.proxy import removeSecurityProxy
    >>> verifyObject(ICodeImportMachineSet, removeSecurityProxy(machine_set))
    True
    >>> machine = machine_set.getByHostname('frobisher.example.com')
    >>> machine in machine_set.getAll()
    True

getByHostname returns None if there is no machine by that name in the
database.

    >>> print machine_set.getByHostname('unlikely.example.com')
    None

Machine objects themselves provide ICodeImportMachine, which includes
hostname and online state information.

    >>> verifyObject(ICodeImportMachine, removeSecurityProxy(machine))
    True
    >>> machine.hostname
    u'frobisher.example.com'
    >>> print machine.state.name
    OFFLINE


== Modifying CodeImportMachine ==

The web app cannot edit this information, because it does not have
UPDATE rights on the CodeImportMachine table.

    >>> from canonical.launchpad.interfaces import CodeImportMachineState
    >>> removeSecurityProxy(machine).state = CodeImportMachineState.ONLINE
    >>> removeSecurityProxy(machine).syncUpdate()
    Traceback (most recent call last):
      ...
    ProgrammingError: ERROR:  permission denied for relation codeimportmachine
    ...
    >>> from canonical.database.sqlbase import begin
    >>> begin()

Jobs running on the machine itself will connect as the 'importd' user,
which has rights to update the table so it can update the machine state.

    >>> from canonical.testing import LaunchpadZopelessLayer
    >>> LaunchpadZopelessLayer.switchDbUser('importd')

The importd database user is only used by zopeless scripts that run
under the PermissiveSecurityPolicy.

    >>> from zope.security.management import setSecurityPolicy
    >>> from zope.security.simplepolicies import PermissiveSecurityPolicy
    >>> _ = setSecurityPolicy(PermissiveSecurityPolicy)
    >>> login(ANONYMOUS)

Even scripts cannot directly set attributes of CodeImportMachine
objects. Instead, they must use methods that create the appropriate
CodeImportEvent records.

    >>> machine = machine_set.getByHostname('frobisher.example.com')
    >>> print machine.state.name
    OFFLINE
    >>> machine.state = CodeImportMachineState.ONLINE
    Traceback (most recent call last):
      ...
    ForbiddenAttribute: ...

The following helpers are useful to demonstrate that appropriate
CodeImportEvent objects are indeed created.

    >>> from canonical.launchpad.database import CodeImportEvent
    >>> 
    >>> def list_events_for_machine(machine):
    ...     """List all events for the given machine."""
    ...     return list(
    ...         CodeImportEvent.selectBy(machine=machine).orderBy(['id']))
    >>> 
    >>> def list_event_types_for_machine(machine):
    ...     """List the types of all events for the given machine."""
    ...     return [event.event_type.name
    ...             for event in list_events_for_machine(machine)]


=== setOnline ===

When a code-import-controller daemon starts, it must call the setOnline
method of its associated CodeImportMachine.

    >>> list_event_types_for_machine(machine)
    []
    >>> machine.setOnline()
    >>> print machine.state.name
    ONLINE
    >>> list_event_types_for_machine(machine)
    ['ONLINE']


=== setOffline ===

When a code-import-controller daemon stops, or when the watchdog detects
that it has not updated its heartbeat for some time, they must call the
setOffline method.

    >>> list_event_types_for_machine(machine)
    ['ONLINE']
    >>> from canonical.launchpad.interfaces import (
    ...     CodeImportEventDataType, CodeImportMachineOfflineReason)
    >>> machine.setOffline(CodeImportMachineOfflineReason.STOPPED)
    >>> print machine.state.name
    OFFLINE
    >>> list_event_types_for_machine(machine)
    ['ONLINE', 'OFFLINE']
    >>> OFFLINE_REASON = CodeImportEventDataType.OFFLINE_REASON
    >>> dict(list_events_for_machine(machine)[-1].items())[OFFLINE_REASON]
    u'STOPPED'

