Support Tracker Pages
=====================

Several views are used to handle the various operations on a ticket.

    >>> from zope.component import getView
    >>> from canonical.launchpad.webapp.servers import LaunchpadTestRequest
    >>> from canonical.launchpad.interfaces import (
    ...     IDistributionSet, IProductSet)
    >>> ubuntu = getUtility(IDistributionSet).getByName('ubuntu')
    >>> ticket_three = ubuntu.getTicket(3)
    >>> firefox = getUtility(IProductSet).getByName('firefox')
    >>> firefox_ticket = firefox.getTicket(2)

    (The firefox_ticket doesn't have any subscribers, let's subscribe
    the owner.)
    >>> login('test@canonical.com')
    >>> firefox_ticket.subscribe(firefox_ticket.owner)
    <TicketSubscription...>

    (Let's define a helper function which commits the transaction, so
    that the notifications are queued in stub.test_emails and pops these
    notifications from the queue.)
    >>> from canonical.launchpad.mail import stub
    >>> import email
    >>> import transaction
    >>> def pop_notifications():
    ...     transaction.commit()
    ...     notifications = [
    ...         email.message_from_string(raw_message)
    ...         for fromaddr, toaddrs, raw_message in sorted(stub.test_emails)
    ...     ]
    ...     stub.test_emails = []
    ...     return notifications

TicketSubscriptionView
----------------------

This view is used to subscribe and unsubscribe from a ticket.
Subscription is done when the user click on the 'Subscribe' button.

    >>> request = LaunchpadTestRequest(form={'subscribe': 'Subscribe'})
    >>> request.method = 'POST'
    >>> view = getView(ticket_three, '+subscribe', request)
    >>> view.initialize()
    >>> ticket_three.isSubscribed(getUtility(ILaunchBag).user)
    True

A notification message is displayed and the view redirect to the ticket
view page.

    >>> for notice in request.notifications:
    ...     print notice.message
    You have subscribed to this request.
    >>> request.response.getHeader('Location')
    '.../+ticket/3'

Unsubscription works in a similar manner.

    >>> request = LaunchpadTestRequest(form={'subscribe': 'Unsubscribe'})
    >>> request.method = 'POST'
    >>> view = getView(ticket_three, '+subscribe', request)
    >>> view.initialize()
    >>> ticket_three.isSubscribed(getUtility(ILaunchBag).user)
    False
    >>> for notice in request.notifications:
    ...     print notice.message
    You have unsubscribed from this request.
    >>> request.response.getHeader('Location')
    '.../+ticket/3'

These two actions didn't generate any notification mails:

    >>> len(pop_notifications())
    0

TicketWorkflowView
------------------

TicketWorkflowView is the view used to handle the comments submitted by
users on the ticket. The actions available on it always depends on the
current state of the ticket and the identify of the user viewing the
form.

    (Setup a harness to easily test the view.)
    >>> from canonical.launchpad.ftests import LaunchpadFormHarness
    >>> from canonical.launchpad.browser import TicketWorkflowView
    >>> workflow_harness = LaunchpadFormHarness(
    ...     firefox_ticket, TicketWorkflowView)

    (Let's define a helper method that will return the names of the
    available actions.)
    >>> def getAvailableActionNames(view):
    ...     names = [action.__name__.split('.')[-1]
    ...              for action in view.actions
    ...              if action.available()]
    ...     return sorted(names)

Unlogged users cannot post any comments on the ticket:

    >>> login(ANONYMOUS)
    >>> workflow_harness.submit('', {})
    >>> getAvailableActionNames(workflow_harness.view)
    []

When ticket is in the OPEN state, the owner can either answer his own
question or provide more information.

    >>> login('test@canonical.com')
    >>> workflow_harness.submit('', {})
    >>> getAvailableActionNames(workflow_harness.view)
    ['giveinfo', 'selfanswer']

But when another user sees the ticket, he can provide an answer or
request for more information.

    >>> login('no-priv@canonical.com')
    >>> workflow_harness.submit('', {})
    >>> getAvailableActionNames(workflow_harness.view)
    ['answer', 'requestinfo']

When the other user requests for more information, a confirmation is
displayed, the ticket status is changed to NEEDSINFO and the user is
redirected back to the ticket page.

    >>> workflow_harness.submit(
    ...     'requestinfo', {
    ...         'field.message': 'Can you provide an example of an URL'
    ...             'displaying the problem?'})
    >>> for notification in workflow_harness.request.response.notifications:
    ...     print notification.message
    Thanks for your information request.
    >>> print firefox_ticket.status.name
    NEEDSINFO
    >>> workflow_harness.redirectionTarget()
    '.../+ticket/2'

Workflow actions like these will send out notifications to subscribers.
(Complete notifications testing will be found in
support-tracker-notifications.txt)

    >>> len(pop_notifications())
    1

The available actions for that other user are still between giving an
answer or requesting for more information:

    >>> getAvailableActionNames(workflow_harness.view)
    ['answer', 'requestinfo']

And the ticket owner still has the same possibilities then initially:

    >>> login('test@canonical.com')
    >>> workflow_harness.submit('', {})
    >>> getAvailableActionNames(workflow_harness.view)
    ['giveinfo', 'selfanswer']

If he replies with the requested information, the ticket is moved back
to the OPEN state.

    >>> workflow_harness.submit(
    ...     'giveinfo', {
    ...         'field.message': "The following SVG doesn't display properly:"
    ...             "\nhttp://www.w3.org/2001/08/rdfweb/rdfweb-chaals-and-dan.svg"})
    >>> for notification in workflow_harness.request.response.notifications:
    ...     print notification.message
    Thanks for adding more information to your request.
    >>> print firefox_ticket.status.name
    OPEN
    >>> workflow_harness.redirectionTarget()
    '.../+ticket/2'

The other user can come back and gives an answer:

    >>> login('no-priv@canonical.com')
    >>> workflow_harness.submit(
    ...     'answer', {
    ...         'field.message': "New version of the firefox package are "
    ...             "available with SVG support enabled. Using apt-get or "
    ...             "adept you should be able to upgrade."})
    >>> for notification in workflow_harness.request.response.notifications:
    ...     print notification.message
    Thanks for your answer.
    >>> print firefox_ticket.status.name
    ANSWERED
    >>> workflow_harness.redirectionTarget()
    '.../+ticket/2'

Once the ticket is answered, the set of possible actions for the ticket
owner changes. He can now either confirm the answer, answer the problem
himself, or reopen the request because that answer isn't working.

    >>> login('test@canonical.com')
    >>> workflow_harness.submit('', {})
    >>> getAvailableActionNames(workflow_harness.view)
    ['confirm', 'reopen', 'selfanswer']

Let's say he confirms the previous answer, in this case, the ticket will
move to the 'SOLVED' state. Note that the UI doesn't enable the user to
enter a confirmation message at that stage.

    >>> workflow_harness.submit(
    ...     'confirm', {'answer_id': firefox_ticket.messages.count()-1,
    ...                 'field.message': ''})
    >>> for notification in workflow_harness.request.response.notifications:
    ...     print notification.message
    Thanks for your feedback.
    >>> print firefox_ticket.status.name
    SOLVED
    >>> workflow_harness.redirectionTarget()
    '.../+ticket/2'

Since no confirmation message was given, a default one was used.

    >>> print firefox_ticket.messages[-1].text_contents
    User confirmed that the request is solved.

Once in the SOLVED state, the owner can now only either add a comment
or reopen the request:

    >>> getAvailableActionNames(workflow_harness.view)
    ['comment', 'reopen']

Adding a comment doesn't change the status:

    >>> workflow_harness.submit(
    ...     'comment', {
    ...         'field.message': "The example now displays "
    ...         "correctly. Thanks."})
    >>> for notification in workflow_harness.request.response.notifications:
    ...     print notification.message
    Thanks for your comment.
    >>> workflow_harness.redirectionTarget()
    '.../+ticket/2'
    >>> print firefox_ticket.status.name
    SOLVED

And the other user can only comment on the ticket:

    >>> login('no-priv@canonical.com')
    >>> workflow_harness.submit('', {})
    >>> getAvailableActionNames(workflow_harness.view)
    ['comment']

If the ticket owner reopens the request, its status is changed back to
'OPEN'.

    >>> login('test@canonical.com')
    >>> workflow_harness.submit(
    ...     'reopen', {
    ...         'field.message': "Actually, there are still SVG "
    ...         "that do not display correctly. For example, the following "
    ...         "http://people.w3.org/maxf/ChessGML/immortal.svg doesn't "
    ...         "display correctly."})
    >>> for notification in workflow_harness.request.response.notifications:
    ...     print notification.message
    Your request was reopened.
    >>> print firefox_ticket.status.name
    OPEN
    >>> workflow_harness.redirectionTarget()
    '.../+ticket/2'

When the ticket owner answers his own request, it is moved straight to
the SOLVED state.

    >>> workflow_harness.submit(
    ...     'selfanswer', {
    ...         'field.message': "OK, this example requires some "
    ...         "SVG features that will only be available in Firefox 2.0."})
    >>> for notification in workflow_harness.request.response.notifications:
    ...     print notification.message
    Thanks for sharing your solution.
    >>> print firefox_ticket.status.name
    SOLVED
    >>> workflow_harness.redirectionTarget()
    '.../+ticket/2'

    (Clear all notifications.)
    >>> notifications = pop_notifications()

TicketMakeBugView
-----------------

The TicketMakeBugView is used to handle the creation of a bug from a
ticket. In addition to creating a bug, this operation will also link
the bug to the ticket.

If the user cancels a bug creation request, the user is redirected back
the ticket page.

    >>> login('foo.bar@canonical.com')
    >>> request = LaunchpadTestRequest(form={'cancel': 'cancel'})
    >>> request.method = 'POST'
    >>> makebug = getView(ticket_three, '+makebug', request)
    >>> makebug.initialize()
    >>> makebug.process_form()
    ''
    >>> list(ticket_three.bugs)
    []

If the user creates a bug, a "Linked to bug" notification is sent and
the user is subscribed to the bug.

    >>> request = LaunchpadTestRequest(
    ...     form={'create': 'create',
    ...           'field.title': 'Bug title',
    ...           'field.description': 'Bug description.'})
    >>> request.method = 'POST'
    >>> makebug = getView(ticket_three, '+makebug', request)
    >>> makebug.initialize()
    >>> makebug.process_form()
    >>> sorted(bug.id for bug in ticket_three.bugs)
    [11L]
    >>> print ticket_three.bugs[0].title
    Bug title
    >>> print ticket_three.bugs[0].description
    Bug description.
    >>> print makebug.user.name
    name16
    >>> ticket_three.bugs[0].isSubscribed(makebug.user)
    True
    >>> [n.message for n in request.notifications]
    [u'Thank you! Bug #11 created.']


    >>> notifications = pop_notifications()
    >>> len(notifications)
    1
    >>> print notifications[0].get_payload(decode=True)
    Your support request #3...
    ...
        Linked to bug: #11
    ...

If the ticket already has bugs linked to it, no new bug can be created.

    >>> request = LaunchpadTestRequest(form={'create': 'create'})
    >>> request.method = 'POST'
    >>> makebug = getView(ticket_three, '+makebug', request)
    >>> makebug.initialize()
    >>> for n in request.notifications:
    ...     print n.message
    You cannot create a bug report...

BugLinkView and BugsUnlinkView
------------------------------

Linking bug (+linkbug) to the ticket is managed through the BugLinkView.
Unlinking bugs from the ticket is managed through the BugsUnlinkView.
See 'buglinktarget-pages.txt' for their documentation. The notifications
sent along linking and unlinking bugs can be found in
'support-tracker-notifications.txt'.

TicketRejectView
----------------

That view is used by administrator and support contacts to reject a
support request.

    >>> login('foo.bar@canonical.com')
    >>> request = LaunchpadTestRequest(
    ...     form={'field.actions.reject': 'Reject',
    ...           'field.message': 'Rejecting for the fun of it.'})
    >>> request.method = 'POST'
    >>> view = getView(firefox_ticket, '+reject', request)
    >>> view.initialize()
    >>> for notice in request.notifications:
    ...     print notice.message
    You have rejected this request.
    >>> print firefox_ticket.status.title
    Invalid

TicketChangeStatusView
----------------------

TicketChangeStatusView is used by administrator to change the status
outside of the comment workflow.

    >>> request = LaunchpadTestRequest(
    ...     form={'field.actions.change-status': 'Change Status',
    ...           'field.status': 'Solved',
    ...           'field.message': 'Previous rejection was an error.'})
    >>> request.method = 'POST'
    >>> view = getView(firefox_ticket, '+change-status', request)
    >>> view.initialize()
    >>> for notice in request.notifications:
    ...     print notice.message
    Request status updated.
    >>> print firefox_ticket.status.title
    Solved

    (Clear the notification)
    >>> notifications = pop_notifications()

TicketEditView
--------------

TicketEditView available through '+edit' is used to edit most ticket
fields. It can be used to edit the ticket title and description and also
its metadata like priority, assignee, source package and whiteboard.

    >>> login('test@canonical.com')
    >>> ticket_three.sourcepackagename = None
    >>> request = LaunchpadTestRequest(form={
    ...     'field.actions.change': 'Continue',
    ...     'field.title': 'Better Title',
    ...     'field.description': 'A better description.',
    ...     'field.sourcepackagename': 'mozilla-firefox',
    ...     'field.assignee': 'name16',
    ...     'field.whiteboard': 'Some note',
    ...     'field.priority': 'Wishlist'})
    >>> request.method = 'POST'
    >>> view = getView(ticket_three, '+edit', request)
    >>> view.initialize()
    >>> ticket_three.title
    u'Better Title'
    >>> ticket_three.description
    u'A better description.'
    >>> print ticket_three.sourcepackagename.name
    mozilla-firefox

Since only a user with launchpad.Admin privilege can change the
priority, assignee and status whiteboard, the values won't have been
changed:

    >>> print ticket_three.priority.title
    Normal
    >>> ticket_three.assignee is None
    True
    >>> ticket_three.whiteboard is None
    True

This View send the event appropriate to send out a notification:

    >>> notifications = pop_notifications()
    >>> len(notifications)
    1
    >>> print notifications[0].get_payload(decode=True)
    Your support request #3...
    ...
    Summary changed to:
    Better Title
    <BLANKLINE>
    Description changed to:
    A better description.
    <BLANKLINE>

<<<<<<< TREE
If the user has the required permission, the assignee, whiteboard and
priority fields will be updated:

    >>> login('foo.bar@canonical.com')
    >>> request = LaunchpadTestRequest(form={
    ...     'field.actions.change': 'Continue',
    ...     'field.title': 'Better Title',
    ...     'field.description': 'A better description.',
    ...     'field.sourcepackagename': 'mozilla-firefox',
    ...     'field.assignee': 'name16',
    ...     'field.whiteboard': 'Some note',
    ...     'field.priority': 'Wishlist'})
    >>> request.method = 'POST'
    >>> view = getView(ticket_three, '+edit', request)
    >>> view.initialize()
    >>> print ticket_three.priority.title
    Wishlist
    >>> print ticket_three.assignee.displayname
    Foo Bar
    >>> print ticket_three.whiteboard
    Some note

In a similar manner, the sourcepackagename field can only be updated on
a distribution ticket:

    >>> request = LaunchpadTestRequest(form={
    ...     'field.actions.change': 'Continue',
    ...     'field.title': 'Better Title',
    ...     'field.description': 'A better description.',
    ...     'field.sourcepackagename': 'mozilla-firefox',
    ...     'field.assignee': '',
    ...     'field.whiteboard': '',
    ...     'field.priority': 'Normal'})
    >>> request.method = 'POST'
    >>> view = getView(firefox_ticket, '+edit', request)
    >>> view.initialize()
    >>> firefox_ticket.sourcepackagename is None
    True

    (Clear out the pending notifications.)
    >>> notifications = pop_notifications()


SearchTicketsView
-----------------

This view is used as a base class to search for tickets. It is intended
to be easily customizable to offer more specific reports, while
keeping those searchable.

    # Define a subclass to demonstrate the customizability of the base
    # view.
    >>> from canonical.launchpad.browser import SearchTicketsView
    >>> class MyCustomSearchTicketsView(SearchTicketsView):
    ...
    ...     default_filter = {}
    ...
    ...     def getDefaultFilter(self):
    ...         return dict(**self.default_filter)

    # Set up a harness for easier testing.
    >>> from canonical.launchpad.ftests import LaunchpadFormHarness
    >>> search_view_harness = LaunchpadFormHarness(
    ...     ubuntu, MyCustomSearchTicketsView)

By default, that class provides widgets to search by text and by status.

    >>> search_view = search_view_harness.view
    >>> search_view.widgets.get('search_text') is not None
    True
    >>> search_view.widgets.get('status') is not None
    True

It also includes a widget to select the sort order.

    >>> search_view.widgets.get('sort') is not None
    True

The tickets matching the search are available by using the
searchResults() method. The returned results are batched.

    # We want 5 items per page for these tests.
    >>> from canonical.config import config
    >>> original_default_batch_size = config.launchpad.default_batch_size
    >>> config.launchpad.default_batch_size = 5

    >>> tickets = search_view.searchResults()
    >>> tickets
    <canonical.launchpad.webapp.batching.BatchNavigator ...>
    >>> print "\n".join([ticket.title for ticket in tickets.batch])
    Continue playing after shutdown
    Play DVDs in Totem
    mailto: problem in webpage
    Installation of Java Runtime Environment for Mozilla
    Slow system

These were the default results when no search is entered. The user
can tweak the search and filter the results:

    >>> search_view_harness.submit('search', {
    ...     'field.status': ['Solved', 'Open'],
    ...     'field.search_text': 'firefox',
    ...     'field.sort': 'by relevancy',})
    >>> search_view = search_view_harness.view
    >>> tickets = search_view.searchResults()
    >>> for ticket in tickets.batch:
    ...     print ticket.title, ticket.status.title
    mailto: problem in webpage  Solved

Specific views can provide a default filter by returning the default
search parameters to use in the getDefaultFilter() method:

    >>> from canonical.lp.dbschema import TicketStatus
    >>> MyCustomSearchTicketsView.default_filter = {
    ...     'status': [TicketStatus.SOLVED, TicketStatus.INVALID]}
    >>> search_view_harness.submit('', {})

In this example, only the solved and invalid tickets are listed by
default.

    >>> search_view = search_view_harness.view
    >>> tickets = search_view.searchResults()
    >>> for ticket in tickets.batch:
    ...     print ticket.title
    mailto: problem in webpage
    Better Title

The status widget displays the default criteria used:

    >>> for status in search_view.widgets['status']._getFormValue():
    ...     print status.title
    Solved
    Invalid

The user selected search parameters will override these default
criteria.

    >>> search_view_harness.submit('search', {
    ...     'field.status': ['Solved'],
    ...     'field.search_text': 'firefox',
    ...     'field.sort': 'by relevancy'})
    >>> search_view = search_view_harness.view
    >>> tickets = search_view.searchResults()
    >>> for ticket in tickets.batch:
    ...     print ticket.title
    mailto: problem in webpage
    >>> for status in search_view.widgets['status']._getFormValue():
    ...     print status.title
    Solved

The base view computes the page heading and the message displayed when
no results are found based on the selected search filter:

    >>> from zope.i18n import translate
    >>> search_view_harness.submit('', {})
    >>> print translate(search_view_harness.view.pageheading)
    Support requests for Ubuntu
    >>> print translate(search_view_harness.view.empty_listing_message)
    There are no support requests for Ubuntu with the requested statuses.

    >>> MyCustomSearchTicketsView.default_filter = dict(
    ...     status=[TicketStatus.OPEN], search_text='Firefox')
    >>> search_view_harness.submit('', {})
    >>> print translate(search_view_harness.view.pageheading)
    Open support requests about "Firefox" for Ubuntu
    >>> print translate(search_view_harness.view.empty_listing_message)
    There are no open support requests about "Firefox" for Ubuntu.

It works also with user submitted values:

    >>> search_view_harness.submit('search', {
    ...     'field.status': ['Answered'],
    ...     'field.search_text': '',
    ...     'field.sort': 'by relevancy'})
    >>> print translate(search_view_harness.view.pageheading)
    Answered support requests for Ubuntu
    >>> print translate(search_view_harness.view.empty_listing_message)
    There are no answered support requests for Ubuntu.

    >>> search_view_harness.submit('search', {
    ...     'field.status': ['Open', 'Answered'],
    ...     'field.search_text': 'evolution',
    ...     'field.sort': 'by relevancy'})
    >>> print translate(search_view_harness.view.pageheading)
    Support requests about "evolution" for Ubuntu
    >>> print translate(search_view_harness.view.empty_listing_message)
    There are no support requests about "evolution" for Ubuntu with the
    requested statuses.

Cleanup
-------

    # Restore original batch size.
    >>> config.launchpad.default_batch_size = original_default_batch_size
