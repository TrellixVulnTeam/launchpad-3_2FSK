= Introduction =

Bugs are some of the more complex objects in Launchpad. They have a
lot of state and many relationships to other objects.

  >>> from pprint import PrettyPrinter
  >>> pprint = PrettyPrinter(width=76).pprint
  >>> def show(thing):
  ...     if isinstance(thing, dict):
  ...         thing = sorted(thing.iteritems())
  ...     pprint(thing)


== Bugs themselves ==

At the top level we provide a collection of bugs.

  >>> from operator import itemgetter
  >>> bugs = webservice.get("/bugs").jsonBody()
  >>> bugs['total_size']
  15
  >>> bug_entries = sorted(bugs['entries'], key=itemgetter('id'))
  >>> show(bug_entries[0])
  [(u'attachments_collection_link',
    u'http://.../bugs/11/attachments'),
   (u'bug_tasks_collection_link',
    u'http://.../bugs/11/bug_tasks'),
   (u'bug_watches_collection_link',
    u'http://.../bugs/11/bug_watches'),
   (u'cves_collection_link', u'http://.../bugs/11/cves'),
   (u'date_created', u'2007-03-15T20:33:56.678930+00:00'),
   (u'date_last_message', None),
   (u'date_last_updated', u'2007-03-15T20:37:51.603369+00:00'),
   (u'date_made_private', None),
   (u'description', u"I've had problems when switching..."),
   (u'duplicate_of_link', None),
   (u'duplicates_collection_link',
    u'http://.../bugs/11/duplicates'),
   (u'id', 11),
   (u'messages_collection_link',
    u'http://.../bugs/11/messages'),
   (u'name', None),
   (u'owner_link', u'http://.../~name16'),
   (u'private', False),
   (u'resource_type_link', u'http://.../#bug'),
   (u'security_related', False),
   (u'self_link', u'http://.../bugs/11'),
   (u'subscriptions_collection_link',
    u'http://.../bugs/11/subscriptions'),
   (u'tags', []),
   (u'title', u'Make Jokosher use autoaudiosink'),
   (u'users_affected_count', 0),
   (u'users_unaffected_count', 0),
   (u'who_made_private_link', None)]

Bugs are indexed by number beneath the top-level collection.

  >>> bug_one = webservice.get("/bugs/1").jsonBody()
  >>> bug_one['id']
  1

Bugs have relationships to other bugs, like "duplicate_of".

  >>> duplicates_of_five = webservice.get(
  ...     "/bugs/5/duplicates").jsonBody()['entries']
  >>> len(duplicates_of_five)
  1
  >>> duplicates_of_five[0]['id']
  6

  >>> bug_six_url = duplicates_of_five[0]['self_link']
  >>> bug_six = webservice.get(bug_six_url).jsonBody()
  >>> bug_six['duplicate_of_link']
  u'http://.../bugs/5'

To create a new bug we use the createBug operation.  That operation
takes a target parameter which must be a either a Product, a
Distribution or a DistributionSourcePackage.

    >>> project_collection = webservice.get(
    ...   "/projects?ws.op=search&text=firefox").jsonBody()
    >>> firefox = project_collection['entries'][0]
    >>> print webservice.named_post(
    ...     '/bugs', 'createBug',
    ...     title='Test bug', description='Test bug',
    ...     target=firefox['self_link'])
    HTTP/1.1 201 Created
    ...
    Location: http://.../bugs/...
    <BLANKLINE>

    >>> print webservice.named_post(
    ...     '/bugs', 'createBug',
    ...     title='Test bug', description='Test bug',
    ...     target=webservice.getAbsoluteUrl('/ubuntu'))
    HTTP/1.1 201 Created
    ...
    Location: http://.../bugs/...
    <BLANKLINE>

    >>> print webservice.named_post(
    ...     '/bugs', 'createBug',
    ...     title='Test bug', description='Test bug',
    ...     target=webservice.getAbsoluteUrl('/ubuntu/+source/evolution'))
    HTTP/1.1 201 Created
    ...
    Location: http://.../bugs/...
    <BLANKLINE>

A ProductSeries can't be the target of a new bug.

    >>> print webservice.named_post(
    ...     '/bugs', 'createBug',
    ...     title='Test bug', description='Test bug',
    ...     target=webservice.getAbsoluteUrl('/firefox/1.0'))
    HTTP/1.1 400 Bad Request
    ...
    A bug target must be a Project, a Distribution or a
    DistributionSourcePackage.  Got <ProductSeries...

That operation will fail if the client doesn't specify the product or
distribution in which the bug exists.

    >>> print webservice.named_post(
    ...     '/bugs', 'createBug',
    ...     title='Test bug', description='Test bug')
    HTTP/1.1 400 Bad Request
    ...
    target: Required input is missing.


== Bugs as message targets ==

Each bug has a collection of messages.

  >>> messages = webservice.get("/bugs/5/messages").jsonBody()['entries']
  >>> show(messages[0])
  [(u'bug_attachments_collection_link',
    u'http://.../firefox/+bug/5/comments/0/bug_attachments'),
   (u'content',
    u'All ways of downloading firefox should provide...'),
   (u'date_created', u'2005-01-14T17:27:03.702622+00:00'),
   (u'owner_link', u'http://.../~name12'),
   (u'parent_link', None),
   (u'resource_type_link',
    u'http://.../#message'),
   (u'self_link',
    u'http://.../firefox/+bug/5/comments/0'),
   (u'subject', u'Firefox install instructions should be complete')]

The messages are stored beneath the bug-specific collection. Their
URLs are based on their position with respect to the
bug. /firefox/+bug/5/comments/0 is the first message for bug 5, and it's
different from /firefox/+bug/1/comments/0.

  >>> messages[0]['self_link']
  u'http://.../firefox/+bug/5/comments/0'

  >>> message = webservice.get(messages[0]['self_link']).jsonBody()
  >>> message == messages[0]
  True

There is no top-level collection of messages; they only exist in
relation to some bug.

  >>> webservice.get("/messages").getStatus()
  404

We can add a new message to a bug by calling the newMessage method.

  >>> print webservice.named_post(
  ...     "/bugs/5", 'newMessage',
  ...     subject='A new message',
  ...     content='This is a new message added through the webservice API.')
  HTTP/1.1 201 Created
  Content-Length: 0
  Content-Type: text/plain
  Location: http://api.launchpad.dev/beta/firefox/+bug/5/comments/1
  <BLANKLINE>

  >>> show(webservice.get("/firefox/+bug/5/comments/1").jsonBody())
  [...,
   (u'content', u'This is a new message added through the webservice API.'),
   ...
   (u'resource_type_link', u'http://api.launchpad.dev/beta/#message'),
   (u'self_link',
    u'http://api.launchpad.dev/beta/firefox/+bug/5/comments/1'),
   (u'subject', u'A new message')]


== Bug tasks ==

Each bug may be associated with one or more bug tasks. Much of the
data in a bug task is derived from the bug.

  >>> bug_one_bugtasks_url = bug_one['bug_tasks_collection_link']
  >>> bug_one_bugtasks = sorted(webservice.get(
  ...     bug_one_bugtasks_url).jsonBody()['entries'])
  >>> len(bug_one_bugtasks)
  3

  >>> show(bug_one_bugtasks[0])
  [(u'assignee_link', None),
   (u'bug_link', u'http://.../bugs/1'),
   (u'bug_target_display_name', u'mozilla-firefox (Debian)'),
   (u'bug_target_name', u'mozilla-firefox (Debian)'),
   (u'bug_watch_link', u'http://.../bugs/1/+watch/8'),
   (u'date_assigned', u'2005-01-04T11:07:20.584746+00:00'),
   (u'date_closed', None),
   (u'date_confirmed', None),
   (u'date_created', u'2004-01-04T03:49:22.790240+00:00'),
   (u'date_fix_committed', None),
   (u'date_fix_released', None),
   (u'date_in_progress', None),
   (u'date_left_closed', None),
   (u'date_left_new', None),
   (u'date_triaged', None),
   (u'importance', u'Low'),
   (u'is_complete', False),
   (u'owner_link', u'http://.../~name12'),
   (u'related_tasks_collection_link',
    u'http://api.../debian/+source/mozilla-firefox/+bug/1/related_tasks'),
   (u'resource_type_link',
    u'http://.../#bug_task'),
   (u'self_link',
    u'http://api.../debian/+source/mozilla-firefox/+bug/1'),
   (u'status', u'Confirmed'),
   (u'title',
    u'Bug #1 in mozilla-firefox (Debian): "Firefox does not support SVG"')]

  >>> bugtask_path = bug_one_bugtasks[0]['self_link']
  >>> bugtask = webservice.get(bugtask_path).jsonBody()
  >>> bugtask == bug_one_bugtasks[0]
  True

The collection of bug tasks is not exposed as a resource:

  >>> webservice.get("/bug_tasks").getStatus()
  404

It's possible to change the task's assignee.

  >>> print webservice.named_post(
  ...     bugtask_path, 'transitionToAssignee',
  ...     assignee=webservice.getAbsoluteUrl('/~cprov'))
  HTTP/1.1 200 Ok
  ...
  Content-Type: application/json
  <BLANKLINE>
  null

  >>> print webservice.get(bugtask_path).jsonBody()['assignee_link']
  http://.../~cprov

Let's try modifying the importance of a task.

  >>> body = webservice.get(bugtask_path).jsonBody()
  >>> body['importance']
  u'Low'
  >>> print webservice.named_post(
  ...     bugtask_path, 'transitionToImportance', importance='High')
  HTTP/1.1 200 Ok
  ...
  Content-Type: application/json
  <BLANKLINE>
  null
  >>> body = webservice.get(bugtask_path).jsonBody()
  >>> body['importance']
  u'High'

Only bug supervisors or people who can otherwise edit the bugtask's
pillar are authorised to edit the importance.

  >>> print user_webservice.named_post(
  ...     bugtask_path, 'transitionToImportance', importance='Low')
  HTTP/1.1 401 Unauthorized...

  >>> body = webservice.get(bugtask_path).jsonBody()
  >>> body['importance']
  u'High'


== Bug subscriptions ==

We can get the the collection of subscriptions to a bug.

  >>> bug_one_subscriptions_url = bug_one['subscriptions_collection_link']
  >>> subscriptions = webservice.get(bug_one_subscriptions_url).jsonBody()
  >>> subscription_entries = sorted(
  ...     subscriptions['entries'], key=itemgetter('self_link'))
  >>> for entry in subscription_entries:
  ...     show(entry)
  [(u'bug_link', u'http://.../bugs/1'),
   (u'person_link', u'http://.../~name12'),
   (u'resource_type_link',
    u'http://.../#bug_subscription'),
   (u'self_link',
    u'http://.../bugs/1/+subscription/name12'),
   (u'subscribed_by_link', u'http://.../~janitor')]
  [(u'bug_link', u'http://.../bugs/1'),
   (u'person_link', u'http://.../~stevea'),
   (u'resource_type_link',
    u'http://.../#bug_subscription'),
   (u'self_link',
    u'http://.../bugs/1/+subscription/stevea'),
   (u'subscribed_by_link', u'http://.../~janitor')]

Each subscription can be accessed individually.

  >>> subscription = webservice.get(
  ...     subscription_entries[1]['self_link']).jsonBody()
  >>> show(subscription)
  [(u'bug_link', u'http://.../bugs/1'),
   (u'person_link', u'http://.../~stevea'),
   (u'resource_type_link', u'http://.../#bug_subscription'),
   (u'self_link', u'http://.../bugs/1/+subscription/stevea'),
   (u'subscribed_by_link', u'http://.../~janitor')]

We can also create new subscriptions.

    >>> new_subscription = webservice.named_post(
    ...     bug_one['self_link'], 'subscribe',
    ...     person=webservice.getAbsoluteUrl('/~cprov')).jsonBody()
    >>> pprint(new_subscription)
    {...u'self_link':
        u'http://.../bugs/1/+subscription/cprov'...}

But we can only unsubscribe ourselves.

    >>> print webservice.named_post(
    ...     bug_one['self_link'], 'unsubscribe')
    HTTP/1.1 200 Ok...


== Bug Watches ==

Bugs can have bug watches associated with them. Each bugwatch can also
be optionally associated with one of the bugtasks in a bug, in which
case aspects of the bugtask (like status) are slaved to the remote bug
report described by the bugwatch.

  >>> bug_one_bug_watches = sorted(webservice.get(
  ...     bug_one['bug_watches_collection_link']).jsonBody()['entries'])
  >>> len(bug_one_bug_watches)
  4

  >>> [bug_watch_2000] = [
  ...     bug_watch for bug_watch in bug_one_bug_watches
  ...     if bug_watch['remote_bug'] == u'2000']

  >>> show(bug_watch_2000)
  [(u'bug_link', u'http://.../bugs/1'),
   (u'bug_tasks_collection_link',
    u'http://.../bugs/1/+watch/2/bug_tasks'),
   (u'bug_tracker_link',
    u'http://.../bugs/bugtrackers/mozilla.org'),
   (u'date_created', u'2004-10-04T01:00:00+00:00'),
   (u'date_last_changed', u'2004-10-04T01:00:00+00:00'),
   (u'date_last_checked', u'2004-10-04T01:00:00+00:00'),
   (u'last_error_type', None),
   (u'owner_link', u'http://.../~sabdfl'),
   (u'remote_bug', u'2000'),
   (u'remote_importance', None),
   (u'remote_status', u''),
   (u'resource_type_link',
    u'http://.../#bug_watch'),
   (u'self_link', u'http://.../bugs/1/+watch/2'),
   (u'title', u'The Mozilla.org Bug Tracker #2000'),
   (u'url', u'https://bugzilla.mozilla.org/show_bug.cgi?id=2000')]

  >>> bug_watch = webservice.get(bug_watch_2000['self_link']).jsonBody()
  >>> bug_watch == bug_watch_2000
  True

The collection of bug watches is not exposed as a resource:

  >>> webservice.get("/bug_watches").getStatus()
  404

We can modify the remote bug.

  >>> bug_watch['remote_bug']
  u'2000'

  >>> from simplejson import dumps
  >>> patch = {u'remote_bug': u'1234'}
  >>> response = webservice.patch(
  ...     bug_watch_2000['self_link'], 'application/json', dumps(patch))

  >>> bug_watch = webservice.get(bug_watch_2000['self_link']).jsonBody()
  >>> bug_watch['remote_bug']
  u'1234'

But we can't change other things, like the URL.

  >>> patch = {u'url': u'http://www.example.com/'}
  >>> response = webservice.patch(
  ...     bug_watch_2000['self_link'], 'application/json', dumps(patch))
  >>> print response.getOutput()
  HTTP/1.1 400 Bad Request
  Content-Length: 47
  Content-Type: text/plain
  <BLANKLINE>
  url: You tried to modify a read-only attribute.

We can use the factory function `addWatch` to create a new bug watch
associated with a bug.

  >>> response = webservice.named_post(
  ...     bug_one['self_link'], 'addWatch',
  ...     bug_tracker=webservice.getAbsoluteUrl(
  ...                      '/bugs/bugtrackers/mozilla.org'),
  ...     remote_bug='9876')
  >>> print response.getOutput()
  HTTP/1.1 201 Created
  Content-Length: 0
  Content-Type: text/plain
  Location: http://.../bugs/1/+watch/13

Following the redirect, we can see the new bug watch:

  >>> new_bug_watch_path = response.getHeader('Location')
  >>> new_bug_watch = webservice.get(new_bug_watch_path).jsonBody()
  >>> show(new_bug_watch)
  [(u'bug_link', u'http://.../bugs/1'),
   (u'bug_tasks_collection_link',
    u'http://.../bugs/1/+watch/13/bug_tasks'),
   (u'bug_tracker_link',
    u'http://.../bugs/bugtrackers/mozilla.org'),
   (u'date_created', u'...'),
   (u'date_last_changed', None),
   (u'date_last_checked', None),
   (u'last_error_type', None),
   (u'owner_link', u'http://.../~salgado'),
   (u'remote_bug', u'9876'),
   (u'remote_importance', None),
   (u'remote_status', None),
   (u'resource_type_link',
    u'http://.../#bug_watch'),
   (u'self_link', u'http://.../bugs/1/+watch/13'),
   (u'title', u'The Mozilla.org Bug Tracker #9876'),
   (u'url', u'https://bugzilla.mozilla.org/show_bug.cgi?id=9876')]


== Bug Trackers ==

  >>> bug_tracker = webservice.get(bug_watch['bug_tracker_link']).jsonBody()

  >>> show(bug_tracker)
  [(u'base_url', u'https://bugzilla.mozilla.org/'),
   (u'base_url_aliases', []),
   (u'bug_tracker_type', u'Bugzilla'),
   (u'contact_details', u'Carrier pigeon only'),
   (u'has_lp_plugin', None),
   (u'name', u'mozilla.org'),
   (u'registrant_link', u'http://.../~name12'),
   (u'resource_type_link',
    u'http://.../#bug_tracker'),
   (u'self_link',
    u'http://.../bugs/bugtrackers/mozilla.org'),
   (u'summary',
    u'The Mozilla.org bug tracker is the grand-daddy of bugzillas...'),
   (u'title', u'The Mozilla.org Bug Tracker'),
   (u'watches_collection_link',
    u'http://.../bugs/bugtrackers/mozilla.org/watches')]

We can change various aspects of bug trackers.

  >>> patch = {
  ...     u'name': u'bob',
  ...     u'title': u"Bob's Tracker",
  ...     u'summary': u"Where Bob files his bugs.",
  ...     u'base_url': u'http://bugs.example.com/',
  ...     u'base_url_aliases': [u'http://bugs.example.com/bugs/',
  ...                           u'http://www.example.com/bugtracker/'],
  ...     u'contact_details': u'bob@example.com',
  ...     }
  >>> response = webservice.patch(
  ...     bug_tracker['self_link'], 'application/json', dumps(patch))
  >>> print response.getOutput()
  HTTP/1.1 301 Moved Permanently
  Content-Length: 0
  Content-Type: text/plain
  Location: http://.../bugs/bugtrackers/bob
  <BLANKLINE>

Note the 301 response. We changed the name, so the API URL at which
the bug tracker can be found has changed.

  >>> print webservice.get(bug_tracker['self_link']).getOutput()
  HTTP/1.1 404 Not Found
  Content-Length: ...
  Content-Type: text/plain
  X-Lazr-Oopsid: OOPS-...
  <BLANKLINE>
  Object: <...BugTrackerSet object at ...>, name: u'mozilla.org'
  <BLANKLINE>
  Traceback (most recent call last):
  ...
  NotFound: Object: <...BugTrackerSet object at ...>, name: u'mozilla.org'
  <BLANKLINE>

Naturally, if we follow the Location: header then we'll get the
renamed bug tracker.

  >>> bug_tracker_path = response.getHeader('Location')
  >>> bug_tracker = webservice.get(bug_tracker_path).jsonBody()
  >>> show(bug_tracker)
  [(u'base_url', u'http://bugs.example.com/'),
   (u'base_url_aliases',
    [u'http://bugs.example.com/bugs/',
     u'http://www.example.com/bugtracker/']),
   (u'bug_tracker_type', u'Bugzilla'),
   (u'contact_details', u'bob@example.com'),
   (u'has_lp_plugin', None),
   (u'name', u'bob'),
   (u'registrant_link', u'http://.../~name12'),
   (u'resource_type_link',
    u'http://.../#bug_tracker'),
   (u'self_link', u'http://.../bugs/bugtrackers/bob'),
   (u'summary', u'Where Bob files his bugs.'),
   (u'title', u"Bob's Tracker"),
   (u'watches_collection_link',
    u'http://.../bugs/bugtrackers/bob/watches')]


== Bug attachments ==

Bug 1 has no attachments:

  >>> attachments = webservice.get(
  ...     bug_one['attachments_collection_link']).jsonBody()
  >>> show(attachments)
  [(u'entries', []),
   (u'resource_type_link',
    u'http://.../#bug_attachment-page-resource'),
   (u'start', None),
   (u'total_size', 0)]

An attachment can be added to the bug:

  >>> response = webservice.named_post(
  ...     bug_one['self_link'], 'addAttachment',
  ...     data="12345", filename="numbers.txt", content_type='foo/bar',
  ...     comment="The numbers you asked for.")
  >>> print response.getOutput()
  HTTP/1.1 201 Created
  Content-Length: 0
  Content-Type: text/plain
  Location: http://.../bugs/1/attachments/1

Now, bug 1 has one attachment:

  >>> attachments = webservice.get(
  ...     bug_one['attachments_collection_link']).jsonBody()
  >>> show(attachments)
  [(u'entries',
    [{u'bug_link': u'http://.../bugs/1',
      u'data_link': u'http://.../bugs/1/attachments/1/data',
      u'message_link': u'http://.../firefox/+bug/1/comments/2',
      u'resource_type_link': u'http://.../#bug_attachment',
      u'self_link': u'http://.../bugs/1/attachments/1',
      u'title': u'numbers.txt',
      u'type': u'Unspecified'}]),
   (u'resource_type_link',
    u'http://.../#bug_attachment-page-resource'),
   (u'start', 0),
   (u'total_size', 1)]

The attachment can be fetched directly:

  >>> [attachment] = attachments['entries']
  >>> show(webservice.get(attachment['self_link']).jsonBody())
  [(u'bug_link', u'http://.../bugs/1'),
   (u'data_link',
    u'http://.../bugs/1/attachments/1/data'),
   (u'message_link',
    u'http://.../firefox/+bug/1/comments/2'),
   (u'resource_type_link',
    u'http://.../#bug_attachment'),
   (u'self_link', u'http://.../bugs/1/attachments/1'),
   (u'title', u'numbers.txt'),
   (u'type', u'Unspecified')]

Fetching the data actually yields a redirect to the Librarian, which
we must follow to download the data.

  >>> data_response = webservice.get(attachment['data_link'])
  >>> print data_response.getOutput()
  HTTP/1.1 303 See Other
  Content-Length: 0
  Content-Type: text/plain
  Location: http://localhost:58000/.../numbers.txt

  >>> from urllib2 import urlopen

  >>> data = None
  >>> conn = urlopen(data_response.getHeader('Location'))
  >>> try:
  ...     data = conn.read()
  ... finally:
  ...     conn.close()

  >>> conn.headers['Content-Type']
  'foo/bar'

  >>> conn.headers['Content-Length']
  '5'

  >>> data
  '12345'

We can see that a message was created and linked to our
attachment. This is where our comment is recorded.

  >>> message = webservice.get(attachment['message_link']).jsonBody()
  >>> show(message)
  [(u'bug_attachments_collection_link',
    u'http://.../firefox/+bug/1/comments/2/bug_attachments'),
   (u'content', u'The numbers you asked for.'),
   (u'date_created', u'...'),
   (u'owner_link', u'http://.../~salgado'),
   (u'parent_link', None),
   (u'resource_type_link', u'http://.../#message'),
   (u'self_link',
    u'http://.../firefox/+bug/1/comments/2'),
   (u'subject', None)]

The message also links back to the attachments that were uploaded at
the same time.

  >>> attachments = webservice.get(
  ...     message['bug_attachments_collection_link']).jsonBody()
  >>> show(attachments)
  [(u'entries', [...]),
   (u'resource_type_link',
    u'http://.../#bug_attachment-page-resource'),
   (u'start', 0),
   (u'total_size', 1)]


== Searching for bugs ==

Bug targets expose the searchTasks method, which provides a search interface
for bug tasks, similar to the advanced search form on the web interface.

Calling searchTasks with no arguments just returns a collection of all the
bug tasks for the target.

    >>> show(webservice.named_get('/firefox', 'searchTasks').jsonBody())
    [(u'entries',
      [{...
        u'self_link': u'http://api.launchpad.dev/beta/firefox/+bug/5',
        ...
        u'self_link': u'http://api.launchpad.dev/beta/firefox/+bug/4',
        ...
        u'self_link': u'http://api.launchpad.dev/beta/firefox/+bug/1',
        ...
        u'self_link': u'http://api.launchpad.dev/beta/firefox/+bug/16',
        ...
     (u'total_size', 4)]

Some parameters accept lists of values, just like when searching from
the web interface. The importance and status parameters, for example,
accept many values and return only tasks with these values.

    >>> show(webservice.named_get(
    ...     '/firefox', 'searchTasks',
    ...     importance=['Critical', 'Low']).jsonBody())
    [(u'entries',
      [{...
        u'importance': u'Critical',
        ...
        u'self_link': u'http://api.launchpad.dev/beta/firefox/+bug/5',
        ...
        u'importance': u'Low',
        ...
        u'self_link': u'http://api.launchpad.dev/beta/firefox/+bug/1',
        ...
     (u'total_size', 2)]

The tags parameter also accepts a list of values. By default, it
searches for bugs with any of the given tags.

    >>> show(webservice.named_get(
    ...     '/ubuntu', 'searchTasks',
    ...     tags=['crash', 'dataloss']).jsonBody())
    [(u'entries',
      [{...
        u'bug_link': u'http://api.launchpad.dev/beta/bugs/9',
        ...
        u'self_link': u'http://api.launchpad.dev/beta/ubuntu/+source/thunderbird/+bug/9',
        ...
        u'bug_link': u'http://api.launchpad.dev/beta/bugs/10',
        ...
        u'self_link': u'http://api.launchpad.dev/beta/ubuntu/+source/linux-source-2.6.15/+bug/10',
        ...
        u'bug_link': u'http://api.launchpad.dev/beta/bugs/2',
        ...
        u'self_link': u'http://api.launchpad.dev/beta/ubuntu/+bug/2',
        ...
     (u'total_size', 3)]

It can be used for searching for bugs with all of the given tags by
setting the tags_combinator parameter to 'All'.

    >>> show(webservice.named_get(
    ...     '/ubuntu', 'searchTasks',
    ...     tags=['crash', 'dataloss'],
    ...     tags_combinator='All').jsonBody())
    [(u'entries', []), (u'start', None), (u'total_size', 0)]

Search results can be ordered using the same string values used by
the advanced search interface.

    >>> ordered_bugtasks = webservice.named_get(
    ...     '/ubuntu', 'searchTasks',
    ...     order_by='-datecreated').jsonBody()['entries']
    >>> for ordered_bugtask in ordered_bugtasks:
    ...     print ordered_bugtask['self_link']
    http://api.launchpad.dev/beta/ubuntu/+source/evolution/+bug/18
    http://api.launchpad.dev/beta/ubuntu/+bug/17
    http://api.launchpad.dev/beta/ubuntu/+bug/2
    http://api.launchpad.dev/beta/ubuntu/+source/linux-source-2.6.15/+bug/10
    http://api.launchpad.dev/beta/ubuntu/+source/thunderbird/+bug/9


== Affected users ==

It is possible to mark a bug as affecting the user using the web service.

    >>> print webservice.named_post(
    ...     bug_one['self_link'], 'isUserAffected').jsonBody()
    None
    >>> webservice.named_post(
    ...     bug_one['self_link'], 'markUserAffected',
    ...     affected=True).jsonBody()
    >>> webservice.named_post(
    ...     bug_one['self_link'], 'isUserAffected').jsonBody()
    True
    >>> webservice.named_post(
    ...     bug_one['self_link'], 'markUserAffected',
    ...     affected=False).jsonBody()
    >>> webservice.named_post(
    ...     bug_one['self_link'], 'isUserAffected').jsonBody()
    False


== CVEs ==

CVEs and how they relate to Launchpad bugs can be accessed using the API.

The collection of all CVEs is available at the top level.

    >>> cves = webservice.get("/bugs/cve").jsonBody()
    >>> show(cves)
    [(u'entries',
      [{u'date_created': u'2005-09-13T14:05:17.043865+00:00',
        u'date_modified': u'2005-09-13T14:05:17.043865+00:00',
        u'description': u'Cross-site scripting (XSS) vulnerability in PhotoPost PHP Pro 5.1 allows remote attackers to inject arbitrary web script or HTML via EXIF data, such as the Camera Model Tag.',
        u'display_name': u'CVE-2005-2737',
        u'resource_type_link': u'http://.../#cve',
        u'self_link': u'http://.../bugs/cve/2005-2737',
        u'sequence': u'2005-2737',
        u'status': u'Candidate',
        u'title': u'CVE-2005-2737 (Candidate)',
        u'url': u'http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=2005-2737'},
       {...,
        u'self_link': u'http://.../bugs/cve/2005-2736',
        ...},
       {...,
        u'self_link': u'http://.../bugs/cve/2005-2735',
        ...},
       {...,
        u'self_link': u'http://.../bugs/cve/2005-2734',
        ...,
       {...,
        u'self_link': u'http://.../bugs/cve/2005-2733',
        ...}]),
     (u'next_collection_link',
      u'http://.../bugs/cve?ws.start=5&ws.size=5'),
     (u'resource_type_link', u'http://.../#cves'),
     (u'start', 0),
     (u'total_size', 10)]

And for every bug we can look at the CVEs linked to it.

    >>> bug_one_cves_url = bug_one['cves_collection_link']
    >>> show(webservice.get(bug_one_cves_url).jsonBody())
    [(u'entries',
      [{u'date_created': u'2005-09-07T19:00:32.944561+00:00',
        u'date_modified': u'2005-09-13T14:00:03.508959+00:00',
        u'description': u'Firefox crashes all the time',
        u'display_name': u'CVE-1999-8979',
        u'resource_type_link': u'http://.../#cve',
        u'self_link': u'http://.../bugs/cve/1999-8979',
        u'sequence': u'1999-8979',
        u'status': u'Entry',
        u'title': u'CVE-1999-8979 (Entry)',
        u'url': u'http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=1999-8979'}]),
     (u'resource_type_link',
      u'http://.../#cve-page-resource'),
     (u'start', 0),
     (u'total_size', 1)]

Unlink CVEs from that bug.

    >>> print webservice.named_post(
    ...     bug_one['self_link'], 'unlinkCVE',
    ...     cve='http://api.launchpad.dev/beta/bugs/cve/1999-8979')
    HTTP/1.1 200 Ok...
    >>> show(webservice.get(bug_one_cves_url).jsonBody())
    [(u'entries', []),
     ...,
     (u'total_size', 0)]

And link new CVEs to the bug.

    >>> print webservice.named_post(
    ...     bug_one['self_link'], 'linkCVE',
    ...     cve='http://api.launchpad.dev/beta/bugs/cve/2005-2733')
    HTTP/1.1 200 Ok...
    >>> show(webservice.get(bug_one_cves_url).jsonBody())
    [(u'entries',
      [{...,
        u'self_link': u'http://.../bugs/cve/2005-2733',
        ...}]),
     ...,
     (u'total_size', 1)]
