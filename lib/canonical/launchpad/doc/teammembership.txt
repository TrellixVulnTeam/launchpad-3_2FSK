Team Membership/Participation
=============================

When a person joins a team, we store the relationship in the TeamMembership
table. In this table we store the membership status, the join date and the
expiry date. TeamMembership stores only direct members. However, when a 
member of a team is in fact another team (in the case of Team Y is a member
of Team X), the membership is transitive (members of Team Y are also a 
member of team X). For this reason the TeamParticipation table exists: it
represents all the people who are /effective members/ of the team.

First of all, create some teams:

    >>> import pytz
    >>> from datetime import datetime, timedelta
    >>> from canonical.lp.dbschema import (
    ...     TeamSubscriptionPolicy, TeamMembershipStatus)

XXX: This doctest needs a lot of cleanups!
-- Guilherme Salgado, 2006-12-15

    >>> from zope.component import getUtility
    >>> from canonical.launchpad.interfaces import IPersonSet
    >>> personset = getUtility(IPersonSet)
    >>> foobar = personset.getByName('name16')
    >>> reviewer = p = foobar
    >>> t1 = personset.newTeam(
    ...     foobar, 't1', 't1',
    ...     subscriptionpolicy=TeamSubscriptionPolicy.OPEN)
    >>> t2 = personset.newTeam(
    ...     foobar, 't2', 't2',
    ...     subscriptionpolicy=TeamSubscriptionPolicy.OPEN)
    >>> t3 = personset.newTeam(
    ...     foobar, 't3', 't3',
    ...     subscriptionpolicy=TeamSubscriptionPolicy.MODERATED)
    >>> t4 = personset.newTeam(
    ...     foobar, 't4', 't4',
    ...     subscriptionpolicy=TeamSubscriptionPolicy.OPEN)
    >>> t5 = personset.newTeam(
    ...     foobar, 't5', 't5',
    ...     subscriptionpolicy=TeamSubscriptionPolicy.OPEN)

One of our users (Salgado) wants to join the t3 and t4 teams.

    >>> salgado = personset.getByName('salgado')
    >>> salgado.join(t3)
    True
    >>> salgado.join(t4)
    True

But t3 is a MODERATED team, so somebody has to approve Salgado as a member:

    >>> [m.displayname for m in t4.allmembers]
    [u'Foo Bar', u'Guilherme Salgado']

    >>> [m.displayname for m in t3.allmembers]
    [u'Foo Bar']
    >>> t3.setMembershipData(salgado, TeamMembershipStatus.APPROVED, reviewer)
    >>> [m.displayname for m in t3.allmembers]
    [u'Foo Bar', u'Guilherme Salgado']

Now we add t3 as a member of t2. But t3 is a team, and because teams take no
actions, it can't actually "join" t2. Instead, an administrator of t2 has
to addMember() it.

    >>> t3.join(t2)
    Traceback (most recent call last):
    ...
    AssertionError: Teams take no actions in Launchpad...

    >>> t2.addMember(t3, reviewer)

By making t3 a member of t2, that means that all members of t3 will also be
added as a member of t2.

    >>> [m.displayname for m in t2.allmembers]
    [u'Foo Bar', u'Guilherme Salgado', u't3']

Can we add t2 as a member of t3? No, we prevent this kind of loop, and users
can't do this because our vocabularies won't allow members that would cause
loops.

    >>> t3.addMember(t2, reviewer)
    Traceback (most recent call last):
    ...
    AssertionError: Team 't3' is a member of 't2'. As a consequence, 't2' can't be added as a member of 't3'

Adding t2 as a member of t1 will add all t2 members as t1 members too.

    >>> t1.addMember(t2, reviewer)
    >>> [m.displayname for m in t1.allmembers]
    [u'Foo Bar', u'Guilherme Salgado', u't2', u't3']

Adding t2 as a member of t5 will add all t2 members as t5 members too.

    >>> t5.addMember(t2, reviewer)
    >>> [m.displayname for m in t5.allmembers]
    [u'Foo Bar', u'Guilherme Salgado', u't2', u't3']

Adding t5 and t1 as members of t4 will add all t5 and t1 members as t4 
members too.

    >>> t4.addMember(t5, reviewer)
    >>> t4.addMember(t1, reviewer)
    >>> [m.displayname for m in t4.allmembers]
    [u'Foo Bar', u'Guilherme Salgado', u't1', u't2', u't3', u't5']

After adding all this mess, this is what we have:

(This table doesn't include the team owner (Foo Bar), but since he's the
owner he's also a direct member of all teams)
=============================================================
||  Team      ||  Direct Members   ||  Indirect Members    ||
=============================================================
||   T1       ||  T2               ||  T3, Salgado         ||
||   T2       ||  T3               ||  Salgado             ||
||   T3       ||  Salgado          ||                      ||
||   T4       ||  T5, T1, Salgado  ||  T2, T3              ||
||   T5       ||  T2               ||  T3, Salgado         ||


    >>> from canonical.database.sqlbase import flush_database_updates
    >>> flush_database_updates()

t2 can't use its leave() method to leave t5 because it's a team and teams
take no actions. One of t5 administrators have to go and remove t2 from t5
if t2 shouldn't be a member of t5 anymore.

    >>> t5.setMembershipData(t2, TeamMembershipStatus.DEACTIVATED, reviewer)

Removing t2 from t5 will have implications in all teams that have t5 as a
(direct or indirect) member.

t5 had only one member and two other indirect members. Now that t2 is not its
member anymore, it doesn't have any members apart from its owner.

    >>> [m.displayname for m in t5.allmembers]
    [u'Foo Bar']

Removing t2 from t5 won't remove it from t4, because t2 is also a member of
t1, which is a member of t4.
    >>> [m.displayname for m in t4.allmembers]
    [u'Foo Bar', u'Guilherme Salgado', u't1', u't2', u't3', u't5']

Nothing changes in t1, because t5 wasn't one of its members.
    >>> [m.displayname for m in t1.allmembers]
    [u'Foo Bar', u'Guilherme Salgado', u't2', u't3']

If 'Guilherme Salgado' decides to leave t3, he'll also be removed from t1
and t2, but not from t4, because he's a direct member of t4.
    >>> salgado.leave(t3)
    >>> salgado in t1.allmembers
    False
    >>> salgado in t2.allmembers 
    False
    >>> salgado in t4.allmembers
    True


This is what we have now, after removing t2 from t5 and Salgado from t3.

(This table doesn't include the team owner (Foo Bar), but since he's the
owner he's also a direct member of all teams)
=============================================================
||  Team      ||  Members          ||  Indirect Members    ||
=============================================================
||   T1       ||  T2               ||  T3                  ||
||   T2       ||  T3               ||                      ||
||   T3       ||                   ||                      ||
||   T4       ||  T5, T1, Salgado  ||  T2, T3              ||
||   T5       ||                   ||                      ||


Now, if I add a new member to t3, will it be added to t2, t1 and t4 as well?
Let's see...

    >>> cprov = getUtility(IPersonSet).getByName('cprov')
    >>> t3.addMember(cprov, reviewer)
    >>> [m.displayname for m in t3.allmembers]
    [u'Celso Providelo', u'Foo Bar']

    >>> [m.displayname for m in t2.allmembers]
    [u'Celso Providelo', u'Foo Bar', u't3']

    >>> [m.displayname for m in t1.allmembers]
    [u'Celso Providelo', u'Foo Bar', u't2', u't3']

    >>> [m.displayname for m in t4.allmembers]
    [u'Celso Providelo', u'Foo Bar', u'Guilherme Salgado', u't1', u't2',
     u't3', u't5']


# XXX: Need to fix this
It's important to note that even if p is not a member of t5, he still retains
his rights over the team because he's the team's owner:

    >>> flush_database_updates()
    >>> p.inTeam(t5)
    True


Flagging expired memberships
----------------------------

The expired memberships are flagged by a cronscript that runs daily. This
script simply flags all active memberships which reached their expiry date as
expired.

    >>> from canonical.launchpad.database import TeamMembershipSet
    >>> from canonical.launchpad.ftests import login
    >>> login('foo.bar@canonical.com')
    >>> one_day_ago = datetime.now(pytz.timezone('UTC')) - timedelta(days=1)

Let's change the expiry date of an active membership, so we have something for
our script to flag as expired.

    >>> foobar_on_admins = TeamMembershipSet().getByPersonAndTeam(
    ...     Person.selectOneBy(name='name16'),
    ...     Person.selectOneBy(name='admins'))
    >>> foobar_on_admins.dateexpires is None
    True
    >>> foobar_on_admins.status.title
    'Administrator'
    >>> foobar_on_admins.dateexpires = one_day_ago

And here we change the expiry date of a membership that's already deactivated.
The cronscript will not change this membership, because it's not active.

    >>> sp_on_ubuntu_translators = TeamMembershipSet().getByPersonAndTeam(
    ...     Person.selectOneBy(name='name12'),
    ...     Person.selectOneBy(name='ubuntu-translators'))
    >>> sp_on_ubuntu_translators.dateexpires is None
    True
    >>> sp_on_ubuntu_translators.status.title
    'Deactivated'
    >>> sp_on_ubuntu_translators.dateexpires = one_day_ago

Now we commit the changes and run the cronscript.
XXX: flush_database_updates() shouldn't be needed. This seems to be
Bug 3989 -- StuarBishop 20060713

    >>> flush_database_updates()
    >>> transaction.commit()

    # XXX: This thing here needs a proper test
    >>> import subprocess
    >>> process = subprocess.Popen(
    ...     'cronscripts/flag-expired-memberships.py -q', shell=True,
    ...     stdin=subprocess.PIPE, stdout=subprocess.PIPE, 
    ...     stderr=subprocess.PIPE)
    >>> (out, err) = process.communicate()
    >>> out, err
    ('', '')
    >>> process.returncode
    0

Here we can see that the membership that was active is now flagged as expired
while the one that was inactive hasn't changed.

    # These two objects were updated in another transaction, so we need to
    # expire them.
    >>> foobar_on_admins.expire()
    >>> sp_on_ubuntu_translators.expire()

    >>> foobar_on_admins = TeamMembershipSet().getByPersonAndTeam(
    ...     Person.selectOneBy(name='name16'),
    ...     Person.selectOneBy(name='admins'))
    >>> foobar_on_admins.status.title
    'Expired'

    >>> sp_on_ubuntu_translators = TeamMembershipSet().getByPersonAndTeam(
    ...     Person.selectOneBy(name='name12'),
    ...     Person.selectOneBy(name='ubuntu-translators'))
    >>> sp_on_ubuntu_translators.status.title
    'Deactivated'


Querying team memberships
-------------------------

You can check a person's direct memberships by using myactivememberships:

    >>> [(membership.team.name, membership.status.title)
    ...  for membership in salgado.myactivememberships]
    [(u'admins', 'Administrator'), (u't4', 'Approved')]

And you can check which direct memberships a team has by using activememberships:

    >>> [(membership.person.name, membership.status.title)
    ...  for membership in t3.activememberships]
    [(u'cprov', 'Approved'), (u'name16', 'Administrator')]

A team has a number of other methods that return what people are members
of it, all based on Person._getMembersByStatus:

    >>> [(membership.person.name, membership.status.title)
    ...     for membership in t3.declinedmembers]
    []

(which is the same as saying

    # We want to use a private method here, so we'll remove the security
    # proxy from t3
    >>> from zope.security.proxy import removeSecurityProxy
    >>> naked_t3 = removeSecurityProxy(t3)
    >>> declined = TeamMembershipStatus.DECLINED
    >>> [(membership.person.name, membership.status.title)
    ...  for membership in naked_t3._getMembersByStatus(declined)]
    []

except shorter)

Querying a person for team participation
----------------------------------------

Team membership is direct; team participation is indirect, people being
participants of teams by virtue of being members of other teams which are in
turn members of these teams.

We can ask a person what teams they participate in. The
teams_participated_in attribute works recusively, listing all teams the
person is an active member of as well as teams those teams are an active
member of.

    >>> print '\n'.join(team.name for team in salgado.teams_participated_in)
    admins
    t4

Adding admins as a member of t1 will make Salgado a member of t1 as well.

    >>> admins = getUtility(IPersonSet).getByName('admins')
    >>> t1.addMember(admins, reviewer=t1.teamowner)
    >>> flush_database_updates()
    >>> print '\n'.join(team.name for team in salgado.teams_participated_in)
    admins
    t1
    t4

On the other hand, making t2 a member of admins won't change anything
for Salgado.

    >>> admins.addMember(t2, reviewer=admins.teamowner)
    >>> flush_database_updates()
    >>> print '\n'.join(team.name for team in salgado.teams_participated_in)
    admins
    t1
    t4

