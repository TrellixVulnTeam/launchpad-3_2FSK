= POFile =

Get evolution template for Ubuntu Hoary

>>> from zope.component import getUtility
>>> from zope.interface.verify import verifyObject
>>> from canonical.launchpad.interfaces import (
... IPOTemplateSet, ISourcePackageNameSet, IDistributionSet, IPOFile)
>>> sourcepackagenameset = getUtility(ISourcePackageNameSet)
>>> sourcepackagename = sourcepackagenameset['evolution']
>>> distributionset = getUtility(IDistributionSet)
>>> distribution = distributionset['ubuntu']
>>> release = distribution['hoary']
>>> potemplateset = getUtility(IPOTemplateSet)
>>> potemplatesubset = potemplateset.getSubset(
...     distrorelease=release, sourcepackagename=sourcepackagename)
>>> potemplate = potemplatesubset['evolution-2.2']

Get Xhosa translation

>>> pofile = potemplate.getPOFileByLang('xh')
>>> dummy_pofile = potemplate.getDummyPOFile('pt_BR')

Both implement the IPOFile interface:

>>> verifyObject(IPOFile, pofile)
True

>>> verifyObject(IPOFile, dummy_pofile)
True

Get the set of POTMsgSets that are untranslated.

>>> potmsgsets = list(pofile.getPOTMsgSetUntranslated())
>>> len(potmsgsets)
22

Get Spanish translation

>>> pofile = potemplate.getPOFileByLang('es')

Get the set of POTMsgSets that are untranslated.

>>> potmsgsets = list(pofile.getPOTMsgSetUntranslated())
>>> len(potmsgsets)
13

Test that the header is updated.

>>> from canonical.launchpad.components.poparser import POHeader

This is the comment.

>>> comment = ' This is the top comment.'

This is the new header.

>>> msgstr = '''Project-Id-Version: es
... POT-Creation-Date: 2004-08-18 11:10+0200
... PO-Revision-Date: 2005-08-18 13:22+0000
... Last-Translator: Carlos Perelló Marín <carlos@canonical.com>
... Language-Team: Spanish <traductores@es.gnome.org>
... MIME-Version: 1.0
... Content-Type: text/plain; charset=UTF-8
... Content-Transfer-Encoding: 8bit
... Report-Msgid-Bugs-To: serrador@hispalinux.es
... Plural-Forms: nplurals=2; plural=n != 1;'''

Now, get a POHeader object with that information.

>>> new_header = POHeader(commentText=comment, msgstr=msgstr)
>>> new_header.updateDict()

We check that the plural forms expression is correctly parsed:

>>> new_header.getPluralFormExpression() == 'n != 1'
True

To be sure the new header is being applied, here we have the old values:

>>> print pofile.topcomment.encode('utf-8')
traducción de es.po al Spanish
translation of es.po to Spanish
...

>>> print pofile.header.encode('utf-8')
Project-Id-Version: es
POT-Creation-Date: 2004-08-17 11:10+0200
PO-Revision-Date: 2005-04-07 13:22+0000
...
Plural-Forms: nplurals=2; plural=(n != 1);

>>> pofile.fuzzyheader
True

Now, is time to change the old header with the new one.

>>> pofile.updateHeader(new_header)

And the new values:

>>> pofile.topcomment
u' This is the top comment.'

>>> print pofile.header.encode('utf-8')
Project-Id-Version: es
POT-Creation-Date: 2004-08-18 11:10+0200
PO-Revision-Date: 2005-08-18 13:22+0000
...
Plural-Forms: nplurals=2; plural=n != 1;

>>> pofile.fuzzyheader
False

Now I'm going to test creating a header with invalid plural-forms and
trying to parse the number and type of plural forms it has.

>>> msgstr = '''Project-Id-Version: es
... POT-Creation-Date: 2004-08-18 11:10+0200
... PO-Revision-Date: 2005-08-18 13:22+0000
... Last-Translator: Carlos Perelló Marín <carlos@canonical.com>
... Language-Team: Spanish <traductores@es.gnome.org>
... MIME-Version: 1.0
... Content-Type: text/plain; charset=UTF-8
... Content-Transfer-Encoding: 8bit
... Report-Msgid-Bugs-To: serrador@hispalinux.es
... Plural-Forms: n != 1'''
>>> new_header = POHeader(msgstr=msgstr)
>>> new_header.updateDict()
WARNING:root:The plural form header has an unknown error. Using the default value...
>>> new_header.getPluralFormExpression() == None
True


== isPORevisionDateOlder ==

This method helps to compare two PO files header and decide if the given one
is older than the one we have in the IPOFile object. We are using this
method, for instance, to know if a new imported PO file should be ignored
because we already have a newer one.

This test is to be sure that the date comparation is working and that two
headers with the same date will always be set as newer because lazy
translators forget to update that field from time to time and sometimes we
were losing translations because we were ignoring those imports too.

    >>> from canonical.launchpad.components.poparser import POHeader

    >>> print pofile.header.encode('utf-8')
    Project-Id-Version: es
    ...
    PO-Revision-Date: 2005-08-18 13:22+0000
    ...

First, we check with the same date.

    >>> header = POHeader(msgstr=u'PO-Revision-Date: 2005-08-18 13:22+0000')
    >>> header.updateDict()
    WARNING:root:PO file header entry has no content-type field
    >>> pofile.isPORevisionDateOlder(header)
    False

Now, we check with a date that is in the past.

    >>> header = POHeader(msgstr=u'PO-Revision-Date: 2005-08-18 13:21+0000')
    >>> header.updateDict()
    WARNING:root:PO file header entry has no content-type field
    >>> pofile.isPORevisionDateOlder(header)
    True

== canEditTranslations ==

This method determines if someone is allowed to edit translations.

Do some needed imports.

    >>> from canonical.launchpad.interfaces import ILaunchpadCelebrities
    >>> from canonical.launchpad.interfaces import IPersonSet
    >>> from canonical.launchpad.interfaces import IProductSet
    >>> from canonical.launchpad.interfaces import ITranslationGroupSet
    >>> from canonical.launchpad.database import POFile
    >>> from canonical.launchpad.ftests import login
    >>> from canonical.lp.dbschema import TranslationPermission
    >>> person_set = getUtility(IPersonSet)

Need extra permissions to change the values.

    >>> login('carlos@canonical.com')

Set a translation group to test the CLOSED mode. This mode allows translations
only from the teams set as official translators.

    >>> product = getUtility(IProductSet).getByName('evolution')
    >>> product.translationgroup = getUtility(
    ...     ITranslationGroupSet)['testing-translation-team']
    >>> product.translationpermission = TranslationPermission.CLOSED

Get the IPOFile we are going to use.

    >>> product_series = product.translatable_series[0]
    >>> potemplate = product_series.getPOTemplate('evolution-2.2')
    >>> pofile_es = potemplate.getPOFileByLang('es')

A Launchpad admin must have permission always.

    >>> admins = getUtility(ILaunchpadCelebrities).admin
    >>> pofile_es.canEditTranslations(admins)
    True

A Rosetta Expert too.

    >>> rosetta_experts = getUtility(ILaunchpadCelebrities).rosetta_expert
    >>> pofile_es.canEditTranslations(rosetta_experts)
    True

And Valentina Commissari, as member of the Spanish translation team for
evolution should also have rights.

    >>> valentina = person_set.getByName('tsukimi')
    >>> pofile_es.canEditTranslations(valentina)
    True

But the unprivileged account should not.

    >>> no_priv = person_set.getByName('no-priv')
    >>> pofile_es.canEditTranslations(no_priv)
    False

Now, we get an IPOFile that does not have a translation team assigned.

    >>> pofile_cy = potemplate.getDummyPOFile('cy')

Valentina Commissari is not a translator for this language and does not
have permissions.

    >>> pofile_cy.canEditTranslations(valentina)
    False

And same thing with the unprivileged account.

    >>> pofile_cy.canEditTranslations(no_priv)
    False

Now, let's test the STRUCTURED mode. In this mode, only the defined
translation teams can translate like the CLOSE mode, but in addition, if we
don't have any language team for one language, anyone can add translations.

    >>> product.translationpermission = TranslationPermission.STRUCTURED

Valentina Commissari, as member of the Spanish translation team for
evolution should have rights for the Spanish IPOFile.

    >>> pofile_es.canEditTranslations(valentina)
    True

But the unprivileged account should not.

    >>> pofile_es.canEditTranslations(no_priv)
    False

And this is the difference with the CLOSED mode, anyone will be able to
translate into Welsh, as we can see with Valentina:

    >>> pofile_cy.canEditTranslations(valentina)
    True

And same thing with the unprivileged account.

    >>> pofile_cy.canEditTranslations(no_priv)
    True

Finally, let's check the OPEN mode to be 100% sure that in that mode
anyone can do translations.

    >>> product.translationgroup = None
    >>> product.translationpermission = TranslationPermission.OPEN

We don't have any translation group for the Evolution product so there are
no translators assigned to it, but Valentina Commissari still has rights to
do translations.

    >>> pofile_es.canEditTranslations(valentina)
    True

And samething with the unprivileged account.

    >>> pofile_es.canEditTranslations(no_priv)
    True

== uncachedExport ==

This method serializes an IPOFile as a .po file.

Get a concrete POFile we know doesn't have a UTF-8 encoding.

    >>> pofile = POFile.get(24)
    >>> print pofile.header
    Project-Id-Version: PACKAGE VERSION
    ...
    Content-Type: text/plain; charset=EUC-JP
    ...

Now, let's export it with its default encoding.

    >>> stream = pofile.uncachedExport()
    >>> stream_list = stream.splitlines()

The header is not changed.

    >>> stream_list[23]
    '"Content-Type: text/plain; charset=EUC-JP\\n"'

And checking one of the translations, we can see that it's using the EUC-JP
encoding.

    >>> stream_list[30]
    'msgstr "\xc0\xdf\xc4\xea\xa4\xce\xa5\xab\xa5\xb9\xa5\xbf\xa5\xde\xa5\xa4\xa5\xba\xa4\xcb /etc/mozilla/prefs.js \xa4\xac\xcd\xf8\xcd\xd1\xa4\xc7\xa4\xad\xa4\xde\xa4\xb9\xa1\xa3"'


Now, let's force the UTF-8 encoding.

    >>> stream = pofile.uncachedExport(force_utf8=True)
    >>> stream_list = stream.splitlines()

We can see that the header has been updated to have UTF-8

    >>> stream_list[23]
    '"Content-Type: text/plain; charset=UTF-8\\n"'

And the encoding used is also using UTF-8 chars.

    >>> stream_list[30]
    'msgstr "\xe8\xa8\xad\xe5\xae\x9a\xe3\x81\xae\xe3\x82\xab\xe3\x82\xb9\xe3\x82\xbf\xe3\x83\x9e\xe3\x82\xa4\xe3\x82\xba\xe3\x81\xab /etc/mozilla/prefs.js \xe3\x81\x8c\xe5\x88\xa9\xe7\x94\xa8\xe3\x81\xa7\xe3\x81\x8d\xe3\x81\xbe\xe3\x81\x99\xe3\x80\x82"'

== getPOTMsgSetUntranslated ==

The POTMsgSet that are untranslated are the ones that are not complete and
that aren't fuzzy.

If a POTMsgSet doesn't have a POMsgSet for a concrete translation, we take
that as not bein complete too.

    >>> untranslated_potmsgset = pofile_es.getPOTMsgSetUntranslated()
    >>> untranslated_potmsgset.count()
    13

    >>> for potmsgset in untranslated_potmsgset:
    ...     pomsgset = potmsgset.getPOMsgSet(
    ...         pofile_es.language.code, pofile_es.variant)
    ...     assert (pomsgset is None or
    ...             (pomsgset.iscomplete == False and
    ...              pomsgset.isfuzzy == False))


== createMessageSetFromText ==

This method returns a new IPOMsgSet for the associated text.

Let's get the IPOFile we are going to use for this test.

  >>> pofile_sr = potemplate.newPOFile('sr')

And the msgid we are looking for.

  >>> msgid = u'Found %i invalid file.'

Now, just to be sure that this entry doesn't exist yet:

  >>> pofile_sr.getPOMsgSet(msgid) is None
  True

Is time to create it.

  >>> pomsgset = pofile_sr.createMessageSetFromText(msgid)

As we can see, is the msgid we were looking for.

  >>> pomsgset.potmsgset.primemsgid_.msgid == msgid
  True

This entry is in fact one that is not used anymore, that means, its sequence
is zero.

  >>> pomsgset.potmsgset.sequence
  0

Also, as we just created it, it shouldn't have any translation.

  >>> pomsgset.active_texts
  [None, None, None]
  >>> pomsgset.published_texts
  [None, None, None]

== export and validExportCache ==

The export method is used to get a .po file from our database rows. It's
strongly related with validExportCache, which drives whether the export
should be a full export from our database or just return an already
cached value.

  # Get hold of a PO file which has been exported before.
  >>> from canonical.launchpad.database import POFile
  >>> pofile = POFile.get(1)

The way to know whether there is a previous export is to have a value in
IPOFile.exportfile. That's a link to a librarian file containing a cached
export.

  >>> pofile.exportfile is None
  False
  >>> old_cached_file_id = pofile.exportfile.id

However, it would be old, so it doesn't have a valid cache.

  >>> pofile.validExportCache()
  False

Now ask it to export itself.

  >>> export = pofile.export()
  >>> export.split('\n')[0]
  '# traducci\xc3\xb3n de es.po al Spanish'

  # Now, because of a SQLObject quirk, we need to call .sync() on the PO file.
  # This is because calling .export() has set pofile.exporttime to the magic
  # constant UTC_NOW. This would normally be fine, as the attribute would not
  # normally be accessed again in the same SQLObject session, and it would
  # appear as a datetime value the next time around. However, in this case, we
  # need to access it immediately, so we need to write it to the database and
  # read it back again.
  >>> pofile.sync()

Because the PO file has been exported, it will have updated the cache.

  >>> pofile.validExportCache()
  True

Which is different than previous one:

  >>> old_cached_file_id != pofile.exportfile.id
  True
  >>> old_cached_file_id = pofile.exportfile.id

  # In order to have different datetimes for the export time of the pofile,
  # and for any new stuff we do, lets commit a transaction.
  >>> transaction.commit()

validExportCache method detects any translation change done in the IPOFile and
invalidates the cache.

  # We can see current value before we do a change, so we are completely sure
  # that the exported file includes the modification.
  >>> print export.decode('UTF-8')
  #...
  #: addressbook/addressbook-errors.xml.h:6
  msgid "Failed to authenticate with LDAP server."
  msgstr ""
  ...

  # Let's update a translation to the PO file.
  >>> from canonical.launchpad.database import Person
  >>> person = Person.get(1)
  >>> msgid = u"Failed to authenticate with LDAP server."
  >>> msgset = pofile.getPOMsgSet(msgid)
  >>> print msgset.active_texts
  [None]
  >>> import datetime
  >>> import pytz
  >>> UTC = pytz.timezone('UTC')
  >>> msgset.updateTranslationSet(person, {0: 'Blah.'}, fuzzy=False,
  ...     published=False, lock_timestamp=datetime.datetime.now(UTC))
  >>> print msgset.active_texts
  [u'Blah.']
  >>> txt = msgset.active_texts[0]

  # We need to sync the changed objects for the same reason as before.
  >>> msgset.sync()

  >>> pofile.validExportCache()
  False

Another export run generates a new cached file that contains that new
translation.

  >>> export = pofile.export()
  >>> export is not None
  True

  # And we can see that it's applied in the exported file.
  >>> print export.decode('UTF-8')
  #...
  #: addressbook/addressbook-errors.xml.h:6
  msgid "Failed to authenticate with LDAP server."
  msgstr "Blah."
  ...
  >>> old_cached_file_id != pofile.exportfile.id
  True
  >>> pofile.validExportCache()
  True

There is a corner case in the way we check that the cached export is valid.
When the IPOFile has no submissions at all we don't have a way to know
when was last time that a translation was updated, because there are no
translations.

This tests two specific things:

 - That a PO file with no translations can be exported.
 - The situation where there is a cached export for a file with no
   translations, and there is no submission which we can use to check the
   cache's validity.

  >>> empty_pofile = pofile.potemplate.newPOFile('cy')
  >>> empty_pofile.last_touched_pomsgset is None
  True
  >>> empty_pofile.validExportCache()
  False

  # There is something exported.
  >>> len(empty_pofile.export()) > 0
  True

XXX DaniloSegan 20070115: we're currently unable to track cache status
for empty PO files, since this is similar to case of a single deactivated
translation.

  >>> empty_pofile.validExportCache()
  False

Also, the export is robust enough to handle a situation where Librarian is not
available.

  # To demonstrate it, we are going to shutdown Librarian.
  >>> from canonical.testing import LibrarianLayer
  >>> LibrarianLayer.hide()

At this point, librarian is not available, but the export is still working.

  >>> pofile = POFile.get(1)
  >>> pofile.validExportCache()
  True
  >>> old_cached_file_id = pofile.exportfile.id
  >>> len(pofile.export()) > 0
  ERROR:root:Error fetching a cached file from librarian
  Traceback (most recent call last):
  ...
  LookupError: ...
  WARNING:root:Error uploading a cached file into librarian
  ...
  UploadFailed: (111, 'Connection refused')
  True

Although the cache is still pointing to previous value because it cannot be
updated.

  >>> pofile.exportfile.id == old_cached_file_id
  True

Even when we there is no cached file, the export will work and will not be
stored due the problem with Librarian.

  >>> pofile.invalidateCache()
  >>> len(pofile.export()) > 0
  WARNING:root:Error uploading a cached file into librarian
  ...
  UploadFailed: (111, 'Connection refused')
  True
  >>> pofile.validExportCache()
  False

  # We restore now Librarian
  >>> LibrarianLayer.reveal()

When an IPOFile has the wrong encoding defined in its header, the system
exports it as UTF-8

  >>> pofile.header = 'Content-Type: text/plain; charset=broken\n'
  >>> pofile.sync()
  >>> export_content = pofile.export()
  >>> unicode(export_content)
  Traceback (most recent call last):
  ...
  UnicodeDecodeError: ...
  >>> print export_content.decode('UTF-8')
  #...
  "Content-Type: text/plain; charset=UTF-8\n"
  ...

== getPOTMsgSetChangedInLaunchpad ==

This method returns only those POTMsgSet's which contain translation
submissions through Launchpad which change existing published translations.

Lets get Evolution Spanish translation in distribution Hoary.

  >>> sourcepackagenameset = getUtility(ISourcePackageNameSet)
  >>> sourcepackagename = sourcepackagenameset['evolution']
  >>> distributionset = getUtility(IDistributionSet)
  >>> distribution = distributionset['ubuntu']
  >>> release = distribution['hoary']
  >>> potemplateset = getUtility(IPOTemplateSet)
  >>> potemplatesubset = potemplateset.getSubset(
  ...     distrorelease=release, sourcepackagename=sourcepackagename)
  >>> potemplate = potemplatesubset['evolution-2.2']
  >>> pofile_changed = potemplate.getPOFileByLang('es')

This translation file already contains one message which has been changed in
Launchpad.

  >>> potmsgsets = list(pofile_changed.getPOTMsgSetChangedInLaunchpad())
  >>> len(potmsgsets)
  1

We make sure that submissions on untranslated strings are not considered
'changed in Launchpad', since this method is mainly designed to help
translators revert translations to published translations.

Lets get a single untranslated POTMsgSet.

  >>> untranslated = list(pofile_changed.getPOTMsgSetUntranslated())[0]
  >>> untranslated is None
  False
  >>> pomsgset = pofile_changed.getPOMsgSet(untranslated.primemsgid_.msgid)
  >>> pomsgset is None
  False

Now, lets provide a translation for it.

  >>> import datetime
  >>> import pytz
  >>> UTC = pytz.timezone('UTC')
  >>> pomsgset.updateTranslationSet(
  ...     pofile_changed.owner, {0: u'sample translation'}, fuzzy=False,
  ...     published=False, lock_timestamp=datetime.datetime.now(UTC))

And make sure that the count of changed in Launchpad hasn't changed.

  >>> potmsgsets = list(pofile_changed.getPOTMsgSetChangedInLaunchpad())
  >>> len(potmsgsets)
  1

Now, lets change translation for a message which already has a published
translation.  First we need to find a message with active, published
translation:

  >>> for pomsgset in pofile_changed:
  ...     submission = pomsgset.getPublishedSubmission(0)
  ...     if submission and submission.active:
  ...         break
  >>> pomsgset is None
  False

Lets re-translate that:

  >>> pomsgset.updateTranslationSet(
  ...     pofile_changed.owner, {0: u'new translation'}, fuzzy=False,
  ...     published=False, lock_timestamp=datetime.datetime.now(UTC))

And make sure that the count of messages changed in Launchpad _has_ changed:

  >>> potmsgsets = list(pofile_changed.getPOTMsgSetChangedInLaunchpad())
  >>> len(potmsgsets)
  2

= POFile Security tests =

Import the function that will help us to do this test.

    >>> from canonical.launchpad.webapp.authorization import check_permission

A Launchpad admin must have permission to edit an IPOFile always.
    >>> login('foo.bar@canonical.com')
    >>> check_permission('launchpad.Edit', pofile)
    True

And a Rosetta Expert too.

    >>> login('jordi@ubuntu.com')
    >>> check_permission('launchpad.Edit', pofile)
    True

And that's all, folks!
