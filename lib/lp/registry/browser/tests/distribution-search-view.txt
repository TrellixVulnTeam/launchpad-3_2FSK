== DistributionPackageSearchView ==

The DistributionPackageSearchView adds some functionality to the base
PackageSearchView class, specifically for making the results more useful.

By default the view will be initialized as a binary-package-name search,
and the search_by_binary_name property is used to determine the search
type (in templates):

    >>> from lp.registry.interfaces.distribution import IDistributionSet
    >>> ubuntu = getUtility(IDistributionSet)['ubuntu']
    >>> distro_pkg_search_view = create_initialized_view(
    ...     ubuntu, name="+search")
    >>> distro_pkg_search_view.search_by_binary_name
    True

But users can specify that the search should be on source-package-names
instead:

    >>> distro_pkg_search_view = create_initialized_view(
    ...     ubuntu, name="+search", form={'search_type': 'source'})
    >>> distro_pkg_search_view.search_by_binary_name
    False

Unless the distribution being searched does not support binaries, in which
cases it will always be on source:

    >>> debian = factory.makeDistribution(
    ...     name='mydebian', displayname='debian-without-binaries')

    >>> debian.has_published_binaries
    False

    >>> distro_pkg_search_view = create_initialized_view(
    ...     debian, name="+search", form={'search_type': 'binary'})
    >>> distro_pkg_search_view.search_by_binary_name
    False


=== Exact matches ===

The DistributionPackageSearchView view has an exact_matches property
and a has_exact_matches property which are used to find packages that
match exactly on the binary/source name.

First, we'll create a binary 'mozilla-firefox' for the source package
'my-branded-browser' and then update the package cache.

    >>> from lp.soyuz.tests.test_publishing import (
    ...     SoyuzTestPublisher)
    >>> login('foo.bar@canonical.com')
    >>> test_publisher = SoyuzTestPublisher()
    >>> test_publisher.prepareBreezyAutotest()
    >>> my_branded_browser = test_publisher.getPubSource(
    ...     sourcename='my-branded-browser')
    >>> mozilla_firefox_bins = test_publisher.getPubBinaries(
    ...     binaryname='mozilla-firefox', pub_source=my_branded_browser)
    >>> mozilla_firefox_bins[0].binarypackagerelease.sourcepackagename
    u'my-branded-browser'
    >>> archive = test_publisher.distroseries.main_archive
    >>> import transaction
    >>> from canonical.testing.layers import LaunchpadZopelessLayer
    >>> from canonical.config import config
    >>> LaunchpadZopelessLayer.switchDbUser(config.uploadqueue.dbuser)

    Let's use a fake logger object:

    >>> class TestLog:
    ...     def debug(self, msg):
    ...         print 'DEBUG: %s' % msg

    >>> test_publisher.distroseries.removeOldCacheItems(
    ...     archive=archive, log=TestLog())

    >>> test_publisher.distroseries.updateCompletePackageCache(
    ...     archive=archive, ztm=transaction, log=TestLog())
    DEBUG: Considering binary 'mozilla-firefox'
    DEBUG: Creating new binary cache entry.
    DEBUG: Considering binary version 666
    1
    >>> LaunchpadZopelessLayer.switchDbUser('launchpad')

In the following example, there
are two source packages that have a binary with the exact name
'mozilla-firefox':

    >>> distro_pkg_search_view = create_initialized_view(
    ...     ubuntu, name="+search", form={'text': 'mozilla-firefox'})
    >>> distro_pkg_search_view.has_exact_matches
    True
    >>> for package in distro_pkg_search_view.exact_matches:
    ...     print package.name
    mozilla-firefox
    my-branded-browser

The DistributionPackageSearchView also has a helper property to
help templates print the list of distroseries that an exactly-matched
package is available in:

    >>> distro_pkg_search_view.distroseries_names
    {u'mozilla-firefox': u'warty', u'my-branded-browser': u'breezyautotest'}
    >>> distro_pkg_search_view = create_initialized_view(
    ...     ubuntu, name="+search", form={'text': 'foobar'})
    >>> distro_pkg_search_view.distroseries_names

Another helper on the DistributionPackageSearchView is the
matching_binary_names property which can be used by templates to get
a list of the binary names that matched the search term for each
package:



