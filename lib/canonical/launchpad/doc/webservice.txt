= RESTful Web Services =

LAZR builds on Zope conventions to make it easy to expose your model
objects as RESTful HTTP resources. I'll demonstrate these features by
defining a model for managing recipes, and then publishing the model
objects as resources through a web service.

# XXX leonardr 2008-04-23 bug=221037: This test should be moved to
# launchpad/doc and made to run without layers.

== Example model objects ==

Here's the interface for a simple set of model objects. This is the
kind of model object you'd find in any Zope application, with no
special knowledge of web services. The model is of a group of
cookbooks. Each cookbook has a known person as the author. Each
cookbook contains multiple recipes. A recipe is a recipe _for_ a dish,
and two or more cookbooks may provide different recipes for the same
dish. Users may comment on cookbooks and on individual recipes.

    # All classes defined in this test are new-style classes.
    >>> __metaclass__ = type

    >>> from zope.interface import Interface, Attribute
    >>> from zope.schema import Bool, Bytes, Int, Text, TextLine, Object

    >>> class IAuthor(Interface):
    ...     name = TextLine(title=u"Name", required=True)
    ...     # favorite_recipe.schema will be set to IRecipe once
    ...     # IRecipe is defined.
    ...     favorite_recipe = Object(schema=Interface)
    ...     popularity = Int(readonly=True)

    >>> class ICommentTarget(Interface):
    ...     comments = Attribute('List of comments about this object.')

    >>> class IComment(Interface):
    ...     target = Attribute('The object containing this comment.')
    ...     text = TextLine(title=u"Text", required=True)

    >>> class ICookbook(ICommentTarget):
    ...     name = TextLine(title=u"Name", required=True)
    ...     author = Object(schema=IAuthor)
    ...     cuisine = TextLine(title=u"Cuisine", required=False, default=None)
    ...     recipes = Attribute("List of recipes published in this cookbook.")
    ...     cover = Bytes(0, 5000, title=u"An image of the cookbook's cover.")

    >>> class IDish(Interface):
    ...     name = TextLine(title=u"Name", required=True)
    ...     recipes = Attribute("List of recipes for this dish.")

    >>> class IRecipe(ICommentTarget):
    ...     id = Int(title=u"Unique ID", required=True)
    ...     dish = Object(schema=IDish)
    ...     cookbook = Object(schema=ICookbook)
    ...     instructions = Text(title=u"How to prepare the recipe.",
    ...         required=True)
    ...     private = Bool(title=u"Whether the public can see this recipe.",
    ...                    default=False)

    >>> IAuthor['favorite_recipe'].schema = IRecipe

Here's the interface for the 'set' objects that manage the authors,
cookbooks, and dishes. The inconsistent naming is intentional.

    >>> class IAuthorSet(Interface):
    ...     def getAllAuthors(self):
    ...         "Get all authors."
    ...
    ...     def getAuthor(self, name):
    ...         "Retrieve a single author by name."

    >>> class ICookbookSet(Interface):
    ...     def getAll(self):
    ...         "Get all cookbooks."
    ...
    ...     def get(self, name):
    ...         "Retrieve a single cookbook by name."
    ...
    ...     def findRecipes(self, name):
    ...         "Find recipes with a given name, across cookbooks."

    >>> class IDishSet(Interface):
    ...     def getAll(self):
    ...         "Get all dishes."
    ...
    ...     def get(self, name):
    ...         "Retrieve a single dish by name."


Here are simple implementations of IAuthor, IComment, ICookbook, IDish,
and IRecipe.

    >>> from zope.security.checker import CheckerPublic
    >>> from zope.interface import implements
    >>> from canonical.lazr.security import protect_schema

    >>> class Author:
    ...     implements(IAuthor)
    ...     def __init__(self, name):
    ...         self.name = name
    ...         self.favorite_recipe = None
    ...         self.popularity = 1
    >>> protect_schema(Author, IAuthor, write_permission=CheckerPublic)

    >>> class Comment(object):
    ...     implements(IComment)
    ...     def __init__(self, target, text):
    ...         self.target = target
    ...         self.text = text
    ...         self.target.comments.append(self)
    >>> protect_schema(Comment, IComment, write_permission=CheckerPublic)

    >>> class Cookbook:
    ...     implements(ICookbook)
    ...     def __init__(self, name, author, cuisine=None):
    ...         self.name = name
    ...         self.author = author
    ...         self.recipes = []
    ...         self.comments = []
    ...         self.cuisine = cuisine
    ...         self.cover = None
    >>> protect_schema(Cookbook, ICookbook, write_permission=CheckerPublic)

    >>> class Dish:
    ...     implements(IDish)
    ...     def __init__(self, name):
    ...         self.name = name
    ...         self.recipes = []
    >>> protect_schema(Dish, IDish, write_permission=CheckerPublic)

    >>> class Recipe:
    ...     implements(IRecipe)
    ...     def __init__(self, id, cookbook, dish, instructions,
    ...                  private=False):
    ...         self.id = id
    ...         self.cookbook = cookbook
    ...         self.cookbook.recipes.append(self)
    ...         self.dish = dish
    ...         self.dish.recipes.append(self)
    ...         self.instructions = instructions
    ...         self.comments = []
    ...         self.private = private
    >>> protect_schema(Recipe, IRecipe, read_permission='launchpad.View',
    ...                write_permission=CheckerPublic)

Here are the "model objects" themselves:

    >>> A1 = Author(u"Julia Child")
    >>> A2 = Author(u"Irma S. Rombauer")
    >>> A3 = Author(u"James Beard")
    >>> AUTHORS = [A1, A2, A3]

    >>> C1 = Cookbook(u"Mastering the Art of French Cooking", A1)
    >>> C2 = Cookbook(u"The Joy of Cooking", A2)
    >>> C3 = Cookbook(u"James Beard's American Cookery", A3)
    >>> COOKBOOKS = [C1, C2, C3]

    >>> D1 = Dish("Roast chicken")
    >>> C1_D1 = Recipe(1, C1, D1, u"You can always judge...")
    >>> C2_D1 = Recipe(2, C2, D1, u"Draw, singe, stuff, and truss...")
    >>> C3_D1 = Recipe(3, C3, D1, u"A perfectly roasted chicken is...")

    >>> D2 = Dish("Baked beans")
    >>> C2_D2 = Recipe(4, C2, D2, "Preheat oven to...")
    >>> C3_D2 = Recipe(5, C3, D2, "Without doubt the most famous...", True)

    >>> D3 = Dish("Foies de voilaille en aspic")
    >>> C1_D3 = Recipe(6, C1, D3, "Chicken livers sauteed in butter...")

    >>> COM1 = Comment(C2_D1, "Clear and concise.")
    >>> COM2 = Comment(C2, "A kitchen staple.")

    >>> A1.favorite_recipe = C1_D1
    >>> A2.favorite_recipe = C2_D2
    >>> A3.favorite_recipe = C3_D2

Here's a simple CookbookSet with a predefined list of cookbooks.

    >>> from zope.component import provideUtility
    >>> class CookbookSet:
    ...     implements(ICookbookSet)
    ...     def __init__(self):
    ...         self.cookbooks = COOKBOOKS
    ...
    ...     def newCookbook(self, author_name, title, cuisine):
    ...         authors = AuthorSet()
    ...         author = authors.getAuthor(author_name)
    ...         if author is None:
    ...             author = authors.newAuthor(author_name)
    ...         cookbook = Cookbook(title, author, cuisine)
    ...         self.cookbooks.append(cookbook)
    ...         return cookbook
    ...
    ...     def getAll(self):
    ...         return self.cookbooks
    ...
    ...     def get(self, name):
    ...         match = [c for c in self.cookbooks if c.name == name]
    ...         if len(match) > 0:
    ...             return match[0]
    ...         return None
    ...
    ...     def findRecipes(self, name):
    ...         """Find recipes for a given dish across cookbooks."""
    ...         matches = []
    ...         for c in self.cookbooks:
    ...             for r in c.recipes:
    ...                 if r.dish.name == name:
    ...                     matches.append(r)
    ...                     break
    ...         # A somewhat arbitrary and draconian bit of error handling
    ...         # for the sake of demonstration.
    ...         if len(matches) == 0:
    ...             raise ValueError("No matches for %s" % name)
    ...         return matches
    >>> protect_schema(CookbookSet, ICookbookSet)
    >>> provideUtility(CookbookSet(), ICookbookSet)

Here's a simple AuthorSet with predefined authors.

    >>> class AuthorSet:
    ...     implements(IAuthorSet)
    ...     def __init__(self):
    ...         self.authors = AUTHORS
    ...
    ...     def newAuthor(self, name):
    ...         author = Author(name)
    ...         self.authors.append(author)
    ...         return author
    ...
    ...     def getAllAuthors(self):
    ...         return self.authors
    ...
    ...     def getAuthor(self, name):
    ...         match = [p for p in self.authors if p.name == name]
    ...         if len(match) > 0:
    ...             return match[0]
    ...         return None
    >>> protect_schema(AuthorSet, IAuthorSet)
    >>> provideUtility(AuthorSet(), IAuthorSet)

Here's a vocabulary of authors, for a field that presents a Choice
among authors.

    >>> from zope.schema.interfaces import IVocabulary
    >>> class AuthorVocabulary:
    ...     implements(IVocabulary)
    ...     def __iter__(self):
    ...         """Iterate over the authors."""
    ...         return AuthorSet().getAllAuthors().__iter__()
    ...
    ...     def __len__(self):
    ...         """Return the number of authors."""
    ...         return len(AuthorSet().getAllAuthors())
    ...
    ...     def getTerm(self, name):
    ...         """Retrieve an author by name."""
    ...         return AuthorSet().getAuthor(name)

Finally, a simple DishSet with predefined dishes.

    >>> class DishSet:
    ...     implements(IDishSet)
    ...     def __init__(self):
    ...         self.dishes = [D1, D2, D3]
    ...
    ...     def getAll(self):
    ...         return self.dishes
    ...
    ...     def get(self, name):
    ...         match = [d for d in self.dishes if d.name == name]
    ...         if len(match) > 0:
    ...             return match[0]
    ...         return None
    >>> protect_schema(DishSet, IDishSet)
    >>> provideUtility(DishSet(), IDishSet)


== Security ==

Here's an IAuthorization implementation for our business objects. Its
lenient policy makes it possible, in general, for users to see the
objects.

    >>> from canonical.launchpad.webapp.interfaces import IAuthorization
    >>> from zope.component import provideAdapter
    >>> class OpenAuthorization:
    ...     implements(IAuthorization)
    ...     def __init__(self, context):
    ...         pass
    ...
    ...     def checkUnauthenticated(self):
    ...         return True
    ...
    ...     def checkAuthenticated(self, user):
    ...         return True
    >>> provideAdapter(OpenAuthorization, [IAuthor],
    ...                IAuthorization, name='launchpad.View')
    >>> provideAdapter(OpenAuthorization, [IComment],
    ...                IAuthorization, name='launchpad.View')
    >>> provideAdapter(OpenAuthorization, [ICookbook],
    ...                IAuthorization, name='launchpad.View')
    >>> provideAdapter(OpenAuthorization, [IDish],
    ...                IAuthorization, name='launchpad.View')

Here's an different IAuthorization implementation for IRecipe. This
will prevent unauthenticated users from seeing private recipes.

    >>> class PublicOnlyAuthorization:
    ...     implements(IAuthorization)
    ...     def __init__(self, context):
    ...         self.context = context
    ...
    ...     def checkUnauthenticated(self):
    ...         return not self.context.private
    ...
    ...     def checkAuthenticated(self, user):
    ...         return True
    >>> provideAdapter(PublicOnlyAuthorization, [IRecipe],
    ...                IAuthorization, name='launchpad.View')


== Navigation ==

The web service uses the standard Navigation components to map URLs to
components to publish (see navigation.txt) and the standard
ICanonicalUrlData to map content object back to URL (see
canonical_url.txt).

The navigation for these components:

    >>> from urllib import unquote
    >>> from canonical.launchpad.webapp.publisher import (
    ...     Navigation, stepthrough)
    >>> from zope.publisher.interfaces.browser import (
    ...     IBrowserPublisher, IDefaultBrowserLayer)

    >>> def register_navigation(navigation, for_):
    ...     provideAdapter(navigation, [for_, IDefaultBrowserLayer],
    ...         IBrowserPublisher)

    >>> class DishSetNavigation(Navigation):
    ...     def traverse(self, name):
    ...         return self.context.get(unquote(name))
    >>> register_navigation(DishSetNavigation, IDishSet)

    >>> class AuthorSetNavigation(Navigation):
    ...     def traverse(self, name):
    ...         return self.context.getAuthor(unquote(name))
    >>> register_navigation(AuthorSetNavigation, IAuthorSet)

    >>> class CookbookSetNavigation(Navigation):
    ...     def traverse(self, name):
    ...         return self.context.get(unquote(name))
    >>> register_navigation(CookbookSetNavigation, ICookbookSet)

    >>> class CookbookNavigation(Navigation):
    ...     @stepthrough('comments')
    ...     def traverse_comments(self, name):
    ...         try:
    ...             return self.context.comments[int(name)-1]
    ...         except (IndexError, TypeError, ValueError):
    ...             return None
    ...
    ...     @stepthrough('recipes')
    ...     def traverse_recipes(self, name):
    ...         name = unquote(name)
    ...         for recipe in self.context.recipes:
    ...             if recipe.dish.name == name:
    ...                 return recipe
    ...         return None
    >>> register_navigation(CookbookNavigation, ICookbook)

    >>> class RecipeNavigation(Navigation):
    ...     @stepthrough('comments')
    ...     def traverse_comments(self, name):
    ...         try:
    ...             return self.context.comments[int(name)-1]
    ...         except (IndexError, TypeError, ValueError):
    ...             return None
    >>> register_navigation(RecipeNavigation, IRecipe)

    >>> class RootNavigation(Navigation):
    ...     top_level_names = {
    ...         'dishes': DishSet(),
    ...         'cookbooks': CookbookSet(),
    ...         'authors': AuthorSet()}
    ...
    ...     def traverse(self, name):
    ...         return self.top_level_names.get(name)

The canonical URLs for these components:

    >>> from urllib import quote
    >>> from canonical.launchpad.webapp.interfaces import ICanonicalUrlData
    >>> class BaseUrlData(object):
    ...     inside = None
    ...     def __init__(self, context):
    ...         self.context = context
    ...         self.rootsite = None
    ...
    ...     @property
    ...     def path(self):
    ...         return quote(self.context.name)

    >>> class AuthorUrlData(BaseUrlData):
    ...     @property
    ...     def inside(self):
    ...         return AuthorSet()
    >>> provideAdapter(AuthorUrlData, [IAuthor], ICanonicalUrlData)

    >>> class DishUrlData(BaseUrlData):
    ...     @property
    ...     def inside(self):
    ...         return DishSet()
    >>> provideAdapter(DishUrlData, [IDish], ICanonicalUrlData)

    >>> class RecipeUrlData(BaseUrlData):
    ...     @property
    ...     def inside(self):
    ...         return self.context.cookbook
    ...     @property
    ...     def path(self):
    ...         return quote(u"recipes/%s" % str(self.context.dish.name))
    >>> provideAdapter(RecipeUrlData, [IRecipe], ICanonicalUrlData)

    >>> class CookbookUrlData(BaseUrlData):
    ...     @property
    ...     def inside(self):
    ...         return CookbookSet()
    >>> provideAdapter(CookbookUrlData, [ICookbook], ICanonicalUrlData)

    >>> class DishSetUrlData(BaseUrlData):
    ...     path = 'dishes'
    >>> provideAdapter(DishSetUrlData, [IDishSet], ICanonicalUrlData)

    >>> class CookbookSetUrlData(BaseUrlData):
    ...     path = 'cookbooks'
    >>> provideAdapter(CookbookSetUrlData, [ICookbookSet], ICanonicalUrlData)

    >>> class AuthorSetUrlData(BaseUrlData):
    ...     path = 'authors'
    >>> provideAdapter(AuthorSetUrlData, [IAuthorSet], ICanonicalUrlData)

    >>> class CommentUrlData(BaseUrlData):
    ...     @property
    ...     def path(self):
    ...         return "comments/%d" % (
    ...             self.context.target.comments.index(self.context)+1)
    ...     @property
    ...     def inside(self):
    ...         return self.context.target
    >>> provideAdapter(CommentUrlData, [Comment], ICanonicalUrlData)


== Defining the resources ==

LAZR provides an interface, IEntry, used by an individual model object
exposed through a specific resource. This interface defines only one
attribute 'schema' which should contain a schema describing the data
fields available in the entry.  The same kind of fields defined by a
model interface like IRecipe.  It is expected that the entry adapter
also provides that schema itself.

If there's not much to an interface, you can expose it through the web
service exactly as it's defined, by defining a class that inherits
from both the interface and IEntry. Since IAuthor and IComment are so
simple, we can define IAuthorEntry and ICommentEntry this way:

    >>> from canonical.lazr.interfaces import IEntry
    >>> class IAuthorEntry(IAuthor, IEntry):
    ...     """The part of an author we expose through the web service."""

    >>> from canonical.lazr.interfaces import IEntry
    >>> class ICommentEntry(IComment, IEntry):
    ...     """The part of a comment we expose through the web service."""

The only extra step we have to take is to annotate the interfaces with
human-readable names for the objects we're exposing.

    >>> from canonical.lazr.rest.resource import LAZR_WEBSERVICE_NAME

    # XXX leonardr 2008-07-09 bug=145746
    # Once we're using Zope 3.4 we can call
    # zope.interface.taggedValue(LAZR_WEBSERVICE_NAME, dict(...))
    # from within the interface declaration.
    >>> def tag_with_names(interface, singular, plural):
    ...     interface.setTaggedValue(
    ...         LAZR_WEBSERVICE_NAME, dict(singular=singular, plural=plural))
    >>> tag_with_names(IAuthorEntry, 'author', 'authors')
    >>> tag_with_names(ICommentEntry, 'comment', 'comments')

Most of the time, it doesn't work to expose to the web service the
same data model we expose internally. Usually there are fields we
don't want to expose, synthetic fields we do want to expose, fields we
want to expose as a different type under a different name, and so
on. This is why we have IEntry in the first place: the IEntry
interface defines the interface we _do_ want to expose through the web
service.

The reason we can't just define IDishEntry(IDish, IEntry) is that
IDish defines the "recipes" collection as an Attribute. Attribute is
about as generic as "object", and doesn't convey any information about
what kind of object is in the collection, or even that "recipes" is a
collection at all. To expose the corresponding field to the web
service we use CollectionField.

    >>> from canonical.lazr.fields import CollectionField
    >>> class IDishEntry(IEntry):
    ...     "The part of a dish that we expose through the web service."
    ...     recipes = CollectionField(value_type=Object(schema=IRecipe))
    >>> tag_with_names(IDishEntry, 'dish', 'dishes')

In the following code block we define an interface that exposes the
underlying Recipe's name but not its ID. References to associated
objects (like the recipe's cookbook) are represented with the
zope.schema.Object type: this makes it possible to serve a link from a
recipe to its cookbook.

    >>> class IRecipeEntry(IEntry):
    ...     "The part of a recipe that we expose through the web service."
    ...     cookbook = Object(schema=ICookbook)
    ...     dish = Object(schema=IDish)
    ...     instructions = Text(title=u"Name", required=True)
    ...     comments = CollectionField(value_type=Object(schema=IComment))
    >>> tag_with_names(IRecipeEntry, 'recipe', 'recipes')

    >>> from canonical.lazr.fields import ReferenceChoice
    >>> class ICookbookEntry(IEntry):
    ...     name = TextLine(title=u"Name", required=True)
    ...     cuisine = TextLine(title=u"Cuisine", required=False, default=None)
    ...     author = ReferenceChoice(schema=IAuthor, vocabulary=AuthorVocabulary())
    ...     recipes = CollectionField(value_type=Object(schema=IRecipe))
    ...     comments = CollectionField(value_type=Object(schema=IComment))
    ...     cover = Bytes(0, 5000, title=u"An image of the cookbook's cover.")
    >>> tag_with_names(ICookbookEntry, 'cookbook', 'cookbooks')

The 'author' field is a choice between Author objects. To make sure
that the Author objects are properly marshalled to JSON, we need to
define an adapter to IFieldMarshaller.

    >>> from zope.schema.interfaces import IChoice
    >>> from canonical.lazr.rest.marshallers import (
    ...     ObjectLookupFieldMarshaller)
    >>> from canonical.lazr.interfaces import (
    ...     IFieldMarshaller, WebServiceLayer)
    >>> provideAdapter(ObjectLookupFieldMarshaller,
    ...     [IChoice, WebServiceLayer,
    ...      AuthorVocabulary], IFieldMarshaller)


== Implementing the resources ==

Here's the implementation of IAuthorEntry: a simple decorator on the
original model object. It subclasses Entry, a simple base class that
defines a constructor. (See lazr/doc/decorates.txt for more on
decorates().)

    >>> from zope.component import adapts
    >>> from zope.interface.verify import verifyObject
    >>> from canonical.lazr import decorates
    >>> from canonical.lazr.rest import Entry

    >>> class AuthorEntry(Entry):
    ...     """An author, as exposed through the web service."""
    ...     adapts(IAuthor)
    ...     decorates(IAuthorEntry)
    ...     schema = IAuthorEntry

    >>> verifyObject(IAuthorEntry, AuthorEntry(A1))
    True

The "schema" attribute points to the interface class that defines the
attributes exposed through the web service. Above, "schema" is
IAuthorEntry, which exposes only "name".

IEntry also defines an invariant that enforce that it can be
adapted to the interface defined in the schema attribute. This
is usually not a problem, since the schema is usually the interface
itself.

    >>> IAuthorEntry.validateInvariants(AuthorEntry(A1))

But the invariant will complain if that doesn't isn't true.

    >>> class InvalidAuthorEntry(Entry):
    ...     adapts(IAuthor)
    ...     decorates(IAuthorEntry)
    ...     schema = ICookbookEntry

    >>> verifyObject(IAuthorEntry, InvalidAuthorEntry(A1))
    True
    >>> IAuthorEntry.validateInvariants(InvalidAuthorEntry(A1))
    Traceback (most recent call last):
      ...
    Invalid: InvalidAuthorEntry doesn't provide its ICookbookEntry schema.

Other entries are defined similarly.

# XXX flacoste 2008/03/17 Update this example to show how adapters can
# be used to resolve the impedance mismatch between the web-service
# visible interface and the internal data model.)

    >>> class CookbookEntry(Entry):
    ...     """A cookbook, as exposed through the web service."""
    ...     adapts(ICookbook)
    ...     decorates(ICookbookEntry)
    ...     schema = ICookbookEntry

    >>> class DishEntry(Entry):
    ...     """A dish, as exposed through the web service."""
    ...     adapts(IDish)
    ...     decorates(IDishEntry)
    ...     schema = IDishEntry

    >>> class CommentEntry(Entry):
    ...     """A comment, as exposed through the web service."""
    ...     adapts(IComment)
    ...     decorates(ICommentEntry)
    ...     schema = ICommentEntry

    >>> class RecipeEntry(Entry):
    ...     adapts(IRecipe)
    ...     decorates(IRecipeEntry)
    ...     schema = IRecipeEntry

We need to register these entries as an adapter from (eg.) IAuthor to
(eg.) IAuthorEntry. In ZCML a registration would look like this.

    <adapter
        for="my.app.interfaces.IAuthor"
        provides="my.app.interfaces.IAuthorEntry"
        factory="my.app.rest.AuthorEntry"
        />

Since we're in the middle of a Python test we need to do the equivalent
in Python code:

    >>> provideAdapter(AuthorEntry, [IAuthor], IAuthorEntry)
    >>> provideAdapter(CookbookEntry, [ICookbook], ICookbookEntry)
    >>> provideAdapter(DishEntry, [IDish], IDishEntry)
    >>> provideAdapter(CommentEntry, [IComment], ICommentEntry)
    >>> provideAdapter(RecipeEntry, [IRecipe], IRecipeEntry)

LAZR also defines an interface and a base class for collections of
objects. I'll use it to expose the AuthorSet collection and other
top-level collections through the web service. A collection must
define a method called find(), which returns the model objects in the
collection.

    >>> from canonical.lazr.rest import Collection
    >>> from canonical.lazr.interfaces import ICollection

    >>> class AuthorCollection(Collection):
    ...     """A collection of authors, as exposed through the web service."""
    ...
    ...     entry_schema = IAuthorEntry
    ...
    ...     def find(self):
    ...        """Find all the authors."""
    ...        return self.context.getAllAuthors()
    ...
    >>> provideAdapter(AuthorCollection, [IAuthorSet], ICollection)

    >>> verifyObject(ICollection, AuthorCollection(AuthorSet()))
    True

    >>> class CookbookCollection(Collection):
    ...     """A collection of cookbooks, as exposed through the web service.
    ...     """
    ...
    ...     entry_schema = ICookbookEntry
    ...
    ...     def find(self):
    ...        """Find all the cookbooks."""
    ...        return self.context.getAll()
    >>> provideAdapter(CookbookCollection, [ICookbookSet], ICollection)

    >>> class DishCollection(Collection):
    ...     """A collection of dishes, as exposed through the web service."""
    ...
    ...     entry_schema = IDishEntry
    ...
    ...     def find(self):
    ...        """Find all the dishes."""
    ...        return self.context.getAll()
    >>> provideAdapter(DishCollection, [IDishSet], ICollection)

Like Entry, Collection is a simple base class that defines a
constructor. The 'entry_schema' attribute gives a Collection class
knowledge about what kind of entry it's supposed to contain.

    >>> DishCollection.entry_schema
    <InterfaceClass __builtin__.IDishEntry>

We also need to define a collection of the recipes associated with a
cookbook. We say that the collection of recipes is scoped to a
cookbook. Scoped collections adapters are looked for based on the type
of the scope, and the type of the entries contained in the scoped
collection. There is a default ScopedCollection adapter that works
whenever the scoped collection is available as an iterable attribute
of the context.

    >>> from zope.component import getMultiAdapter
    >>> from canonical.lazr.interfaces import IScopedCollection

    >>> def scope_collection(parent, child, name):
    ...     """A helper method that simulates a scoped collection lookup."""
    ...     parent_entry = IEntry(parent)
    ...     scoped = getMultiAdapter((parent_entry, IEntry(child)),
    ...                               IScopedCollection)
    ...     scoped.relationship = parent_entry.schema.get(name)
    ...     return scoped

The default adapter works just fine with the collection of recipes for
a cookbook.

    >>> scoped_collection = scope_collection(C1, C1_D1, 'recipes')
    >>> scoped_collection
    <canonical.lazr.rest.resource.ScopedCollection...>

Like a regular collection, a scoped collection knows what kind of
object is inside it. Recall that the 'recipes' collection of a
cookbook was defined as one that contains Objects with a schema of
IRecipe. This information is available to the ScopedCollection object.

    >>> scoped_collection.entry_schema
    <InterfaceClass __builtin__.IRecipeEntry>


== Custom operations ==

The CookbookSet class defines a method called 'findRecipes'. This is
exposed through the cookbook collection resource as a custom operation
called 'find_recipes'. Each custom operation is implemented as a class
that implementsIResourceGETOperation.

    >>> from canonical.lazr.rest import ResourceGETOperation
    >>> from zope.publisher.interfaces.http import IHTTPApplicationRequest
    >>> from canonical.lazr.fields import Reference
    >>> from canonical.lazr.interfaces import IResourceGETOperation
    >>> class FindRecipesOperation(ResourceGETOperation):
    ...    """An operation that searches for recipes across cookbooks."""
    ...    params = [ TextLine(__name__='name') ]
    ...    return_type = CollectionField(value_type=Reference(schema=IRecipe))
    ...
    ...    def call(self, name):
    ...        try:
    ...            return self.context.findRecipes(name)
    ...        except ValueError, e:
    ...            self.request.response.setStatus(400)
    ...            return str(e)

To register the class we just defined as implementing the
'find_recipes' operation, we need to register it as a named adapter
providing IResourceGETOperation for the ICookbookSet interface.

    >>> provideAdapter(FindRecipesOperation,
    ...                [ICookbookSet, IHTTPApplicationRequest],
    ...                IResourceGETOperation, "find_recipes")

The same underlying method is exposed through the recipe entry
resource as a custom operation called 'find_similar_recipes'.

    >>> class FindSimilarRecipesOperation(ResourceGETOperation):
    ...    """Finds recipes with the same name."""
    ...    params = []
    ...    return_type = CollectionField(value_type=Reference(schema=IRecipe))
    ...
    ...    def call(self):
    ...        try:
    ...            return CookbookSet().findRecipes(self.context.dish.name)
    ...        except AssertionError, e:
    ...            self.request.response.setStatus(400)
    ...            return str(e)

    >>> provideAdapter(FindSimilarRecipesOperation,
    ...                [IRecipe, IHTTPApplicationRequest],
    ...                IResourceGETOperation, "find_similar_recipes")

Named GET operations are read-only operations like searches, but
resources can also expose named write operations, through POST. Here's
a named factory operation for creating a new cookbook.

    >>> from canonical.lazr.rest import ResourcePOSTOperation
    >>> class CookbookFactoryOperation(ResourcePOSTOperation):
    ...     """An operation that creates a new cookbook."""
    ...     params = (
    ...         TextLine(__name__='author_name'),
    ...         TextLine(__name__='title'),
    ...         TextLine(
    ...             __name__='cuisine', default=u'Brazilian', required=False),
    ...     )
    ...     return_type = Object(schema=IRecipe)
    ...
    ...     def call(self, author_name, title, cuisine):
    ...         cookbook = CookbookSet().newCookbook(
    ...             author_name, title, cuisine)
    ...         self.request.response.setStatus(201)
    ...         self.request.response.setHeader(
    ...             "Location", canonical_url(cookbook))
    ...         return cookbook

    >>> from canonical.lazr.interfaces import IResourcePOSTOperation
    >>> provideAdapter(CookbookFactoryOperation,
    ...                [ICookbookSet, IHTTPApplicationRequest],
    ...                IResourcePOSTOperation, "create_cookbook")

Here's a named POST operation that's not a factory operation: it
makes a cookbook's cuisine sound more interesting.

    >>> class MakeMoreInterestingOperation(ResourcePOSTOperation):
    ...     params = ()
    ...     return_type = None
    ...     send_modification_event = True
    ...
    ...     def call(self):
    ...         cookbook = self.context
    ...         cookbook.cuisine = "Nouvelle " + cookbook.cuisine

    >>> provideAdapter(MakeMoreInterestingOperation,
    ...                [ICookbook, IHTTPApplicationRequest],
    ...                IResourcePOSTOperation, "make_more_interesting")


== Resource objects ==

LAZR's Resource objects are the objects that actually handle incoming
HTTP requests. There are a few very common types of HTTP resources,
and LAZR defines classes for some of them. For instance, there's the
"collection" resource that responds to GET (to get the items in the
collection) and POST (to invoke named operations on the
collection). LAZR implements this as a CollectionResource which uses
the HTTP arguments to drive Collection methods like find().

Of course, a CollectionResource has to expose a collection _of_
something. That's why each CollectionResource is associated with some
concrete implementation of ICollection, like AuthorCollection. All you
have to do is define the behaviour of the collection, and
CollectionResource takes care of exposing the collection through HTTP.

Similarly, you can implement RecipeEntry to the IEntry interface, and
expose it through the web as an EntryResource.


== The Service Root Resource ==

How are these Resource objects connected to the web? Through the
ServiceRootResource. This is a special resource that represents the
root of the object tree.

    >>> from canonical.launchpad.webapp.interfaces import (
    ...    ILaunchpadApplication)
    >>> from canonical.lazr.interfaces import IServiceRootResource
    >>> from canonical.lazr.rest import ServiceRootResource
    >>> class IMyWebServiceApplication(ILaunchpadApplication,
    ...                                IServiceRootResource):
    ...     """Marker interface for the web service."""
    >>> class MyServiceRootResource(ServiceRootResource):
    ...     implements(IMyWebServiceApplication)
    >>> register_navigation(RootNavigation, IMyWebServiceApplication)

    >>> from canonical.launchpad.webapp.servers import WebServicePublication
    >>> class MyWebServicePublication(WebServicePublication):
    ...    def getApplication(self, request):
    ...        return MyServiceRootResource()

If you call the service root resource, and pass in an HTTP request, it
will act as though you had performed a GET on the URL
'http://api.launchpad.net/beta/'.

    >>> from canonical.launchpad.webapp.servers import WebServiceTestRequest
    >>> from cStringIO import StringIO

    >>> def create_web_service_request(
    ...     path_info, method='GET', body=None, environ=None,
    ...     http_host='api.launchpad.dev'):
    ...     test_environ = {
    ...         'SERVER_URL': 'http://%s' % http_host,
    ...         'HTTP_HOST': http_host,
    ...         'PATH_INFO': path_info,
    ...     }
    ...     if environ is not None:
    ...         test_environ.update(environ)
    ...     if body is None:
    ...         body_instream = body
    ...     else:
    ...         test_environ['CONTENT_LENGTH'] = len(body)
    ...         body_instream = StringIO(body)
    ...     request = WebServiceTestRequest(
    ...         body_instream=body_instream, environ=test_environ,
    ...         method=method)
    ...     request.setPublication(MyWebServicePublication(None))
    ...     # Set the "current" request.
    ...     login(ANONYMOUS, request)
    ...     request.processInputs()
    ...     return request

    >>> app = MyServiceRootResource()
    >>> from canonical.launchpad.interfaces import IOpenLaunchBag
    >>> getUtility(IOpenLaunchBag).add(app)
    >>> request = create_web_service_request('/beta/')
    >>> ignore = request.traverse(app)

The response document is a JSON document full of links to the
top-level collections of authors, cookbooks, and dishes. It's the
'home page' for the web service.

    # XXX leonardr 2008-04-24 bug=221037: It also includes top-level
    # collections from the Launchpad web service. This part of the
    # test can be simplified once the test is moved to another layer.
    >>> import simplejson
    >>> response = app(request)
    >>> representation = simplejson.loads(response)

    >>> representation["authors_collection_link"]
    u'http://api.launchpad.dev/beta/authors'

    >>> representation["cookbooks_collection_link"]
    u'http://api.launchpad.dev/beta/cookbooks'

    >>> representation["dishes_collection_link"]
    u'http://api.launchpad.dev/beta/dishes'

The standard canonical_url() function can be used to generate URLs to
content objects published on the web service. It works for the web
service root also.

    >>> from canonical.launchpad.webapp import canonical_url
    >>> ICanonicalUrlData.providedBy(app)
    True
    >>> canonical_url(app)
    u'http://api.launchpad.dev/beta/'


=== WADL documents ===

Every resource can serve a WADL representation of itself. The main
WADL document is the WADL representation of the server root. It
describes the capabilities of the web service as a whole.

    >>> wadl_headers = {'HTTP_ACCEPT' : 'application/vd.sun.wadl+xml'}
    >>> wadl_request = create_web_service_request(
    ...     '/beta/', environ=wadl_headers)
    >>> wadl_resource = wadl_request.traverse(app)
    >>> print wadl_resource(wadl_request)
    <?xml version="1.0"?>
    <!DOCTYPE...
    <wadl:application ...>
    ...
    </wadl:application>

If the resources are improperly configured, the WADL can't be
generated. Here's an example, where DishCollection is registered as an
adapter twice. Earlier it was registered as the adapter for IDishSet;
here it's also registered as the adapter for IAuthorSet. The WADL
generation doesn't know whether to describe DishCollection using the
named operations defined against IAuthorSet or the named operations
defined against IDishSet, so there's an AssertionError.

    >>> provideAdapter(DishCollection, [IAuthorSet], ICollection)
    >>> print wadl_resource(wadl_request)
    Traceback (most recent call last):
    ...
    AssertionError: There must be one (and only one) adapter
    from DishCollection to ICollection.


== Collection resources ==

The default root navigation defined in our model contains the top-level
Set objects that should be published. When these sets are published on
the web service, they will we wrapped in the appropriate
CollectionResource.

The following example is equivalent to requesting
'http://api.launchpad.net/cookbooks/'. The code will traverse to the
CookbookSet published normally at '/cookbooks' and it will be wrapped
into a CollectionResource.

    >>> request = create_web_service_request('/beta/cookbooks')
    >>> collection = request.traverse(app)
    >>> collection
    <canonical.lazr.rest.resource.CollectionResource object ...>

Calling the collection resource yields a JSON document, which can be
parsed with standard tools.

    >>> representation = simplejson.loads(collection())
    >>> representation['resource_type_link']
    u'http://api.launchpad.dev/beta/#cookbooks'


=== Pagination ===

Collections are paginated and served one page at a time. This
particular collection is small enough to fit on one page; it's only
got three entries.

    >>> sorted(representation.keys())
    [u'entries', u'resource_type_link', u'start', u'total_size']
    >>> len(representation['entries'])
    3
    >>> representation['total_size']
    3

But if we ask for a page size of two, we can see how pagination
works. Here's page one, with two cookbooks on it.

    >>> request = create_web_service_request(
    ...     '/beta/cookbooks', environ={'QUERY_STRING' : 'ws.size=2'})
    >>> collection = request.traverse(app)
    >>> representation = simplejson.loads(collection())

    >>> sorted(representation.keys())
    [u'entries', u'next_collection_link', u'resource_type_link',
     u'start', u'total_size']
    >>> representation['next_collection_link']
    u'http://api.launchpad.dev/beta/cookbooks?ws.start=2&ws.size=2'
    >>> len(representation['entries'])
    2
    >>> representation['total_size']
    3

Follow the 'next_collection_link' and you'll end up at page two, which
has the last cookbook on it.

    >>> request = create_web_service_request(
    ...     '/beta/cookbooks',
    ...     environ={'QUERY_STRING' : 'ws.start=2&ws.size=2'})
    >>> collection = request.traverse(app)
    >>> representation = simplejson.loads(collection())

    >>> sorted(representation.keys())
    [u'entries', u'prev_collection_link', u'resource_type_link',
     u'start', u'total_size']
    >>> representation['prev_collection_link']
    u'http://api.launchpad.dev/beta/cookbooks?ws.start=0&ws.size=2'
    >>> len(representation['entries'])
    1


=== Custom operations ===

A collection may also expose a number of custom operations through
GET. The cookbook collection exposes a custom GET operation called
'find_recipes', which searches for recipes with a given name across
cookbooks.

    >>> request = create_web_service_request(
    ...    '/beta/cookbooks',
    ...    environ={'QUERY_STRING' :
    ...             'ws.op=find_recipes&name=Roast%20chicken'})
    >>> operation_resource = request.traverse(app)
    >>> chicken_recipes = simplejson.loads(operation_resource())
    >>> sorted([c['instructions'] for c in chicken_recipes['entries']])
    [u'A perfectly roasted chicken is...',
     u'Draw, singe, stuff, and truss...',
     u'You can always judge...']

Custom operations may include custom error checking. Error messages
are passed along to the client.

    >>> request = create_web_service_request(
    ...    '/beta/cookbooks',
    ...    environ={'QUERY_STRING' :
    ...             'ws.op=find_recipes&name=NoSuchRecipe'})
    >>> operation_resource = request.traverse(app)
    >>> print operation_resource()
    No matches for NoSuchRecipe

Collections may also support named POST operations. These requests
have two effects on the server side: they modify the dataset, and they
may also trigger event notifications. Here are two simple handlers set
up to print a message whenever we modify a cookbook or the cookbook
set.

    >>> def modified_cookbook(object, event):
    ...     """Print a message when triggered."""
    ...     print "You just modified a cookbook."

    >>> from canonical.launchpad.event.interfaces import (
    ...     ISQLObjectModifiedEvent)
    >>> from canonical.launchpad.ftests.event import TestEventListener
    >>> cookbook_listener = TestEventListener(
    ...     ICookbook, ISQLObjectModifiedEvent, modified_cookbook)

    >>> def modified_cookbook_set(object, event):
    ...     """Print a message when triggered."""
    ...     print "You just modified the cookbook set."

    >>> cookbook_set_listener = TestEventListener(
    ...     ICookbookSet, ISQLObjectModifiedEvent, modified_cookbook_set)

Here we create a new cookbook for an existing author. Because the
operation's definition doesn't set send_modified_event to True, no
event will be sent and modified_cookbook_set() won't be called.

    >>> body = ("ws.op=create_cookbook&title=Beard%20on%20Bread&"
    ...         "author_name=James%20Beard")
    >>> request = create_web_service_request(
    ...     '/beta/cookbooks', 'POST', body,
    ...     {'CONTENT_TYPE' : 'application/x-www-form-urlencoded'})
    >>> operation_resource = request.traverse(app)
    >>> result = operation_resource()

    >>> request.response.getStatus()
    201
    >>> request.response.getHeader('Location')
    'http://api.launchpad.dev/beta/cookbooks/Beard%20on%20Bread'

Here we create a cookbook for a new author.

    >>> body = ("ws.op=create_cookbook&title=Everyday%20Greens&"
    ...         "author_name=Deborah%20Madison")
    >>> request = create_web_service_request(
    ...     '/beta/cookbooks', 'POST', body,
    ...     {'CONTENT_TYPE' : 'application/x-www-form-urlencoded'})
    >>> operation_resource = request.traverse(app)
    >>> result = operation_resource()
    >>> request.response.getStatus()
    201
    >>> request.response.getHeader('Location')
    'http://api.launchpad.dev/beta/cookbooks/Everyday%20Greens'

The new Author object is created implicitly and is published as a
resource afterwards.

    >>> path = '/beta/authors/Deborah%20Madison'
    >>> request = create_web_service_request(path)
    >>> author = request.traverse(app)
    >>> simplejson.loads(author())['name']
    u'Deborah Madison'

Here we modify a cookbook's cuisine using a named operation. Because
this operation's definition does set send_modified_event to True, an
event will be sent and modified_cookbook_set() will be called.

    >>> body = "ws.op=make_more_interesting"
    >>> request = create_web_service_request(
    ...     '/beta/cookbooks/Everyday%20Greens', 'POST', body,
    ...     {'CONTENT_TYPE' : 'application/x-www-form-urlencoded'})
    >>> operation_resource = request.traverse(app)
    >>> result = operation_resource()
    You just modified a cookbook.
    >>> request.response.getStatus()
    200

    >>> path = '/beta/cookbooks/Everyday%20Greens'
    >>> request = create_web_service_request(path)
    >>> cookbook = request.traverse(app)
    >>> simplejson.loads(cookbook())['cuisine']
    u'Nouvelle Brazilian'


== Entry resources ==

The collection resource is a list of entries. Each entry has some
associated information (like 'name'), a 'self_link' (the URL to the
entry's resource), and possibly links to associated resources.

    >>> import operator
    >>> request = create_web_service_request('/beta/cookbooks')
    >>> collection = request.traverse(app)
    >>> representation = simplejson.loads(collection())
    >>> entries = sorted(representation['entries'],
    ...                  key=operator.itemgetter('name'))
    >>> entries[0]['self_link']
    u'http://api.launchpad.dev/beta/cookbooks/Beard%20on%20Bread'

Regular data fields are exposed with their given names. The 'name'
field stays 'name'.

    >>> entries[0]['name']
    u'Beard on Bread'

Fields that are references to other objects -- Object, Reference, and
ReferenceChoice -- are exposed as links to those objects. Each
cookbook has such a link to its author.

    >>> entries[0]['author_link']
    u'http://api.launchpad.dev/beta/authors/James%20Beard'

Fields that are references to externally hosted files (Bytes) are also
exposed as links to those files. Each cookbook has such a link to its
cover image.

    >>> entries[0]['cover_link']
    u'http://api.launchpad.dev/beta/cookbooks/Beard%20on%20Bread/cover'

Fields that are references to collections of objects are exposed as
links to those collections. Each cookbook has such a link to its
recipes.

    >>> entries[0]['recipes_collection_link']
    u'http://api.launchpad.dev/beta/cookbooks/Beard%20on%20Bread/recipes'

Calling the CollectionResource object makes it process the incoming
request. Since this is a GET request, calling the resource publishes
the resource to the web. A CollectionResource is made up of a bunch of
EntryResources, and the base EntryResource class knows how to use the
entry schema class (in this case, IRecipeEntry) to publish a JSON
document.

The same way collections are wrapped into CollectionResource, navigating
to an object that has an IEntry adapter, will wrap it into an
EntryResource.

For instance, creating a new cookbook and making a request to its URL
will wrap it into an EntryResource.

    >>> body = ("ws.op=create_cookbook&title=Feijoada&"
    ...         "author_name=Fernando%20Yokota")
    >>> request = create_web_service_request(
    ...     '/beta/cookbooks', 'POST', body,
    ...     {'CONTENT_TYPE' : 'application/x-www-form-urlencoded'})
    >>> operation_resource = request.traverse(app)
    >>> result = operation_resource()
    >>> request.response.getHeader('Location')
    'http://api.launchpad.dev/beta/cookbooks/Feijoada'
    >>> request = create_web_service_request('/beta/cookbooks/Feijoada')
    >>> feijoada_resource = request.traverse(app)
    >>> feijoada_resource
    <canonical.lazr.rest.resource.EntryResource object ...>
    >>> feijoada = simplejson.loads(feijoada_resource())

Notice how the request above didn't specify the book's cuisine,
but since that is not a required field Launchpad used the default
value (Brazilian) specified in CookbookFactoryOperation for it.

    >>> sorted(feijoada.items())
    [(u'author_link',
      u'http://api.launchpad.dev/beta/authors/Fernando%20Yokota'),
     (u'comments_collection_link',
      u'http://api.launchpad.dev/beta/cookbooks/Feijoada/comments'),
     (u'cover_link',
      u'http://api.launchpad.dev/beta/cookbooks/Feijoada/cover'),
     (u'cuisine', u'Brazilian'),
     (u'name', u'Feijoada'),
     (u'recipes_collection_link',
      u'http://api.launchpad.dev/beta/cookbooks/Feijoada/recipes'),
     (u'resource_type_link',
      u'http://api.launchpad.dev/beta/#cookbook'),
     (u'self_link', u'http://api.launchpad.dev/beta/cookbooks/Feijoada')]

You can also traverse from an entry to an item in a scoped collection:

    >>> request = create_web_service_request(
    ...     quote('/beta/cookbooks/The Joy of Cooking/recipes/Roast chicken'))
    >>> chicken_recipe_resource = request.traverse(app)
    >>> chicken_recipe = simplejson.loads(chicken_recipe_resource())
    >>> sorted(chicken_recipe.items())
    [(u'comments_collection_link',
      u'http://api...Joy%20of%20Cooking/recipes/Roast%20chicken/comments'),
    (u'cookbook_link',
     u'http://api.launchpad.dev/beta/cookbooks/The%20Joy%20of%20Cooking'),
    (u'dish_link', u'http://api.launchpad.dev/beta/dishes/Roast%20chicken'),
    (u'instructions', u'Draw, singe, stuff, and truss...'),
    (u'self_link',
     u'http://api.../The%20Joy%20of%20Cooking/recipes/Roast%20chicken')]

Another example traversing to a comment:

    >>> roast_chicken_comments_url = quote(
    ... '/beta/cookbooks/The Joy of Cooking/recipes/Roast chicken/comments')
    >>> request = create_web_service_request(roast_chicken_comments_url)
    >>> comments_resource = request.traverse(app)

    >>> comments = simplejson.loads(comments_resource())
    >>> [c['text'] for c in comments['entries']]
    [u'Clear and concise.']

    >>> request = create_web_service_request(
    ...     roast_chicken_comments_url + '/1')
    >>> comment_one_resource = request.traverse(app)
    >>> comment_one = simplejson.loads(comment_one_resource())
    >>> sorted(comment_one.items())
    [(u'resource_type_link', u'http://api.launchpad.dev/beta/#comment'),
     (u'self_link',
      u'http://api...Joy%20of%20Cooking/recipes/Roast%20chicken/comments/1'),
     (u'text', u'Clear and concise.')]

An entry may expose a number of custom operations through GET. The
recipe entry exposes a custom GET operation called
'find_similar_recipes', which searches for recipes with the same name
across cookbooks.

    >>> request = create_web_service_request(
    ...     '/beta/cookbooks/The%20Joy%20of%20Cooking/recipes/Roast%20chicken',
    ...     environ={'QUERY_STRING' : 'ws.op=find_similar_recipes'})
    >>> operation_resource = request.traverse(app)
    >>> chicken_recipes = simplejson.loads(operation_resource())
    >>> sorted([c['instructions'] for c in chicken_recipes['entries']])
    [u'A perfectly roasted chicken is...',
     u'Draw, singe, stuff, and truss...',
     u'You can always judge...']


== Named operation return values ==

The return value of a named operation is serialized to a JSON data
structure, and the response's Content-Type header is set to
application/json. These examples show how different return values are
serialized.

    >>> class DummyOperation(ResourceGETOperation):
    ...
    ...     params = ()
    ...     result = None
    ...     return_type = None
    ...
    ...     def call(self):
    ...         return self.result

    >>> def make_dummy_operation_request(result):
    ...    request = create_web_service_request('/')
    ...    operation = DummyOperation(None, request)
    ...    operation.result = result
    ...    return request, operation

Scalar Python values like strings and booleans are serialized as you'd
expect.

    >>> request, operation = make_dummy_operation_request("A string.")
    >>> print operation()
    "A string."
    >>> request.response.getStatus()
    200
    >>> print request.response.getHeader('Content-Type')
    application/json

    >>> request, operation = make_dummy_operation_request(True)
    >>> operation()
    'true'

    >>> request, operation = make_dummy_operation_request(10)
    >>> operation()
    '10'

    >>> request, operation = make_dummy_operation_request(None)
    >>> operation()
    'null'

    >>> request, operation = make_dummy_operation_request(1.3)
    >>> operation()
    '1.3'

When a named operation returns an object that has an IEntry
implementation, the object is serialized to a JSON hash.

    >>> request, operation = make_dummy_operation_request(D2)
    >>> operation()
    '{...}'

A named operation can return a data structure that incorporates
objects with IEntry implementations. Here's a dictionary that contains
a Dish object. The Dish object is serialized as a JSON dictionary
within the larger dictionary.

    >>> request, operation = make_dummy_operation_request({'dish': D2})
    >>> operation()
    '{"dish": {...}}'

When a named operation returns a list or tuple of objects, we serve
the whole thing as a JSON list.

    >>> request, operation = make_dummy_operation_request([1,2,3])
    >>> operation()
    '[1, 2, 3]'

    >>> request, operation = make_dummy_operation_request((C1_D1, C2_D1))
    >>> operation()
    '[{...}, {...}]'

When a named operation returns a non-builtin object that provides the
iterator protocol, we don't return the whole list. The object probably
provides access to a potentially huge dataset, like a list of database
results. In this case we do the same thing we do when serving a
collection resource. We fetch one batch of results and represent it as
a JSON hash containing a list of entries.

    >>> class DummyResultSet(object):
    ...     results = [C1_D1, C2_D1]
    ...
    ...     def __iter__(self):
    ...         return iter(self.results)
    ...
    ...     def __len__(self):
    ...         return len(self.results)
    ...
    ...     def __getitem__(self, index):
    ...         return self.results[index]

    >>> recipes = DummyResultSet()
    >>> request, operation = make_dummy_operation_request(recipes)
    >>> operation()
    '{"total_size": 2, ... "entries": [{...}, {...}]}'

When a named operation returns an object that has an ICollection
implementation, the result is similar: we return a JSON hash
describing one batch from the collection.

    >>> request, operation = make_dummy_operation_request(DishSet())
    >>> operation()
    '{"total_size": ..., "start": ...}'

If the return value can't be converted into JSON, you'll get an
exception.

    >>> request, operation = make_dummy_operation_request(object())
    >>> operation()
    Traceback (most recent call last):
    ...
    TypeError: Could not serialize object <object...> to JSON.

    >>> request, operation = make_dummy_operation_request(
    ...     {'anobject' : object()})
    >>> operation()
    Traceback (most recent call last):
    ...
    TypeError: Could not serialize object {'anobject': <object...>} to JSON.

    >>> request, operation = make_dummy_operation_request([object()])
    >>> operation()
    Traceback (most recent call last):
    ...
    TypeError: Could not serialize object [<object object...>] to JSON.


== ETags ==

Every entry resource has a short opaque string called an ETag that
summarizes the resource's current state. The ETag is sent as the
response header 'ETag'.

    >>> julia_object = A1
    >>> julia_url = quote('/beta/authors/Julia Child')
    >>> get_request = create_web_service_request(julia_url)
    >>> ignored = get_request.traverse(app)()
    >>> etag_original = get_request.response.getHeader('ETag')

The ETag is different across revisions of the software, but within a
release it'll always the same for a given resource with a given state.

    >>> get_request = create_web_service_request(julia_url)
    >>> ignored = get_request.traverse(app)()
    >>> etag_after_get = get_request.response.getHeader('ETag')

    >>> etag_after_get == etag_original
    True

A client can use a previously obtained ETag as the value of
If-None-Match when making a request. If the ETags match, it means the
resource hasn't changed since the client's last request. The server
sends a response code of 304 ("Not Modified") instead of sending the
same representation again.

    >>> headers = {'CONTENT_TYPE' : 'application/json',
    ...            'HTTP_IF_NONE_MATCH' : etag_original }
    >>> get_request = create_web_service_request(julia_url, environ=headers)
    >>> get_request.traverse(app)()
    ''
    >>> get_request.response.getStatus()
    304

If the ETags don't match, the server assumes the client has an old
representation, and sends the new representation.

    >>> headers['HTTP_IF_NONE_MATCH'] = 'bad etag'
    >>> get_request = create_web_service_request(julia_url, environ=headers)
    >>> get_request.traverse(app)()
    '{...}'

Change the state of the resource, and the ETag changes.

    >>> julia_object.favorite_recipe = C2_D2
    >>> get_request = create_web_service_request(julia_url)
    >>> ignored = get_request.traverse(app)()
    >>> etag_after_modification = get_request.response.getHeader('ETag')

    >>> etag_after_modification == etag_original
    False

The client can't modify read-only fields, but they might be modified
behind the scenes. If one of them changes, the ETag will change.

    >>> julia_object.popularity = 5
    >>> get_request = create_web_service_request(julia_url)
    >>> ignored = get_request.traverse(app)()
    >>> etag_after_readonly_change = get_request.response.getHeader('ETag')
    >>> etag_after_readonly_change == etag_original
    False


== Resource Visibility ==

Certain resources might not be visible to every user. In this example,
certain recipes have been designated as private and can't be seen by
unauthenticated users. For demonstration purposes, the recipe for
"Baked beans" in "James Beard's American Cookery" has been marked as
private. An unauthorized attempt to GET this resource will result in
an error.

    >>> private_recipe_url = quote(
    ...     "/beta/cookbooks/James Beard's American Cookery/recipes/"
    ...     "Baked beans")
    >>> get_request = create_web_service_request(private_recipe_url)
    >>> recipe_resource = get_request.traverse(app)
    Traceback (most recent call last):
    ...
    Unauthorized: (<Recipe object...>, 'dish', 'launchpad.View')

The recipe will not show up in collections:

    >>> recipes_url = quote(
    ...     "/beta/cookbooks/James Beard's American Cookery/recipes")
    >>> get_request = create_web_service_request(recipes_url)
    >>> collection_resource = get_request.traverse(app)
    >>> collection = simplejson.loads(collection_resource())

The web service knows about two recipes from James Beard's American
Cookery, but an unauthorized user can only see one of them.

    >>> len(collection['entries'])
    1

Note that the 'total_size' of the collection is slightly inaccurate,
having been generated before invisible recipes were filtered out.

    >>> collection['total_size']
    2

As it happens, the author "James Beard" has his 'favorite_recipe'
attribute set to the "Baked beans" recipe. But an unauthorized user
can't see anything about that recipe, not even its URL.

    >>> beard_url = quote('/beta/authors/James Beard')
    >>> get_request = create_web_service_request(beard_url)
    >>> author_resource = get_request.traverse(app)
    >>> author = simplejson.loads(author_resource())

The author's name is public information, so it's visible. But the link
to his favorite recipe has been redacted.

    >>> author['name']
    u'James Beard'
    >>> author['favorite_recipe_link']
    u'tag:launchpad.net:2008:redacted'

It's possible to use a representation that contains redacted
information when sending a PUT or PATCH request back to the
server. The server will know that the client isn't actually trying to
set the field value to 'tag:launchpad.net:2008:redacted'.

    >>> headers = {'CONTENT_TYPE' : 'application/json'}
    >>> body = simplejson.dumps(author)
    >>> put_request = create_web_service_request(
    ...     beard_url, body=body, environ=headers, method='PUT')
    >>> put_request.traverse(app)()
    ''

And since no special permission is necessary to _change_ a person's
'favorite_recipe', it's possible to set it to a visible recipe using
PUT, even when its current value is redacted.

    >>> author['favorite_recipe_link'] = 'http://' + quote(
    ...     'api.launchpad.dev/beta/cookbooks/'
    ...     'The Joy of Cooking/recipes/Roast chicken')
    >>> body = simplejson.dumps(author)
    >>> put_request = create_web_service_request(
    ...     beard_url, body=body, environ=headers, method='PUT')
    >>> put_request.traverse(app)()
    ''

After that PUT, James Beard's 'favorite_recipe' attribute is no longer
redacted. It's the value set by the PUT request.

    >>> get_request = create_web_service_request(beard_url)
    >>> author_resource = get_request.traverse(app)
    >>> author = simplejson.loads(author_resource())
    >>> author['favorite_recipe_link']
    u'http://api.launchpad.dev/beta/cookbooks/The%20Joy%20of%20Cooking/recipes/Roast%20chicken'

Finally, you can't set an attribute to a value that you wouldn't have
permission to see:

    >>> author['favorite_recipe_link'] = (
    ...     'http://api.launchpad.dev' + private_recipe_url)
    >>> body = simplejson.dumps(author)
    >>> put_request = create_web_service_request(
    ...     beard_url, body=body, environ=headers, method='PUT')
    >>> put_request.traverse(app)()
    Traceback (most recent call last):
    ...
    Unauthorized: (<Recipe object...>, 'dish', 'launchpad.View')


== Stored file resources ==

Binary files, such as the covers of cookbooks, are stored on an
external server, but they have addresses within the web service. A
newly created cookbook has no cover.

    >>> cover_url = quote('/beta/cookbooks/The Joy of Cooking/cover')
    >>> get_request = create_web_service_request(cover_url)
    >>> file_resource = get_request.traverse(app)
    >>> file_resource()
    Traceback (most recent call last):
    ...
    NotFound: ... name: 'cover'

    >>> print C2.cover
    None

A cookbook can be given a cover with PUT.

    >>> headers = {'CONTENT_TYPE' : 'image/png'}
    >>> body = 'Pretend this is an image.'
    >>> put_request = create_web_service_request(
    ...     cover_url, body=body, environ=headers, method='PUT')
    >>> file_resource = put_request.traverse(app)
    >>> file_resource()

    >>> C2.cover
    <LibraryFileAlias ...>

At this point it exists:

    >>> get_request = create_web_service_request(cover_url)
    >>> file_resource = get_request.traverse(app)
    >>> file_resource()
    >>> get_request.response.getStatus()
    303
    >>> print get_request.response.getHeader('Location')
    http://localhost:58000/.../cover

The cover can be deleted with DELETE.

    >>> delete_request = create_web_service_request(
    ...     cover_url, method='DELETE')
    >>> file_resource = delete_request.traverse(app)
    >>> file_resource()

    >>> get_request = create_web_service_request(cover_url)
    >>> file_resource = get_request.traverse(app)
    >>> file_resource()
    Traceback (most recent call last):
    ...
    NotFound: ... name: 'cover'

    >>> print C2.cover
    None


== Requesting non available resources ==

If the user tries to traverse to a nonexistent object, the result is a
NotFound exception.

Requesting a non-existent top-level collection:

    >>> create_web_service_request('/beta/nosuchcollection').traverse(app)
    Traceback (most recent call last):
    ...
    NotFound: ... name: u'nosuchcollection'

Requesting a non-existent cookbook:

    >>> create_web_service_request('/beta/cookbooks/104').traverse(app)
    Traceback (most recent call last):
    ...
    NotFound: ... name: u'104'

Requesting an attribute which isn't exposed as a collection:

    >>> create_web_service_request(
    ...     '/beta/cookbooks/The%20Joy%20of%20Cooking/name').traverse(app)
    Traceback (most recent call last):
    ...
    NotFound: ... name: u'name'

Requesting a non-existent comment:

    >>> create_web_service_request(
    ...  '/beta/cookbooks/The%20Joy%20of%20Cooking/comments/10').traverse(app)
    Traceback (most recent call last):
    ...
    NotFound: ... name: u'10'


== Manipulating entries ==

Most entry resources support write operations by responding to PATCH
requests. The entity-body of a PATCH request should be a JSON document
with new values for some of the entry's attributes. Basically, a set
of assertions about what the object *should* look like.

A PATCH request will automatically result in a modification event
being sent out about the modified object, which means that
modify_cookbook() will be run. Here, we modify the name of one of the
cookbooks.

    >>> headers = {'CONTENT_TYPE' : 'application/json'}
    >>> body = '{"name" : "The Joy of Cooking (revised)"}'

    >>> patch_request = create_web_service_request(
    ...     '/beta/cookbooks/The%20Joy%20of%20Cooking', body=body,
    ...     environ=headers, method='PATCH')
    >>> joy_resource_patch = patch_request.traverse(app)
    >>> joy_resource_patch()
    You just modified a cookbook.
    ''

    >>> patch_request.response.getHeader('Location')
    'http://api.../cookbooks/The%20Joy%20of%20Cooking%20%28revised%29'

The new name is reflected in the cookbook's representation, and the
cookbook's URL has changed as well.

    >>> request = create_web_service_request(
    ...     '/beta/cookbooks/The%20Joy%20of%20Cooking%20%28revised%29')
    >>> joy_resource = request.traverse(app)
    >>> joy = simplejson.loads(joy_resource())
    >>> joy['name']
    u'The Joy of Cooking (revised)'

An entry that responds to PATCH will also respond to PUT. With PUT you
modify the document you got in response to a GET request, and send the
whole thing back to the server, whereas with PATCH you're creating a
new document that describes a subset of the entry's state.

Here, we use PUT to change the cookbook's name back to what it was
before. Note that we send the entire dictionary back to the
server. Note also that another modification event is sent out and
intercepted by the modified_cookbook() listener.

    >>> joy['name'] = 'The Joy of Cooking'
    >>> body = simplejson.dumps(joy)
    >>> put_request = create_web_service_request(
    ...     '/beta/cookbooks/The%20Joy%20of%20Cooking%20%28revised%29',
    ...     body=body, environ=headers, method='PUT')

    >>> joy_resource_put = put_request.traverse(app)
    >>> joy_resource_put()
    You just modified a cookbook.
    ''

Now that we've proved our point, let's disable the event handler so it
doesn't keep printing those messages.

    >>> cookbook_listener.unregister()

The cookbook's URL has changed back to what it was before.

    >>> put_request.response.getStatus()
    301
    >>> put_request.response.getHeader('Location')
    'http://api.launchpad.dev/beta/cookbooks/The%20Joy%20of%20Cooking'

So has the cookbook's name.

    >>> joy_resource = create_web_service_request(
    ...     '/beta/cookbooks/The%20Joy%20of%20Cooking').traverse(app)
    >>> joy = simplejson.loads(joy_resource())
    >>> joy['name']
    u'The Joy of Cooking'

It's also possible to change the relationships between objects. Here,
we change a cookbook's author. Since all objects are identified by
their URLs, we make the change by modifying the cookbook's
'author_link' field to point to another author.

    >>> def change_joy_author(new_author_link, host='api.launchpad.dev'):
    ...     representation = {'author_link' : new_author_link}
    ...     resource = create_web_service_request(
    ...         '/beta/cookbooks/The%20Joy%20of%20Cooking',
    ...         body=simplejson.dumps(representation), environ=headers,
    ...         method='PATCH', http_host=host).traverse(app)
    ...     return resource()
    >>> path = '/beta/authors/Julia%20Child'

    >>> change_joy_author(u'http://api.launchpad.dev' + path)
    ''

    >>> joy_resource = create_web_service_request(
    ...     '/beta/cookbooks/The%20Joy%20of%20Cooking').traverse(app)
    >>> joy = simplejson.loads(joy_resource())
    >>> joy['author_link']
    u'http://api.launchpad.dev/beta/authors/Julia%20Child'

When identifying an object by URL, make sure the hostname of your URL
matches the hostname you're requesting. If they don't match, your
request will fail.

    >>> change_joy_author(u'http://api.launchpad.net' + path)
    'author_link: No such object...'

One possible source of hostname mismatches is the HTTP port. If the
web service is served from a strange port, you'll need to specify that
port in the URLs you send.

    >>> change_joy_author(u'http://api.launchpad.dev' + path,
    ...                   host='api.launchpad.dev:9000')
    'author_link: No such object...'

    >>> change_joy_author(u'http://api.launchpad.dev:9000' + path,
    ...                   host='api.launchpad.dev:9000')
    ''

You don't have to specify the default port in the URLs you send, even
if you specified it when you made the request.

    >>> change_joy_author(u'http://api.launchpad.dev' + path,
    ...                   host='api.launchpad.dev:80')
    ''

    >>> change_joy_author(u'http://api.launchpad.dev:80' + path,
    ...                   host='api.launchpad.dev')
    ''

    >>> change_joy_author(u'https://api.launchpad.dev' + path,
    ...                   host='api.launchpad.dev:443')
    'author_link: No such object...'

    >>> from canonical.config import config
    >>> config.push('use-https', """
    ...     [vhosts]
    ...     use_https: True
    ...     """)
    >>> change_joy_author(u'https://api.launchpad.dev' + path,
    ...                   host='api.launchpad.dev:443')
    ''

    >>> ignored = config.pop('use-https')

= Cleanup =

The final step is to unregister the adapters registered for this test,
so that they don't show up in other tests as parts of the site.

    >>> from zope.component import getGlobalSiteManager
    >>> site = getGlobalSiteManager()
    >>> def unregister(required, provided, name=''):
    ...     site.unregisterAdapter(
    ...         required=required, provided=provided, name=name)
    >>> unregister([IAuthor], IAuthorEntry)
    >>> unregister([ICookbook], ICookbookEntry)
    >>> unregister([IDish], IDishEntry)
    >>> unregister([IComment], ICommentEntry)
    >>> unregister([IRecipe], IRecipeEntry)

    >>> unregister([IAuthorSet], ICollection)
    >>> unregister([ICookbookSet], ICollection)
    >>> unregister([IDishSet], ICollection)

    >>> unregister([IAuthor], IAuthorization, 'launchpad.View')
    >>> unregister([ICookbook], IAuthorization, 'launchpad.View')
    >>> unregister([IComment], IAuthorization, 'launchpad.View')
    >>> unregister([IDish], IAuthorization, 'launchpad.View')
    >>> unregister([IRecipe], IAuthorization, 'launchpad.View')

    >>> unregister([ICookbookSet, IHTTPApplicationRequest],
    ...                   IResourcePOSTOperation, 'create_cookbook')
    >>> unregister([ICookbookSet, IHTTPApplicationRequest],
    ...                    IResourceGETOperation, "find_recipes")
    >>> unregister([IRecipe, IHTTPApplicationRequest],
    ...                   IResourceGETOperation, "find_similar_recipes")
