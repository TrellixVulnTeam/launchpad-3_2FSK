= Builder Class =

This test aims to meet the requirements of
<https://launchpad.canonical.com/BasicTestCoverage> for the Builder class,
which represents the Buildd Slave entity.

Need auxiliar methods from zope toolchain:

    >>> from canonical.launchpad.webapp.testing import verifyObject
    >>> from zope.component import getUtility

Importing Builder content class and its interface:

    >>> from lp.soyuz.model.builder import Builder
    >>> from lp.soyuz.interfaces.builder import IBuilder

Get an instance of Builder from the current sampledata:

    >>> builder = Builder.get(1)

Test some attributes:

    >>> builder.id, builder.name
    (1, u'bob')

Test 'status' property:

    >>> builder.failnotes = 'Could not open Socket'
    >>> print builder.status
    Could not open Socket

    >>> builder.builderok = True
    >>> print builder.status
    Building i386 build of mozilla-firefox 0.9 in ubuntu hoary RELEASE

    >>> builder.manual = True
    >>> print builder.status
    Building i386 build of mozilla-firefox 0.9 in ubuntu hoary RELEASE

In case of copy archives the status string will show both the copy
archive owner as well as the copy archive name.

    >>> from lp.soyuz.interfaces.archive import ArchivePurpose
    >>> from zope.security.proxy import removeSecurityProxy
    >>> builder_archive = removeSecurityProxy(
    ...     builder.currentjob.build.archive)
    >>> saved_purpose = builder_archive.purpose
    >>> builder_archive.purpose = ArchivePurpose.COPY

The archive owner and name are shown at the end of the status string.

    >>> print builder.status
    Building ... mozilla-firefox 0.9 in ubuntu ... [ubuntu-team/primary]

Similarly, the status for a build in a PPA will show the owner and the
archive name:

    >>> builder_archive.purpose = ArchivePurpose.PPA
    >>> print builder.status
    Building ... mozilla-firefox 0.9 in ubuntu ... [ubuntu-team/primary]

The name of a PRIVATE team cannot be displayed publicly, so it is we
simply don't bother in adding the PPA information in the content
class domain.

    # Create a new PRIVATE team and reassign the building PPA to it.
    >>> from lp.registry.interfaces.person import (
    ...     IPersonSet, PersonVisibility)
    >>> login('foo.bar@canonical.com')
    >>> salgado = getUtility(IPersonSet).getByName('salgado')
    >>> private_team = factory.makeTeam(
    ...     salgado, name='private-team',
    ...     displayname='Private Team',
    ...     visibility=PersonVisibility.PRIVATE)
    >>> saved_owner = builder_archive.owner
    >>> builder_archive.owner = private_team
    >>> login(ANONYMOUS)

    >>> print builder.status
    Building i386 build of mozilla-firefox 0.9 in ubuntu hoary RELEASE

Restore the original archive purpose and owner.

    >>> builder_archive.purpose = saved_purpose
    >>> builder_archive.owner = saved_owner

Confirm we can get the slave xmlrpc interface

    >>> s = builder.slave

Confirm that the urlbase is correct in that slave. (If the protocol changes,
this may change too)

    >>> s.urlbase == builder.url
    True

Check if the instance corresponds to the declared interface:

    >>> verifyObject(IBuilder, builder)
    True


== BuilderSet ==

Now perform the tests for the Builder ContentSet class, BuilderSet.

Check if it can be imported:

    >>> from lp.soyuz.interfaces.builder import IBuilderSet

Check we can use the set as a utility:

    >>> builderset = getUtility(IBuilderSet)

Check if the instance returned as utility corresponds to its
respective interface:

    >>> verifyObject(IBuilderSet, builderset)
    True

Check if the instance is iterable:

    >>> for b in builderset:
    ...     b.id
    1
    2

Check if the __getitem__ method:

    >>> builderset['bob'].name
    u'bob'

Check now the specific method in the utility as new():

    >>> bnew = builderset.new(1, 'http://dummy.com:8221/', 'dummy',
    ...	                   'Dummy Title', 'eh ?', 1)
    >>> bnew.name
    u'dummy'

Check get() which returns a correspondent Builder instance to a given id:

    >>> builderset.get(bnew.id).name
    u'dummy'

Or raises an SQLObjectNotFound exception:

    >>> builderset.get(100)
    Traceback (most recent call last):
    ...
    SQLObjectNotFound: Object not found

count() return the number of builder instance we have stored:

    >>> builderset.count()
    3

getBuilder() method returns all the builders available. It seems the
same than the own instance but we have plans to turn it aware of some
attributes of builder instance as: builderok and trust.

    >>> for b in builderset.getBuilders():
    ...     b.name
    u'bob'
    u'dummy'
    u'frog'

'getBuildQueueSizeForProcessor' returns the number of pending builds
for a given Processor. The callsites can also control which build-farm
they are interested via the 'virtualized' argument.

    >>> from lp.soyuz.model.processor import Processor
    >>> p386 = Processor.selectOneBy(name='386')
    >>> amd64 = Processor.selectOneBy(name='amd64')

We will also set the 'estimated_build_duration' for the only i386
NEEDSBUILD build record we have in the sampledata.

    >>> import datetime
    >>> from lp.registry.interfaces.distribution import IDistributionSet
    >>> from lp.soyuz.interfaces.build import BuildStatus
    >>> ubuntu = getUtility(IDistributionSet).getByName('ubuntu')
    >>> pending_build = ubuntu.getBuildRecords(
    ...     build_state=BuildStatus.NEEDSBUILD)[0]
    >>> one_minute = datetime.timedelta(seconds=60)
    >>> removeSecurityProxy(pending_build).estimated_build_duration = one_minute

'virtualized' defaults to False, so if not passed, it will return the
size and estimated duration of the non-virtualized (trusted) build queue.

    >>> builderset.getBuildQueueSizeForProcessor(p386)
    (1, datetime.timedelta(0, 60))

The 'amd64' build queue is empty.

    >>> builderset.getBuildQueueSizeForProcessor(amd64)
    (0, None)

The virtualized build queue for 386 is also empty.

    >>> builderset.getBuildQueueSizeForProcessor(p386, virtualized=True)
    (0, None)

The queue size is not affect by builds target to disabled
archives. Builds for disabled archive are not dispatched as well, this
is an effective manner to hold activity in a specific archive.

We will temporarily disable the ubuntu primary archive.

    >>> login('foo.bar@canonical.com')
    >>> ubuntu.main_archive.enabled = False
    >>> login(ANONYMOUS)

That done, the non-virtualized queue for i386 becomes empty.

    >>> builderset.getBuildQueueSizeForProcessor(p386)
    (0, None)

Let's re-enable the ubuntu primary archive.

    >>> login('foo.bar@canonical.com')
    >>> ubuntu.main_archive.enabled = True
    >>> login(ANONYMOUS)

The build for the ubuntu primary archive shows up again.

    >>> builderset.getBuildQueueSizeForProcessor(p386)
    (1, datetime.timedelta(0, 60))


== Resuming buildd slaves ==

Virtual slaves are resumed using a command specified in the
configuration profile. Production configuration uses a SSH trigger
account accessed via a private key available in the builddmaster
machine (which used ftpmaster configuration profile) as in:

{{{
ssh ~/.ssh/ppa-reset-key ppa@%(vm_host)s
}}}

The test configuration uses a fake command that can be performed in
development machine and allow us to tests the important features used
in production, as 'vm_host' variable replacement.

    >>> from canonical.config import config
    >>> config.builddmaster.vm_resume_command
    'echo %(vm_host)s'

Before performing the command, it checks if the builder is indeed
virtual and raises CannotResumeHost if it isn't.

    >>> bob = getUtility(IBuilderSet)['bob']
    >>> bob.resumeSlaveHost()
    Traceback (most recent call last):
    ...
    CannotResumeHost: Builder is not virtualized.

For testing purposes resumeSlaveHost returns the stdout and stderr
buffer resulted from the command.

    >>> frog = getUtility(IBuilderSet)['frog']
    >>> out, err = frog.resumeSlaveHost()
    >>> print out.strip()
    localhost-host.ppa

If the specified command fails, resumeSlaveHost also raises
CannotResumeHost exception with the results stdout and stderr.

    # The command must have a vm_host dict key and when executed,
    # have a returncode that is not 0.
    >>> vm_resume_command = """
    ...     [builddmaster]
    ...     vm_resume_command: test "%(vm_host)s = 'false'"
    ...     """
    >>> config.push('vm_resume_command', vm_resume_command)
    >>> frog.resumeSlaveHost()
    Traceback (most recent call last):
    ...
    CannotResumeHost: Resuming failed:
    OUT:
    <BLANKLINE>
    ERR:
    <BLANKLINE>

Restore default value for resume command.

    >>> config_data = config.pop('vm_resume_command')

