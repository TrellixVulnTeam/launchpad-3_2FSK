= ExternalBugTracker: Trac =

This covers the implementation of the ExternalBugTracker class for Trac
bugwatches.


== Basics ==

The ExternalBugTracker descendant class which implements methods for updating
bug watches on Trac bug trackers is externalbugtracker.Trac.

    >>> from canonical.launchpad.components.externalbugtracker import Trac
    >>> Trac('http://trac.foo.com')
    <canonical.launchpad.components.externalbugtracker.Trac object at...>


== Status Conversion ==

The basic Trac ticket statuses map to Launchpad bug statuses.
Trac.convertRemoteStatus() handles the conversion.

    >>> trac = Trac('http://foo.bar')
    >>> trac.convertRemoteStatus('open').title
    'New'
    >>> trac.convertRemoteStatus('assigned').title
    'Confirmed'
    >>> trac.convertRemoteStatus('fixed').title
    'Fix Released'
    >>> trac.convertRemoteStatus('invalid').title
    'Invalid'
    >>> trac.convertRemoteStatus('wontfix').title
    "Won't Fix"
    >>> trac.convertRemoteStatus('duplicate').title # XXX: Fix this, too!
    'Confirmed'
    >>> trac.convertRemoteStatus('worksforme').title
    'Invalid'

If the status isn't one that our Trac ExternalBugTracker can understand,
Unknown will be returned and a warning logged.

    >>> trac.convertRemoteStatus('eggs').title
    WARNING:...:Unknown status 'eggs'
    'Unknown'

UNKNOWN_REMOTE_STATUS maps to Unknown without generating a
warning. This handles the case where we've tried to probe for a bug
but didn't succeed. For example, if the bug number was invalid.

    >>> from canonical.launchpad.interfaces import UNKNOWN_REMOTE_STATUS
    >>> trac.convertRemoteStatus(UNKNOWN_REMOTE_STATUS).title
    'Unknown'


== Initialization ==

Calling initializeRemoteBugDB() on our Trac instance and passing it a set of
remote bug IDs will fetch those bug IDs from the server and file them in a
local variable for later use.

We use a test-oriented implementation for the purposes of these tests, so that
we don't have to rely on a working network connection.

    >>> from canonical.launchpad.ftests.externalbugtracker import TestTrac
    >>> trac = TestTrac('http://test.trac')
    >>> trac.initializeRemoteBugDB([1])
    >>> sorted(trac.bugs.keys())
    [1]

If we initialise with a different set of keys we overwrite the first set:

    >>> trac.initializeRemoteBugDB([6,7,8,9,10,11,12])
    >>> sorted(trac.bugs.keys())
    [6, 7, 8, 9, 10, 11, 12]


== Updating Bug Watches ==

First, we create some bug watches to test with:

    >>> from canonical.launchpad.database import BugTracker
    >>> from canonical.launchpad.interfaces import IBugSet, IPersonSet
    >>> from canonical.launchpad.ftests.externalbugtracker import TestMantis
    >>> from canonical.lp.dbschema import BugTrackerType

    >>> sample_person = getUtility(IPersonSet).getByEmail('test@canonical.com')

    >>> example_bug_tracker = BugTracker(
    ...     name="example-bugs",
    ...     title="Example.com Trac",
    ...     bugtrackertype=BugTrackerType.TRAC,
    ...     baseurl="http://bugs.example.com",
    ...     summary="Contains bugs for Example.com",
    ...     contactdetails="foo.bar@example.com",
    ...     owner=sample_person)

    >>> login('foo.bar@canonical.com')

    >>> example_bug = getUtility(IBugSet).get(10)
    >>> example_bugwatch = example_bug.addWatch(
    ...     example_bug_tracker, 1, sample_person)

    >>> login('no-priv@canonical.com')

Collect the Example.com watches:

    >>> for bug_watch in example_bug_tracker.watches:
    ...     print "%s: %s" % (bug_watch.remotebug, bug_watch.remotestatus)
    1: None

And have a Trac instance process them:

    >>> trac = TestTrac(example_bug_tracker.baseurl)
    >>> trac.updateBugWatches(example_bug_tracker.watches)
    >>> for bug_watch in example_bug_tracker.watches:
    ...     print "%s: %s" % (bug_watch.remotebug, bug_watch.remotestatus)
    1: fixed

We'll add some more watches now.

    >>> from canonical.launchpad.interfaces import IBugSet, IBugWatchSet

    >>> bug_watch_set = getUtility(IBugWatchSet)
    >>> expected_remote_statuses = dict(
    ...     (int(bug_watch.remotebug), bug_watch.remotestatus)
    ...     for bug_watch in example_bug_tracker.watches)

    >>> expected_remote_statuses
    {1: u'fixed'}

    >>> remote_bugs = [
    ...     (143, 'fixed'),
    ...     (144, 'assigned'),
    ...     (145, 'duplicate'),
    ...     (146, 'invalid'),
    ...     (147, 'worksforme'),
    ...     (148, 'wontfix'),
    ...     (149, 'reopened'),
    ...     (150, 'new'),
    ...     (151, 'new'),
    ...     (152, 'new'),
    ...     (153, 'new'),
    ... ]

    >>> for remote_bug_id, remote_status in remote_bugs:
    ...     bug_watch = bug_watch_set.createBugWatch(
    ...         bug=example_bug, owner=sample_person,
    ...         bugtracker=example_bug_tracker,
    ...         remotebug=str(remote_bug_id))
    ...     expected_remote_statuses[remote_bug_id] = remote_status

Because we're updating more than ten bugs our Trac code will ask the server
for them all at once.

    >>> trac.trace_calls = True
    >>> trac.updateBugWatches(example_bug_tracker.watches)
    CALLED urlopen(u'http://bugs.example.com/query?id=...

    >>> remote_statuses = dict(
    ...     (int(bug_watch.remotebug), bug_watch.remotestatus)
    ...     for bug_watch in example_bug_tracker.watches)

    >>> for remote_bug_id in set(remote_statuses).union(
    ...     expected_remote_statuses):
    ...     remote_status = remote_statuses[remote_bug_id]
    ...     expected_remote_status = expected_remote_statuses[remote_bug_id]
    ...     print 'Remote bug %d' % (remote_bug_id,)
    ...     print ' * Expected << %s >>' % (expected_remote_status,)
    ...     print ' *      Got << %s >>' % (remote_status,)
    Remote bug 1
     * Expected << fixed >>
     *      Got << fixed >>
    Remote bug 143
     * Expected << fixed >>
     *      Got << fixed >>
    Remote bug 144
     * Expected << assigned >>
     *      Got << assigned >>
    Remote bug 145
     * Expected << duplicate >>
     *      Got << duplicate >>
    Remote bug 146
     * Expected << invalid >>
     *      Got << invalid >>
    Remote bug 147
     * Expected << worksforme >>
     *      Got << worksforme >>
    Remote bug 148
     * Expected << wontfix >>
     *      Got << wontfix >>
    Remote bug 149
     * Expected << reopened >>
     *      Got << reopened >>
    Remote bug 150
     * Expected << new >>
     *      Got << new >>
    Remote bug 151
     * Expected << new >>
     *      Got << new >>
    Remote bug 152
     * Expected << new >>
     *      Got << new >>
    Remote bug 153
     * Expected << new >>
     *      Got << new >>

updateBugWatches() updates the lastchecked attribute on the watches, so
now no bug watches are in need of updating:

    >>> from canonical.database.sqlbase import flush_database_updates
    >>> flush_database_updates()
    >>> example_bug_tracker.getBugWatchesNeedingUpdate(23).count()
    0

If the status isn't different, the lastchanged attribute doesn't get
updated:

    >>> import pytz
    >>> from datetime import datetime, timedelta
    >>> bug_watch = example_bug_tracker.watches[0]
    >>> now = datetime.now(pytz.timezone('UTC'))
    >>> bug_watch.lastchanged = now - timedelta(weeks=2)
    >>> old_last_changed = bug_watch.lastchanged
    >>> trac.trace_calls = False
    >>> trac.updateBugWatches(example_bug_tracker.watches)
    >>> bug_watch.lastchanged == old_last_changed
    True
