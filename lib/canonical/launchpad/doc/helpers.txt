Helper Functions and Classes
============================

There are some helper functions and classes located in
canonical.launchpad.helpers which can be used in order to avoid
duplicating code in different parts of Launchpad.

Checking If the Logged In User is a Maintainer
----------------------------------------------

We can check if the user is a maintainer of something which has an
owner by using is_maintainer():

    >>> from canonical.launchpad.helpers import is_maintainer

Let's create something that provides IHasOwner and set the owner to
Sample Person:

    >>> from zope.component import getUtility
    >>> from zope.interface import implements
    >>> from canonical.launchpad.interfaces import IPersonSet, IHasOwner
    >>> from canonical.launchpad.ftests import login
    >>> personset = getUtility(IPersonSet)
    >>> sample_person = personset.get(12)
    >>> class HasOwner:
    ...     implements(IHasOwner)
    ...     owner = sample_person
    >>> has_owner = HasOwner()

Neither anonymous nor Foo Bar is a maintainer:

    >>> is_maintainer(has_owner)
    False
    >>> login('foo.bar@canonical.com')
    >>> is_maintainer(has_owner)
    False

But Sample Person is:

    >>> login('test@canonical.com')
    >>> is_maintainer(has_owner)
    True

If we set the owner to the Ubuntu Team, Sample Person is no longer a
maintainer, while Foo Bar is, since he's a member of the team:

    >>> ubuntu_team = personset.get(17)
    >>> has_owner.owner = ubuntu_team
    >>> is_maintainer(has_owner)
    False

    >>> login('foo.bar@canonical.com')
    >>> is_maintainer(has_owner)
    True

If hasowner wouldn't provide IHasOwner a TypeError is raised:

    >>> class NoIHasOwner:
    ...     owner = sample_person
    >>> noIHasOwner = NoIHasOwner()
    >>> is_maintainer(noIHasOwner)
    Traceback (most recent call last):
    ...
    TypeError: ... doesn't provide IHasOwner


Getting a valid name as our database asks for from a string
-----------------------------------------------------------

    >>> from canonical.launchpad.helpers import getValidNameFromString

The string has capital letters.

    >>> original_string = 'EvilStringNotFollowingOurRules'
    >>> getValidNameFromString(original_string)
    'evilstringnotfollowingourrules'

The string has underscores.

    >>> original_string = 'evil_string_not_following_our_rules'
    >>> getValidNameFromString(original_string)
    'evil-string-not-following-our-rules'

The string has white spaces.

    >>> original_string = 'evil string not following our rules'
    >>> getValidNameFromString(original_string)
    'evil-string-not-following-our-rules'

A mix of all previous cases.

    >>> original_string = 'Evil String Not_Following_our rUles'
    >>> getValidNameFromString(original_string)
    'evil-string-not-following-our-rules'


requestCountry
--------------

    >>> from canonical.launchpad.helpers import requestCountry

Check if the function gets a country for localhost.

    >>> dummy_request = {'REMOTE_ADDR': '127.0.0.1'}
    >>> country = requestCountry(dummy_request)
    >>> country is not None
    True

If we don't have REMOTE_ADDR or HTTP_X_FORWARDED_FOR keys inside the request,
the country is unknown.

    >>> dummy_request = {}
    >>> country = requestCountry(dummy_request)
    >>> country is None
    True


check_permission
----------------

    >>> from canonical.launchpad.helpers import check_permission

This is the same check available in TALES as something/required:permission.Name.
It checks that the currently logged in user has the requested permission on an
object:

    >>> login('test@canonical.com')
    >>> personset = getUtility(IPersonSet)
    >>> sample_person = personset.getByEmail('test@canonical.com')
    >>> check_permission('launchpad.Edit', sample_person)
    True
    >>> sabdfl = personset.getByEmail('mark@hbd.com')
    >>> check_permission('launchpad.Edit', sabdfl)
    False

If the permission doesn't exist, it raises an error:

    >>> check_permission('mushroom.Badger', sample_person)
    Traceback (most recent call last):
    ...
    ValueError: ('Undefined permission id', 'mushroom.Badger')


Get a Snapshot of an Object
---------------------------

You can create a simple snapshot of an object with Snapshot:

    >>> from zope.interface import Interface, implements, Attribute
    >>> from canonical.launchpad.helpers import Snapshot
    >>> class IFoo(Interface):
    ...     title = Attribute('title')
    ...     description = Attribute('description')
    >>> class Foo:
    ...     implements(IFoo) 
    ...     title = 'Some Title'
    ...     description = 'bla bla bla' 
    >>> foo = Foo() 
    >>> snapshot = Snapshot(foo, names=['title'])

Only the given attributes will be assigned to the snapshot:
    
    >>> snapshot.title == foo.title
    True
    >>> hasattr(snapshot, 'description')
    False

The snapshot won't provided the same interface as foo, though:
   
    >>> IFoo.providedBy(snapshot)
    False

If we want the snapshot to provide some interface, we have to specify
that explicitly:

    >>> snapshot = Snapshot(foo, names=['title'], providing=IFoo)
    >>> snapshot.title == foo.title
    True
    >>> hasattr(snapshot, 'description')
    False
    >>> IFoo.providedBy(snapshot)
    True

We can also give more than one interface to provide as an iterable. If
we don't specify any names, all the names in the given interfaces will
be copied:
    
    >>> from zope.interface import providedBy
    >>> snapshot = Snapshot(foo, providing=providedBy(foo))
    >>> snapshot.title == foo.title
    True
    >>> snapshot.description == foo.description
    True
    >>> IFoo.providedBy(snapshot)
    True
    
    >>> class IBar(Interface):
    ...     pass
    >>> snapshot = Snapshot(foo, providing=[IFoo, IBar])
    >>> IFoo.providedBy(snapshot)
    True
    >>> IBar.providedBy(snapshot)
    True

    >>> snapshot = Snapshot(foo, providing=IFoo)
    >>> snapshot.title == foo.title
    True
    >>> snapshot.description == foo.description
    True
    >>> IFoo.providedBy(snapshot)
    True


We have to specify either 'names' or 'providing':

    >>> snapshot = Snapshot(foo)
    Traceback (most recent call last):
    ...
    SnapshotCreationError: ...
     
