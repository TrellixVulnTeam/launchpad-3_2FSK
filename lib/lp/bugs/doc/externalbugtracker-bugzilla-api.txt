Bugzilla bugtrackers with an XML-RPC API
========================================

Instances of Bugzilla version 3.4+ offer an XML-RPC API for working with
bugs. This is very similar in some regards to that offered by the
Launchpad plugin for versions 3.0 and 3.2, however the differences
between them necessitate Launchpad's support for Bugzilla 3.4+ being
implemented as a separate ExternalBugTracker.

As with the BugzillaLPPlugin ExternalBugTracker, we use a special XML-RPC
transport for the purposes of testing.

    >>> from lp.bugs.externalbugtracker.bugzilla import (
    ...     BugzillaAPI)
    >>> from lp.bugs.tests.externalbugtracker import (
    ...     TestBugzillaAPIXMLRPCTransport)
    >>> test_transport = TestBugzillaAPIXMLRPCTransport(
    ...     'http://bugzilla-3.4.example.com/')
    >>> bugzilla = BugzillaAPI(
    ...     'http://bugzilla-3.4.example.com/',
    ...     xmlrpc_transport=test_transport)
    >>> bugzilla.xmlrpc_transport == test_transport
    True


Authentication
--------------

Any XML-RPC method that modifies data on the remote server requires the
user to be logged in. The Bugzilla 3.4 API provides a method to do this
using a username and password.

The BugzillaAPI._authenticate() method is responsible for attempting to
log in to the remote server.

    >>> test_transport.print_method_calls = True
    >>> bugzilla._authenticate()
    CALLED User.login({'login': 'foo.bar@canonical.com'...})

The authorisation cookie will be stored in the auth_cookie property of
the XML-RPC transport.

    >>> test_transport.cookie_processor.cookiejar
    <cookielib.CookieJar[Cookie(version=0, name='Bugzilla_login'...),
                         Cookie(version=0, name='Bugzilla_logincookie'...)]>

Trying to log in to a Bugzilla instance for which we have no credentials
will raise an error:

    >>> transport = TestBugzillaAPIXMLRPCTransport(
    ...     'http://thiswillfail.example.com/')
    >>> non_auth_bugzilla = BugzillaAPI(
    ...     'http://thiswillfail.example.com/',
    ...     xmlrpc_transport=transport)

    >>> non_auth_bugzilla._authenticate()
    Traceback (most recent call last):
      ...
    BugTrackerAuthenticationError: http://thiswillfail.example.com:
    No credentials found.

Trying to log in to a Bugzilla with incorrect credentials will also
raise an error.

    >>> class BadCredentialsBugzillaAPI(BugzillaAPI):
    ...
    ...     credentials = {'login': 'fail', 'password': 'fail'}

    >>> non_auth_bugzilla = BadCredentialsBugzillaAPI(
    ...     'http://thiswillfail.example.com/',
    ...     xmlrpc_transport=transport)

    >>> non_auth_bugzilla._authenticate()
    Traceback (most recent call last):
        ...
    BugTrackerAuthenticationError: http://thiswillfail.example.com:
    Fault 300: The username or password you entered is not valid.


Getting the server time
-----------------------

To be able to accurately sync with a bug tracker, we need to be able to
check the time on the remote server. We use BugzillaAPI.getCurrentDBTime()
to get the current time on the remote server.

    # There's no way to create a UTC timestamp without monkey-patching
    # the TZ environment variable. Rather than do that, we create our
    # own datetime and work with that.
    >>> from datetime import datetime
    >>> remote_time = datetime(2009, 8, 19, 17, 2, 2)

    >>> test_transport.local_datetime = remote_time
    >>> bugzilla.getCurrentDBTime()
    CALLED Bugzilla.time()
    datetime.datetime(2009, 8, 19, 17, 2, 2, tzinfo=<UTC>)

If the remote system is in a different timezone, getCurrentDBTime() will
convert its time to UTC before returning it.

    >>> test_transport.utc_offset = 60**2
    >>> test_transport.timezone = 'CET'
    >>> bugzilla.getCurrentDBTime()
    CALLED Bugzilla.time()
    datetime.datetime(2009, 8, 19, 16, 2, 2, tzinfo=<UTC>)

This works whether the UTC offset is positive or negative.

    >>> test_transport.utc_offset = -5 * 60**2
    >>> test_transport.timezone = 'US/Eastern'
    >>> bugzilla.getCurrentDBTime()
    CALLED Bugzilla.time()
    datetime.datetime(2009, 8, 19, 22, 2, 2, tzinfo=<UTC>)


Initializing the bug database
-----------------------------

BugzillaAPI implements IExternalBugTracker.initializeRemoteBugDB(),
which takes a list of bug IDs to fetch from the remote server and stores
those bugs locally for future use.

    >>> bugzilla.initializeRemoteBugDB([1, 2])
    CALLED Bug.get({'ids': [1, 2], 'permissive': True})

The bug data is stored as a list of dicts:

    >>> def print_bugs(bugs):
    ...     for bug in sorted(bugs):
    ...         print "Bug %s:" % bug
    ...         for key in sorted(bugzilla._bugs[bug]):
    ...             print "    %s: %s" % (key, bugzilla._bugs[bug][key])
    ...         print "\n"

    >>> print_bugs(bugzilla._bugs)
    Bug 1:
        alias: 
        assigned_to: test@canonical.com
        component: GPPSystems
        creation_time: 20080610T16:19:53
        id: 1
        internals:...
        is_open: True
        last_change_time: 20080610T16:19:53
        priority: P1
        product: Marvin
        resolution: FIXED
        severity: normal
        status: RESOLVED
        summary: That bloody robot still exists.
    <BLANKLINE>
    Bug 2:
        alias: bug-two
        assigned_to: marvin@heartofgold.ship
        component: Crew
        creation_time: 20080611T09:23:12
        id: 2
        internals:...
        is_open: True
        last_change_time: 20080611T09:24:29
        priority: P1
        product: HeartOfGold
        resolution: 
        severity: high
        status: NEW
        summary: Collect unknown persons in docking bay 2.
    <BLANKLINE>
    <BLANKLINE>


Storing bugs
------------

initializeRemoteBugDB() uses the _storeBugs() method to store bug data.
_storeBugs() will only store a bug once, even if it is requested both by
alias and ID. We'll reset the test BugzillaAPI's _bugs and _bug_aliases
dicts to demonstrate this.

    >>> bugzilla._bugs = {}
    >>> bugzilla._bug_aliases = {}
    >>> bugzilla.initializeRemoteBugDB([2, 'bug-two'])
    CALLED Bug.get({'ids': [2, 'bug-two'], 'permissive': True})

    >>> for bug in sorted(bugzilla._bugs):
    ...     print "Bug %r:" % bug
    ...     for key in sorted(bugzilla._bugs[bug]):
    ...         print "    %s: %s" % (key, bugzilla._bugs[bug][key])
    ...     print "\n"
    Bug 2:
        alias: bug-two
        assigned_to: marvin@heartofgold.ship
        component: Crew
        creation_time: 20080611T09:23:12
        id: 2
        internals:...
        is_open: True
        last_change_time: 20080611T09:24:29
        priority: P1
        product: HeartOfGold
        resolution: 
        severity: high
        status: NEW
        summary: Collect unknown persons in docking bay 2.
    <BLANKLINE>
    <BLANKLINE>

Aliases are stored in a separate dict, which contains a mapping between
the alias and the bug's actual ID.

    >>> for alias, bug_id in bugzilla._bug_aliases.items():
    ...     print "%s: %s" % (alias, bug_id)
    bug-two: 2

The method _getActualBugId() returns the correct bug ID for a passed bug
ID or alias.

    >>> bugzilla._getActualBugId('bug-two')
    2

    >>> bugzilla._getActualBugId(2)
    2


Getting remote statuses
-----------------------

BugzillaAPI.getRemoteStatus() will return the remote status of a given
bug as a string. If the bug has a resolution, that will be returned too.

    >>> test_transport.print_method_calls = False
    >>> bugzilla.initializeRemoteBugDB([1, 2])

    >>> print bugzilla.getRemoteStatus(1)
    RESOLVED FIXED

    >>> print bugzilla.getRemoteStatus(2)
    NEW

If a bug can't be found a BugNotFound error will be raised.

    >>> bugzilla.getRemoteStatus('no-such-bug')
    Traceback (most recent call last):
      ...
    BugNotFound: no-such-bug

If the data we've imported from Bugzilla is incomplete and doesn't
contain either the bug's status or its resolution an UnparseableBugData
error will be raised. We can add a sample bug to demonstrate this.

    >>> bugzilla._bugs[999] = {}
    >>> bugzilla.getRemoteStatus(999)
    Traceback (most recent call last):
      ...
    UnparseableBugData

    >>> del bugzilla._bugs[999]


Getting a list of changed bugs
------------------------------

IExternalBugTracker defines a method, getModifiedRemoteBugs(), which
accepts a list of bug IDs and a datetime as a parameter and returns the
list of all the bug IDs in the passed set that have been changed since
that datetime.

This is acheived by calling the Bug.search() method on the
remote server and passing it a 'changed_since' parameter.

    >>> bugzilla._bugs = {}
    >>> bugzilla._bug_aliases = {}
    >>> test_transport.print_method_calls = True

    >>> bugzilla.xmlrpc_transport.print_method_calls = True
    >>> changed_since = datetime(2008, 6, 11, 9, 0, 0, 0)
    >>> bug_ids = bugzilla.getModifiedRemoteBugs([1, 2], changed_since)
    CALLED Bug.search({'id': [1, 2],
        'last_change_time': <DateTime ...'20080611T09:00:00' at...>})

    >>> print bug_ids
    [2]

If we alter the changed_since date to move it back by a day, we'll get
both bugs 1 and 2 back from getModifiedRemoteBugs()

    >>> changed_since = datetime(2008, 6, 10, 9, 0, 0, 0)
    >>> bug_ids = bugzilla.getModifiedRemoteBugs([1, 2], changed_since)
    CALLED Bug.search({'id': [1, 2],
        'last_change_time': <DateTime ...'20080610T09:00:00' at...>})

    >>> print bug_ids
    [1, 2]

Bugzilla's Bug.search() method returns all the data for each bug it
returns. getModifiedRemoteBugs() saves this information into the
BugzillaAPI instance's bugs dict.

    >>> for bug in sorted(bugzilla._bugs):
    ...     print "Bug %s:" % bug
    ...     for key in sorted(bugzilla._bugs[bug]):
    ...         print "    %s: %s" % (key, bugzilla._bugs[bug][key])
    ...     print "\n"
    Bug 1:
        alias: 
        assigned_to: test@canonical.com...
    Bug 2:
        alias: bug-two
        assigned_to: marvin@heartofgold.ship...

Once getModifiedRemoteBugs() has stored this data there's no need for
initializeRemoteBugDB() to try to retrieve it again. If we pass bug IDs
that getModifiedRemoteBugs() has already retrieved to
initializeRemoteBugDB() it will not attempt to retrieve them from the
remote system.

    >>> bugzilla.initializeRemoteBugDB([1, 2, 3])
    CALLED Bug.get({'ids': [3], 'permissive': True})


Getting the remote product
--------------------------

getRemoteProduct() returns the product a remote bug is associated with
in Bugzilla.

    >>> bugzilla.xmlrpc_transport.bugs[2]['product']
    'HeartOfGold'
    >>> bugzilla.getRemoteProduct(2)
    'HeartOfGold'

A bug alias can also be given to getRemoteProduct().

    >>> bugzilla.getRemoteProduct('bug-two')
    'HeartOfGold'

If the product is requested for a bug that can't be found, BugNotFound
is raised.

    >>> bugzilla.getRemoteProduct(12345)
    Traceback (most recent call last):
    ...
    BugNotFound: 12345
