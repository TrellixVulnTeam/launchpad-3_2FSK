The Build table
^^^^^^^^^^^^^^^

The build table contains the information pertaining to a given build
of a sourcepackagerelease on a distroarchrelease.

The build record may have many BinaryPackageRelease records pointing
at it and it may reference a build log if the build was done on a
launchpad build daemon.

  >>> from zope.interface.verify import verifyObject
  >>> from canonical.launchpad.interfaces import (
  ...     IDistributionSet, IBuildSet)
  >>> from canonical.lp.dbschema import BuildStatus

  >>> ubuntu = getUtility(IDistributionSet)['ubuntu']
  >>> warty = ubuntu['warty']
  >>> hoary = ubuntu['hoary']


First up, can we get the builds out of the sample data?

  >>> firefox_build = getUtility(IBuildSet).getByBuildID(18)
  >>> pmount_build = getUtility(IBuildSet).getByBuildID(19)

Let's check the complex properties of a build object.

  >>> firefox_build.distrorelease.name
  u'breezy-autotest'

  >>> firefox_build.title
  u'i386 build of mozilla-firefox 0.9 in ubuntu breezy-autotest'

  >>> firefox_build.was_built
  True

  >>> firefox_build.build_icon
  '/@@/build-success'

  >>> firefox_build.buildlog = 34
  >>> firefox_build.buildlog.url
  'http://localhost:58000/34/evolution-2.2-test.pot'

  >>> firefox_build.changesfile
  <LibraryFileAlias ...>

Test "reset" functionality:

  >>> firefox_build.can_be_reset
  False

  >>> frozen_build = getUtility(IBuildSet).getByBuildID(9)
  >>> frozen_build.title
  u'i386 build of pmount 0.1-1 in ubuntu warty'
  >>> frozen_build.buildstate.title
  'Failed to build'
  >>> frozen_build.can_be_reset
  False

  >>> resetable_build = getUtility(IBuildSet).getByBuildID(17)
  >>> resetable_build.title
  u'i386 build of pmount 0.1-1 in ubuntu breezy-autotest'
  >>> resetable_build.buildstate.title
  'Failed to build'
  >>> resetable_build.can_be_reset
  True
  >>> resetable_build.builder.name
  u'bob'

Reset Build record in question:

  >>> resetable_build.reset()

Build record has no history and is NEEDSBUILD:

  >>> resetable_build.builder is None
  True

  >>> resetable_build.buildstate.value is 0
  True

  >>> resetable_build.buildqueue_record is not None
  True


Initialize all the required arguments to create a binary package for a
given build record entry.

  >>> from canonical.launchpad.interfaces import IBinaryPackageNameSet
  >>> binarypackagename = getUtility(IBinaryPackageNameSet).ensure('demo').id
  >>> version = '0.0.1-demo'
  >>> summary = 'Summmmmmmmary'
  >>> description = 'Descripppppppption'
  >>> from canonical.lp import dbschema
  >>> binpackageformat = dbschema.BinaryPackageFormat.DEB
  >>> component = firefox_build.sourcepackagerelease.component.id
  >>> section = firefox_build.sourcepackagerelease.section.id
  >>> priority = dbschema.PackagePublishingPriority.STANDARD
  >>> shlibdeps = None
  >>> depends = None
  >>> recommends = None
  >>> suggests = None
  >>> conflicts = None
  >>> replaces = None
  >>> provides = None
  >>> essential = False
  >>> installedsize = 0
  >>> copyright = None
  >>> licence = None
  >>> architecturespecific = False

Invoke createBinaryPackageRelease with all required arguments.

  >>> bin = pmount_build.createBinaryPackageRelease(
  ...                                 binarypackagename, version,
  ...                                 summary, description,
  ...                                 binpackageformat, component,
  ...                                 section, priority, shlibdeps,
  ...                                 depends, recommends, suggests,
  ...                                 conflicts, replaces, provides,
  ...                                 essential, installedsize,
  ...                                 copyright, licence,
  ...                                 architecturespecific)

  >>> from canonical.launchpad.interfaces import IBinaryPackageRelease
  >>> verifyObject(IBinaryPackageRelease, bin)
  True


Commit previous transaction, data we want to preserv:

  >>> import transaction
  >>> transaction.commit()

Check binarypackages property:

  >>> for b in pmount_build.binarypackages:
  ...     b.version
  u'0.0.1-demo'
  u'0.1-1'

Emulate a huge list of binaries for 'pmount':

  >>> bpnameset = getUtility(IBinaryPackageNameSet)
  >>> for i in range(15):
  ...     version = "%d" % i
  ...     bpname = bpnameset.ensure("test-%d" % i).id
  ...     b = pmount_build.createBinaryPackageRelease(
  ...                                 bpname, version,
  ...                                 summary, description,
  ...                                 binpackageformat, component,
  ...                                 section, priority, shlibdeps,
  ...                                 depends, recommends, suggests,
  ...                                 conflicts, replaces, provides,
  ...                                 essential, installedsize,
  ...                                 copyright, licence,
  ...                                 architecturespecific)


Check if the property still working:

  >>> len(pmount_build.binarypackages)
  17

Ensure the list is ordered by 'name'

  >>> for b in pmount_build.binarypackages:
  ...     b.name, b.version
  (u'demo', u'0.0.1-demo')
  (u'pmount', u'0.1-1')
  (u'test-0', u'0')
  (u'test-1', u'1')
  (u'test-10', u'10')
  (u'test-11', u'11')
  (u'test-12', u'12')
  (u'test-13', u'13')
  (u'test-14', u'14')
  (u'test-2', u'2')
  (u'test-3', u'3')
  (u'test-4', u'4')
  (u'test-5', u'5')
  (u'test-6', u'6')
  (u'test-7', u'7')
  (u'test-8', u'8')
  (u'test-9', u'9')

Rollback transaction to no disturb the other tests:

  >>> transaction.abort()



The BuildSet class gives us some useful ways to consider the
collection of builds.

  >>> bs = getUtility(IBuildSet)

We can find builds given a source package release and architecture tag.

  >>> bs.getBuildBySRAndArchtag(20,'i386').count()
  5

Exercises IHasBuildRecords' base method getBuildsByArchIds():

For full architectures in hoary:

  >>> arch_ids = [arch.id for arch in hoary.architectures]
  >>> bs.getBuildsByArchIds(arch_ids).count()
  5

Using build status, only the succesfully built ones:

  >>> bs.getBuildsByArchIds(arch_ids,
  ...     status=BuildStatus.FULLYBUILT).count()
  2

Check the result content:

  >>> [b.title for b in bs.getBuildsByArchIds(arch_ids,
  ...     status=BuildStatus.FULLYBUILT)]
  [u'i386 build of pmount 0.1-1 in ubuntu hoary', u'i386 build of pmount 0.1-1 in ubuntu hoary']

Using optional 'name' filter (mathing with SQL LIKE %||filter||%)

  >>> bs.getBuildsByArchIds(arch_ids,
  ...     status=BuildStatus.FULLYBUILT,
  ...     name='pmo').count()
  2

Checking optional 'pocket' restriction:

  >>> from canonical.lp.dbschema import PackagePublishingPocket
  >>> bs.getBuildsByArchIds(arch_ids,
  ...     pocket=PackagePublishingPocket.UPDATES).count()
  0

  >>> bs.getBuildsByArchIds(arch_ids,
  ...     pocket=PackagePublishingPocket.RELEASE).count()
  5


We can find recent and pending builds for a given distrorelease.

  >>> hoary.getBuildRecords().count()
  5

Or for a given distroarchrelease.

  >>> hoaryi386 = hoary['i386']
  >>> hoaryi386.title
  u'The Hoary Hedgehog Release for i386 (x86)'

Exercises IHasBuildRecords abilities for distroarchreleases

  >>> hoaryi386.getBuildRecords().count()
  5

  >>> hoaryi386.getBuildRecords(status=BuildStatus.FULLYBUILT).count()
  2

  >>> hoaryi386.getBuildRecords(name='pm').count()
  2

  >>> hoaryi386.getBuildRecords(
  ...     pocket=PackagePublishingPocket.RELEASE).count()
  5

  >>> hoaryi386.getBuildRecords(
  ...     pocket=PackagePublishingPocket.UPDATES).count()
  0


Same for distroreleases:

  >>> hoary.getBuildRecords().count()
  5

  >>> hoary.getBuildRecords(status=BuildStatus.FULLYBUILT).count()
  2

  >>> hoary.getBuildRecords(name='pm').count()
  2

  >>> hoary.getBuildRecords(
  ...     pocket=PackagePublishingPocket.RELEASE).count()
  5

  >>> hoary.getBuildRecords(
  ...     pocket=PackagePublishingPocket.UPDATES).count()
  0


For sourcepackage:

  >>> firefox = warty.getSourcePackage('mozilla-firefox')

  >>> firefox.getBuildRecords().count()
  3

  >>> firefox.getBuildRecords(status=BuildStatus.FULLYBUILT).count()
  2

  >>> firefox.getBuildRecords(
  ...     pocket=PackagePublishingPocket.RELEASE).count()
  3

  >>> firefox.getBuildRecords(
  ...     pocket=PackagePublishingPocket.UPDATES).count()
  0


For a given distribution as well:

  >>> ubuntu.getBuildRecords().count()
  14

  >>> L = ubuntu.getBuildRecords(status=BuildStatus.FULLYBUILT)
  >>> for l in L:
  ...     print l.datecreated, l.id, l.buildstate.value
  2005-03-24 00:00:00+00:00 19 1
  2005-03-24 00:00:00+00:00 16 1
  2005-03-24 00:00:00+00:00 7 1
  2004-09-27 11:57:13+00:00 18 1
  2004-09-27 11:57:13+00:00 2 1

Retrieve the current PENDING builds

  >>> builds = ubuntu.getBuildRecords(status=BuildStatus.NEEDSBUILD)
  >>> builds.count()
  2

Inspect the FAILED builds:

  >>> failures = ubuntu.getBuildRecords(status=BuildStatus.FAILEDTOBUILD)
  >>> failures.count()
  1

Retrieve the single entry:

  >>> failed_build = failures[0]
  >>> failed_build.title
  u'i386 build of pmount 0.1-1 in ubuntu warty'

Try resetting the failed build record for released distroreleases failed:

  >>> failed_build.reset()
  Traceback (most recent call last):
  ...
  AssertionError: Build 9 can not be reset

Note, by ordering the build by BuildQueue.lastscore, it already notice
the existence of a new pending build, since reset already creates a
new BuildQueue record:

  >>> builds = ubuntu.getBuildRecords(status=BuildStatus.NEEDSBUILD)
  >>> builds.count()
  2

Note that they are ordered by DESC lastscore, as expected:

  >>> for b in builds:
  ...     b.id, b.buildstate.value, b.buildqueue_record.lastscore
  (11, 0, 10)
  (17, 0, 0)

Using the optional name argument to filter build results:

  >>> builds = ubuntu.getBuildRecords(name='pm')
  >>> builds.count()
  5
  >>> [(b.sourcepackagerelease.name, b.distrorelease.name) for b in builds]
  [(u'pmount', u'breezy-autotest'), (u'pmount', u'warty'), (u'pmount', u'breezy-autotest'), (u'pmount', u'hoary'), (u'pmount', u'hoary')]

or using optional pocket argument:

  >>> from canonical.lp.dbschema import PackagePublishingPocket

  >>> ubuntu.getBuildRecords(
  ...    status=BuildStatus.NEEDSBUILD,
  ...    pocket=PackagePublishingPocket.RELEASE).count()
  2

  >>> ubuntu.getBuildRecords(
  ...    status=BuildStatus.NEEDSBUILD,
  ...    pocket=PackagePublishingPocket.SECURITY).count()
  0
