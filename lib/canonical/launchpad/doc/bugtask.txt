Introduction
============

Bugs are problems in software. When a bug gets assigned to a specific
upstream or distro/sourcepackagename/binarypackagename, a bug /task/ is
created. In essence, a bug task is a bug that needs to be fixed in a specific
place. Where a bug has things like a title, comments and subscribers, it's
the bug task that tracks priority, severity, assignee, etc.

Working with Bug Tasks in Launchpad
===================================

Creating Bug Tasks
------------------

All BugTask creation and retrieval is done through an IBugTaskSet utility.

    >>> from zope.component import getUtility
    >>> import transaction
    >>> from canonical.launchpad.interfaces import IBugTaskSet
    >>> bugtaskset = getUtility(IBugTaskSet)

To create a bug task, you have to be logged in:

    >>> from canonical.launchpad.ftests import login, ANONYMOUS
    >>> login('foo.bar@canonical.com')

There are three kinds of bug tasks. We need to pass the bug task creation
methods some other objects to create a task, so lets get the utilities we need
to access those other objects:

    >>> from canonical.launchpad.interfaces import (IBugSet, IPersonSet,
    ...     IProductSet, IDistributionSet, IDistroReleaseSet,
    ...     ISourcePackageNameSet)
    >>> productset = getUtility(IProductSet)
    >>> distroset = getUtility(IDistributionSet)
    >>> distoreleaseset = getUtility(IDistroReleaseSet)
    >>> sourcepackagenameset = getUtility(ISourcePackageNameSet)
    >>> bugset = getUtility(IBugSet)
    >>> personset = getUtility(IPersonSet)
    >>> bug_one = bugset.get(1)
    >>> sabdfl = personset.get(1)

Next, we need to grab some values to provide for priority, severity and status.

    >>> from canonical.lp.dbschema import (BugTaskStatus, BugTaskSeverity,
    ...     BugTaskPriority)
    >>> STATUS_UNCONFIRMED = BugTaskStatus.UNCONFIRMED
    >>> STATUS_CONFIRMED = BugTaskStatus.CONFIRMED
    >>> STATUS_RELEASED = BugTaskStatus.RELEASED
    >>> SEVERITY_NORMAL = BugTaskSeverity.NORMAL
    >>> PRIORITY_MEDIUM = BugTaskPriority.MEDIUM

  i. Upstream -- a bug that has to be fixed in an upstream product

    >>> evolution = productset.get(5)
    >>> upstream_task = bugtaskset.createTask(
    ...     bug=bug_one, product=evolution, owner=sabdfl,
    ...     status=STATUS_UNCONFIRMED, priority=PRIORITY_MEDIUM,
    ...     severity=SEVERITY_NORMAL)
    >>> upstream_task.product == evolution
    True

    >>> from canonical.launchpad.interfaces import IUpstreamBugTask
    >>> IUpstreamBugTask.providedBy(upstream_task)
    True

  ii. Distro -- a bug that has to be fixed in a specific distro

    >>> ubuntu = distroset.get(1)
    >>> distro_task = bugtaskset.createTask(
    ...     bug=bug_one, distribution=ubuntu, owner=sabdfl,
    ...     status=STATUS_UNCONFIRMED, priority=PRIORITY_MEDIUM,
    ...     severity=SEVERITY_NORMAL)
    >>> distro_task.distribution == ubuntu
    True

    >>> from canonical.launchpad.interfaces import IDistroBugTask
    >>> IDistroBugTask.providedBy(distro_task)
    True

  ii. Distro Release -- a bug that has to be fixed in a specific distro
  release. This primary use case for distro release bug tasks is for backporting
  fixes (e.g. for security bugs or bugs causing critical data loss.)

    >>> hoary = distoreleaseset.get(3)
    >>> distro_release_task = bugtaskset.createTask(
    ...     bug=bug_one, distrorelease=hoary, owner=sabdfl,
    ...     status=STATUS_UNCONFIRMED, priority=PRIORITY_MEDIUM,
    ...     severity=SEVERITY_NORMAL)
    >>> distro_release_task.distrorelease == hoary
    True

    >>> from canonical.launchpad.interfaces import IDistroReleaseBugTask
    >>> IDistroReleaseBugTask.providedBy(distro_release_task)
    True

XXX: Brad Bollenbach, 2005-02-24: See the bottom of this file for a chunk of
test documentation that is missing from here, due to problems with resetting
the connection after a ProgrammingError is raised. ARGH.

Retrieving and Searching for Bug Tasks
--------------------------------------

To retrieve a specific BugTask, use IBugTaskSet.get. As an example, interacting
with the system as an anonymous (i.e. unauthenticated) user:

    >>> from canonical.launchpad.interfaces import IPerson
    >>> from canonical.launchpad.database import Person
    >>> login(ANONYMOUS)

let's fetch the BugTask with ID 2:

    >>> bugtask = bugtaskset.get(2)
    >>> bugtask.bug.title
    u'Firefox does not support SVG'

If you pass an ID for which no object exists, you'll get a
zope.exceptions.NotFoundError:

    >>> bugtask = bugtaskset.get(-1)
    Traceback (most recent call last):
      ...
    NotFoundError: 'BugTask with ID -1 does not exist'

Bug Task Targets
----------------

The "target" of an IBugTask is one of the following things:

 * an upstream product

    >>> upstream_task.target == evolution
    True

  * a distribution

    >>> distro_task.target == ubuntu
    True

  * a distrorelease

    >>> distro_release_task.target == hoary
    True

  * a distribution sourcepackage

    >>> from canonical.launchpad.database.distributionsourcepackage import DistributionSourcePackage
    >>> from canonical.launchpad.interfaces import IDistributionSourcePackage
    >>> distro_sp_task = bugtaskset.get(4)
    >>> expected_target = DistributionSourcePackage(
    ...     distro_sp_task.distribution,
    ...     distro_sp_task.sourcepackagename)
    >>> got_target = distro_sp_task.target
    >>> IDistributionSourcePackage.providedBy(distro_sp_task.target)
    True
    >>> got_target.distribution == expected_target.distribution
    True
    >>> got_target.sourcepackagename == expected_target.sourcepackagename
    True

  * a distrorelease sourcepackage

    >>> from canonical.launchpad.database import SourcePackage
    >>> from canonical.launchpad.interfaces import ISourcePackage
    >>> distro_release_sp_task = bugtaskset.get(16)
    >>> expected_target = SourcePackage(
    ...     distrorelease=distro_release_sp_task.distrorelease,
    ...     sourcepackagename=distro_release_sp_task.sourcepackagename)
    >>> got_target = distro_release_sp_task.target
    >>> ISourcePackage.providedBy(distro_release_sp_task.target)
    True
    >>> got_target.distrorelease == expected_target.distrorelease
    True
    >>> got_target.sourcepackagename == expected_target.sourcepackagename
    True

Each task has a "targetname", a string describing the site of the
task. It concatenates the display names of the distribution,

    >>> bugtask = bugtaskset.get(17)
    >>> bugtask.targetname
    u'mozilla-firefox (ubuntu)'

distro release, or product;

    >>> bugtask = bugtaskset.get(2)
    >>> bugtask.targetname
    u'firefox (upstream)'

the name of the source package (if any); and the name of the binary
package (but only if it's named differently from the source
package).

Let's thoroughly test BugTask._calculate_targetname.  We'll set up a dummy
bugtask class into which we put a copy of the targetname method, so we can
test it in isolation.

    >>> from canonical.launchpad.components.bugtask import NullBugTask
    >>> from canonical.launchpad.database import BugTask
    >>> class DummyBugTask:
    ...     distribution = None
    ...     distrorelease = None
    ...     sourcepackagename = None
    ...     binarypackagename = None
    ...     product = None
    ...
    ...     # This next line is a hack to take a copy of the method and
    ...     # add it to this class.
    ...     _calculate_targetname = NullBugTask._calculate_targetname.im_func
    >>> class NamedThing:
    ...     def __init__(self, name):
    ...         self.name = '[%s.name]' % name
    ...         self.displayname = '[%s.displayname]' % name
    ...         self.fullreleasename = '[%s.fullreleasename]' % name

When all the important attributes are None, then the bugtask is in an invalid
state.

    >>> bugtask = DummyBugTask()
    >>> bugtask._calculate_targetname()
    Traceback (most recent call last):
    ...
    AssertionError: ...

Product alone:

    >>> bugtask.product = NamedThing('product')
    >>> bugtask._calculate_targetname()
    '[product.name] (upstream)'

Put things back the way they were.

    >>> bugtask.product = None

Distribution alone.

    >>> bugtask.distribution = NamedThing('distribution')
    >>> bugtask._calculate_targetname()
    '[distribution.displayname]'

Distribution and sourcepackagename.

    >>> bugtask.sourcepackagename = NamedThing('spn')
    >>> bugtask._calculate_targetname()
    '[spn.name] ([distribution.displayname])'

Distribution and sourcepackagename and binarypackagename.

    >>> bugtask.binarypackagename = NamedThing('bpn')
    >>> bugtask._calculate_targetname()
    '[spn.name] [bpn.name] ([distribution.displayname])'

Reset the state of our bugtask.

    >>> bugtask.binarypackagename = None
    >>> bugtask.sourcepackagename = None
    >>> bugtask.distribution = None

Just a distrorelease.

    >>> bugtask.distrorelease = NamedThing('distrorelease')
    >>> bugtask.distrorelease.distribution = NamedThing('distribution')
    >>> bugtask._calculate_targetname()
    '[distrorelease.fullreleasename]'

Distrorelease and sourcepackagename.

    >>> bugtask.sourcepackagename = NamedThing('spn')
    >>> bugtask._calculate_targetname()
    '[spn.name] ([distrorelease.fullreleasename])'

Distrorelease, sourcepackagename and binarypackagename.

    >>> bugtask.binarypackagename = NamedThing('bpn')
    >>> bugtask._calculate_targetname()
    '[spn.name] [bpn.name] ([distrorelease.fullreleasename])'

Note that we haven't tested any combinations that shouldn't occur, except
for the case when everything is None.

To retrieve a set of bug tasks matching a set of search criteria, use
the searchTasks method of the IBugTarget interface. Here's how you'd
grab all the UNCONFIRMED and CONFIRMED tasks:

For upstream:

    >>> from canonical.launchpad.searchbuilder import any
    >>> from canonical.lp.dbschema import BugTaskStatus
    >>> from canonical.launchpad.database import Product
    >>> from canonical.launchpad.interfaces import BugTaskSearchParams
    >>> upstream_mozilla = Product.get(4)
    >>> params = BugTaskSearchParams(status=any(BugTaskStatus.UNCONFIRMED,
    ...                                         BugTaskStatus.CONFIRMED),
    ...                              orderby="id", user=None)
    >>> bugtasks = upstream_mozilla.searchTasks(params)
    >>> print bugtasks.count()
    4
    >>> bugtask_ids = [bt.id for bt in bugtasks]
    >>> print bugtask_ids
    [2, 13, 14, 15]

For a distribution:

    >>> debian = distroset.get(3)
    >>> sample_person = personset.get(12)
    >>> params = BugTaskSearchParams(status=any(BugTaskStatus.UNCONFIRMED,
    ...                                         BugTaskStatus.CONFIRMED),
    ...                              orderby="id", user=None,
    ...                              assignee=sample_person)
    >>> bugtasks = debian.searchTasks(params)
    >>> print bugtasks.count()
    1
    >>> bugtasks[0].id
    5

For a person:

    >>> from canonical.database.sqlbase import (
    ...     flush_database_updates, flush_database_caches)
    >>> foobar = personset.get(16)
    >>> evolution_sourcepackage = sourcepackagenameset.queryByName('evolution')
    >>> ubuntu_evolution_task = bugtaskset.createTask(
    ...     bug=bug_one, distribution=ubuntu, owner=foobar,
    ...     status=STATUS_UNCONFIRMED, priority=PRIORITY_MEDIUM,
    ...     severity=SEVERITY_NORMAL, sourcepackagename=evolution_sourcepackage)
    >>> flush_database_updates()
    >>> params = BugTaskSearchParams(owner=foobar, user=None,
    ...                              orderby='targetname')
    >>> [bugtask.targetname for bugtask in foobar.searchTasks(params)]
    [u'evolution (ubuntu)', u'evolution (upstream)', u'mozilla-firefox (debian)', u'mozilla-firefox (ubuntu)']

It's also possible to search bugs that a person is subscribed to:

    >>> params = BugTaskSearchParams(user=None, subscriber=foobar)
    >>> [bugtask.bug.id for bugtask in foobar.searchTasks(params)]
    [7]

To provide null-matching search criteria, use canonical.launchpad.searchbuilder.NULL:

    >>> from canonical.launchpad.searchbuilder import NULL
    >>> params = BugTaskSearchParams(assignee=NULL, user=None)
    >>> bugtasks = upstream_mozilla.searchTasks(params)
    >>> print bugtasks.count()
    2
    >>> print [bugtask.bug.id for bugtask in bugtasks]
    [4, 6]

There's also support for searching tasks based on a string of text, e.g.:

    >>> params = BugTaskSearchParams(searchtext="instructions", user=None)
    >>> bugtasks = upstream_mozilla.searchTasks(params)
    >>> print bugtasks.count()
    1
    >>> print [bugtask.bug.id for bugtask in bugtasks]
    [5]

It's also possible to iterate over all the bug tasks:

    >>> bugtasks = [bugtask for bugtasks in bugtaskset]
    >>> len(bugtasks)
    19

Bug Task Maintainers
--------------------

The upcoming sections mention bug task maintainers, so we should
probably clarify that before going any further. IBugTask provides a
maintainer attribute, and a maintainer_displayname attribute; the
latter is mainly for use in ZCML configuration on add/editforms where
you want to show the maintainer's name. maintainer_displayname will
probably go away in the future and be replaced by a smarter display
widget for the maintainer name.

The maintainer of an upstream task is simply the Product.owner:

    >>> bugtask = bugtaskset.get(2)
    >>> bugtask.maintainer.displayname
    u'Sample Person'

The maintainer of a distribution task is the source package maintainer:

    >>> bugtask = bugtaskset.get(4)
    >>> bugtask.maintainer.id
    1

or None, if the task is not yet assigned to a specific source
package. So, borrowing the distro task we filed earlier:

    >>> print distro_task.maintainer
    None
    >>> print distro_task.maintainer_displayname
    None

Editing Bug Tasks
-----------------

Upstream Bug Tasks
^^^^^^^^^^^^^^^^^^

To edit an upstream task, you must be logged in. Anonymous users
cannot edit upstream tasks.

    >>> login(ANONYMOUS)
    >>> upstream_task.status = STATUS_CONFIRMED
    Traceback (most recent call last):
      ...
    Unauthorized: ('status', 'launchpad.Edit')

Now let's login as a maintainer and try again.

    >>> login('test@canonical.com')
    >>> upstream_task.status = STATUS_RELEASED

Again, this time as someone other than the maintainer:

    >>> login('jeff.waugh@ubuntulinux.com')
    >>> upstream_task.status = STATUS_RELEASED

Distro and Distro Release Bug Tasks
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Any logged-in user can edit tasks filed on distros as long as the bug
is not marked private. So, as an anonymous user, we can edit anything:

    >>> login(ANONYMOUS)
    >>> distro_task.status = STATUS_RELEASED
    Traceback (most recent call last):
      ...
    Unauthorized: ('status', 'launchpad.Edit')

    >>> distro_release_task.assignee = sample_person
    Traceback (most recent call last):
      ...
    Unauthorized: ('assignee', 'launchpad.Edit')

But once authenticated:

    >>> login('test@canonical.com')

We can edit the task:

    >>> distro_task.status = STATUS_RELEASED
    >>> distro_release_task.assignee = sample_person

Null Bug Tasks
--------------

Sometimes we need to be able to render a page for a bug in a context,
when the bug hasn't actually been filed yet in that context. For cases
like these, use the NullBugTask object.

    >>> netapplet = productset.get(11)
    >>> null_bugtask = NullBugTask(bug=bug_one, product=netapplet)
    >>> IUpstreamBugTask.providedBy(null_bugtask)
    True

    >>> null_bugtask.id is None
    True
    >>> null_bugtask.title == 'Bug #1 in netapplet (upstream): "Firefox does not support SVG"'
    True
    >>> null_bugtask.product is netapplet
    True
    >>> null_bugtask.bug == bug_one
    True
    >>> null_bugtask.datecreated is None
    True
    >>> null_bugtask.dateassigned is None
    True
    >>> null_bugtask.age is None
    True
    >>> null_bugtask.status is None
    True
    >>> null_bugtask.priority is None
    True
    >>> null_bugtask.sourcepackagename is None
    True
    >>> null_bugtask.distribution is None
    True
    >>> null_bugtask.distrorelease is None
    True
    >>> null_bugtask.milestone is None
    True
    >>> null_bugtask.statusexplanation is None
    True
    >>> null_bugtask.severity is None
    True
    >>> null_bugtask.assignee is None
    True
    >>> null_bugtask.binarypackagename is None
    True
    >>> null_bugtask.bugwatch is None
    True
    >>> null_bugtask.owner is None
    True
    >>> null_bugtask.maintainer == netapplet.owner
    True
    >>> null_bugtask.maintainer_displayname == netapplet.owner.displayname
    True
    >>> null_bugtask.target == netapplet
    True
    >>> null_bugtask.targetname
    u'netapplet (upstream)'
    >>> expected_related_task_ids = [
    ...     task.id for task in null_bugtask.related_tasks]
    >>> actual_related_task_ids = [task.id for task in bug_one.bugtasks]
    >>> expected_related_task_ids.sort()
    >>> actual_related_task_ids.sort()
    >>> expected_related_task_ids == actual_related_task_ids
    True
    >>> null_bugtask.statusdisplayhtml
    u'Not reported in netapplet (upstream)'
    >>> null_bugtask.statuselsewhere
    'fixed in 2 of 7 places'

The astute reader will have noticed that NullBugTask automatically
"marked" itself as providing the correct IBugTask interface. Let's see
two more examples:

    >>> ubuntu_null_bugtask = NullBugTask(bug=bug_one, distribution=ubuntu)
    >>> IDistroBugTask.providedBy(ubuntu_null_bugtask)
    True

    >>> hoary_null_bugtask = NullBugTask(bug=bug_one, distrorelease=hoary)
    >>> IDistroReleaseBugTask.providedBy(hoary_null_bugtask)
    True

Bug Privacy
===========

A bug is either private or public. Private bugs are only visible (e.g. in search
listings) to explicit subscribers and Launchpad admins. Public bugs are visible
to anyone.

    >>> from zope.event import notify
    >>> from zope.publisher.browser import TestRequest
    >>> from canonical.launchpad.event.sqlobjectevent import (
    ...     SQLObjectToBeModifiedEvent, SQLObjectModifiedEvent)

Privacy and Unpriviledged Users
-------------------------------

Let's log in as the user Foo Bar (to be allowed to edit bugs):

    >>> login('foo.bar@canonical.com')
    >>> foobar = getUtility(ILaunchBag).user

and mark one of the Firefox bugs private:

    >>> bug_upstream_firefox_no_svg_support = bugtaskset.get(2)
    >>> notify(SQLObjectToBeModifiedEvent(
    ...     bug_upstream_firefox_no_svg_support.bug, {'private' : True}))

    >>> def capture_state(obj, *fields):
    ...     class State: pass
    ...     state = State()
    ...     for field in fields:
    ...         setattr(state, field, getattr(obj, field))
    ...     return state
    >>> old_state = capture_state(
    ...     bug_upstream_firefox_no_svg_support.bug, "id", "title",
    ...     "summary", "description", "private", "name",
    ...     "duplicateof")
    >>> bug_upstream_firefox_no_svg_support.bug.private = True
    >>> bug_set_private = SQLObjectModifiedEvent(
    ...     bug_upstream_firefox_no_svg_support.bug, old_state,
    ...     ["id", "title", "private"])
    >>> notify(bug_set_private)
    >>> transaction.commit()

If we now login as someone who was neither implicitly nor explicitly subscribed
to this bug, e.g. No Privileges Person, they will not be able to access or set
properties of the bugtask.

    >>> login("no-priv@canonical.com")
    >>> mr_no_privs = getUtility(ILaunchBag).user

    >>> bug_upstream_firefox_no_svg_support.status
    Traceback (most recent call last):
      ...
    Unauthorized: ('status', 'launchpad.View')

    >>> bug_upstream_firefox_no_svg_support.status = BugTaskStatus.FIXED
    Traceback (most recent call last):
      ...
    Unauthorized: ('status', 'launchpad.Edit')

The private bugs will be invisible to No Privileges Person in the search
results:

    >>> params = BugTaskSearchParams(
    ...     status=any(STATUS_UNCONFIRMED, STATUS_CONFIRMED),
    ...     orderby="id", user=mr_no_privs)
    >>> bugtasks = upstream_mozilla.searchTasks(params)
    >>> print bugtasks.count()
    3
    >>> bug_ids = [bt.bug.id for bt in bugtasks]
    >>> print sorted(bug_ids)
    [4, 5, 6]

Likewise when the No Privileges Person tries to do a search on tasks
maintained by Foo Bar.

    >>> foobar_maintained_tasks = bugtaskset.maintainedBugTasks(
    ...     foobar, user=mr_no_privs)
    >>> [bugtask.bug.id for bugtask in foobar_maintained_tasks]
    [2]

Privacy and Priviledged Users
-----------------------------

Now, we'll log in as Mark Shuttleworth, who was assigned to this bug
when it was marked private:

    >>> login("mark@hbd.com")

And note that he can access and set the bugtask attributes:

    >>> bug_upstream_firefox_no_svg_support.status.title
    'Unconfirmed'

    >>> bug_upstream_firefox_no_svg_support.status = BugTaskStatus.UNCONFIRMED

Privacy and Team Awareness
--------------------------

Foo Bar is a member of the Ubuntu Team. At the moment he can't see the
private bug, since he's not a subscriber:

    >>> login("foo.bar@canonical.com")
    >>> firefox = productset['firefox']
    >>> params = BugTaskSearchParams(
    ...     status=any(STATUS_UNCONFIRMED, STATUS_CONFIRMED), user=foobar)
    >>> firefox_bugtasks = firefox.searchTasks(params)
    >>> [bugtask.bug.id for bugtask in firefox_bugtasks]
    [4, 5, 6]


But if we subscribe the Ubuntu Team, of which Foo Bar is a member, he
will see the private bug.

    >>> login("mark@hbd.com")
    >>> bug_upstream_firefox_no_svg_support.bug.subscribe(foobar)
    <BugSubscription...>

    >>> login("foo.bar@canonical.com")
    >>> params = BugTaskSearchParams(
    ...     status=any(STATUS_UNCONFIRMED, STATUS_CONFIRMED), user=foobar)
    >>> firefox_bugtasks = firefox.searchTasks(params)
    >>> [bugtask.bug.id for bugtask in firefox_bugtasks]
    [1, 4, 5, 6]


If we query for all bugtasks reported on all packages/products that
Sample Person maintains, we'll see that bug 1 is there (we'll not see it
if we query logged in as a user who can't see that bug).

    >>> foobar_maintained_tasks = bugtaskset.maintainedBugTasks(
    ...     sample_person, user=foobar)
    >>> [bugtask.bug.id for bugtask in foobar_maintained_tasks]
    [1, 4, 5, 7]

Privacy and Launchpad Admins
----------------------------

Let's log in as David Allouche:

    >>> login("david.allouche@canonical.com")
    >>> ddaa = getUtility(ILaunchBag).user

The same search as above yields the same result, because David Allouche is an
administrator.

    >>> firefox = productset.get(4)
    >>> params = BugTaskSearchParams(status=any(STATUS_UNCONFIRMED,
    ...                                         STATUS_CONFIRMED),
    ...                              user=foobar)
    >>> firefox_bugtasks = firefox.searchTasks(params)
    >>> [bugtask.bug.id for bugtask in firefox_bugtasks]
    [1, 4, 5, 6]

If, still logged in as David Allouche, we query for all bugtasks
reported on packages/products for which Sample Person is the maintainer,
we'll also see bug 1 again in the results, even though it's private.

    >>> foobar_maintained_tasks = bugtaskset.maintainedBugTasks(
    ...     sample_person, user=ddaa)
    >>> [bugtask.bug.id for bugtask in foobar_maintained_tasks]
    [1, 4, 5, 7]

Trying to retrieve the bug directly will work fine:

    >>> bug_upstream_firefox_no_svg_support = bugtaskset.get(2)

As will attribute access:

    >>> bug_upstream_firefox_no_svg_support.status.title
    'Unconfirmed'

And attribute setting:

    >>> bug_upstream_firefox_no_svg_support.status = BugTaskStatus.RELEASED
    >>> bug_upstream_firefox_no_svg_support.status = BugTaskStatus.UNCONFIRMED

It's all good.

Privacy and Maintainers
-----------------------

Then logged in as the Firefox maintainer:

    >>> login('test@canonical.com')
    >>> sample_person = getUtility(ILaunchBag).user

We'll find all four IBugTasks that match the search criteria. The maintainer is
also an explicit subscriber in this case.

    >>> params = BugTaskSearchParams(
    ...     status=any(STATUS_UNCONFIRMED, STATUS_CONFIRMED),
    ...     orderby="id", user=sample_person)
    >>> bugtasks = upstream_mozilla.searchTasks(params)
    >>> print bugtasks.count()
    4
    >>> bug_ids = [bt.bug.id for bt in bugtasks]
    >>> print sorted(bug_ids)
    [1, 4, 5, 6]

And, as you would expect, we'll also be able to access it directly:

    >>> bug_upstream_firefox_no_svg_support = bugtaskset.get(2)
    >>> bug_upstream_firefox_no_svg_support.bug.title
    u'Firefox does not support SVG'

    >>> bug_upstream_firefox_no_svg_support.status = BugTaskStatus.UNCONFIRMED

Sorting Bug Tasks
-----------------

Bug tasks need to sort in a very particular order. We want product tasks
first, then ubuntu tasks, then other distro-related tasks. In the
distro-related tasks we want a distribution-task first, then
distrorelease-tasks for that same distribution. The distrorelease tasks
should be sorted by distrorelease version.

Phew.

Let's just make sure that the tasks on bug_one sort correctly.

    >>> tasks = bug_one.bugtasks
    >>> for task in tasks:
    ...     print task.targetname
    evolution (upstream)
    firefox (upstream)
    ubuntu
    evolution (ubuntu)
    mozilla-firefox (ubuntu)
    Ubuntu Hoary
    mozilla-firefox (debian)

BugTask Adaptation
------------------

An IBugTask can be adapted to an IBug.

   >>> from canonical.launchpad.interfaces import IBug

   >>> bugtask_four = bugtaskset.get(4)
   >>> bug = IBug(bugtask_four)
   >>> bug.title
   u'Firefox does not support SVG'

The targetnamecache attribute of BugTask
----------------------------------------

The BugTask table has this targetnamecache attribute which stores a computed
value to allow us to sort and search on that value without having to do lots
of SQL joins. This cached value gets updated daily by the
update-bugtask-targetnamecaches cronscript and whenever the bugtask is changed.
Of course, it's also computed and set when a bugtask is created.

    >>> upstream_task = bugtaskset.createTask(
    ...     bug=bug_one, product=netapplet, owner=sabdfl,
    ...     status=STATUS_UNCONFIRMED, priority=PRIORITY_MEDIUM,
    ...     severity=SEVERITY_NORMAL)
    >>> upstream_task.targetname
    u'netapplet (upstream)'

    >>> thunderbird = productset.get(8)
    >>> upstream_task_id = upstream_task.id
    >>> upstream_task.product = thunderbird
    >>> upstream_task.targetname
    u'thunderbird (upstream)'

    >>> thunderbird.name = 'thunderbird-ng'

    # XXX: This flush_database_updates() shouldn't be needed because we
    # already have the transaction.commit() here, but without it
    # (flush_database_updates), the cronscript won't see the thunderbird name
    # change. See https://launchpad.net/products/launchpad/+bug/3989 for more
    # information.
    >>> flush_database_updates()
    >>> transaction.commit()

    >>> import subprocess
    >>> process = subprocess.Popen(
    ...     'cronscripts/update-bugtask-targetnamecaches.py -q', shell=True,
    ...     stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    >>> (out, err) = process.communicate()
    >>> out, err
    ('', '')
    >>> process.returncode
    0

    # XXX: If we don't call flush_database_caches() here, we won't see the
    # changes made by the cronscript in objects we already have cached.
    >>> flush_database_caches()
    >>> transaction.commit()

    >>> bugtaskset.get(upstream_task_id).targetname
    u'thunderbird-ng (upstream)'

Handling IntegrityError and ProgrammingError
--------------------------------------------

XXX: Brad Bollenbach, 2005-02-24: This bit testing the IntegrityError should be
higher up in the file (under the explanation about creating tasks), but I can't
figure out how to reset the connection properly after an IntegrityError is
raised. ARGH.

Note that a task filed on a specific distro release does *not* have its
distribution column set. In fact, a task must have exactly one of its product,
distribution or distrorelease fields set, otherwise the database integrity
constraints will be violated.

note that DatabaseError is a superclass of both IntegrityError and
ProgrammingError

    >>> from psycopg import DatabaseError
    >>> import sys
    >>> try: bad_task = bugtaskset.createTask(
    ...     bug=bug_one, distribution=ubuntu, distrorelease=hoary,
    ...     owner=sabdfl, status=STATUS_UNCONFIRMED, priority=PRIORITY_MEDIUM,
    ...     severity=SEVERITY_NORMAL)
    ... except DatabaseError: print sys.exc_value
    ERROR:  new row for relation "bugtask" violates check constraint "bugtask_assignment_checks"
    <BLANKLINE>
    INSERT INTO BugTask ...

