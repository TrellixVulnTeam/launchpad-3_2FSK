= Launchpad's WADL documents =

Every resource in the web service has a WADL representation that
describes the capabilities of the resource in a machine-readable
format. These documents are similar to the HTML documents that provide
human beings with links to click and forms to fill out.


== Entry resources ==

Let's get a WADL representation of a resource (in this case, a bug
task), and see what's inside.

    >>> wadl = webservice.get('/beta/debian/+source/mozilla-firefox/+bug/1',
    ...                       'application/vd.sun.wadl+xml').getBody()


It's an XML document.

    >>> print wadl
    <?xml version="1.0"?>
    <application xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xmlns="http://research.sun.com/wadl/2006/10"
        xsi:schemaLocation="http://research.sun.com/wadl/2006/10/wadl.xsd">
    ...
    </application>

Let's parse it.

    >>> import cElementTree as ET
    >>> tree = ET.fromstring(wadl)

The root tag of any WADL document is called 'application'. Note the
namespaced tag name; I'm going to ignore the namespace from this point
on.

    >>> tree.tag
    '{http://research.sun.com/wadl/2006/10}application'

A WADL representation of a Launchpad resource has four tags beneath
the 'application' tag. These tags describe the representation you get
from a GET request and are expected to send with a PUT request, the
representation you are expected to send with a PATCH request, a
description of what you're allowed to do with a certain type of
resource, and a statement that this resource is of the type just
described.

    >>> (full_rep, diff_rep, resource_type, resources) = list(tree)


== Representations ==

First let's look at the two representations. Each is a 'representation'
tag, and each specifies what media type it's describing. Both of these
are JSON representations.

    >>> full_rep.tag
    '...representation'
    >>> full_rep.attrib
    {'mediaType': 'application/json', 'id': 'BugTaskEntry-full'}

    >>> diff_rep.tag
    '...representation'
    >>> diff_rep.attrib
    {'mediaType': 'application/json', 'id': 'BugTaskEntry-diff'}


=== Parameters ===

The 'representation' tag can specify parameters that point clients to
interesting parts of the representation. Our JSON representations of
entries are hashes, and we've chosen to specify a parameter for each
key of the hash.

    >>> full_params = list(full_rep)
    >>> full_params[0].tag
    '...param'
    >>> full_rep_names = sorted([param.attrib['name']
    ...                         for param in full_params])
    >>> full_rep_names
    ['assignee_link', 'bug_link', ... 'title']

In addition to a name, each parameter has a 'path', which is what you
have to do to the JSON data structure to get the parameter's value.

    >>> sorted([param.attrib['path'] for param in full_params])
    ['["assignee_link"]', '["bug_link"]', ... '["title"]']

So to get the assignee link out of data structure 'foo' you need the
code 'foo["assignee_link"]'. This is not a standard; it's something we
made up due to the lack of an XPath-like standard for JSON. If such a
standard emerges we should change it.

Some parameters are links to other resources. These parameters have a
child tag called 'link' with information about what's on the other end
of the link.

    >>> assignee_param, = [param for param in full_params
    ...                    if param.attrib['name'] == 'assignee_link']
    >>> assignee_link, = list(assignee_param)
    >>> assignee_link.tag
    '...link'

Right now there's no information about the link, just the fact that it
is a link.

    >>> assignee_link.attrib
    {}

The full representation contains all fields, even read-only ones,
because it's describing the document you receive when you make a GET
request. You can modify such a document and send it back with PUT, so
the full representation also suffices to describe the documents you
PUT. But you can't send values for read-only fields with PATCH, so we
define a second representation for use with PATCH requests.

    >>> diff_params = list(diff_rep)
    >>> diff_params[0].tag
    '...param'
    >>> diff_rep_names = sorted([param.attrib['name']
    ...                          for param in diff_params])

    >>> 'related_tasks_collection_link' in full_rep_names
    True
    >>> 'related_tasks_collection_link' in diff_rep_names
    False

Most 'param' tags don't tell the client much beyond where to find a
certain parameter, but some of our parameters take values from a
proscribed vocabulary. These parameters correspond to Choice fields
who take their vocabulary from an EnumeratedValue. For these
parameters, we provide the client with information about the possible
values.

    >>> status_param, = [param for param in full_params
    ...                  if param.attrib['name'] == 'status']
    >>> status_options = list(status_param)
    >>> status_options[0].tag
    '...option'
    >>> sorted(status.attrib['value'] for status in status_options)
    ['Confirmed', 'Fix Committed', ... "Won't Fix"]


=== The resource type ===

The 'representation' tags tell you what representations a resource
sends and receives. In this case the representations are for a
'bugtask' resource. What about the resource itself? All bug tasks are
pretty much the same, and so most of the information about a bug task
is kept in a 'resource_type' tag.

    >>> resource_type.tag
    '...resource_type'

A resource type tells the client about the three standard operations
on a resource (GET, PUT, and PATCH), as well as any custom GET or POST
operations.

    >>> methods = list(resource_type)
    >>> get, put, patch, post = methods

The name of a method is always the HTTP method used to activate
it. Different operations that use the same method are distinguished by
id. Here that's not a problem; we have one custom POST method
('BugTaskEntry-change_status'), plus the standard GET, PATCH, and PUT.

    >>> [method.attrib['name'] for method in methods]
    ['GET', 'PUT', 'PATCH', 'POST']

    >>> [method.attrib['id'] for method in methods]
    ['BugTaskEntry-get', 'BugTaskEntry-put',
     'BugTaskEntry-patch', 'BugTaskEntry-change_status']


=== Standard operations ===

The standard GET method defines a 'response' tag, which tells the
client that they can use content negotiation to get two different
representations of a bug task: the JSON one described above as
"BugTask-full", and a WADL document--this document, in fact.

    >>> response, = list(get)
    >>> response.tag
    '...response'
    >>> full, wadl = list(response)
    >>> full.attrib
    {'href': '#BugTaskEntry-full'}
    >>> wadl.attrib
    {'mediaType': 'application/vd.sun.wadl+xml', 'id': 'BugTaskEntry-wadl'}

Note that the JSON representation is just a hyperlink to the
representation defined earlier.

Similarly, the standard PUT and PATCH methods each include a 'request'
tag, which tells the client which representation it should send along
with a request.

    >>> request, = list(put)
    >>> request.tag
    '...request'
    >>> representation, = list(request)
    >>> representation.attrib
    {'href': '#BugTaskEntry-full'}

    >>> patch[0][0].attrib
    {'href': '#BugTaskEntry-diff'}

This is why we defined the representations separately. Now we can
link to them instead of describing them every time.


=== Custom operations ===

Custom operations define parameters, just like representations do.

    >>> post_params = list(post)
    >>> [param.attrib['name'] for param in post_params]
    ['ws_op', 'status']

The 'ws_op' parameter is present for all custom operations. It's always
required, and fixed to a particular value.

    >>> ws_op, status = post_params
    >>> ws_op.attrib['required']
    'True'
    >>> ws_op.attrib['fixed']
    'change_status'

Depending on the operation there might be other parameters. If the
parameters of the right type, they too can be described with a list of
valid values.

    >>> sorted([value.attrib['value'] for value in list(status)])
    ['Confirmed', 'Fix Committed', ... "Won't Fix"]


=== The resource ===

Now we know what a bug task resource can do and what documents it can
serve. But we haven't defined any actual bug task resources! This
happens in the final tag under consideration.

    >>> resources.attrib['href']
    'http://api.launchpad.dev/beta/debian/+source/mozilla-firefox/+bug/1'

The tag is called 'resources' but only one resource is defined. That's
because this WADL document is a representation of a specific resource:
a bug task. It's not a description of the whole site--in fact, there
is no such description, just descriptions of the kinds of objects and
how they interact.

    >>> resource, = list(resources)

A resource's path is defined relative to the URL given in its parent
'resources' tag. Since only one resource is being defined, the
simplest thing to do is put the full URL in the 'resources' tag.

    >>> resource.attrib['path']
    ''

The whole rest of the document was dedicated to defining the interface
of bugtask-type entries, so to say that the resource at
/debian/+source/mozilla-firefox/+bug/1 is a bugtask-type entry, all
we have to do is refer to the previous definition.

    >>> resource.attrib['type']
    '#BugTaskEntry'

A client can resolve the relative URL "#BugTaskEntry" and figure out
what HTTP methods the resource exposes and what representations it
serves and expects.


== Collection resources ==

A collection resource has a simpler WADL representation. Collections
support one standard HTTP method (GET) in addition to any custom
operations. The representation of one type of entry (say, a person)
looks different from the representation of another type (say, a bug),
but all collections look the same, no matter what kind of entries they
contain.

    >>> wadl = webservice.get('/beta/people',
    ...                       'application/vd.sun.wadl+xml').getBody()
    >>> tree = ET.fromstring(wadl)
    >>> (page_rep, resource_type, resources) = list(tree)

    >>> page_rep.tag
    '...representation'
    >>> page_rep.attrib
    {'mediaType': 'application/json', 'id': 'collection-page'}
    >>> params = list(page_rep)
    >>> [param.attrib['name'] for param in params]
    ['total_size', 'next_collection_link', 'prev_collection_link', 'entries']
    >>> size, next, prev, entries = params

The 'next_collection_link' and 'prev_collection_link' parameters are
links to other resources. What are these other resources? Other pages
of the same collection!

    >>> next_type, = list(next)
    >>> next_type.attrib['type']
    '#collection-page'

    >>> prev_type, = list(prev)
    >>> prev_type.attrib['type']
    '#collection-page'

=== Collection operations ===

The "list of people" resource exposes a standard GET, as well as two
custom operations, 'create_person' (POST) and 'people' (GET).

    >>> methods = list(resource_type)

    >>> [method.attrib['name'] for method in methods]
    ['GET', 'POST', 'GET']

    >>> [method.attrib['id'] for method in methods]
    ['PersonCollection-get', 'PersonCollection-create_person',
     'PersonCollection-people']

    >>> (get, create_person, people) = methods

The standard GET operation is a way of getting either the
'collection-page' representation defined above, or else the WADL
document we're working on right now.

    >>> response, = list(get)
    >>> json_rep, wadl_rep = list(response)
    >>> json_rep.attrib
    {'href': '#collection-page'}
    >>> wadl_rep.attrib
    {'mediaType': 'application/vd.sun.wadl+xml',
     'id': 'PersonCollection-wadl'}

The 'create_person' custom operation takes a number of parameters.

    >>> [param.attrib['name'] for param in list(create_person)]
    ['ws_op', 'email_address', 'comment', 'name', 'display_name', 'password']

    >>> ws_op = create_person[0]
    >>> ws_op.attrib['fixed']
    'create_person'

So does the 'people' custom operation.

    >>> [param.attrib['name'] for param in list(people)]
    ['ws_op', 'text']

    >>> ws_op = people[0]
    >>> ws_op.attrib['fixed']
    'people'

=== The resource ===

As with an entry, a collection's WADL representation ends with a short
'resources' stanza referencing the big definitions that preced it.

    >>> resources.attrib['href']
    'http://api.launchpad.dev/beta/people'

    >>> resource, = resources
    >>> resource.attrib
    {'path': '', 'type': '#PersonCollection'}


== Scoped collection resources ==

Scoped collection resources have WADL representations that look just
like the representations of regular collections.

    >>> wadl = webservice.get('/beta/~admins/members',
    ...                       'application/vd.sun.wadl+xml').getBody()

    >>> tree = ET.fromstring(wadl)
    >>> (page_rep, resource_type, resources) = list(tree)

    >>> page_rep.attrib['id']
    'collection-page'

    >>> resources.attrib['href']
    'http://api.launchpad.dev/beta/~admins/members'
    >>> resource, = resources
    >>> resource.attrib
    {'path': '', 'type': '#ScopedCollection'}

The main difference is that, right now, scoped collections never have
custom operations.

    >>> resource_type.attrib['id']
    'ScopedCollection'
    >>> get, = resource_type
    >>> get.attrib['id']
    'ScopedCollection-get'

