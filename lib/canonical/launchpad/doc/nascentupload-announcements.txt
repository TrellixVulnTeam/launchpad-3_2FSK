= NascentUpload Announcements =

NascentUpload announces uploads according its final status (NEW,
AUTO-APPROVED, UNAPPROVED) and its destination pocket:

 * NEW to RELEASE (via insecure): submitter set (changes signer,
   Changed-by and maintainer) receives an 'new' warning message.

 * UNAPPROVED to frozen-RELEASE/UPDATES/BACKPORTS/PROPOSED (via insecure):
   submitter set receives an 'unapproved' warning (announcement is
   sent after the upload gets reviewed by archive-admin at queue time).

 * AUTO-APPROVED to RELEASE (via insecure): submitter set receives an
   'acceptance' warning and the target distrorelease changeslist
   address receives an 'announcement' message.

 * AUTO-APPROVED to BACKPORTS (via sync): submitter set receives an
   'acceptance' warning ('announcement' is skipped).

 * AUTO-APPROVED sources to SECURITY (via security): submitter set
   receives an 'acceptance' warning and the target distrorelease
   changeslist address receives an 'announcement' message.

 * AUTO-APPROVED binaries to SECURITY (via security): submitter set
   receives only an 'acceptance' warning ('announcement' is skipped).

We need to be logged into the security model in order to get any further

  >>> login('foo.bar@canonical.com')

For the purpose of this test, hoary needs to be an open (development)
distrorelease so that we can upload to it. Also adjust 'changeslist'
address:

  >>> from canonical.launchpad.interfaces import IDistributionSet
  >>> from canonical.lp.dbschema import DistributionReleaseStatus
  >>> ubuntu = getUtility(IDistributionSet)['ubuntu']
  >>> hoary = ubuntu['hoary']
  >>> hoary.releasestatus = DistributionReleaseStatus.DEVELOPMENT
  >>> hoary.changeslist = "hoary-announce@lists.ubuntu.com"

The policy we feed to to the nascent upload needs to have its command
line options passed in and a local loggers:

  >>> class MockOptions:
  ...     distro = "ubuntu"
  ...     distrorelease = "hoary"

  >>> class MockLogger:
  ...     def debug(self, s):
  ...         print "DEBUG:", s

  >>> class MockMunchyLogger:
  ...     def debug(self, s):
  ...         pass

NEW source upload to RELEASE pocket via 'sync' policy (it presents
the same behaviour than using insecure policy, apart of allowing
unsigned changes):

  >>> from canonical.archivepublisher.nascentupload import NascentUpload
  >>> from canonical.archivepublisher.uploadpolicy import findPolicyByName
  >>> from canonical.archivepublisher.tests import datadir

  >>> netapplet_src = NascentUpload(
  ...     findPolicyByName('sync'), datadir('suite/bar_1.0-1'),
  ...     "bar_1.0-1_source.changes", MockMunchyLogger())
  >>> netapplet_src.policy.setOptions(MockOptions())
  >>> netapplet_src.process()
  >>> netapplet_src.logger = MockLogger()
  >>> result, msgs = netapplet_src.do_accept()
  DEBUG: Building recipients list.
  ...
  DEBUG: Creating a New queue entry

  >>> len(msgs)
  1

  >>> import email
  >>> [email.message_from_string(str(m))['To'] for m in msgs]
  ['Daniel Silverstone <daniel.silverstone@canonical.com>']

Let's ACCEPT bar sources in order to make the next uploads of this
series *known* in hoary:

  >>> netapplet_src.queue_root.setAccepted()
  >>> netapplet_src.queue_root.realiseUpload()

Make the uploaded orig file available to librarian lookups

  >>> import transaction
  >>> transaction.commit()

NEW binary upload to RELEASE pocket via 'sync' policy (we need to
override sync policy to allow binary uploads):

  >>> netapplet_src = NascentUpload(
  ...     findPolicyByName('sync'), datadir('suite/bar_1.0-1_binary'),
  ...     "bar_1.0-1_i386.changes", MockMunchyLogger())
  >>> netapplet_src.policy.setOptions(MockOptions())
  >>> netapplet_src.policy.can_upload_binaries = True
  >>> netapplet_src.process()
  >>> netapplet_src.logger = MockLogger()
  >>> result, msgs = netapplet_src.do_accept()
  DEBUG: Building recipients list.
  ...
  DEBUG: Creating a New queue entry

We simply ignores messages generated at this step because they are not
going to exist in production. We simply need this binary to be published
in other test other features in post-release pockets.

Let's accept & publish bar binary in order to make the next uploads of
this series *known* in hoary:

  >>> netapplet_src.queue_root.setAccepted()
  >>> netapplet_src.queue_root.realiseUpload()


Release hoary, enable uploads to post-release pockets:

  >>> hoary.releasestatus = DistributionReleaseStatus.CURRENT


AUTO-APPROVED upload to BACKPORTS pocket via 'sync' policy:

  >>> netapplet_src = NascentUpload(
  ...     findPolicyByName('sync'), datadir('suite/bar_1.0-4'),
  ...     "bar_1.0-4_source.changes", MockMunchyLogger())
  >>> local_options = MockOptions()
  >>> local_options.distrorelease = "hoary-backports"
  >>> netapplet_src.policy.setOptions(local_options)
  >>> netapplet_src.process()
  >>> netapplet_src.logger = MockLogger()
  >>> result, msgs = netapplet_src.do_accept()
  DEBUG: Building recipients list.
  ...
  DEBUG: Setting it to ACCEPTED
  DEBUG: Skipping announcement, it is a BACKPORT.

  >>> len(msgs)
  1

  >>> [email.message_from_string(str(m))['To'] for m in msgs]
  ['Celso Providelo <celso.providelo@canonical.com>']

Remove orig.tar.gz pumped from librarian to disk during the upload
checks:

 >>> import os
 >>> os.remove(os.path.join(datadir('suite/bar_1.0-4'), 'bar_1.0.orig.tar.gz'))


AUTO-APPROVED source upload to SECURITY pocket via 'security' policy:

  >>> netapplet_src = NascentUpload(
  ...     findPolicyByName('security'), datadir('suite/bar_1.0-2'),
  ...     "bar_1.0-2_source.changes", MockMunchyLogger())
  >>> local_options = MockOptions()
  >>> local_options.distrorelease = "hoary-security"
  >>> netapplet_src.policy.setOptions(local_options)

  >>> netapplet_src.process()
  >>> netapplet_src.rejected
  False

  >>> netapplet_src.logger = MockLogger()
  >>> result, msgs = netapplet_src.do_accept()
  DEBUG: Building recipients list.
  ...
  DEBUG: Setting it to ACCEPTED

  >>> len(msgs)
  2

  >>> [email.message_from_string(str(m))['To'] for m in msgs]
  ['Daniel Silverstone <daniel.silverstone@canonical.com>', 'hoary-announce@lists.ubuntu.com']

Let's publish security bar sources in order to allow its binaries to
come:

  >>> netapplet_src.queue_root.realiseUpload()

Remove orig.tar.gz pumped from librarian to disk during the upload
checks:

 >>> os.remove(os.path.join(datadir('suite/bar_1.0-2'), 'bar_1.0.orig.tar.gz'))


AUTO-APPROVED binary upload to SECURITY pocket via 'security' policy:

  >>> netapplet_bin = NascentUpload(
  ...     findPolicyByName('security'), datadir('suite/bar_1.0-2_binary'),
  ...     "bar_1.0-2_i386.changes", MockMunchyLogger())
  >>> local_options = MockOptions()
  >>> local_options.distrorelease = "hoary-security"
  >>> netapplet_bin.policy.setOptions(local_options)
  >>> netapplet_bin.process()
  >>> netapplet_bin.rejected
  False

  >>> netapplet_bin.logger = MockLogger()
  >>> result, msgs = netapplet_bin.do_accept()
  DEBUG: Building recipients list.
  ...
  DEBUG: Setting it to ACCEPTED
  DEBUG: Skipping announcement, it is a binary upload to SECURITY.

  >>> len(msgs)
  1

  >>> [email.message_from_string(str(m))['To'] for m in msgs]
  ['Daniel Silverstone <daniel.silverstone@canonical.com>']


