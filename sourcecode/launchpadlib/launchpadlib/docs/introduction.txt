= launchpadlib =

launchpadlib is the standalone Python language bindings to Launchpad's web
services API.  It is officially supported by Canonical, although third party
packages may be available to provide bindings to other programming languages.

launchpadlib is currently in pre-alpha release.

    >>> import launchpadlib
    >>> launchpadlib.__version__
    '0.1'

launchpadlib talks to Launchpad's API facet, but anonymous users are not
allowed to access even the root service.

    >>> from urllib import urlopen
    >>> import lxml.objectify
    >>> def parse(url):
    ...     connection = urlopen(url)
    ...     try:
    ...         tree = lxml.objectify.parse(connection)
    ...     finally:
    ...         connection.close()
    ...     return tree.getroot()

    >>> root = parse('http://api.launchpad.dev')
    >>> root.head.title
    'Forbidden'
    >>> root.body.div[1].table.tr.td.div.text.strip()
    u'Not logged in \u2014'

Anonymous users cannot even access the beta service.

    >>> root = parse('http://api.launchpad.dev/beta')
    >>> root.head.title
    'Forbidden'
    >>> root.body.div[1].table.tr.td.div.text.strip()
    u'Not logged in \u2014'


== OAuth authentication ==

The Launchpad API requires user authentication via OAuth, and launchpadlib
provides a high level interface to OAuth for the most common use cases.
Several pieces of information are necessary to complete the OAuth request:

 * A consumer key, which is unique to the application using the API
 * An access token, which represents the user to the web service

Consumer keys are hard-baked into the application.  They are generated by the
application developer and registered with Launchpad independently of the use
of the application.  Since consumer keys are arbitrary, a registered consumer
key usually comes with a secret, but most open source applications will forgo
this since it's not really a secret anyway.

The access token cannot be provided directly.  Instead, the application
generates an unauthenticated request token, exchanging this for an access
token and a secret after obtaining approval to so from the user.  This
permission is typically gained by redirecting the user through their trusted
web browser, then back to the application.

This entire exchange is managed by the Credentials class and a few OAuth
classes.  There are several subclasses of Credentials, depending on whether
the application wants to store the access token on the file system or not.  In
the simplest case, the application will request a new access token every time.

    >>> from launchpadlib.credentials import Consumer
    >>> consumer = Consumer('launchpad-library')
    >>> consumer.key
    'launchpad-library'
    >>> consumer.secret
    ''

Salgado has full access to the Launchpad API.  In the simplest case, the
application itself will now obtain Salgado's approval to access the Launchpad
API on his behalf.  How the application does this is up to the application,
provided it conforms to the OAuth protocol.  Let's assume the application has
done this dance, and retrieved Salgado's access token and secret.

    >>> from launchpadlib.credentials import AccessToken
    >>> access_token = AccessToken(
    ...     'hgm2VK35vXD6rLg5pxWw',
    ...     'QzsKbdk2Fr8RsJX3j89VVq5mWVGVQ84Hpwdrg0Cw'
    ...     + '8VVwW4ClNnPHDPJ7vm3xjDRn5hLpKc3r6WfznFVz')

And now the root service can be accessed, using these credentials.

    >>> from launchpadlib.credentials import Credentials
    >>> credentials = Credentials(consumer, access_token)

    >>> from launchpadlib.launchpad import Launchpad as _Launchpad
    >>> class Launchpad(_Launchpad):
    ...     """A testable Launchpad proxy accessing the demo service root."""
    ...     SERVICE_ROOT = 'http://api.launchpad.dev:8085/beta'

    >>> launchpad = Launchpad(credentials=credentials)
    >>> sorted(launchpad.people)
    [...]
    >>> sorted(launchpad.bugs)
    [...]

It can be convenient to store the credentials on the file system, so that the
next time the user interacts with the application, he won't have to go through
the whole OAuth request dance.  Security of the stored credentials information
is controlled by the file-like object that's passed to the save() and load()
methods of the Credentials class.

    >>> import os
    >>> import tempfile
    >>> fd, path = tempfile.mkstemp('.credentials')
    >>> os.close(fd)
    >>> credentials_file = open(path)

If the credentials file is empty, no credentials will be loaded from it.

    >>> credentials = Credentials()
    >>> credentials.load(credentials_file)
    >>> credentials_file.close()
    >>> print credentials.consumer
    None
    >>> print credentials.access_token
    None

Once Salgado's credentials are obtained for the first time, just set the
appropriate instance variables and use the save() method.

    >>> credentials.consumer = consumer
    >>> credentials.access_token = access_token
    >>> credentials_file = open(path, 'w')
    >>> credentials.save(credentials_file)
    >>> credentials_file.close()

And the credentials are perfectly valid for accessing Launchpad.

    >>> launchpad = Launchpad(credentials=credentials)
    >>> sorted(launchpad.people)
    [...]
    >>> sorted(launchpad.bugs)
    [...]

The credentials can also be retrieved from the file, so that the OAuth request
dance can be avoided.

    >>> credentials = Credentials()
    >>> credentials_file = open(path)
    >>> credentials.load(credentials_file)
    >>> credentials_file.close()
    >>> credentials.consumer.key
    'launchpad-library'
    >>> credentials.consumer.secret
    ''
    >>> credentials.access_token.key
    'hgm2VK35vXD6rLg5pxWw'
    >>> credentials.access_token.secret
    'QzsKbdk2Fr8RsJX3j89VVq5mWVGVQ84Hpwdrg0Cw...

These credentials too, are perfectly usable to access Launchpad.

    >>> launchpad = Launchpad(credentials=credentials)
    >>> sorted(launchpad.people)
    [...]
    >>> sorted(launchpad.bugs)
    [...]

It is an error to save a credentials file when no consumer or access token is
available.

    >>> credentials_file = open(path, 'w')
    >>> credentials.consumer = None
    >>> credentials.save(credentials_file)
    Traceback (most recent call last):
    ...
    CredentialsFileError: No consumer

    >>> credentials.consumer = consumer
    >>> credentials.access_token = None
    >>> credentials.save(credentials_file)
    Traceback (most recent call last):
    ...
    CredentialsFileError: No access token

    >>> credentials_file.close()


== Bad credentials ==

The application is not allowed to access Launchpad with a bad access token.

    >>> access_token = AccessToken('bad', 'no-secret')
    >>> credentials = Credentials(consumer, access_token)
    >>> launchpad = Launchpad(credentials=credentials)
    Traceback (most recent call last):
    ...
    HTTPError: HTTP Error 403: Forbidden

The application is not allowed to access Launchpad with a bad access secret.

    >>> access_token = AccessToken('hgm2VK35vXD6rLg5pxWw', 'bad-secret')
    >>> credentials = Credentials(consumer, access_token)
    >>> launchpad = Launchpad(credentials=credentials)
    Traceback (most recent call last):
    ...
    HTTPError: HTTP Error 403: Forbidden


== Clean up ==

    >>> os.remove(path)
