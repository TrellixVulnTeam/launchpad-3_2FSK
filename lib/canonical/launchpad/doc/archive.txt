= Personal Package Archives =

An Archive models a Debian Archive ...

  >>> from zope.interface.verify import verifyObject
  >>> from canonical.launchpad.interfaces import (
  ...     IPerson, IPersonSet, IArchiveSet, IArchive,
  ...     IDistributionSet)

Let get the IArchiveSet utility:

  >>> archive_set = getUtility(IArchiveSet)

A new Archive can be created by passing a name and an owner

  >>> name16 = getUtility(IPersonSet).getByName('name16')
  >>> sandbox_archive = archive_set.new(owner=name16)

  >>> verifyObject(IArchive, sandbox_archive)
  True

  >>> sandbox_archive.owner == name16
  True

An Archive can be retrieved via IPerson.archive SingleJoin:

  >>> name16.archive == sandbox_archive
  True

IArchive implements a published source lookup method:

  >>> cprov = getUtility(IPersonSet).getByName('cprov')
  >>> cprov_archive = cprov.archive

  >>> cprov_archive.getPublishedSources().count()
  2

This lookup also support 'name' restriction (as in SQL
"LIKE '%%' || NAME || '%%'")

  >>> cd_lookup = cprov_archive.getPublishedSources(name='cd')
  >>> cd_lookup.count()
  1
  >>> cd_lookup[0].sourcepackagerelease.name
  u'cdrkit'

  >>> ice_lookup = cprov_archive.getPublishedSources(name='ice')
  >>> ice_lookup.count()
  1
  >>> ice_lookup[0].sourcepackagerelease.name
  u'iceweasel'

  >>> cprov_archive.getPublishedSources(name='foo').count()
  0

It also implements a build look method, which supports, 'name',
'status' and 'pocket'.

Let's check 'name' build lookup:

  >>> cd_lookup = cprov_archive.getBuildRecords(name='cd')
  >>> cd_lookup.count()
  1
  >>> cd_lookup[0].sourcepackagerelease.name
  u'cdrkit'

  >>> ice_lookup = cprov_archive.getBuildRecords(name='ice')
  >>> ice_lookup.count()
  1
  >>> ice_lookup[0].sourcepackagerelease.name
  u'iceweasel'

  >>> cprov_archive.getBuildRecords(name='foo').count()
  0

Let's check 'status' build lookup:

  >>> from canonical.lp.dbschema import BuildStatus
  >>> cprov_archive.getBuildRecords(status=BuildStatus.FULLYBUILT).count()
  1

  >>> cprov_archive.getBuildRecords(status=BuildStatus.FAILEDTOBUILD).count()
  1

  >>> cprov_archive.getBuildRecords(status=BuildStatus.NEEDSBUILD).count()
  0

Let's check 'pocket' build lookup:

  >>> from canonical.lp.dbschema import PackagePublishingPocket
  >>> cprov_archive.getBuildRecords(
  ...     pocket=PackagePublishingPocket.RELEASE).count()
  2

  >>> cprov_archive.getBuildRecords(
  ...     pocket=PackagePublishingPocket.UPDATES).count()
  0


IArchive has a method to provide a modified Publisher Configuration (see
lib/archivepublisher/config.py), which provides the right paths for its
publication according to the given distribution:

  >>> ubuntutest = getUtility(IDistributionSet)['ubuntutest']

  >>> proxied_pubconfig = sandbox_archive.getPubConfig(ubuntutest)

XXX cprov 20061127: Publisher Config is missing interface.

  >>> from zope.security.proxy import removeSecurityProxy
  >>> pubconfig = removeSecurityProxy(proxied_pubconfig)

The base Archive publication location is set in the current Launchpad
configuration file:

  >>> from canonical.config import config
  >>> pubconfig.distroroot == config.personalpackagearchive.root
  True

Then, the archive topology will follow:

<PPA_BASE_DIR>/<PERSONNAME>/<DISTRIBUTION>

  >>> pubconfig.archiveroot
  u'/var/tmp/ppa.test/name16/ubuntutest'

  >>> pubconfig.poolroot
  u'/var/tmp/ppa.test/name16/ubuntutest/pool'

  >>> pubconfig.distsroot
  u'/var/tmp/ppa.test/name16/ubuntutest/dists'

Path not used in *personal* archives publication workflow are set to
None, so they won't get created:

  >>> pubconfig.overrideroot is None
  True
  >>> pubconfig.cacheroot is None
  True
  >>> pubconfig.miscroot is None
  True

Usual methods from Publisher Configuration are preserved:

  >>> pubconfig.distroSeriesNames()
  ['breezy-autotest', 'hoary-test']

  >>> pubconfig.archTagsForSeries('breezy-autotest')
  []

  >>> pubconfig.componentsForSeries('breezy-autotest')
  ['main', 'restricted', 'universe', 'multiverse']


IArchiveSet.getAllPPAs provides all present *personal* archive:

  >>> [archive.owner.name for archive in archive_set.getAllPPAs()]
  [u'cprov', u'sabdfl', u'no-priv', u'name16']


Iteration over the own utility is performed against all archives,
including the *main_archives*:

  >>> main_archives = 0
  >>> ppas = 0
  >>> for archive in archive_set:
  ...     if archive.owner is None:
  ...          main_archives += 1
  ...     else:
  ...          ppas += 1
  >>> main_archives, ppas
  (7, 4)
