= Code Import Machines =

There is a simple CodeImportMachine table in the database that records
the machines that can perform imports and whether they are online (that
is, currently capable of performing imports).

    >>> from canonical.launchpad.interfaces import (
    ...     ICodeImportMachine, ICodeImportMachineSet, CodeImportMachineState)

== Accessing ICodeImportMachine/ICodeImportMachineSet ==

The CodeImportMachine table is represented by an utility that provides the
ICodeImportMachineSet interface.  Currently we hide all aspects of the new
system from anonymous and regular users.

    >>> login(ANONYMOUS)
    >>> machine_set = getUtility(ICodeImportMachineSet)
    >>> machine_set.getAll()
    Traceback (most recent call last):
      ...
    Unauthorized: ...

    >>> login('test@canonical.com')
    >>> machine_set = getUtility(ICodeImportMachineSet)
    >>> machine_set.getAll()
    Traceback (most recent call last):
      ...
    Unauthorized: ...

Once we've logged in as David Allouche, a member of vcs-imports, the
object that provides ICodeImportMachineSet allows access to machines by
hostname and to all machines.

    >>> login('david.allouche@canonical.com')
    >>> from canonical.launchpad.interfaces import ILaunchpadCelebrities
    >>> ddaa = getUtility(ILaunchBag).user
    >>> ddaa.inTeam(getUtility(ILaunchpadCelebrities).vcs_imports)
    True

    >>> machine_set = getUtility(ICodeImportMachineSet)
    >>> from canonical.launchpad.webapp.testing import verifyObject
    >>> verifyObject(ICodeImportMachineSet, machine_set)
    True


== Retrieving CodeImportMachines ==

The 'getAll' method of ICodeImportMachineSet returns an iterable of all
CodeImportMachine.  There is only one CodeImportMachine in the sample data.

    >>> [sample_machine] = machine_set.getAll()

Machine objects themselves provide ICodeImportMachine, which includes
hostname and online state information.

    >>> verifyObject(ICodeImportMachine, machine)
    True
    >>> sample_machine.hostname
    u'bazaar-importer'
    >>> print sample_machine.state.name
    ONLINE

getByHostname looks for a machine of the given hostname, and returns None if
there is no machine by that name in the database.

    >>> print machine_set.getByHostname('bazaar-importer')
    <...CodeImportMachine...>

    >>> print machine_set.getByHostname('unlikely-to-exist')
    None


== Creating CodeImportMachines ==

CodeImportMachines can be created with the 'new' method of
ICodeImportMachineSet.  New machines are created in the OFFLINE state.

    >>> new_machine = machine_set.new('frobisher')
    >>> print new_machine.state.name
    OFFLINE


== Modifying CodeImportMachine ==

Directly setting the state information on CodeImportMachines is not permitted.

    >>> print new_machine.state.name
    OFFLINE
    >>> new_machine.state = CodeImportMachineState.ONLINE
    Traceback (most recent call last):
      ...
    ForbiddenAttribute: ...

Instead, the setOnline() and related methods must be used.  These methods
update the fields and in addition create events in the CodeImportEvent audit
trail.  The NewEvents class helps testing the creation of CodeImportEvent
objects.

    >>> from canonical.launchpad.tests.test_codeimportjob import NewEvents

=== setOnline ===

The setOnline method sets the machine's state to ONLINE and records the
corresponding event. It is called when a code-import-controller daemon
goes online.

    >>> new_events = NewEvents()
    >>> new_machine = reset_machine(machine)
    >>> new_machine.setOnline()
    >>> print new_machine.state.name
    ONLINE
    >>> print new_events.summary()
    ONLINE frobisher

=== setOffline ===

The setOffline method sets the machine's state to OFFLINE and records
the corresponding event. It is called when a code-import-controller
daemon stops, or when the watchdog detects that it has not updated its
heartbeat for some time.

    >>> new_events = NewEvents()
    >>> new_machine.setOffline(CodeImportMachineOfflineReason.STOPPED)
    >>> print new_machine.state.name
    OFFLINE
    >>> print new_events.summary()
    OFFLINE frobisher

    >>> [new_event] = new_events
    >>> dict(new_event.items())[CodeImportEventDataType.OFFLINE_REASON]
    u'STOPPED'


=== setQuiescing ===

The setQuiescing method sets the machine's state to QUIESCING and
records the corresponding event.

    >>> new_machine.setOnline()
    >>> new_events = NewEvents()
    >>> new_machine.setQuiescing(ddaa, "1.1.42 rollout")
    >>> print new_events.summary()
    QUIESCING frobisher David Allouche

    >>> [new_event] = new_events
    >>> dict(new_event.items())[CodeImportEventDataType.MESSAGE]
    u'1.1.42 rollout'


=== Allowed State Transitions ===

Not all CodeImportMachine.state transitions are allowed.

The CodeImportMachine.setOffline method needs to be provided a value
from the CodeImportMachineOfflineReason enum. The specific reason value
does not matter to the state machine.

    >>> some_reason = CodeImportMachineOfflineReason.STOPPED

From the OFFLINE state, a machine can only go ONLINE. The setOffline and
setQuiescing methods must fail.

Since our scripts and daemons run at "READ COMMITTED" isolation level,
there are races that we cannot easily detect within the limitation of
SQLObject, when the watchdog process and the controller daemon
concurrently call setOffline. Those undetected races will lead to the
creation of redundant OFFLINE events with different reason values, where
one of the reasons will be WATCHDOG. Those races should not have any
other adverse effect.

If the machine state is already offline, setOffline will defensively
fail, this will usefully detect logic errors where a single thread of
execution makes redundant calls to this method.

    >>> new_machine.setOnline()
    >>> print new_machine.state.name
    ONLINE

    >>> new_machine.setOffline()
    >>> print new_machine.state.name
    OFFLINE
    >>> new_machine.setOffline(some_reason)
    Traceback (most recent call last):
    ...
    AssertionError: State of machine frobisher was OFFLINE.

Attempting the transition from OFFLINE to QUIESCING is also logic error.

    >>> print new_machine.state.name
    OFFLINE
    >>> new_machine.setQuiescing(ddaa, "No worky!")
    Traceback (most recent call last):
    ...
    AssertionError: State of machine frobisher was OFFLINE.

From the ONLINE state, a machine can go OFFLINE or QUIESCING, setOnline
must fail.

    >>> new_machine.setOnline()
    >>> print new_machine.state.name
    ONLINE
    >>> new_machine.setOnline()
    Traceback (most recent call last):
    ...
    AssertionError: State of machine frobisher was ONLINE.

    >>> print new_machine.state.name
    ONLINE
    >>> new_machine.setQuiescing(ddaa, "Because.")
    >>> print new_machine.state.name
    QUIESCING


From the QUIESCING state, a machine can only go OFFLINE. The setOnline
and setQuiescing method must fail.

It would be meaningful to allow the transition from QUIESCING to ONLINE,
meaning "oops, I did not want you to quiesce, after all", but it would
require a new event type. We will add it later if we find we need it.

    >>> print new_machine.state.name
    QUIESCING
    >>> new_machine.setOnline()
    Traceback (most recent call last):
    ...
    AssertionError: State of machine frobisher was QUIESCING.

    >>> print new_machine.state.name
    QUIESCING
    >>> new_machine.setQuiescing(ddaa, "No worky!")
    Traceback (most recent call last):
    ...
    AssertionError: State of machine frobisher was QUIESCING.

    >>> print new_machine.state.name
    QUIESCING
    >>> new_machine.setOffline(some_reason)
    >>> print new_machine.state.name
    OFFLINE
