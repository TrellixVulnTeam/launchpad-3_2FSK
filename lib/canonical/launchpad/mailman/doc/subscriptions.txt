= Mailing list subscriptions =

Both direct and indirect members of a team may subscribe to a team's mailing
list.  First, create the mailing list, which will send a notification messages
to all the members of the mailing list.  We can ignore these messages.

    >>> from canonical.launchpad.mailman.testing import helpers
    >>> list_one = helpers.create_list('itest-one')

Anne registers with Launchpad and decides to subscribe to the mailing list.

    >>> from canonical.launchpad.ftests.mailinglists_helper import (
    ...     get_alternative_email, new_person)
    >>> from canonical.launchpad.interfaces import IPersonSet
    >>> from zope.component import getUtility
    >>> person_set = getUtility(IPersonSet)
    >>> from canonical.launchpad.ftests import login, logout
    >>> login('foo.bar@canonical.com')    
    >>> team_one = person_set.getByName('itest-one')

    # Subscribe Anne with her preferred address.
    >>> anne = new_person('Anne')
    >>> anne.join(team_one)
    >>> from canonical.launchpad.ftests import sync
    >>> sync(list_one)
    >>> list_one.subscribe(anne)

    # Subscribe Bart with his alternative address.
    >>> bart = new_person('Bart')
    >>> bart.join(team_one)
    >>> list_one.subscribe(bart, get_alternative_email(bart))
    >>> from canonical.database.sqlbase import commit

    >>> from canonical.launchpad.mailman.testing import logwatcher
    >>> serial_watcher = logwatcher.LogWatcher('serial')
    >>> commit()
    >>> serial_watcher.wait()

Both Anne and Bart are now members of the mailing list.  Both have two
subscribed addresses (because both are validated with Launchpad), but only one
of them is enabled.

    >>> from Mailman.MailList import MailList
    >>> from Mailman.MemberAdaptor import ENABLED
    >>> def print_members(mailing_list):
    ...     for key in sorted(mailing_list.getMembers()):
    ...         address = mailing_list.getMemberCPAddress(key)
    ...         fullname = mailing_list.getMemberName(key)
    ...         is_enabled = (mailing_list.getDeliveryStatus(key) == ENABLED)
    ...         print fullname, '<%s>' % address, is_enabled

    >>> mailing_list = MailList('itest-one', lock=False)
    >>> print_members(mailing_list)
    Anne Person <anne.person@example.com> True
    Anne Person <aperson@example.org> False
     <archive@mail-archive.dev> True
    Bart Person <bart.person@example.com> False
    Bart Person <bperson@example.org> True

Cris and Dirk now subscribe to the team and its list.  Anne changes her
preferred email address, and Bart unsubscribes from the mailing list.

    >>> team_one = person_set.getByName('itest-one')
    >>> sync(list_one)

    # Subscribe Cris with her preferred address.
    >>> cris = new_person('Cris')
    >>> cris.join(team_one)
    >>> list_one.subscribe(cris)

    # Subscribe Dirk with his preferred address.
    >>> dirk = new_person('Dirk')
    >>> dirk.join(team_one)
    >>> list_one.subscribe(dirk)

    # Unsubscribe Bart.
    >>> bart = person_set.getByName('bart')
    >>> list_one.unsubscribe(bart)

    # Change Anne's email address to her alternative.
    >>> sync(anne)
    >>> anne.setPreferredEmail(get_alternative_email(anne))
    >>> logout()
    >>> serial_watcher.resync()
    >>> commit()
    >>> serial_watcher.wait()

Anne is now subscribed with her alternate email address, and Cris and Dirk are
the only other members.

    # Reload the list data.
    >>> mailing_list.Load()
    >>> print_members(mailing_list)
    Anne Person <anne.person@example.com> False
    Anne Person <aperson@example.org> True
     <archive@mail-archive.dev> True
    Cris Person <cperson@example.org> False
    Cris Person <cris.person@example.com> True
    Dirk Person <dirk.person@example.com> True
    Dirk Person <dperson@example.org> False


== Alternative addresses ==

Now Anne decides to register another email address with Launchpad, however
before she can validate this address, subscriptions for the list are
synchronized with Mailman.  Anne's non-validated address does not appear in
the membership list, either as an enabled or disabled address.

    >>> from canonical.launchpad.interfaces import IEmailAddressSet
    >>> login('foo.bar@canonical.com')    
    >>> email_set = getUtility(IEmailAddressSet)
    >>> email = email_set.new('anne.x.person@example.net', anne)
    >>> serial_watcher.resync()
    >>> commit()

    # This will time out because no changes have been propagated to Mailman.
    >>> serial_watcher.wait()
    'Timed out'

    # Reload the list data.
    >>> mailing_list.Load()
    >>> print_members(mailing_list)
    Anne Person <anne.person@example.com> False
    Anne Person <aperson@example.org> True
     <archive@mail-archive.dev> True
    Cris Person <cperson@example.org> False
    Cris Person <cris.person@example.com> True
    Dirk Person <dirk.person@example.com> True
    Dirk Person <dperson@example.org> False

Once Anne validates her address though, she may post from it.

    >>> from canonical.launchpad.interfaces import EmailAddressStatus
    >>> email.status = EmailAddressStatus.VALIDATED
    >>> serial_watcher.resync()
    >>> commit()
    >>> logout()
    >>> serial_watcher.wait()

    >>> mailing_list.Load()
    >>> print_members(mailing_list)
    Anne Person <anne.person@example.com> False
    Anne Person <anne.x.person@example.net> False
    Anne Person <aperson@example.org> True
     <archive@mail-archive.dev> True
    Cris Person <cperson@example.org> False
    Cris Person <cris.person@example.com> True
    Dirk Person <dirk.person@example.com> True
    Dirk Person <dperson@example.org> False


== Case-preservation ==

Mailing lists preserve the case of the subscribed email address,
although for subscription purposes, two email addresses that differs
only in case are the same address.

Emma joins Launchpad as normal, then subscribes a mixed-case alternative
email address.

    >>> login('foo.bar@canonical.com')
    >>> emma = new_person('Emma')
    >>> emma.join(team_one)
    >>> email = email_set.new('EmmaXPerson@example.org', emma)
    >>> email.status = EmailAddressStatus.VALIDATED
    >>> list_one.subscribe(emma, email)
    >>> logout()

Wait for Mailman to go through two cycles of downloading the
subscription information for this mailing list.  This ensures that
everyone is properly handling case-preservation without error.  See LP
bug #218628.

    >>> error_watcher = logwatcher.LogWatcher('error')
    >>> serial_watcher.resync()
    >>> commit()
    >>> serial_watcher.wait()
    >>> xmlrpc_watcher = logwatcher.LogWatcher('xmlrpc')
    >>> xmlrpc_watcher.wait()
    >>> xmlrpc_watcher.wait()
    >>> error_watcher.wait()
    'Timed out'

Emma is now a member of the mailing list, using her case-preserved email
address.

    >>> mailing_list.Load()
    >>> print_members(mailing_list)
    Anne Person <anne.person@example.com> False
    Anne Person <anne.x.person@example.net> False
    Anne Person <aperson@example.org> True
     <archive@mail-archive.dev> True
    Cris Person <cperson@example.org> False
    Cris Person <cris.person@example.com> True
    Dirk Person <dirk.person@example.com> True
    Dirk Person <dperson@example.org> False
    Emma Person <emma.person@example.com> False
    Emma Person <EmmaXPerson@example.org> True
    Emma Person <eperson@example.org> False
