Source Package Release
======================

The SourcePackageRelease table represents a particular release of a
SourcePackageName, but isn't tied to any particular DistroRelease
as the same release can appear in many.

In a very basic explanation, this table caches the attributes of an
uploaded DSC (Debian Source Control) file.

This model allow us to have more granular control of the fields,
enabling faster searches, faster readings and model constraints.

Basic attributes
----------------

Let's get one from the database:

   >>> from canonical.launchpad.database import SourcePackageRelease
   >>> spr = SourcePackageRelease.get(14)
   >>> print spr.name
   mozilla-firefox
   >>> print spr.version
   0.9

We can use the magic productrelease property to map this to a ProductRelease:

   >>> pr = spr.productrelease
   >>> print pr.product.name
   firefox
   >>> print pr.productseries.name
   trunk
   >>> print pr.version
   0.9

We can use the sourcepackage and distrosourcepackage properties to
grab magical objects representing that package in the distribution to
which it was uploaded:

   >>> print spr.sourcepackage.displayname
   Hoary mozilla-firefox
   >>> print spr.distrosourcepackage.displayname
   mozilla-firefox in ubuntu

It should also work when the version has a dash and packaging revision
after it:

   >>> spr = SourcePackageRelease.get(16)
   >>> print spr.name
   netapplet
   >>> print spr.version
   1.0-1
   >>> pr = spr.productrelease
   >>> print pr.product.name
   netapplet
   >>> print pr.productseries.name
   trunk
   >>> print pr.version
   1.0

If there isn't one, that should return None.

   >>> print SourcePackageRelease.get(20).productrelease
   None


Check ISourcePackageRelease.override() behaviour:

   >>> spr.component.name, spr.section.name
   (u'main', u'editors')

   >>> from canonical.launchpad.interfaces import (
   ...     IComponentSet, ISectionSet)
   >>> new_comp = getUtility(IComponentSet)['universe']
   >>> new_sec = getUtility(ISectionSet)['mail']

Override the current sourcepackagerelease with new component/section
pair:

   >>> spr.override(component=new_comp, section=new_sec)

   >>> spr.component.name, spr.section.name
   (u'universe', u'mail')

Abort transaction to avoid error propagation of the new attributes:

   >>> import transaction
   >>> transaction.abort()


Verify the creation of a new ISourcePackageRelease based on the
IDistroRelease API:

  >>> from canonical.launchpad.interfaces import (
  ...     IDistributionSet, ISourcePackageNameSet, IGPGKeySet)
  >>> from canonical.database.constants import UTC_NOW
  >>> from canonical.lp.dbschema import SourcePackageUrgency

  >>> hoary = getUtility(IDistributionSet)['ubuntu']['hoary']

All the arguments to create an ISourcePackageRelease are obtained when
processing a source upload, see more details in nascentupload.txt.
Some of the 20 required arguments are foreign keys or DB contants:

  >>> arg_name = getUtility(ISourcePackageNameSet)['pmount']
  >>> arg_comp = getUtility(IComponentSet)['universe']
  >>> arg_sect = getUtility(ISectionSet)['web']
  >>> arg_key = getUtility(IGPGKeySet).get(1)
  >>> arg_dateuploaded = UTC_NOW
  >>> arg_maintainer = hoary.owner
  >>> arg_creator = hoary.owner
  >>> arg_urgency = SourcePackageUrgency.LOW

'manifest' is the only nullable FK:

  >>> arg_manifest = None

The other argurments are strings:

  >>> version = '0.0.99'
  >>> dsc = 'smashed dsc...'
  >>> changelog = 'contigous text....'
  >>> archhintlist = 'any'
  >>> builddepends = 'cdbs, debhelper (>= 4.1.0), libsysfs-dev, libhal-dev'
  >>> builddependsindep = ''
  >>> dsc_maintainer_rfc822 = 'Foo Bar <foo@bar.com>'
  >>> dsc_standards_version = '2.6.1'
  >>> dsc_format = '1.0'
  >>> dsc_binaries = 'pmount'

Having proper arguments in hand we can create a new
ISourcePackageRelease, it will automatically set the
'uploaddistrorelease' to the API entry point, in this case Hoary.

  >>> new_spr = hoary.createUploadedSourcePackageRelease(
  ...     arg_name, version, arg_maintainer, arg_dateuploaded,
  ...     builddepends, builddependsindep, archhintlist, arg_comp, arg_creator,
  ...     arg_urgency, changelog, dsc, arg_key, arg_sect, arg_manifest,
  ...     dsc_maintainer_rfc822, dsc_standards_version, dsc_format,
  ...     dsc_binaries)

  >>> new_spr.uploaddistrorelease.name
  u'hoary'
  >>> new_spr.version
  u'0.0.99'

Throw away the DB changes:

  >>> transaction.abort()


Verify the 'meta_binary' attribute:

   >>> spr_test = SourcePackageRelease.get(20)
   >>> spr_test.name
   u'pmount'

   >>> from canonical.launchpad.interfaces import (
   ...    IDistroReleaseBinaryPackage)

   >>> IDistroReleaseBinaryPackage.providedBy(spr_test.meta_binaries[0])
   True

Counting bugs and tickets
-------------------------

The SourcePackageRelease offers a convenient way of checking how many
bugs are open against this package in the distribution to which it was
uploaded. Because of bug privacy, this method needs a user supplied.

   >>> spr = SourcePackageRelease.get(14)
   >>> print spr.name
   mozilla-firefox
   >>> login('no-priv@canonical.com')
   >>> no_priv = getUtility(ILaunchBag).user
   >>> print spr.countOpenBugsInUploadedDistro(no_priv)
   1

It also offers an easy way of checking the number of tickets open on the
package in the distribution:

   >>> print spr.open_ticket_count
   0

Nobody's having trouble with firefox!

Uploading translations
----------------------

It's time to check the translation upload function.

   >>> import canonical.launchpad
   >>> import os.path
   >>> import transaction
   >>> from canonical.launchpad.interfaces import ITranslationImportQueue
   >>> from canonical.librarian.interfaces import ILibrarianClient
   >>> translation_import_queue = getUtility(ITranslationImportQueue)
   >>> client = getUtility(ILibrarianClient)

We need a test tarball uploaded into librarian to run this test.

   >>> test_file_name = os.path.join(
   ...     os.path.dirname(canonical.launchpad.__file__),
   ...     'doc/sourcepackagerelease-translations.tar.gz')
   >>> file = open(test_file_name)
   >>> size = len(file.read())
   >>> file.seek(0)
   >>> alias = client.addFile(
   ...     name='test.tar.gz',
   ...     size=size,
   ...     file=file,
   ...     contentType='application/x-gtar')

We need the commit to see the upload.

   >>> transaction.commit()

Before the upload, the queue should be empty.

   >>> translation_import_queue.getAllEntries(target='distros').count()
   0

Now we do the upload. It's necessary to retrive an ILibraryFileAlias
correspondent to the alias (long) we already have.

   >>> from canonical.launchpad.interfaces import ILibraryFileAliasSet
   >>> file_alias = getUtility(ILibraryFileAliasSet)[alias]

   >>> spr_test.attachTranslationFiles(file_alias, True)

The commit is needed to see the new entries

   >>> transaction.commit()

And the queue should have a new entry.

   >>> translation_import_queue.getAllEntries(target='distros').count()
   1

Now, we need to do the final import. It's done as a two steps procedure.

The first one, approves the import.

    >>> import subprocess, sys
    >>> process = subprocess.Popen([
    ...     sys.executable, 'cronscripts/rosetta-poimport.py'
    ...     ], stdin=subprocess.PIPE, stdout=subprocess.PIPE,
    ...     stderr=subprocess.STDOUT
    ...     )
    >>> (output, empty) = process.communicate()
    >>> print output
    INFO    The automatic approval system approved some entries.
    INFO    Removed 2 entries from the queue.
    <BLANKLINE>

The second one, executes the import.

    >>> import subprocess, sys
    >>> process = subprocess.Popen([
    ...     sys.executable, 'cronscripts/rosetta-poimport.py'
    ...     ], stdin=subprocess.PIPE, stdout=subprocess.PIPE,
    ...     stderr=subprocess.STDOUT
    ...     )
    >>> (output, empty) = process.communicate()
    >>> print output
    INFO    Importing: Spanish (es) translation of pmount in Ubuntu Hoary package "pmount"
    ...

