This test verifies the basic claim a GPG key workflow.

  >>> import email, re
  >>> from canonical.launchpad.mail import stub
  >>> from canonical.zeca.ftests.harness import ZecaTestSetup

Setup the stub KeyServer:

  >>> z = ZecaTestSetup()
  >>> z.setUp()

Start out with a clean page:

  >>> browser.addHeader('Authorization', 'Basic test@canonical.com:test')
  >>> browser.open("http://launchpad.dev/~name12/+editpgpkeys")
  >>> "<title>Sample Person's OpenPGP keys</title>" in browser.contents
  True
  >>> "1024D/DFD20543" in browser.contents
  False

Claim OpenPGP key:

  >>> key = "A419AE861E88BC9E04B9C26FBA2B9389DFD20543"
  >>> browser.getControl(name='fingerprint').value = key
  >>> browser.getControl(name='import').click()
  >>> "error message" not in browser.contents
  True
  >>> print browser.contents
  <BLANKLINE>
  ...
  A message has been sent to <code>test@canonical.com</code>, encrypted
  with the key <code>1024D/DFD20543</code>.
  To confirm the key is yours, decrypt the message and follow the
  link inside.
  ...

Recover token URL from the encrypted part, but also make sure there's a clear
text part that provides useful information to users who -- for whatever reason -- cannot decrypt the token url.  Start by grabbing the confirmation message.

  >>> from_addr, to_addrs, raw_msg = stub.test_emails.pop()
  >>> msg = email.message_from_string(raw_msg)

Ensure that the outer message is a multipart/alternative.  Actually, both
sub-parts will be text/plain, but the encrypted part, which must come second,
will have a charset of utf-8.  There's no perfect way to tell a mail browser
to display the clear text message only if it can't decode the encrypted part,
because with ASCII armor, both will be text/plain.  This is the best we can
do.

  >>> msg.is_multipart()
  True
  >>> msg.get_content_type()
  'multipart/alternative'
  >>> instructions = msg.get_payload(0)
  >>> encrypted_msg = msg.get_payload(1)

Check that the clear text instructions has the help urls.

  >>> instructions.get_content_type()
  'text/plain'
  >>> instructions.get_content_charset()
  'us-ascii'
  >>> body = instructions.get_payload()
  >>> 'https://help.launchpad.net/ReadingOpenPgpMail' in body
  True
  >>> 'https://help.ubuntu.com/community/GnuPrivacyGuardHowto' in body
  True

Now decode the encrypted part, originally encoded in 'base-64' or
'quoted-printable':

  >>> cipher_body = encrypted_msg.get_payload(decode=True)

  >>> from canonical.launchpad.webapp.interaction import setupInteraction
  >>> setupInteraction(None)

  >>> from canonical.launchpad.interfaces import IGPGHandler
  >>> from zope.component import getUtility
  >>> gpghandler = getUtility(IGPGHandler)

Import the secret keys needed for this test:

  >>> from canonical.launchpad.ftests import (
  ...     import_secret_test_key, decrypt_content)
  >>> import_secret_test_key()

'cipher_body' is a message encrypted with the just-imported
1024D/DFD20543 OpenPGP key, we need to access the current IGpghandler
instance to access this key and decrypt the message.

  >>> body = decrypt_content(cipher_body, 'test')

  >>> from zope.security.management import endInteraction
  >>> endInteraction()

Do the usual procedure to extract the token URL:

  >>> link = re.findall(r'http.*/token/.*', body)[0]
  >>> token = re.sub(r'.*token/', '', link)

Ensure token is ascii to avoid utf-8 mess in URL:

  >>> base_path = '/token/%s' % token.encode('ascii')

Go to the link sent by email, to validate the email address.

  >>> browser.open("http://launchpad.dev%s" % base_path)

Get redirected to +validategpg, and confirm token:

  >>> print browser.url
  http://launchpad.dev/token/.../+validategpg
  >>> browser.getControl(name='VALIDATE').click()

Get redirected to the user's homepage with a greeting:

  >>> browser.url
  'http://launchpad.dev/~name12'
  >>> "The key 1024D/DFD20543 was successfully validated" in browser.contents
  True

Certify the key is imported:

  >>> browser.open("http://launchpad.dev/~name12/+editpgpkeys")

  >>> print browser.contents
  <BLANKLINE>
  ...
  <h2>Active keys</h2>
  ...
  1024D/DFD20543
  ...

Make sure that UIDs were properly processed; in particular, check that
the revoked UID in the key wasn't added as an email address:

  >>> browser.open("http://launchpad.dev/~name12/+editemails")
  >>> "sample.person@canonical.com_unvalidated" in browser.contents
  True
  >>> "sample.revoked@canonical.com" in browser.contents
  False

Verify that the key was imported with the "can encrypt" flag set:

  >>> from canonical.launchpad.database import GPGKey
  >>> key = GPGKey.selectOneBy(
  ...     fingerprint='A419AE861E88BC9E04B9C26FBA2B9389DFD20543')
  >>> print key.owner.name
  name12
  >>> print key.can_encrypt
  True

Kill stub KeyServer:

  >>> z.tearDown()

