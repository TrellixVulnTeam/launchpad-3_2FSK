In addition to what Storm provides, we also have some Launchpad
specific Storm tools.

    >>> import canonical.launchpad.webapp.adapter
    >>> from canonical.launchpad.interfaces import (
    ...     IMasterDBObject, IMasterStore, ISlaveStore, IStore)
    >>> from canonical.launchpad.database import (
    ...     Account, AccountPassword, Person)


You need to use the correct master Store to make changes to
a Launchpad database object. You can use adapters to
retrieve the correct Store.

    >>> auth_master = IMasterStore(Account)
    >>> main_master = IMasterStore(Person)
    >>> auth_master is main_master
    False


You can read most tables from any Store, which is required for doing
fast joins in the database. However, when it is not necessary to
retrieve objects from the same store as another object, it is better to
explicitly use the explicit Store for its replication set. Some tables
are only available from this store, such as the AccountPassword table.

    >>> auth_slave = ISlaveStore(AccountPassword)
    >>> main_slave = ISlaveStore(Person)
    >>> auth_slave is main_slave
    False


You can detect if a store is writable by checking what interfaces it
provides.

    >>> IMasterStore.providedBy(auth_master)
    True
    >>> ISlaveStore.providedBy(auth_master)
    False


Changes to the slave Stores will lag behind the master Stores. If
you only need to read an object but require it to be in sync with the
master, you should use the default Store. Launchpad will give you the
slave store if it is sure all your recent changes have been replicated.
Otherwise, it gives you the master. See IStoreSelector for details.

    >>> main_default = IStore(Person)
    >>> main_master = IMasterStore(Person)
    >>> main_slave = ISlaveStore(Person)
    >>> main_default is main_master
    True
    >>> main_default is main_slave
    False


You can also adapt database object instances to Stores, although
this is less generally useful.

    >>> janitor = ISlaveStore(Person).find(Person, name='janitor').one()
    >>> ISlaveStore(janitor) is ISlaveStore(Person)
    True
    >>> IMasterStore(janitor) is IMasterStore(Person)
    True
    >>> IMasterStore(janitor) is ISlaveStore(Person)
    False


If we need the master copy of an object, we can adapt it to IMasterDBObject

    >>> auth_slave = ISlaveStore(Account)
    >>> t = transaction.begin()
    >>> account = auth_slave.get(Account, 1)
    >>> account.displayname = 'Cannot change'
    >>> transaction.commit()
    Traceback (most recent call last):
    ...
    InternalError: transaction is read-only

    >>> t = transaction.begin()
    >>> account = auth_slave.get(Account, 1)
    >>> IMasterDBObject(account).displayname = 'Can change'
    >>> transaction.commit()


If the adapted object was security proxied, the master copy is
similarly wrapped.

    >>> from canonical.launchpad.interfaces.account import IAccountSet
    >>> from zope.security.proxy import removeSecurityProxy
    >>> account = getUtility(IAccountSet).getByEmail('no-priv@canonical.com')
    >>> removeSecurityProxy(account) is account
    False
    >>> account.displayname
    u'No Privileges Person'
    >>> account.password
    Traceback (most recent call last):
    ...
    Unauthorized: ...

    >>> account = IMasterDBObject(account)
    >>> removeSecurityProxy(account) is account
    False
    >>> account.displayname
    u'No Privileges Person'
    >>> account.password
    Traceback (most recent call last):
    ...
    Unauthorized: ...

    >>> account = IMasterDBObject(removeSecurityProxy(account))
    >>> removeSecurityProxy(account) is account
    True
    >>> account.displayname
    u'No Privileges Person'
    >>> account.password
    u'...'

