***************************
Authorizing a request token
***************************

Once the consumer gets a request token, it must send the user to
Launchpad's +authorize-token page in order for the user to authenticate
and authorize or not the consumer to act on his behalf.

    # Create a new request token.
    >>> from canonical.launchpad.interfaces import IOAuthConsumerSet
    >>> from zope.component import getUtility
    >>> from canonical.launchpad.ftests import ANONYMOUS, login, logout
    >>> login('salgado@ubuntu.com')
    >>> consumer = getUtility(IOAuthConsumerSet).getByKey('foobar123451432')
    >>> token = consumer.newRequestToken()
    >>> logout()

According to the OAuth Core 1.0 spec, the request to the service
provider's user authorization URL (+authorize-token in our case) must
use the HTTP GET method and may include the oauth_callback parameter.
The oauth_token parameter, on the other hand, is required in the
Launchpad implementation.

Access to the page
==================

The +authorize-token page is restricted to authenticated users.

    >>> from urllib import urlencode
    >>> params = dict(
    ...     oauth_token=token.key, oauth_callback='http://launchpad.dev/bzr')
    >>> url = "http://launchpad.dev/+authorize-token?%s" % urlencode(params)
    >>> browser.open(url)
    Traceback (most recent call last):
    ...
    Unauthorized: Anonymous access is not allowed.

However, the details of the authentication are different than from any
other part of Launchpad. Unlike with other pages, a user can authorize
an OAuth token by signing their outgoing requests with an _existing_
OAuth token. This makes it possible for a desktop client to retrieve
this page without knowing the end-user's username and password, or
making them navigate the arbitrarily complex OpenID login procedure.

But, let's deal with that a little later. First let's show how the
process works through HTTP Basic Auth (the testing equivalent of a
regular username-and-password login).

    >>> browser = setupBrowser(auth='Basic no-priv@canonical.com:test')
    >>> browser.open(url)
    >>> browser.title
    'Authorize application to access Launchpad on your behalf'

    >>> main_content = find_tag_by_id(browser.contents, 'maincontent')
    >>> print extract_text(main_content)
    The application identified as foobar123451432 wants to access Launchpad on
    your behalf. What level of access do you want to grant?
    ...
    See all applications authorized to access Launchpad on your behalf.


Using the page
==============

This page contains one submit button for each item of OAuthPermission,
except for 'Grant Permissions', which must be specifically requested.

    >>> browser.getControl('No Access')
    <SubmitControl...
    >>> browser.getControl('Read Non-Private Data')
    <SubmitControl...
    >>> browser.getControl('Change Non-Private Data')
    <SubmitControl...
    >>> browser.getControl('Read Anything')
    <SubmitControl...
    >>> browser.getControl('Change Anything')
    <SubmitControl...

    >>> browser.getControl('Grant Permissions')
    Traceback (most recent call last):
    ...
    LookupError: label 'Grant Permissions'

    >>> actions = main_content.findAll('input', attrs={'type': 'submit'})
    >>> from canonical.launchpad.webapp.interfaces import OAuthPermission
    >>> len(actions) == len(OAuthPermission.items) - 1
    True

An application, when asking to access Launchpad on a user's behalf,
may restrict the user to certain items of OAuthPermission. This
prevents annoying cases where the user grants a level of permission
that isn't enough for the application. The user always has the option
to deny permission altogether.

    >>> def filter_user_agent(key, value, new_value):
    ...     """A filter to replace the User-Agent header.
    ...
    ...     [XXX bug=638058] This is a hack to work around a bug in
    ...     zope.testbrowser.
    ...     """
    ...
    ...     if key.lower() == "user-agent":
    ...         return (key, new_value)
    ...     return (key, value)

    >>> def print_access_levels(allow_permission, user_agent=None):
    ...     if user_agent is not None:
    ...         # [XXX bug=638058] This is a hack to work around a bug in
    ...         # zope.testbrowser which prevents browser.addHeader
    ...         # from working with User-Agent.
    ...         mech_browser = browser.mech_browser
    ...         # Store the original User-Agent for later.
    ...         old_user_agent = [
    ...             value for key, value in mech_browser.addheaders
    ...             if key.lower() == "user-agent"][0]
    ...         # Replace the User-Agent with the value passed into this
    ...         # function.
    ...         mech_browser.addheaders = [
    ...             filter_user_agent(key, value, user_agent)
    ...             for key, value in mech_browser.addheaders]
    ...
    ...     # Okay, now we can make the request.
    ...     browser.open(
    ...         "http://launchpad.dev/+authorize-token?%s&%s"
    ...         % (urlencode(params), allow_permission))
    ...     main_content = find_tag_by_id(browser.contents, 'maincontent')
    ...     actions = main_content.findAll('input', attrs={'type': 'submit'})
    ...     for action in actions:
    ...         print action['value']
    ...
    ...     if user_agent is not None:
    ...         # Finally, restore the old User-Agent.
    ...         mech_browser.addheaders = [
    ...             filter_user_agent(key, value, old_user_agent)
    ...             for key, value in mech_browser.addheaders]


    >>> print_access_levels(
    ...     'allow_permission=WRITE_PUBLIC&allow_permission=WRITE_PRIVATE')
    No Access
    Change Non-Private Data
    Change Anything

The only time the 'Grant Permissions' permission shows up in this list
is if a client identifying itself as the Launchpad Credentials Manager
specifically requests it, and no other permission. (Also requesting
UNAUTHORIZED is okay--it will show up anyway.)

    >>> USER_AGENT = "Launchpad Credentials Manager v1.0"
    >>> print_access_levels(
    ...     'allow_permission=GRANT_PERMISSIONS', USER_AGENT)
    No Access
    Grant Permissions

    >>> print_access_levels(
    ...     'allow_permission=GRANT_PERMISSIONS&allow_permission=UNAUTHORIZED',
    ...     USER_AGENT)
    No Access
    Grant Permissions

    >>> print_access_levels(
    ...     'allow_permission=WRITE_PUBLIC&allow_permission=GRANT_PERMISSIONS')
    No Access
    Change Non-Private Data

If a client asks for GRANT_PERMISSIONS but doesn't claim to be the
Launchpad Credentials Manager, Launchpad will not show GRANT_PERMISSIONS.

    >>> print_access_levels('allow_permission=GRANT_PERMISSIONS')
    No Access
    Read Non-Private Data
    Change Non-Private Data
    Read Anything
    Change Anything

If an application doesn't specify any valid access levels, or only
specifies the UNAUTHORIZED access level, Launchpad will show all the
access levels, except for GRANT_PERMISSIONS.

    >>> print_access_levels('')
    No Access
    Read Non-Private Data
    Change Non-Private Data
    Read Anything
    Change Anything

    >>> print_access_levels('allow_permission=UNAUTHORIZED')
    No Access
    Read Non-Private Data
    Change Non-Private Data
    Read Anything
    Change Anything

An application may also specify a context, so that the access granted
by the user is restricted to things related to that context.

    >>> params_with_context = {'lp.context': 'firefox'}
    >>> params_with_context.update(params)
    >>> browser.open(
    ...     "http://launchpad.dev/+authorize-token?%s"
    ...     % urlencode(params_with_context))
    >>> main_content = find_tag_by_id(browser.contents, 'maincontent')
    >>> print extract_text(main_content)
    The application...wants to access things related to Mozilla Firefox...

A client other than a web browser may request a JSON representation of
the list of authentication levels.

    >>> import simplejson
    >>> from canonical.launchpad.testing.pages import setupBrowser

    >>> json_browser = setupBrowser()
    >>> json_browser.addHeader('Accept', 'application/json')
    >>> json_browser.addHeader('Authorization',
    ...     'Basic test@canonical.com:test')
    >>> json_browser.open(
    ...     "http://launchpad.dev/+authorize-token?%s"
    ...     % urlencode(params))
    >>> json_token = simplejson.loads(json_browser.contents)
    >>> sorted(json_token.keys())
    ['access_levels', 'oauth_token', 'oauth_token_consumer']

    >>> sorted((level['value'], level['title'])
    ...        for level in json_token['access_levels'])
    [('READ_PRIVATE', 'Read Anything'),
     ('READ_PUBLIC', 'Read Non-Private Data'),
     ('UNAUTHORIZED', 'No Access'),
     ('WRITE_PRIVATE', 'Change Anything'),
     ('WRITE_PUBLIC', 'Change Non-Private Data')]

    >>> json_browser.open(
    ...     ("http://launchpad.dev/+authorize-token?%s"
    ...      "&allow_permission=READ_PRIVATE") % urlencode(params))
    >>> json_token = simplejson.loads(json_browser.contents)
    >>> sorted((level['value'], level['title'])
    ...        for level in json_token['access_levels'])
    [('READ_PRIVATE', 'Read Anything'),
     ('UNAUTHORIZED', 'No Access')]

Once the user authorizes the application to access Launchpad on his
behalf, we issue a redirect to the given oauth_callback (if it was
specified by the application).

    >>> browser.open(
    ...     "http://launchpad.dev/+authorize-token?%s" % urlencode(params))
    >>> browser.getControl('Read Non-Private Data').click()

    # This is the URL given to Launchpad in oauth_callback.
    >>> browser.url
    'http://launchpad.dev/bzr'

After the authorization is granted the token gets its permission and
person set.

    # Need to get the token again as it's been changed in another
    # transaction.
    >>> login(ANONYMOUS)
    >>> token = consumer.getRequestToken(token.key)
    >>> token.person.name
    u'no-priv'
    >>> token.permission
    <DBItem OAuthPermission.READ_PUBLIC...
    >>> token.is_reviewed
    True

If no oauth_callback is specified, we redirect the user to
+authorized-token.

    # Create a new (unreviewed) token.
    >>> logout()
    >>> login('salgado@ubuntu.com')
    >>> token = consumer.newRequestToken()
    >>> logout()

    >>> params = dict(oauth_token=token.key)
    >>> browser.open(
    ...     "http://launchpad.dev/+authorize-token?%s" % urlencode(params))

    >>> browser.getControl('Read Anything').click()

    >>> browser.url
    'http://launchpad.dev/+token-authorized?...'
    >>> print extract_text(find_tag_by_id(browser.contents, 'maincontent'))
    Almost finished ...
    To finish authorizing the application identified as foobar123451432 to
    access Launchpad on your behalf you should go back to the application
    window in which you started the process and inform it that you have done
    your part of the process.

If we can't find the token, we will explain that to the user.

    >>> params = dict(oauth_callback='http://example.com/oauth')
    >>> browser.open(
    ...     "http://launchpad.dev/+authorize-token?%s" % urlencode(params))
    >>> print extract_text(find_tag_by_id(browser.contents, 'maincontent'))
    Unable to identify application
    The information provided by the remote application was incorrect or
    incomplete. Because of that we were unable to identify the application
    which would access Launchpad on your behalf.
    See all applications authorized to access Launchpad on your behalf.

    >>> params = dict(
    ...     oauth_token='zzzzzz', oauth_callback='http://example.com/oauth')
    >>> browser.open(
    ...     "http://launchpad.dev/+authorize-token?%s" % urlencode(params))
    >>> print extract_text(find_tag_by_id(browser.contents, 'maincontent'))
    Unable to identify application
    The information provided by the remote application was incorrect or
    incomplete. Because of that we were unable to identify the application
    which would access Launchpad on your behalf.
    See all applications authorized to access Launchpad on your behalf.

The same happens if the token is already reviewed.  Although that's
probably an indication that the user has already reviewed that token in
another window/tab so there's no need to worry.

    # Need to get the token again as it's been changed in another
    # transaction.
    >>> token = consumer.getRequestToken(token.key)
    >>> token.is_reviewed
    True
    >>> params = dict(
    ...     oauth_token=token.key, oauth_callback='http://example.com/oauth')
    >>> browser.open(
    ...     "http://launchpad.dev/+authorize-token?%s" % urlencode(params))
    >>> print extract_text(find_tag_by_id(browser.contents, 'maincontent'))
    Request already reviewed
    This request for accessing Launchpad on your behalf has been
    reviewed ... ago.
    See all applications authorized to access Launchpad on your behalf.

Access through OAuth
====================

Now it's time to show how to go through the same process without
knowing the end-user's username and password. All you need is an OAuth
token issued with the GRANT_PERMISSIONS access level, in the name of
the Launchpad Credentials Manager.

    >>> from zope.component import getUtility
    >>> from oauth.oauth import OAuthConsumer
    >>> from lp.testing import oauth_access_token_for
    >>> from canonical.launchpad.interfaces import IPersonSet
    >>> manager_consumer = OAuthConsumer("Launchpad Credentials Manager", "")
    >>> login(ANONYMOUS)
    >>> no_priv = getUtility(IPersonSet).getByEmail('no-priv@canonical.com')
    >>> grant_permissions_token = oauth_access_token_for(
    ...     manager_consumer.key, no_priv, "GRANT_PERMISSIONS")
    >>> logout()

    >>> from oauth.oauth import OAuthRequest, OAuthSignatureMethod_PLAINTEXT
    >>> from canonical.launchpad.interfaces import OAUTH_REALM
    >>> def oauth_signing_browser(consumer, token, user_agent=USER_AGENT):
    ...     request = OAuthRequest.from_consumer_and_token(consumer, token)
    ...     request.sign_request(
    ...         OAuthSignatureMethod_PLAINTEXT(), consumer, token)
    ...     auth_header = request.to_header(OAUTH_REALM)['Authorization']
    ...     browser = setupBrowser(auth=auth_header)
    ...     # [XXX bug=638058] A hack to work around a bug in
    ...     # zope.testbrowser.
    ...     browser.mech_browser.addheaders = [
    ...             filter_user_agent(key, value, user_agent)
    ...             for key, value in browser.mech_browser.addheaders]
    ...     return browser

Now we're ready to make an OAuth-signed request that works.

    >>> browser = oauth_signing_browser(
    ...     manager_consumer, grant_permissions_token)
    >>> browser.open(url)
    >>> print browser.title
    Authorize application to access Launchpad on your behalf

The user agent sending the signed request must identify itself as the
Launchpad Credentials Manager.

    >>> browser = oauth_signing_browser(
    ...     manager_consumer, grant_permissions_token,
    ...     "Not the Launchpad Credentials Manager")
    >>> browser.open(url)
    Traceback (most recent call last):
    ...
    Unauthorized: Only the Launchpad Credentials Manager can access
    this page by signing requests with an OAuth token.

The OAuth token must have the GRANT_PERMISSIONS access level; no other
access level will work.

    >>> login(ANONYMOUS)
    >>> insufficient_token = oauth_access_token_for(
    ...     manager_consumer.key, no_priv, "WRITE_PRIVATE")
    >>> logout()

    >>> browser = oauth_signing_browser(manager_consumer, insufficient_token)
    >>> browser.open(url)
    Traceback (most recent call last):
    ...
    Unauthorized: OAuth token has insufficient access level.

The OAuth token must be for the Launchpad Credentials Manager, or it
cannot be used. (Launchpad shouldn't be even _issue_ a
GRANT_PERMISSIONS token for any other consumer, but even if it somehow
does, that token can't be used for this.)

    >>> login(ANONYMOUS)
    >>> wrong_consumer = OAuthConsumer(
    ...     "Not the Launchpad Credentials Manager", "")
    >>> wrong_consumer_token = oauth_access_token_for(
    ...     wrong_consumer.key, no_priv, "GRANT_PERMISSIONS")
    >>> logout()

    >>> browser = oauth_signing_browser(wrong_consumer, wrong_consumer_token)
    >>> browser.open(url)
    Traceback (most recent call last):
    ...
    Unauthorized: Only the Launchpad Credentials Manager can access
    this page by signing requests with an OAuth token.

Signing with an anonymous token will also not work.

    >>> from oauth.oauth import OAuthToken
    >>> anonymous_token = OAuthToken(key="", secret="")
    >>> browser = oauth_signing_browser(manager_consumer, anonymous_token)
    >>> browser.open(url)
    Traceback (most recent call last):
    ...
    Unauthorized: Anonymous access is not allowed.

Finally, as usual, a user who is logged in through Basic Auth can see
the page. We'll use this session for the rest of the test.
