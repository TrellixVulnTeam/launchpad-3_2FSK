= DecoratedResultSet =

Within Soyuz (and possibly other areas of Launchpad?) there are a 
number of content classes which do not actually correspond directly to
a database table. For example, a `DistroSeriesBinaryPackage` is really
just a representation of a `BinaryPackageName` within a certain
DistroSeries. Nonetheless, this representation is presented (via views)
to users as a useful reference point for obtaining particular package
releases and/or architectures.

A problem arises however when attempting to present a search result of
such content. For example, when a user searches for all packages within
the Ubuntu Intrepid `DistroSeries` that include the letter 'l', it is 
actually the `DistroSeriesPackageCache` that is searched, but the
results need to be presented back to the browser as a set of
`DistroSeriesBinaryPackage`s. In the past this was achieved by using a
list comprehension on the complete result set to convert each result
into the expected DSBP. This in-memory list was then passed to the view.
But given that views usually paginate results, they are only interested
in 20 or so items at a time, so there is a huge waste of resources (DB
and memory primarily, but some CPU).

The purpose of the `DecoratedResultSet` is to allow such content
classes to pass an un-evaluated result set to the view so that the view
can add limits to the query *before* it is evaluated (batching), while
still ensuring that when the query is evaluated the result is converted
into the expected content class.

First, we'll create the un-decorated result set of all distributions:

    >>> from canonical.launchpad.interfaces import IDistributionSet
    >>> from storm.store import Store
    >>> ubuntu = getUtility(IDistributionSet)['ubuntu']
    >>> store = Store.of(ubuntu)
    >>> from canonical.launchpad.database import Distribution
    >>> result_set = store.find(Distribution)

== Creating the decorator method ==

We create a decorator method that we want to be applied to any
results obtained from our undecorated result set:

    >>> def result_decorator(distribution):
    ...     return "Dist name is: %s" % distribution.name

== Creating the DecoratedResultSet ==

The original result set and the decorator function are then used to
create the decorated result set:

    >>> from canonical.launchpad.components.decoratedresultset import (
    ...     DecoratedResultSet)
    >>> decorated_result_set = DecoratedResultSet(result_set,
    ...     result_decorator)


== Using the DecoratedResultSet ==

The DecoratedResultSet implements the normal ResultSet interface (by
definition), so all the normal methods can be used. Iterating over the
decorated result set produces the decorated results:

    >>> for dist in decorated_result_set:
    ...     print dist
    Dist name is: debian
    Dist name is: gentoo
    ...
    Dist name is: ubuntutest

Splicing works as normal:

    >>> for dist in decorated_result_set[1:3]:
    ...     print dist
    Dist name is: gentoo
    Dist name is: guadalinex

Some methods of the DecoratedResultSet are not actually decorated and
just work like normally:

    >>> decorated_result_set.count()
    7

    >>> decorated_result_set.max(Distribution.id)
    8

== The patched count() method ==

There is currently a bug in the Storm API whereby calling count (or
other aggregates) on a storm ResultSet does not respect the distinct
config option (https://bugs.edge.launchpad.net/storm/+bug/217644):

    >>> from canonical.launchpad.database import (BinaryPackageRelease,
    ...     BinaryPackagePublishingHistory)
    >>> results = store.find(BinaryPackageRelease,
    ...     BinaryPackageRelease.id == 
    ...         BinaryPackagePublishingHistory.binarypackagereleaseID)
    >>> results = results.config(distinct=True)
    >>> len(list(results))
    14
    >>> results.count()
    26

But the DecoratedResultSet works around this bug (until it is fixed in
storm):
    >>> def dummy_result_decorator(result):
    ...     return result
    >>> decorated_results = DecoratedResultSet(results,
    ...     dummy_result_decorator)
    >>> len(list(results))
    14
    >>> decorated_results.count()
    14

The DecoratedResultSet's count method works as per normal if other 
args/kwargs are passed:
    >>> decorated_results.count(distinct=False)
    26

The pre_iter_hook() method is only called once when iteration begins.

    >>> class FakeResultSet(list):
    ...     def count(self, *args, **kwargs):
    ...         return len(self)
    ...     def first(self, *args, **kwargs):
    ...         return self[0]
    ...     def last(self, *args, **kwargs):
    ...         return self[-1]
    ...     def any(self, *args, **kwargs):
    ...         return self[-1]
    ...     def one(self, *args, **kwargs):
    ...         return self[-1]
    ...     def order_by(self, *args, **kwargs):
    ...         return FakeResultSet(self)
    ...     def config(self, *args, **kwargs):
    ...         pass
    ...     def copy(self, *args, **kwargs):
    ...         return FakeResultSet(self)
    >>> rs = FakeResultSet(range(1,5))
    >>> def my_pih(result_set):
    ...     print('this should run once only, count: %s' % len(result_set))
    >>> def my_deco(result):
    ...     print('> original value : %s' % result)
    ...     return (result * 2)

    >>> my_drs = DecoratedResultSet(rs, my_deco, my_pih)
    >>> for res in my_drs:
    ...     print(' decorated result: %s' % res)
    this should run once only, count: 4
    > original value : 1
     decorated result: 2
    > original value : 2
     decorated result: 4
    > original value : 3
     decorated result: 6
    > original value : 4
     decorated result: 8

