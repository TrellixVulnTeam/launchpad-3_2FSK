Security Teams
==============

Responsibility for security-related bugs, are modelled in Launchpad with
a "security contact" on a Distribution or a Product.

    >>> from zope.component import getUtility
    >>> from canonical.launchpad.interfaces import (
    ...     IDistributionSet, IProductSet, IPersonSet, IHasSecurityContact)
    >>> personset = getUtility(IPersonSet)
    >>> productset = getUtility(IProductSet)
    >>> ubuntu = getUtility(IDistributionSet).get(1)
    >>> firefox = productset.get(4)

    >>> IHasSecurityContact.providedBy(ubuntu)
    True
    >>> IHasSecurityContact.providedBy(firefox)
    True

    >>> sabdfl = personset.get(1)
    >>> ubuntu_team = personset.get(17)

Security contacts are set through properties.

    >>> login("foo.bar@canonical.com")

    >>> ubuntu.security_contact = sabdfl
    >>> firefox.security_contact = ubuntu_team

    >>> print ubuntu.security_contact.name
    sabdfl

    >>> print firefox.security_contact.name
    ubuntu-team

When creating a bug, use the security_related flag to indicate that the
bug is a security vulnerability, and the security contact should be
subscribed to the bug. All security vulnerabilities are automatically
made private at bug creation. They can be disclosed after they have been
filed.

    >>> from canonical.launchpad.interfaces import ILaunchBag

    >>> ubuntu_firefox = ubuntu.getSourcePackage("mozilla-firefox")
    >>> bug = ubuntu.createBug(
    ...     owner=getUtility(ILaunchBag).user,
    ...     title="a security bug",
    ...     comment="this is an example security bug",
    ...     security_related=True)

    >>> bug.security_related
    True
    >>> bug.private
    True

The reporter, Foo Bar, and the Ubuntu security contact, Mark
Shuttleworth are both subscribed to the bug.

    >>> sorted([subscription.person.name for subscription in bug.subscriptions])
    [u'name16', u'sabdfl']

If the bug were not reported as security-related, only Foo Bar would
have been subscribed:

    >>> from canonical.launchpad.interfaces import ILaunchBag

    >>> ubuntu_firefox = ubuntu.getSourcePackage("mozilla-firefox")
    >>> bug = ubuntu.createBug(
    ...     owner=getUtility(ILaunchBag).user,
    ...     title="a security bug",
    ...     comment="this is an example security bug",
    ...     security_related=False)

    >>> bug.security_related
    False
    >>> bug.private
    False

    >>> sorted([subscription.person.name for subscription in bug.subscriptions])
    [u'name16']

Likewise, filing a security-related bug on Firefox will subscribe the
security contact, the Ubuntu team, to the bug.

    >>> bug = firefox.createBug(
    ...     owner=getUtility(ILaunchBag).user,
    ...     title="another security bug",
    ...     comment="this is another security bug",
    ...     security_related=True)

    >>> bug.security_related
    True
    >>> bug.private
    True

    >>> sorted([subscription.person.name for subscription in bug.subscriptions])
    [u'name16', u'ubuntu-team']

Again, if the bug were not reported as security-related, the security
contact, the Ubuntu Team, would not have been subscribed:

    >>> bug = firefox.createBug(
    ...     owner=getUtility(ILaunchBag).user,
    ...     title="another security bug",
    ...     comment="this is another security bug",
    ...     security_related=False)

    >>> bug.security_related
    False
    >>> bug.private
    False

    >>> sorted([subscription.person.name for subscription in bug.subscriptions])
    [u'name16']

When no security contact exists, the reporter and product registrant get
subscribed.

    >>> firefox.security_contact = None

    >>> bug = firefox.createBug(
    ...     owner=getUtility(ILaunchBag).user,
    ...     title="another security bug",
    ...     comment="this is another security bug",
    ...     security_related=True)

    >>> bug.security_related
    True
    >>> bug.private
    True

    >>> sorted([subscription.person.name for subscription in bug.subscriptions])
    [u'name16']

When a bug is reported in another package or upstream, the security
contact for that package or upstream is automatically subscribed to the
bug, *if the bug is public*. Malone never auto-subscribes anyone to
private bugs, except when the user chooses that option when filing a
security bug.

Let's first demonstrate adding a task to a public bug causing the
security contact of the new product to be subscribed.

    >>> evolution = productset.get(5)

We'll set lifeless as the security_contact for evolution.

    >>> from canonical.launchpad.interfaces import IBugTaskSet

(Make the bug public to ensure the security contact will get
subscribed.)

    >>> bug.private = False

    >>> lifeless = personset.get(2)
    >>> print lifeless.name
    lifeless
    >>> evolution.security_contact = lifeless

    >>> foobar = personset.get(16)
    >>> print foobar.name
    name16

    >>> bugtaskset = getUtility(IBugTaskSet)
    >>> bug_in_evolution = bugtaskset.createTask(
    ...     bug=bug, product=evolution, owner=foobar)

lifeless is subscribed to the public security bug when a task is added
for evolution.

    >>> sorted([
    ...     subscription.person.name for subscription in
    ...     bug.subscriptions])
    [u'lifeless', u'name16']

But if we repeat the process, using a private bug, he won't be subscribed:

    >>> bug = firefox.createBug(
    ...     owner=getUtility(ILaunchBag).user,
    ...     title="another security bug",
    ...     comment="this is private security bug",
    ...     security_related=True)

    >>> bug.security_related
    True

    >>> bug.private
    True

    >>> sorted([
    ...     subscription.person.name for subscription in
    ...     bug.subscriptions])
    [u'name16']

    >>> bug_in_evolution = bugtaskset.createTask(
    ...     bug=bug, product=evolution, owner=foobar)

    >>> sorted([subscription.person.name for subscription in bug.subscriptions])
    [u'name16']

Finally, reassigning a public bug to a different product will subscribe
the new security contact, if present. Let's set stub to the security
contact for thunderbird to see how this works.

    >>> thunderbird = productset.get(8)
    >>> print thunderbird.name
    thunderbird

    >>> stub = personset.get(22)
    >>> print stub.name
    stub

    >>> thunderbird.security_contact = stub

    >>> from zope.event import notify
    >>> from canonical.launchpad.event.sqlobjectevent import (
    ...     SQLObjectModifiedEvent)
    >>> from canonical.launchpad.webapp.snapshot import Snapshot
    >>> from canonical.launchpad.interfaces import IUpstreamBugTask

    >>> old_state = Snapshot(bug_in_evolution, providing=IUpstreamBugTask)
    >>> bug_in_evolution.product = thunderbird
    >>> bug_product_changed = SQLObjectModifiedEvent(
    ...     bug_in_evolution, old_state, ["product"])

First, let's publish the change event with the bug still marked private,
and notice that the subscription list doesn't change:

    >>> bug.private
    True

    >>> notify(bug_product_changed)

    >>> sorted([
    ...     subscription.person.name for subscription in
    ...     bug.subscriptions])
    [u'name16']

But publish the same event again, when the bug is marked public, and
stub will be added to the subscriber list:

    >>> bug.private = False

    >>> notify(bug_product_changed)

    >>> sorted([subscription.person.name for subscription in bug.subscriptions])
    [u'name16', u'stub']
