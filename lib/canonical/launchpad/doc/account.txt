= Account and AccountSet =

An Account is used by someone to Authenticate with the Launchpad login
service.


= AccountSet =

The AccountSet object provides methods to retrieve `IAccount`s. It
implements the IAccountSet.

    >>> from zope.interface.verify import verifyObject
    >>> from canonical.launchpad.interfaces.account import (
    ...     IAccount, IAccountSet)

    >>> account_set = getUtility(IAccountSet)
    >>> verifyObject(IAccountSet, account_set)
    True


== Looking up accounts by email address ==

Accounts are generally looked up by email address.

    >>> login('no-priv@canonical.com')
    >>> account = account_set.getByEmail('no-priv@canonical.com')
    >>> IAccount.providedBy(account)
    True

    >>> print account_set.getByEmail('invalid@whatever')
    None

Only admins or the person attached to an account can see or edit Account
details. This is obviously wrong, as the account should have access
rather than the (optional) attached person. In particular, it means
Accounts without Person records cannot be managed by the Account owner.
Fixing this involves more surgery to Launchpad's security systems.

    >>> stub_account = account_set.getByEmail('stuart.bishop@canonical.com')
    >>> stub_account.date_created
    Traceback (most recent call last):
    ...
    Unauthorized...

    >>> del stub_account


== Looking up accounts by OpenID identifier ==

Each Launchpad user is assigned an permanent OpenID identity URL. The
last component of this URL is specific to the user, and can be used to
look up the user.

    >>> account = account_set.getByOpenIDIdentifier('no-priv_oid')
    >>> IAccount.providedBy(account)
    True
    >>> print account.displayname
    No Privileges Person

The getByOpenIDIdentifier() method supports the human readable
openid identifiers.

    >>> account.new_openid_identifier
    u'123/no-priv'
    >>> account_2 = account_set.getByOpenIDIdentifier('123/no-priv')
    >>> account_2 == account
    True

None is returned if the identifier is not used by any account.

    >>> print account_set.getByOpenIDIdentifier('no-such-identifier')
    None


= The Account object =

The account implements the IAccount interface.

    >>> verifyObject(IAccount, account)
    True

An account has a displayname.

    >>> print account.displayname
    No Privileges Person

An account has an encrypted password.

    >>> account.password
    u'K7Qmeansl6RbuPfulfcmyDQOzp70OxVh5Fcf'

Ensure the password changes are sticky, as this is a property hiding the
AccountPassword table.

    >>> account.password = None
    >>> print account.password
    None

    >>> account.password = u'K7Qmeansl6RbuPfulfcmyDQOzp70OxVh5Fcf'
    >>> account.password
    u'K7Qmeansl6RbuPfulfcmyDQOzp70OxVh5Fcf'

And other account metadata.

    >>> account.date_created
    datetime.datetime(...)

    >>> print account.creation_rationale.name
    OWNER_CREATED_LAUNCHPAD

    >>> print account.status.name
    ACTIVE

    >>> account.date_status_set >= account.date_created
    True

    >>> print account.status_comment
    None

    >>> account.displayname
    u'No Privileges Person'

When the status is changed, the date_status_set is updated in the
database.

    >>> from canonical.launchpad.interfaces.account import AccountStatus

    >>> original_date_status_set = account.date_status_set
    >>> account.status = AccountStatus.SUSPENDED

    # Shouldn't be necessary with Storm!
    >>> from zope.security.proxy import removeSecurityProxy
    >>> removeSecurityProxy(account).sync()
    >>> account.date_status_set > original_date_status_set
    True

    >>> account.status = AccountStatus.ACTIVE

The Account's displayname is synced to the Person's displayname if there
is one. If the Person.displayname is changed, the Account.displayname is
changed too.

    >>> from canonical.launchpad.interfaces import IPersonSet

    >>> personset = getUtility(IPersonSet)
    >>> person = personset.getByEmail('no-priv@canonical.com')
    >>> person.displayname = 'Something New'
    >>> account.displayname
    u'Something New'

However, the reverse is not true. If we change the Account.displayname,
the linked Person.displayname (if there is one) is not updated
immediately.  Instead, a cron job will sync this information later. This
allows displayname changes to happen even when the Person table is
unavailable.

    >>> account.displayname = 'No Privileges Account'
    >>> person.displayname
    u'Something New'

    >>> person.displayname = 'No Privileges Person'
    >>> account.displayname
    u'No Privileges Person'

An Account has an OpenID identifier used to generate the OpenID identity
URL.

    >>> account.openid_identifier
    u'no-priv_oid'


= Creating new accounts =

New Accounts are created using the AccountSet.new() method. The account
rationale and displayname are required.

    >>> from canonical.launchpad.ftests import syncUpdate
    >>> from canonical.launchpad.interfaces.account import (
    ...     AccountCreationRationale)

    # Login as a user that may see the accounts of other users.
    >>> login('foo.bar@canonical.com')
    >>> passwordless_account = account_set.new(
    ...     AccountCreationRationale.USER_CREATED, 'Passwordless')
    >>> syncUpdate(passwordless_account)
    >>> passwordless_account.creation_rationale.name
    'USER_CREATED'
    >>> passwordless_account.displayname
    u'Passwordless'
    >>> print passwordless_account.password
    None

The new() method accepts the optional parameters of password and
password_is_encrypted. If password_is_encrypted is False, the default,
then the method encrypts it for us.

    >>> passworded_account = account_set.new(
    ...     AccountCreationRationale.OWNER_CREATED_LAUNCHPAD , 'Passworded',
    ...     password=u'clear_password')
    >>> syncUpdate(passworded_account)
    >>> passworded_account.password == u'clear_password'
    False

The method does not encrypt the password if told that it is already
encrypted, by setting password_is_encrypted to True.

    >>> clear_account = account_set.new(
    ...     AccountCreationRationale.OWNER_CREATED_LAUNCHPAD , 'Clear',
    ...     password=u'clear_password', password_is_encrypted=True)
    >>> syncUpdate(clear_account)
    >>> clear_account.password
    u'clear_password'


== OpenID identifiers ==

The account is given old and new openid identifiers. The old
identifier is created directly in the database; it not available until
the account object is synced.

    >>> new_account = account_set.new(
    ...     AccountCreationRationale.OWNER_CREATED_LAUNCHPAD, 'OID Account',
    ...     openid_mnemonic='oid-account', password=u'clear_password')
    >>> syncUpdate(new_account)
    >>> len(new_account.openid_identifier) == 7
    True
    >>> new_account.new_openid_identifier
    u'.../oid-account'

The IAccountSet object can create a human-readable openid identifier
using the createOpenIDIdentifier() method. It requires a string argument
that is used as the mnemonic in the URL. A user name is a example of
a mnemonic that would be used to create a new openid identifier.

    >>> first_identifier = account_set.createOpenIDIdentifier('user-name')
    >>> first_identifier
    '.../user-name'

There is no distinction between using a string mnemonic and a unicode
mnemonic. A str is always returned.

    >>> account_set.createOpenIDIdentifier(u'user-name')
    '.../user-name'

The mnemonic must be a string or a unicode string, otherwise An error is
raised. The unicode string must contain only ascii compatible
characters, otherwise an error is raised.

    >>> account_set.createOpenIDIdentifier(None)
    Traceback (most recent call last):
     ...
    AssertionError: The mnemonic must be a non-empty string.

    >>> account_set.createOpenIDIdentifier(u'b\xe4d')
    Traceback (most recent call last):
     ...
    UnicodeEncodeError: 'ascii' codec can't encode character u'\xe4' in
                         position 5: ordinal not in range(128)

An error is raised if a non-unique openid identifier cannot be created
for the mnemonic. All accounts and OpenID relying parties summaries are
checked for to ensure that an openid identifier is not reused. In the
unlikely chance that a unique random token cannot be found for a
mnemonic, an error is raised.

    # Instrument the random number range to ensure a duplicate will
    # be generated.
    >>> naked_account_set = removeSecurityProxy(account_set)
    >>> naked_account_set._MAX_RANDOM_TOKEN_RANGE
    1000
    >>> naked_account_set._MAX_RANDOM_TOKEN_RANGE = 1

    # Use the only random token available for the openid identifier.
    >>> non_unique_account = account_set.new(
    ...     AccountCreationRationale.OWNER_CREATED_LAUNCHPAD, 'Non Unique',
    ...     openid_mnemonic='non-unique', password=u'clear_password')
    >>> syncUpdate(non_unique_account)
    >>> non_unique_account.new_openid_identifier
    u'000/non-unique'

    >>> account_set.createOpenIDIdentifier('non-unique')
    Traceback (most recent call last):
     ...
    AssertionError: An openid_identifier could not be created with the
                    mnemonic 'non-unique'.

All OpenIDRPSummaries are checked to ensure the openid identifier has
never been used. An error is raised in the unlikely event that every
random token for a mnemonic has been used in the past.

    >>> from canonical.launchpad.database import OpenIDRPSummary

    # Change the new_openid_identifier to ensure that the no account
    # uses '000/non-unique'.
    >>> removeSecurityProxy(
    ...     non_unique_account).new_openid_identifier = '111/non-unique'
    >>> syncUpdate(non_unique_account)
    >>> print account_set.getByOpenIDIdentifier('000/non-unique')
    None

    # Add the openid identifier to the history of used openid identifiers.
    # The model object is used because the OpenIDRPSummarySet.record() may
    # use the old openid identifier.
    >>> summary = OpenIDRPSummary(
    ...     account=non_unique_account,
    ...     openid_identifier='http://id.launchpad.dev/000/non-unique',
    ...     trust_root='http://blog.org/')

    >>> account_set.createOpenIDIdentifier('non-unique')
    Traceback (most recent call last):
     ...
    AssertionError: An openid_identifier could not be created with the
                    mnemonic 'non-unique'.

    # Restore random number range.
    >>> naked_account_set._MAX_RANDOM_TOKEN_RANGE = 1000

