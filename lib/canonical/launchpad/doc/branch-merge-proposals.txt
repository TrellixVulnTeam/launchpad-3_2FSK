= Branch merge proposals =

Branch merge proposals are a way to show intent of one branch to land
code on another branch.  The database object is called a merge proposal
as it has a source branch and a target branch, but when looking at
branch merge proposals through the UI we are looking from a particular
context, and as such they are referred to as landing targets or landing
candidates.

  Landing Targets - these are the branches (or the merge proposals) for
  which the branch that is being looked at is the source branch.  It is
  called that due to the idea that the target branch is where the code
  intentds to 'land' or 'merge'.

  Landing Candidates - these are the branches (or the merge proposals)
  that want to land on the branch being looked at.

Branch merge proposals are created by calling the `addLandingTarget`
method on a branch.  Junk branches cannot have landing targets.

  * The target branch and dependent branch (if it has one) must both
    have the same product as the source branch.

  * There must not already exist a branch merge proposal for the source
    branch and target branch pair.


== Registering a landing target ==

All merge proposals have to be registered by a Person.

    >>> from zope.component import getUtility
    >>> from canonical.launchpad.interfaces import (
    ...     IBranchSet, IPersonSet)
    >>> person_set = getUtility(IPersonSet)
    >>> login('test@canonical.com')
    >>> sample_person = person_set.getByEmail('test@canonical.com')
    >>> from canonical.launchpad.testing import time_counter
    >>> now = time_counter()

In order to register a merge proposal there has to be a source branch
and a target branch.

    >>> branch_set = getUtility(IBranchSet)
    >>> source_branch = branch_set.getByUniqueName(
    ...     '~name12/gnome-terminal/klingon')
    >>> target_branch = branch_set.getByUniqueName(
    ...     '~name12/gnome-terminal/main')

    >>> merge_proposal = source_branch.addLandingTarget(
    ...     sample_person, target_branch, date_created=now.next())

This merge proposal is now listing against both the source and target
branches.

    >>> for proposal in source_branch.landing_targets:
    ...     print proposal.target_branch.unique_name
    ~name12/gnome-terminal/main

    >>> for proposal in target_branch.landing_candidates:
    ...     print proposal.source_branch.unique_name
    ~name12/gnome-terminal/klingon

All the code paths through `addLandingTarget` are exercised by the UnitTest
canonical.launchpad.database.tests.test_branch.BranchAddLandingTarget.

In normal project circumstances there will normally be only one landing
target registered for any given branch.  Sometimes there may be two or more
specified but that would be in the situation where a single patch or fix
is going to land on multiple supported branches.  It is often desirable to
see the landing target information even after the merge has taken place.

In comparison though, a trunk branch will have a significant number of
merge candidates.  From the target branch point of view, it is normally
only the unmerged branches that are of interest.  The landing_candidates
only returns unmerged proposals, with the most recent branch merge proposals
first.

    >>> branch = branch_set.getByUniqueName(
    ...     '~launchpad/gnome-terminal/launchpad')
    >>> proposal = branch.addLandingTarget(
    ...     sample_person, target_branch, date_created=now.next())

    >>> for proposal in target_branch.landing_candidates:
    ...     print proposal.source_branch.unique_name
    ~launchpad/gnome-terminal/launchpad
    ~name12/gnome-terminal/klingon


== Merge proposal states ==

A branch merge proposal can be in one of several states:
 * Work in progress
 * Review requested
 * Code approved
 * Rejected
 * Merged
 * Code failed to merge

When a merge proposal is initially created, it is in the "Work in
progress" state.

    >>> from canonical.launchpad.testing import LaunchpadObjectFactory
    >>> factory = LaunchpadObjectFactory()
    >>> source_branch = factory.makeBranch(owner=sample_person)
    >>> # Needs to be the same product to merge into.
    >>> target_branch = factory.makeBranch(
    ...     owner=sample_person, product=source_branch.product)
    >>> proposal = source_branch.addLandingTarget(
    ...     sample_person, target_branch, date_created=now.next())
    >>> print proposal.queue_status.title
    Work in progress

Directly setting the queue_status is not possible.

    >>> from canonical.launchpad.interfaces import BranchMergeProposalStatus
    >>> proposal.queue_status = BranchMergeProposalStatus.CODE_APPROVED
    Traceback (most recent call last):
    ...
    ForbiddenAttribute: ('queue_status', <BranchMergeProposal at ...>)

Adjusting the state is done through methods on the merge proposal.

    >>> print proposal.date_review_requested
    None
    >>> proposal.requestReview()
    >>> print proposal.queue_status.title
    Needs review

When requesting a review, a timestamp is also recorded.

    >>> proposal.date_review_requested is not None
    True


=== Approving or rejecting code ===

Once code has been reviewed the result of the code review can be
recoreded either as approved or not approved.

There is a limited number of people that are able to make code
as approved or not.  By default it is anyone that is in the team
of the owner of the target branch.  If the target branch has specified
a specific review team, then that review team is used instead to control
who can sign-off code.

Initially both the reviewer and date_reviewed for a merge proposal
are not set.

    >>> print proposal.reviewer
    None
    >>> print proposal.date_reviewed
    None

Since Sample Person is the owner of the target branch they can authorise
their own code.

When approving code the revision id is recorded as the last approved
revision.

    >>> # Revisions can only be added by the scanner, so switch dbuser.
    >>> from canonical.database.sqlbase import commit
    >>> from canonical.testing import LaunchpadZopelessLayer
    >>> from canonical.config import config
    >>> source_branch_unique_name = source_branch.unique_name
    >>> commit()
    >>> LaunchpadZopelessLayer.switchDbUser(config.branchscanner.dbuser)
    >>> factory.makeRevisionsForBranch(source_branch)
    >>> commit()
    >>> LaunchpadZopelessLayer.switchDbUser(config.launchpad.dbuser)
    >>> source_branch = branch_set.getByUniqueName(source_branch_unique_name)
    >>> proposal = source_branch.landing_targets[0]
    >>> source_branch.revision_count
    5
    >>> tip = source_branch.getTipRevision()

    >>> # Reget the sample person as we shouldn't be reusing objects across
    >>> # transaction boundaries.
    >>> sample_person = person_set.getByEmail('test@canonical.com')
    >>> proposal.approveBranch(sample_person, tip.revision_id)
    >>> print proposal.reviewer.displayname
    Sample Person
    >>> proposal.date_reviewed is not None
    True
    >>> print proposal.queue_status.title
    Code approved
    >>> proposal.reviewed_revision_id == tip.revision_id
    True

Code that has been accepted can also be set to rejected.

    >>> proposal.rejectBranch(sample_person)
    >>> print proposal.queue_status.title
    Rejected

Resubmit proposals can also be updated to be approved.

    >>> proposal.approveBranch(sample_person)
    >>> print proposal.queue_status.title
    Code approved

Proposals with either rejected or accepted reviews can request another
review.

    >>> proposal.requestReview()
    >>> print proposal.queue_status.title
    Needs review
    >>> proposal.rejectBranch(sample_person)
    >>> print proposal.queue_status.title
    Rejected
    >>> proposal.requestReview()
    >>> print proposal.queue_status.title
    Needs review

If the target branch has specified a specific reviewer, then only
a user in the reviewer team can approve or reject the branch.

    >>> eric_the_reviewer = factory.makePerson(name="eric-reviewer")
    >>> target_branch = proposal.target_branch
    >>> target_branch.reviewer = eric_the_reviewer
    >>> proposal.rejectBranch(sample_person)
    Traceback (most recent call last):
    ...
    UserNotBranchReviewer
    >>> proposal.approveBranch(sample_person)
    Traceback (most recent call last):
    ...
    UserNotBranchReviewer

    >>> proposal.approveBranch(eric_the_reviewer)
    >>> print proposal.queue_status.title
    Code approved


== Marking as failed to merge ==

Anyone that has rights to edit the merge proposal can say that the
merge failed.

    >>> proposal.mergeFailed(merger=sample_person)
    >>> print proposal.queue_status.title
    Code failed to merge


== Getting a list of previous merge targets ==

In order to make it easier to propose branches to merge on similar
branches, there is a method on the branch set that returns the branches that a
user has previously targetted for merging.

    >>> gnome_terminal = branch.product
    >>> branches = branch_set.getTargetBranchesForUsersMergeProposals(
    ...     sample_person, gnome_terminal)
    >>> for branch in branches:
    ...     print branch.unique_name
    ~name12/gnome-terminal/main


== Marking as merged ==

A merge proposal may be marked as merged by calling the `markAsMerged` method
on the `BranchMergeProposal`.

If a revision number is supplied, the method looks for a `BranchRevision` in
the target branch that matches.  If one is found then the revision date from
the associated `Revision` is used as the merge date.  This allows branches
that are not necessarily available to launchpad to manually mark the merge
proposals as merged.

The user that marked the branch as merged can also be recorded.

    >>> branch = branch_set.getByUniqueName(
    ...     '~launchpad/gnome-terminal/launchpad')
    >>> merge_proposal = branch.landing_targets[0]
    >>> reporter = person_set.getByName('sabdfl')
    >>> merge_proposal.markAsMerged(1234, now.next(), reporter)
    >>> merge_proposal.merged_revno
    1234
    >>> print merge_proposal.merge_reporter.browsername
    Mark Shuttleworth
    >>> print merge_proposal.queue_status.title
    Merged
    >>> flush_database_updates()

The merged proposal is no longer listed amongst the target's candidates.

    >>> print merge_proposal.source_branch.unique_name
    ~launchpad/gnome-terminal/launchpad
    >>> for proposal in merge_proposal.target_branch.landing_candidates:
    ...     print proposal.source_branch.unique_name
    ~name12/gnome-terminal/klingon

But the merge proposal is still listed in the source's targets.

    >>> for proposal in merge_proposal.source_branch.landing_targets:
    ...     print proposal.target_branch.unique_name
    ~name12/gnome-terminal/main

The firefox branches are the branches that are attached to a product
and have revisions (well, a revision).

    >>> source_branch = branch_set.getByUniqueName(
    ...     '~sabdfl/firefox/release-0.9')
    >>> target_branch = branch_set.getByUniqueName(
    ...     '~sabdfl/firefox/release-0.9.2')
    >>> merge_proposal = source_branch.addLandingTarget(
    ...     sample_person, target_branch, date_created=now.next())

The target branch has a revision 1, so the merge time is taken form
that revision.

    >>> history = list(target_branch.revision_history)
    >>> branch_revision = history[0]
    >>> branch_revision.sequence
    1
    >>> print branch_revision.revision.revision_date
    2005-03-09 15:40:00+00:00

    >>> merge_proposal.markAsMerged(1, now.next(), reporter)
    >>> print merge_proposal.date_merged
    2005-03-09 15:40:00+00:00
    >>> print merge_proposal.merge_reporter.browsername
    Mark Shuttleworth


== Interfaces ==

The BranchMergeProposal must implement the IBranchMergeProposal interface.

    >>> from canonical.launchpad.webapp.testing import verifyObject
    >>> from canonical.launchpad.interfaces import IBranchMergeProposal
    >>> verifyObject(IBranchMergeProposal, merge_proposal)
    True


== Canonical URL ==

The URL of a branch merge proposal is based on the source branch.
In order to keep the URL managable, the database ID of the merge
proposal is used.

    >>> login('test@canonical.com')
    >>> from canonical.launchpad.webapp import canonical_url
    >>> merge_proposal = source_branch.landing_targets[0]
    >>> url = canonical_url(merge_proposal)
    >>> url[url.rfind('/')+1:] == str(merge_proposal.id)
    True
    >>> print url
    http://code.launchpad.dev/~sabdfl/firefox/release-0.9/+merge/...


== Deleting merge proposals ==

Deleting merge proposals is done through the destroySelf method on the
merge proposal itself.  The destroySelf method is protected by
launchpad.Edit, which restricts access to the owner of the source
branch, the owner of the target branch, or the registrant (and LP
admins).

    >>> source_branch.landing_targets.count()
    1
    >>> merge_proposal = source_branch.landing_targets[0]
    >>> login('no-priv@canonical.com')
    >>> merge_proposal.destroySelf()
    Traceback (most recent call last):
    ...
    Unauthorized: (<BranchMergeProposal ...>,
    'destroySelf', 'launchpad.Edit')

Sample Person is the registrant, so they can destroy it.

    >>> login('test@canonical.com')
    >>> merge_proposal.destroySelf()
    >>> source_branch.landing_targets.count()
    0
