Team mailing list subscriptions
===============================

Members of a team, either direct or indirect, may subscribe to that team's
mailing list, if it has one.  To illustrate, we'll first create a bunch of
people, a team and its team mailing list.

    # login() as an admin so that we can call join() on anyone
    # and change their mailing list auto-subscription settings.
    >>> login('foo.bar@canonical.com')

    >>> from lp.registry.tests.mailinglists_helper import (
    ...     get_alternative_email, print_addresses)
    >>> anne = factory.makePersonByName('Anne')

Anne gets two email addresses.  One is her preferred address...

    >>> anne.preferredemail.email
    u'anne.person@example.com'

...and the other is her alternative address.

    >>> get_alternative_email(anne).email
    u'aperson@example.org'

    >>> team_owner = 'no-priv'
    >>> bart = factory.makePersonByName('Bart')
    >>> team_one, list_one = factory.makeTeamAndMailingList(
    ...     'team-one', team_owner)
    >>> team_names = [team_one.name]

Once Anne and Bart join team one, they can post to the mailing list, but they
will not get deliveries.

    >>> anne.join(team_one)
    >>> bart.join(team_one)

    # The IMailingListSet APIs use the SLAVE_FLAVOR since they are read-only.
    # Commit the transaction so that the changes are visible there.
    >>> transaction.commit()

    # No Privileges Person shows up as a team member because he created the
    # team (in the doctest infrastructure).
    >>> sorted(member.displayname for member in team_one.allmembers)
    [u'Anne Person', u'Bart Person', u'No Privileges Person']

The list of sender addresses, i.e. those that are allowed to send emails to a
mailing list, are available both through the mailing list object and through
the mailing list set.

    >>> sorted(list_one.getSenderAddresses())
    [u'anne.person@example.com', u'aperson@example.org',
     u'bart.person@example.com', u'bperson@example.org',
     u'no-priv@canonical.com']

    >>> from lp.registry.interfaces.mailinglist import IMailingListSet
    >>> mailinglist_set = getUtility(IMailingListSet)
    >>> print_addresses(mailinglist_set.getSenderAddresses(team_names))
    team-one
        anne.person@example.com, aperson@example.org,
        bart.person@example.com, bperson@example.org,
        no-priv@canonical.com

No one is yet subscribed to the mailing list though.

    >>> list(list_one.getSubscribedAddresses())
    []
    >>> list(list_one.getSubscribers())
    []
    >>> mailinglist_set.getSubscribedAddresses([team_one.name])
    {}

Anne subscribes to the mailing list for team one.  Because Anne does not
provide an email address when she subscribes, her preferred address is used.

    >>> list_one.subscribe(anne)
    >>> transaction.commit()

    >>> sorted(list_one.getSubscribedAddresses())
    [u'anne.person@example.com']
    >>> sorted(person.displayname for person in list_one.getSubscribers())
    [u'Anne Person']

    >>> print_addresses(mailinglist_set.getSubscribedAddresses(team_names))
    team-one
        anne.person@example.com

Now Bart also subscribes to the mailing list, but he does so with something
other than his preferred email address.

    >>> alternative_email = get_alternative_email(bart)
    >>> alternative_email.email
    u'bperson@example.org'
    >>> list_one.subscribe(bart, alternative_email)
    >>> transaction.commit()

    >>> sorted(list_one.getSubscribedAddresses())
    [u'anne.person@example.com', u'bperson@example.org']
    >>> sorted(person.displayname for person in list_one.getSubscribers())
    [u'Anne Person', u'Bart Person']

    >>> print_addresses(mailinglist_set.getSubscribedAddresses(team_names))
    team-one
        anne.person@example.com, bperson@example.org

A team can not subscribe to a mailing list.

    >>> list_one.subscribe(team_one)
    Traceback (most recent call last):
    ...
    CannotSubscribe: Teams cannot be mailing list members: Team One

A user's subscribed address is the address to which they'll receive posted
messages.  However, the user may post a message from any of the addresses
they've confirmed with Launchpad.

    >>> sorted(list_one.getSenderAddresses())
    [u'anne.person@example.com', u'aperson@example.org',
     u'bart.person@example.com', u'bperson@example.org',
     u'no-priv@canonical.com']

However, should Anne register a new, but not-validated email address, she may
not post from it.

    >>> from lp.services.identity.interfaces.emailaddress import IEmailAddressSet
    >>> address_set = getUtility(IEmailAddressSet)
    >>> alternative = address_set.new(
    ...     'anne.x.person@example.net', anne)
    >>> alternative.email
    u'anne.x.person@example.net'

    >>> sorted(list_one.getSenderAddresses())
    [u'anne.person@example.com', u'aperson@example.org',
     u'bart.person@example.com', u'bperson@example.org',
     u'no-priv@canonical.com']

Once Anne validates her new address, she can post from it.

    >>> from lp.services.identity.interfaces.emailaddress import EmailAddressStatus
    >>> alternative.status = EmailAddressStatus.VALIDATED
    >>> transaction.commit()

    >>> sorted(list_one.getSenderAddresses())
    [u'anne.person@example.com', u'anne.x.person@example.net',
     u'aperson@example.org',
     u'bart.person@example.com', u'bperson@example.org',
     u'no-priv@canonical.com']

    >>> print_addresses(mailinglist_set.getSenderAddresses(team_names))
    team-one
        anne.person@example.com, anne.x.person@example.net,
        aperson@example.org,
        bart.person@example.com, bperson@example.org,
        no-priv@canonical.com

    # Reverse the validation so that it doesn't affect subsequent tests.
    >>> alternative.status = EmailAddressStatus.NEW
