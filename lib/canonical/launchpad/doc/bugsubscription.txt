Users can get email notifications of changes to bugs by subscribing to
them.

Bug Subscriber APIs
===================

First, let's login:

    >>> from canonical.launchpad.ftests import login
    >>> login("foo.bar@canonical.com")

IBug has a subscriptions attribute:

    >>> from canonical.launchpad.interfaces import IBugSet
    >>> from zope.component import getUtility
    >>> bugset = getUtility(IBugSet)
    >>> bug = bugset.get(1)
    >>> bug.subscriptions.count()
    2

This list returns only *direct* subscribers. Bugs can also have
indirect subscribers.

Direct vs. Indirect Subscriptions
---------------------------------

A user is directly subscribed to a bug if they or someone else has
subscribed them to the bug.

Then there are three kinds of users that are indirectly subscribed to
a bug:

    * assignees
    * bug contacts
    * direct subscribers from dupes

Bugs may get reassigned, bug contacts may come and go, and dupes may
be unduped or reduped to other bugs. Indirect subscriptions are looked
up at mail sending time, so the mail is automatically sent to new bug
contacts or assignees, stops being sent to subscribers from dupes when
a bug is unduped, and so forth.

Let's create a new bug to demonstrate how direct and indirect
subscriptions work.

    >>> from canonical.launchpad.interfaces import (
    ...     IDistributionSet, ILaunchBag, IPersonSet, CreateBugParams)
    >>> ubuntu = getUtility(IDistributionSet).getByName("ubuntu")
    >>> personset = getUtility(IPersonSet)

    >>> linux_source = ubuntu.getSourcePackage("linux-source-2.6.15")
    >>> linux_source.bugcontacts
    []
    >>> print linux_source.distribution.bugcontact
    None

    >>> foobar = getUtility(ILaunchBag).user
    >>> print foobar.name
    name16

    >>> params = CreateBugParams(
    ...     title="a bug to test subscriptions",
    ...     comment="test", owner=foobar)
    >>> linux_source_bug = linux_source.createBug(params)

The list of direct bug subscribers is accessed via
IBug.getDirectSubscribers().

    >>> import operator
    >>> def print_names(subscribers):
    ...     namegetter = operator.attrgetter("name")
    ...     for subscriber in sorted(subscribers, key=namegetter):
    ...         print subscriber.name

    >>> print_names(linux_source_bug.getDirectSubscribers())
    name16

    >>> sabdfl = personset.getByName("sabdfl")

    >>> linux_source_bug.subscribe(sabdfl)
    <BugSubscription ...>

    >>> print_names(linux_source_bug.getDirectSubscribers())
    name16
    sabdfl

The list of indirect subscribers is accessed via
IBug.getIndirectSubscribers().

    >>> linux_source_bug.getIndirectSubscribers()
    []

Finer-grained access to indirect subscribers is provided by
getAlsoNotifiedSubscribers() and getSubscribersFromDuplicates().

    >>> linux_source_bug.getAlsoNotifiedSubscribers()
    []
    >>> linux_source_bug.getSubscribersFromDuplicates()
    []

The list of all bug subscribers can also be accessed via
IBugTask.bug_subscribers. Our event handling machinery compares a
"snapshot" of this value, before a bug was changed, to the current
value, to check if there are new bugcontacts subscribed to this bug as a
result of a product or sourcepackage reassignment. It's also an
optimization to snapshot this list only on IBugTask, because we don't
need it for changes made only to IBug.

    >>> task = linux_source_bug.bugtasks[0]
    >>> print_names(task.bug_subscribers)
    name16
    sabdfl

Here are some examples of the three types of indirect subscribers:

1. Assignees

    >>> sample_person = personset.getByName("name12")

    >>> linux_source_bug.bugtasks[0].transitionToAssignee(sample_person)

    >>> print_names(linux_source_bug.getIndirectSubscribers())
    name12
    
    >>> linux_source_bug.getSubscribersFromDuplicates()
    []

    >>> print_names(linux_source_bug.getAlsoNotifiedSubscribers())
    name12

2. Bug contacts

    >>> mr_no_privs = personset.getByName("no-priv")

    >>> linux_source.addBugContact(mr_no_privs)

    >>> print_names(bc.bugcontact for bc in linux_source.bugcontacts)
    no-priv

    >>> print_names(linux_source_bug.getIndirectSubscribers())
    name12
    no-priv
    
    >>> linux_source_bug.getSubscribersFromDuplicates()
    []
    >>> print_names(linux_source_bug.getAlsoNotifiedSubscribers())
    name12
    no-priv

    >>> ubuntu_team = personset.getByName("ubuntu-team")

    >>> linux_source.distribution.bugcontact = ubuntu_team

    >>> print_names(linux_source_bug.getIndirectSubscribers())
    name12
    no-priv
    ubuntu-team
    
    >>> print_names(linux_source_bug.getAlsoNotifiedSubscribers())
    name12
    no-priv
    ubuntu-team    

(Adding a product bugtask to demonstrate that the upstream bug contact
is also an indirect subscriber.)

    >>> from canonical.launchpad.interfaces import IBugTaskSet, IProductSet
    >>> firefox = getUtility(IProductSet).get(4)

    >>> getUtility(IBugTaskSet).createTask(
    ...     product=firefox, bug=linux_source_bug,
    ...     owner=foobar)
    <BugTask ...>

    >>> lifeless = personset.getByName("lifeless")
    >>> firefox.bugcontact = lifeless

    >>> print_names(linux_source_bug.getIndirectSubscribers())
    lifeless
    name12
    no-priv
    ubuntu-team
    
    >>> print_names(linux_source_bug.getAlsoNotifiedSubscribers())
    lifeless
    name12
    no-priv
    ubuntu-team

If there were no upstream product bug contact, the product owner would
be used instead.

    >>> firefox.bugcontact = None

    >>> print_names(linux_source_bug.getIndirectSubscribers())
    name12
    no-priv
    ubuntu-team
    
    >>> print_names(linux_source_bug.getAlsoNotifiedSubscribers())
    name12
    no-priv
    ubuntu-team

    >>> previous_owner = firefox.owner

    >>> firefox.owner = lifeless

    >>> print_names(linux_source_bug.getIndirectSubscribers())
    lifeless
    name12
    no-priv
    ubuntu-team
    
    >>> print_names(linux_source_bug.getAlsoNotifiedSubscribers())
    lifeless
    name12
    no-priv
    ubuntu-team    

    >>> firefox.owner = previous_owner
    >>> firefox.bugcontact = lifeless

3. Direct subscribers of duplicate bugs.

    >>> keybuk = personset.getByName("keybuk")

    >>> params = CreateBugParams(
    ...     title="a bug to test subscriptions",
    ...     comment="test", owner=keybuk)
    >>> linux_source_bug_dupe = linux_source.createBug(params)

    >>> print_names(linux_source_bug_dupe.getDirectSubscribers())
    keybuk

Indirect subscribers of duplicates are *not* subscribed to dupe
targets. For example, assigning stub to the dupe bug will demonstrate
how he, as an indirect subscriber of the dupe, but does not get
subscribed to the dupe target.

    >>> linux_source_bug_dupe.bugtasks[0].transitionToAssignee(
    ...     personset.getByName("stub"))

    >>> print_names(linux_source_bug_dupe.getIndirectSubscribers())
    no-priv
    stub
    ubuntu-team
    
    >>> linux_source_bug_dupe.duplicateof = linux_source_bug
    >>> linux_source_bug_dupe.syncUpdate()

    >>> print_names(linux_source_bug.getIndirectSubscribers())
    keybuk
    lifeless
    name12
    no-priv
    ubuntu-team
    
    >>> print_names(linux_source_bug.getSubscribersFromDuplicates())
    keybuk

When a bug is marked private, all its indirect subscribers become direct
subscribers.

    >>> from zope.event import notify

    >>> from canonical.launchpad.event import (
    ...     SQLObjectModifiedEvent, SQLObjectToBeModifiedEvent)
    >>> from canonical.launchpad.webapp.snapshot import Snapshot
    >>> from canonical.launchpad.interfaces import IBug

    >>> print_names(linux_source_bug.getDirectSubscribers())
    name16
    sabdfl

    >>> notify(
    ...     SQLObjectToBeModifiedEvent(linux_source_bug, {"private": True}))

    >>> bug_before_modification = Snapshot(linux_source_bug, providing=IBug)
    >>> linux_source_bug.private = True

    >>> notify(
    ...     SQLObjectModifiedEvent(
    ...         linux_source_bug, bug_before_modification, ["private"]))

    >>> print_names(linux_source_bug.getDirectSubscribers())
    keybuk
    lifeless
    name12
    name16
    no-priv
    sabdfl
    ubuntu-team

A private bug never has indirect subscribers. Since all our indirect
subscribers have been made into direct subscribers, let's add another
indirect subscriber to show that they still aren't included in the
indirect subscriptions.

    >>> linux_source_bug.bugtasks[0].transitionToAssignee(
    ...     personset.getByName("martin-pitt"))

    >>> linux_source_bug.getIndirectSubscribers()
    []
    
    >>> linux_source_bug.getSubscribersFromDuplicates()
    []

Direct subscriptions always take precedence over indirect
subscriptions. So, if we unmark the above bug as private,
indirect_subscribers will include only martin-pitt.

    >>> linux_source_bug.private = False
    >>> linux_source_bug.syncUpdate()

    >>> print_names(linux_source_bug.getDirectSubscribers())
    keybuk
    lifeless
    name12
    name16
    no-priv
    sabdfl
    ubuntu-team

    >>> print_names(linux_source_bug.getIndirectSubscribers())
    martin-pitt
    
    >>> print_names(linux_source_bug.getAlsoNotifiedSubscribers())
    martin-pitt

To get the entire list of email addresses that should receive a
notification email on a bug, call
IBug.notificationRecipientAddresses().

   >>> sorted(linux_source_bug.notificationRecipientAddresses())
   ['foo.bar@canonical.com', 'mark@hbd.com', 'no-priv@canonical.com',
    'robertc@robertcollins.net', 'support@ubuntu.com', 'test@canonical.com']

To find out if someone is already directly subscribed to a bug, call
IBug.isSubscribed, passing in an IPerson:

    >>> linux_source_bug.isSubscribed(personset.getByName("debonzi"))
    False
    >>> linux_source_bug.isSubscribed(sample_person)
    True

Call isSubscribedToDupes to see if a user is directly subscribed to
dupes of a bug. This is useful for, for example, figuring out how to
display the Subscribe/Unsubscribe menu option, and in TAL, for deciding
whether the user needs to be warned, while unsubscribing, that they will
be unsubscribed from dupes.

    >>> bug_five = bugset.get(5)
    >>> bug_six = bugset.get(6)

    >>> bug_six.duplicateof == bug_five
    True

    >>> bug_five.isSubscribedToDupes(sample_person)
    False

    >>> bug_six.subscribe(sample_person)
    <BugSubscription...>

    >>> bug_five.isSubscribedToDupes(sample_person)
    True

Subscribing and Unsubscribing
=============================

To subscribe people to and unsubscribe people from a bug, use
IBug.subscribe and IBug.unsubscribe:

    >>> foobar = personset.getByName("name16")

    >>> bug.isSubscribed(foobar)
    False
    >>> bug.subscribe(foobar)
    <BugSubscription at ...>
    >>> bug.isSubscribed(foobar)
    True

    >>> bug.unsubscribe(foobar)
    >>> bug.isSubscribed(foobar)
    False

To unsubscribe from all dupes for a bug, call
IBug.unsubscribeFromDupes. This is useful because direct subscribers
from dupes are automatically subscribed to dupe targets, so we provide
them a way to unsubscribe.

For example, Sample Person can be unsubscribed from bug #6, by
unsubscribing them from the dupes of bug #5, because bug #6 is a dupe of
bug #5.

    >>> bug_six.duplicateof == bug_five
    True

    >>> bug_six.isSubscribed(sample_person)
    True

The return value of unsubscribeFromDupes() is a list of bugs from which
the user was unsubscribed.

    >>> [bug.id for bug in bug_five.unsubscribeFromDupes(sample_person)]
    [6]

    >>> bug_six.isSubscribed(sample_person)
    False

Automatic Subscriptions on Bug Creation
=======================================

When a new bug is opened, only the bug reporter is automatically, explicitly
subscribed to the bug:

XXX: Brad Bollenbach, 2005-11-25: These bits need real sample data. See
https://launchpad.net/bugs/5484.

Let's have a look at an example for a distribution bug:

    >>> ubuntu.bugcontact = sample_person

    >>> from canonical.launchpad.interfaces import IBugSet

    >>> params = CreateBugParams(
    ...     title="a test bug", comment="a test description",
    ...     owner=foobar)
    >>> new_bug = ubuntu.createBug(params)

Only the bug reporter, Foo Bar, has an explicit subscription.

    >>> [subscription.person.displayname
    ...  for subscription in new_bug.subscriptions]
    [u'Foo Bar']

But because Sample Person is the distribution contact for Ubuntu, he
will be implicitly added to the notification recipients.

    >>> sorted(new_bug.notificationRecipientAddresses())
    ['foo.bar@canonical.com', 'test@canonical.com']

The distro contact will also be subscribed to private bugs, because
there is no security contact:

    >>> ubuntu.security_contact is None
    True

    >>> params = CreateBugParams(
    ...     title="a test bug", comment="a test description",
    ...     owner=foobar, security_related=True, private=True)
    >>> new_bug = ubuntu.createBug(params)

    >>> sorted(new_bug.notificationRecipientAddresses())
    ['foo.bar@canonical.com', 'support@ubuntu.com']

Another example, this time for an upstream:

    >>> firefox.bugcontact = sabdfl

    >>> params = CreateBugParams(
    ...     title="a test bug", comment="a test description",
    ...     owner=foobar)
    >>> new_bug = firefox.createBug(params)

Again, only Foo Bar is explicitly subscribed:

    >>> [subscription.person.displayname
    ...  for subscription in new_bug.subscriptions]
    [u'Foo Bar']

But the upstream Firefox bug contact, sabdfl, is implicitly added to the
recipients list.

    >>> sorted(new_bug.notificationRecipientAddresses())
    ['foo.bar@canonical.com', 'mark@hbd.com']

If we create a bug task on Ubuntu in the same bug, the Ubuntu bug
contact will be subscribed:

    >>> ubuntu_task = getUtility(IBugTaskSet).createTask(
    ...     bug=new_bug, distribution=ubuntu, owner=sabdfl)

    >>> sorted(new_bug.notificationRecipientAddresses())
    ['foo.bar@canonical.com', 'mark@hbd.com', 'test@canonical.com']

But still, only Foo Bar is explicitly subscribed.

    >>> [subscription.person.displayname
    ...  for subscription in new_bug.subscriptions]
    [u'Foo Bar']

When an upstream does *not* have a specific bug contact set, the
product.owner is used instead. So, if Firefox's bugcontact is unset,
Sample Person, the Firefox "owner" will get subscribed instead:

    >>> firefox.bugcontact = None

    >>> params = CreateBugParams(
    ...     title="a test bug", comment="a test description",
    ...     owner=foobar)
    >>> new_bug = firefox.createBug(params)

Foo Bar is the only explicit subscriber:

    >>> [subscription.person.displayname
    ...  for subscription in new_bug.subscriptions]
    [u'Foo Bar']

But the product owner, Sample Person, is implicitly added to the
recipient list:

    >>> sorted(new_bug.notificationRecipientAddresses())
    ['foo.bar@canonical.com', 'test@canonical.com']

The upstream maintainer will be subscribed to security-related private
bugs, because upstream has no security contact, in this case.

    >>> firefox.security_contact is None
    True

    >>> params = CreateBugParams(
    ...     title="a test bug", comment="a test description",
    ...     owner=foobar, security_related=True, private=True)
    >>> new_bug = firefox.createBug(params)

    >>> sorted(new_bug.notificationRecipientAddresses())
    ['foo.bar@canonical.com', 'test@canonical.com']

Now let's create a bug on a specific package, which has no package bug
contacts:

    >>> evolution = ubuntu.getSourcePackage("evolution")
    >>> evolution.bugcontacts
    []

    >>> params = CreateBugParams(
    ...     title="another test bug",
    ...     comment="another test description",
    ...     owner=foobar)
    >>> new_bug = evolution.createBug(params)

    >>> sorted(new_bug.notificationRecipientAddresses())
    ['foo.bar@canonical.com', 'test@canonical.com']

Adding a package bug contact for evolution will mean that that package
bug contact gets implicitly subscribed to all bugs ever opened on that
package.

So, if the Ubuntu team is added as a bug contact to evolution:

    >>> evolution.addBugContact(ubuntu_team)

The team will be implicitly subscribed to the previous bug we
created. (Remember that Sample Person is also implicitly subscribed
because they are the distro bug contact):

    >>> [subscription.person.displayname
    ...  for subscription in new_bug.subscriptions]
    [u'Foo Bar']

    >>> sorted(new_bug.notificationRecipientAddresses())
    ['foo.bar@canonical.com', 'support@ubuntu.com', 'test@canonical.com']

And the Ubuntu team will be implicitly subscribed to future bugs:

    >>> params = CreateBugParams(
    ...     title="yet another test bug",
    ...     comment="yet another test description",
    ...     owner=foobar)
    >>> new_bug = evolution.createBug(params)

    >>> [subscription.person.displayname
    ...  for subscription in new_bug.subscriptions]
    [u'Foo Bar']

    >>> sorted(new_bug.notificationRecipientAddresses())
    ['foo.bar@canonical.com', 'support@ubuntu.com', 'test@canonical.com']

The distribution maintainer, Ubuntu Team, gets subscribed to the private
security bug filed on a package, because Ubuntu has no security contact:

    >>> ubuntu.security_contact is None
    True

    >>> params = CreateBugParams(
    ...     title="yet another test bug",
    ...     comment="yet another test description",
    ...     owner=foobar, security_related=True, private=True)
    >>> new_bug = evolution.createBug(params)

    >>> sorted(new_bug.notificationRecipientAddresses())
    ['foo.bar@canonical.com', 'support@ubuntu.com']
