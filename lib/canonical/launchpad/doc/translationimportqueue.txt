TranslationImportQueue
======================

The translation import queue is the place where the new translation imports
end before being imported into Rosetta.


TranslationImportQueueEntry
===========================

The TranslationImportQueueEntry is an entry of the queue that will be imported
into Rosetta.

guessed_pofile
--------------

This property gives us the IPOFile where we think we should import this entry.

To test it, we need to add an entry to the queue.

Here we have some imports and utility fetch.

    >>> import transaction
    >>> from zope.component import getUtility
    >>> from canonical.launchpad.interfaces import ITranslationImportQueue
    >>> from canonical.launchpad.interfaces import ILaunchpadCelebrities
    >>> from canonical.launchpad.database import ProductSeries
    >>> from canonical.launchpad.database import DistroRelease
    >>> from canonical.launchpad.database import SourcePackageName
    >>> from canonical.launchpad.ftests import login
    >>> from canonical.lp.dbschema import RosettaImportStatus
    >>> translationimportqueue = getUtility(ITranslationImportQueue)
    >>> rosetta_expert = getUtility(ILaunchpadCelebrities).rosetta_expert

First, we are going to try to do the guess against the Evolution product. That
means that we are going to use the ProductSeries.id = 3

    >>> evolution_productseries = ProductSeries.get(3)

Attach the file to the product series, without associate it with any potemplate.

    >>> entry = translationimportqueue.addOrUpdateEntry(
    ...     'po/sr.po', 'foo', True, rosetta_expert,
    ...      productseries=evolution_productseries)
    >>> transaction.commit()

This entry has no information about the IPOFile where it should be attached to:

    >>> entry.import_into == None
    True

And the guessing algorithm will not be able to guess anything as there is no
IPOFiles on the same path and we have two IPOTemplates on the same path where
this IPOFile is located ('po/')

    >>> entry.guessed_pofile == None
    True

Now let's try the same against the evolution sourcepackage that only has an
IPOTemplate.

    >>> hoary_distrorelease = DistroRelease.get(3)
    >>> evolution_sourcepackagename = SourcePackageName.get(9)
    >>> entry = translationimportqueue.addOrUpdateEntry(
    ...     'po/sr.po', 'foo', True, rosetta_expert,
    ...      distrorelease=hoary_distrorelease,
    ...      sourcepackagename=evolution_sourcepackagename)
    >>> transaction.commit()

This entry has no information about the IPOFile where it should be attached to:

    >>> entry.import_into == None
    True

And the guessing algorithm is able to give us an IPOFile where it should be
imported.

    >>> entry.guessed_pofile == None
    False

    >>> entry.guessed_pofile.title
    u'Serbian (sr) translation of evolution-2.2 in Ubuntu Hoary package "evolution"'


Let's try now to update the entries.

We need to know the status that the entry has.

    >>> entry.status.title
    'Needs Review'

And store current creation and status change date:

    >>> previous_dateimported = entry.dateimported
    >>> previous_date_status_changed = entry.date_status_changed

Now, we do a new upload.

    >>> entry = translationimportqueue.addOrUpdateEntry(
    ...     'po/sr.po', 'foo', True, rosetta_expert,
    ...      distrorelease=hoary_distrorelease,
    ...      sourcepackagename=evolution_sourcepackagename)
    >>> transaction.commit()

And the new status is

    >>> entry.status.title
    'Needs Review'

The dateimported remains the same as it was already waiting to be imported.

    >>> entry.dateimported == previous_dateimported
    True

And the date_status_changed is newer

    >>> entry.date_status_changed > previous_date_status_changed
    True

Let's change now its status to imported and see what happens. To do it,
we need to be logged in as an admin.

    >>> login('carlos@canonical.com')
    >>> entry.status = RosettaImportStatus.IMPORTED

Need to update our saved date_status_changed to detect if it changes now.

    >>> previous_date_status_changed = entry.date_status_changed

Do the new upload.

    >>> entry = translationimportqueue.addOrUpdateEntry(
    ...     'po/sr.po', 'foo', True, rosetta_expert,
    ...      distrorelease=hoary_distrorelease,
    ...      sourcepackagename=evolution_sourcepackagename)
    >>> transaction.commit()

And the new status is

    >>> entry.status.title
    'Needs Review'

The dateimported remains the same as it was already waiting to be imported.

    >>> entry.dateimported > previous_dateimported
    True

And the date_status_changed is newer

    >>> entry.date_status_changed > previous_date_status_changed
    True


executeAutomaticBlock
---------------------

This method looks on the queue to find entries to block based on other .pot
entries that are stored on the same directory and are already blocked.

First, we import a new .pot file.

    >>> entry = translationimportqueue.addOrUpdateEntry(
    ...     'po/foo.pot', 'foo', True, rosetta_expert,
    ...      distrorelease=hoary_distrorelease,
    ...      sourcepackagename=evolution_sourcepackagename)

And block it.

    >>> entry.status = RosettaImportStatus.BLOCKED
    >>> transaction.commit()

Check the number of entries on the queue.

    >>> len(translationimportqueue)
    3

First, let's check the status of the existing entries.

    >>> entry1 = translationimportqueue.get(1)
    >>> entry1.path
    u'po/sr.po'
    >>> entry1.status == RosettaImportStatus.NEEDS_REVIEW
    True

    >>> entry2 = translationimportqueue.get(2)
    >>> entry2.path
    u'po/sr.po'
    >>> entry2.status == RosettaImportStatus.NEEDS_REVIEW
    True

    >>> entry3 = translationimportqueue.get(3)
    >>> entry3.path
    u'po/foo.pot'
    >>> entry3.status == RosettaImportStatus.BLOCKED
    True

Let's see how many entries are blocked.

    >>> translationimportqueue.executeAutomaticBlock()
    1

Now is time to check that we only have one item on the NeedsReview status.

    >>> entry1 = translationimportqueue.get(1)
    >>> entry1.path
    u'po/sr.po'

This entry is form a productseries, and it's not blocked because the blocked
.pot entry is for a distrorelease-sourcepackagename.

    >>> entry1.status == RosettaImportStatus.NEEDS_REVIEW
    True

    >>> entry2 = translationimportqueue.get(2)
    >>> entry2.path
    u'po/sr.po'
    >>> entry2.status == RosettaImportStatus.BLOCKED
    True

    >>> entry3 = translationimportqueue.get(3)
    >>> entry3.path
    u'po/foo.pot'
    >>> entry3.status == RosettaImportStatus.BLOCKED
    True
