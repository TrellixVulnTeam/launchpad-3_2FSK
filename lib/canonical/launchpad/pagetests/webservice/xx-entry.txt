= Entries =

Most objects published by the Launchpad web service are entries:
self-contained data structures with an independent existence from any
other entry. Entries are distinguished from collections, which are
groupings of entries.

All entries in the Launchpad web service work pretty much the same
way. This document illustrates the general features of entries, using
Launchpad people and bug tasks as examples.


== Reading ==

It's possible to get a JSON 'representation' of an entry by sending a
GET request to the entry's URL.

Here we see that the user 'salgado' has a display name of 'Guilherme
Salgado'.

  >>> salgado = webservice.get('/~salgado').jsonBody()
  >>> salgado['display_name']
  u'Guilherme Salgado'

The service root resource describes a link to one special entry: the
user account of the authenticated user. To avoid confusion when one
program runs as different users, this is implemented as a redirect to
that person's canonical URL.

  >>> print webservice.get('/people/+me').getOutput()
  HTTP/1.1 303 See Other
  ...
  Location: http://.../~salgado
  ...

Data is served encoded in UTF-8; a good client will automatically
convert it into Unicode.

    >>> webservice.get("/~mpo").jsonBody()['display_name']
    u'Matti P\xf6ll\xe4'


== Content negotiation ==

By varying the 'Accept' header, the client can request either a JSON
or XHTML representation of an entry, or a WADL description of the
entry's capabilities.

  >>> def negotiated_type(accept_header):
  ...     return webservice.get('/~salgado',
  ...                           accept_header).getHeader('Content-Type')

  >>> negotiated_type('application/json')
  'application/json'

  >>> negotiated_type('application/xhtml+xml')
  'application/xhtml+xml'

  >>> negotiated_type('application/vd.sun.wadl+xml')
  'application/vd.sun.wadl+xml'

  >>> negotiated_type(None)
  'application/json'

  >>> negotiated_type('text/html')
  'application/json'

  >>> negotiated_type('application/json, application/vd.sun.wadl+xml')
  'application/json'

  >>> negotiated_type('application/json, application/xhtml+xml')
  'application/json'

  >>> negotiated_type('application/vd.sun.wadl+xml, text/html, '
  ...                 'application/json')
  'application/vd.sun.wadl+xml'

  >>> negotiated_type('application/json;q=0.5, application/vd.sun.wadl+xml')
  'application/vd.sun.wadl+xml'

  >>> negotiated_type('application/json;q=0, application/xhtml+xml;q=0.05,'
  ...                 'application/vd.sun.wadl+xml;q=0.1')
  'application/vd.sun.wadl+xml'


== Custom operations ==

Some entries support custom operations through GET. The custom
operation to be invoked is named in the query string's 'ws.op'
argument. You can get a list of a team's active members by specifying
the 'getMembersByStatus' operation.

  >>> active_members = webservice.get(
  ...     "/~admins?ws.op=getMembersByStatus&status=Approved").jsonBody()
  >>> sorted([m['name'] for m in active_members['entries']])
  [u'carlos', u'daf', u'debonzi', u'kinnison', u'spiv']

Some entries support custom operations through POST. You can change a
bug's status by invoking a custom operation.

  >>> bugtask_path = '/debian/+source/mozilla-firefox/+bug/1'
  >>> webservice.get(bugtask_path).jsonBody()['status']
  u'Confirmed'

  >>> print webservice.named_post(
  ...     bugtask_path, 'transitionToStatus', {}, status='Invalid')
  HTTP/1.1 200 Ok
  ...

  >>> webservice.get(bugtask_path).jsonBody()['status']
  u'Invalid'

Custom operations may have error handling.

  >>> print webservice.get(
  ...     "/~admins?ws.op=getMembersByStatus&status=NoSuchStatus")
  HTTP/1.1 400 Bad Request
  ...
  status: Invalid value "NoSuchStatus". Acceptable values are: ...

  >>> print webservice.named_post(
  ...     bugtask_path, 'transitionToStatus', {}, status='NoSuchStatus')
  HTTP/1.1 400 Bad Request
  ...
  status: Invalid value "NoSuchStatus". Acceptable values are: ...

  >>> print webservice.named_post(
  ...     bugtask_path, 'transitionToStatus', {}, status='Triaged')
  HTTP/1.1 401 Unauthorized
  ...
  Only Bug Supervisors may change status to Triaged.

Trying to invoke a nonexistent custom operation yields an error.

  >>> print webservice.get(
  ...     "/~admins?ws.op=no_such_operation")
  HTTP/1.1 400 Bad Request
  ...
  No such operation: no_such_operation


== Modification ==

It's possible to modify an entry by sending to the server a document
asserting what the entry should look like. The document may only
describe part of the entry's new state, in which case the client
should use the PATCH HTTP method. Or it may completely describe the
entry's state, in which case the client should use PUT.

  >>> import simplejson
  >>> def modify_person(person, representation, method, headers=None):
  ...     "A helper function to send a PUT or PATCH request to a person."
  ...     new_headers = {'Content-type': 'application/json'}
  ...     if headers is not None:
  ...         new_headers.update(headers)
  ...     return webservice('/~' + person, method,
  ...                       simplejson.dumps(representation),
  ...                       headers)

Here we use the web service to change the user 'salgado' so that their
display name is in uppercase. The data returned is the new JSON
representation of the object.

  >>> print modify_person('salgado', {'display_name' : 'GUILHERME SALGADO'},
  ...                     'PATCH')
  HTTP/1.1 209 Content Returned
  ...
  Content-Type: application/json
  <BLANKLINE>
  {...}

  >>> print webservice.get('/~salgado', 'application/xhtml+xml')
  HTTP/1.1 200 Ok
  ...
  <dl ...>
  ...
  </dl>

  >>> salgado = webservice.get('/~salgado').jsonBody()
  >>> salgado['display_name']
  u'GUILHERME SALGADO'

The modification might cause the person's address to change. Here we
use the web service to change the person's name to 'salgado2'.

  >>> print modify_person('salgado', {'name' : 'salgado2'}, 'PATCH')
  HTTP/1.1 301 Moved Permanently
  ...
  Location: http://.../~salgado2
  ...

At this point we can no longer manipulate the 'salgado' Person by
sending HTTP requests to http://api.launchpad.dev/~salgado,
because that Person now 'lives' at
http://api.launchpad.dev/~salgado2. To change 'salgado2' back to
'salgado', we need to send a PATCH request to the new address.

  >>> print modify_person('salgado2', {'name' : 'salgado'}, 'PATCH')
  HTTP/1.1 301 Moved Permanently
  ...
  Location: http://.../~salgado
  ...

The PATCH HTTP method is useful for simple changes, but not all HTTP
clients support PATCH. It's possible to fake a PATCH request with
POST, by setting the X-HTTP-Method-Override header to "PATCH". Because
Firefox 3 mangles the Content-Type header for POST requests, you may
also set the X-Content-Type-Override header, which will override the
value of Content-Type.

  >>> print modify_person('salgado',
  ...     {'display_name' : 'GUILHERME SALGADO XVII'}, 'POST',
  ...     {'X-HTTP-Method-Override' : 'PATCH',
  ...      'Content-Type': 'not-a-valid-content/type',
  ...      'X-Content-Type-Override': 'application/json'})
  HTTP/1.1 209 Content Returned
  ...

If you try to use X-HTTP-Method-Override when the underlying HTTP
method is not POST, you'll get an error.

  >>> print modify_person('salgado',
  ...     {}, 'GET', {'X-HTTP-Method-Override' : 'PATCH'})
  HTTP/1.1 400 Bad Request
  ...
  X-HTTP-Method-Override can only be used with a POST request.


Even if a client supports PATCH, sometimes it's easier to GET a
document, modify it, and send it back. If you have the full document
at hand, you can use the PUT method.

We happen to have a full document from when we sent a GET request to
the 'salgado' Person. Modifying that document and PUTting it back is
less work than constructing a new document and sending it with
PATCH. As with PATCH, a successful PUT serve the new representation of
the object that was modified.

  >>> salgado = webservice.get('/~salgado').jsonBody()
  >>> salgado['display_name']
  u'GUILHERME SALGADO XVII'

  >>> salgado['display_name'] = 'Guilherme Salgado'
  >>> print modify_person('salgado', salgado, 'PUT')
  HTTP/1.1 209 Content Returned
  ...
  <BLANKLINE>
  {...}

  >>> salgado = webservice.get('/~salgado').jsonBody()
  >>> salgado['display_name']
  u'Guilherme Salgado'

Because our patch format is the same as our representation format (a
JSON hash), any document that works with a PUT request will also work
with a PATCH request.

  >>> print modify_person('salgado', salgado, 'PATCH')
  HTTP/1.1 209 Content Returned
  ...


=== Server-side modification ===

Sometimes the server will transparently modify a value sent by the
client, to clean it up or put it into a canonical form. For this
purpose, the response to a PUT or PATCH request includes a brand new
JSON representation of the object, so that the client can know whether
and which changes were made.

Here's an example. Fields that contain URIs have a URI canonicalizer
associated with them.

    >>> def set_project_wiki_url(project_url, value):
    ...     project = webservice.get(project_url).jsonBody()
    ...     repr = simplejson.dumps({'wiki_url': value})
    ...     headers = {'Content-type': 'application/json'}
    ...     return webservice(project_url, "PATCH", repr, headers)

    >>> firefox = webservice.get('/firefox').jsonBody()
    >>> print firefox['wiki_url']
    None
    >>> first_etag = firefox['http_etag']

Send in a URI with no trailing slash and it'll be transparently
changed to have a trailing slash. Whitespace will also be trimmed. The
document returned from the POST request will be the new
representation, modified by both client and server.

    >>> firefox = set_project_wiki_url(
    ...     "/firefox", "   http://www.notrailingslash.com ").jsonBody()
    >>> print firefox['wiki_url']
    http://www.notrailingslash.com/
    >>> firefox['http_etag'] == first_etag
    False

Send in a URI with a trailing slash, and the data will not be modified.

    >>> firefox = set_project_wiki_url(
    ...     "/firefox", "http://www.trailingslash.com/").jsonBody()
    >>> print firefox['wiki_url']
    http://www.trailingslash.com/

The canonicalization works for PUT requests as well.

    >>> firefox['wiki_url'] = "http://www.stillnotrailingslash.com"
    >>> firefox = webservice("/firefox", "PUT", simplejson.dumps(firefox),
    ...                      {'Content-type': 'application/json'}).jsonBody()
    >>> print firefox['wiki_url']
    http://www.stillnotrailingslash.com/

Bad data is not canonicalized.

    >>> print set_project_wiki_url("/firefox", "not-a-url")
    HTTP/1.1 400 Bad Request
    ...
    wiki_url: "not-a-url" is not a valid URI


=== Conditional PUT and PATCH ===

When you GET an entry you're given an ETag; an opaque string that
changes whenever the entry changes.

  >>> response = webservice.get('/~salgado')
  >>> etag = response._response.getHeader('ETag')
  >>> salgado = response.jsonBody()

The ETag is present in the HTTP response headers when you GET an
entry, but it's also present in the representation of the entry
itself.

  >>> salgado['http_etag'] == etag
  True

This is so you can get the ETags for all the entries in a collection
at once, without making a separate HTTP request for each.

  >>> people = webservice.get('/people').jsonBody()
  >>> etags = [person['http_etag'] for person in people['entries']]

The ETag provided with an entry of a collection is the same as the
ETag you'd get if you got that entry individually.

  >>> first_person = people['entries'][0]
  >>> first_person_2 = webservice.get(first_person['self_link']).jsonBody()
  >>> first_person['http_etag'] == first_person_2['http_etag']
  True

When you make a PUT or PATCH request, you can provide the ETag as the
If-Match header. This lets you detect changes that other people made
to the entry, so your changes don't overwrite theirs.

If the ETag you provide in If-Match matches the entry's current ETag,
your request goes through.

  >>> print modify_person('salgado', salgado, 'PATCH',
  ...                     {'If-Match' : etag})
  HTTP/1.1 209 Content Returned
  ...

If the ETags don't match, it's because somebody modified the entry
after you got your copy of it. Your request will fail with status code
412.

  >>> print modify_person('salgado', salgado, 'PATCH',
  ...                     {'If-Match' : '"an-old-etag"'})
  HTTP/1.1 412 Precondition Failed
  ...

If you specify a number of ETags, and any of them match, your request
will go through.

  >>> print modify_person('salgado', salgado, 'PATCH',
  ...                     {'If-Match' : '"an-old-etag", %s' % etag})
  HTTP/1.1 209 Content Returned
  ...

Both PUT and PATCH requests work this way.

  >>> print modify_person('salgado', salgado, 'PUT',
  ...                     {'If-Match' : 'an-old-etag'})
  HTTP/1.1 412 Precondition Failed
  ...


=== What you can't do ===

A document that would be acceptable as the payload of a PATCH request
might not be acceptable as the payload of a PUT request.

  >>> print modify_person('salgado', {'name' : 'salgado2'}, 'PUT')
  HTTP/1.1 400 Bad Request
  ...
  You didn't specify a value for the attribute
  'mailing_list_auto_subscribe_policy'.

A document that's not a valid JSON document is also unacceptable.

  >>> print webservice.patch("/~salgado", "application/json", "{")
  HTTP/1.1 400 Bad Request
  ...
  Entity-body was not a well-formed JSON document.

A document that's valid JSON but is not a JSON hash is unacceptable.

  >>> print modify_person('salgado', 'name=salgado2', 'PATCH')
  HTTP/1.1 400 Bad Request
  ...
  Expected a JSON hash.

An entry's read-only attributes can't be modified.

  >>> print modify_person('salgado', {'date_created' :
  ...                                 u'2001-01-01T01:01:01+00:00Z'}, 'PATCH')
  HTTP/1.1 400 Bad Request
  ...
  date_created: You tried to modify a read-only attribute.

You can send a document that includes a value for a read-only
attribute, but it has to be the same as the current value.

  >>> print modify_person(
  ...     'salgado', {'date_created' : salgado['date_created']}, 'PATCH')
  HTTP/1.1 209 Content Returned
  ...

You can't change the link to an entry's associated collection.

  >>> print modify_person('salgado',
  ...                    {'memberships_details_collection_link' : 'dummy'},
  ...                     'PATCH')
  HTTP/1.1 400 Bad Request
  ...
  memberships_details_collection_link: You tried to modify a collection...

Again, you can send a document that includes a value for an associated
collection link; you just can't _change_ the value.

  >>> link = webservice.getAbsoluteUrl('/~salgado/memberships_details')
  >>> print modify_person('salgado',
  ...                     {'memberships_details_collection_link' : link },
  ...                      'PATCH')
  HTTP/1.1 209 Content Returned
  ...

You can't directly change an entry's URL address.

  >>> print modify_person('salgado',
  ...                    {'self_link' : 'dummy'}, 'PATCH')
  HTTP/1.1 400 Bad Request
  ...
  self_link: You tried to modify a read-only attribute.

You can't directly change an entry's ETag.

  >>> print modify_person('salgado',
  ...                    {'http_etag' : 'dummy'}, 'PATCH')
  HTTP/1.1 400 Bad Request
  ...
  http_etag: You tried to modify a read-only attribute.

You can't change an entry's resource type.

  >>> print modify_person('salgado',
  ...                    {'resource_type_link' : 'dummy'}, 'PATCH')
  HTTP/1.1 400 Bad Request
  ...
  resource_type_link: You tried to modify a read-only attribute.

You can't refer to a link to an associated object or collection as
though it were the actual object:

  >>> print modify_person(
  ...     'salgado', {'memberships_details' : 'dummy'}, 'PATCH')
  HTTP/1.1 400 Bad Request
  ...
  memberships_details: You tried to modify a nonexistent attribute.

  >>> print modify_person('landscape-developers', {'owner' :
  ...                     'salgado'}, 'PATCH')
  HTTP/1.1 400 Bad Request
  ...
  owner: You tried to modify a nonexistent attribute.

You can't set values that violate Launchpad's data integrity rules.

  >>> print modify_person('salgado',
  ...                    {'name' : 'sabdfl'}, 'PATCH')
  HTTP/1.1 400 Bad Request
  ...
  sabdfl is already in use by another person or team.

And of course you can't modify attributes that don't exist.

  >>> print modify_person('salgado', {'nonesuch' : 'dummy'}, 'PATCH')
  HTTP/1.1 400 Bad Request
  ...
  nonesuch: You tried to modify a nonexistent attribute.


=== Changing object relationships ===

In addition to changing an object's data fields, you can change its
relationships to other objects. Here we change the owner of the
'admins' team from 'sabdfl' to 'salgado'.

  >>> admins = webservice.get('/~admins').jsonBody()
  >>> admins['team_owner_link']
  u'http://.../~sabdfl'
  >>> admins['team_owner_link'] = webservice.getAbsoluteUrl('/~salgado')
  >>> print modify_person('admins', admins, 'PUT')
  HTTP/1.1 209 Content Returned
  ...

Identification of the owner is done by specifying a URL; a random
string won't work.

  >>> admins['team_owner_link'] = u'A random string'
  >>> print modify_person('admins', admins, 'PUT')
  HTTP/1.1 400 Bad Request
  ...
  team_owner_link: No such object "A random string".

But not just any URL will do. It has to identify an object in the web
service.

  >>> admins['team_owner_link'] = u'http://www.canonical.com/'
  >>> print modify_person('admins', admins, 'PUT')
  HTTP/1.1 400 Bad Request
  ...
  team_owner_link: No such object "http://www.canonical.com/".

  >>> admins['team_owner_link'] = u'http://www.canonical.com/beta/~admins'
  >>> print modify_person('admins', admins, 'PUT')
  HTTP/1.1 400 Bad Request
  ...
  team_owner_link: No such object "http://www.canonical.com/beta/~admins".

This URL would be valid, but it uses the wrong protocol (HTTPS instead
of HTTP).

  >>> admins['team_owner_link'] = u'https://.../~admins'
  >>> print modify_person('admins', admins, 'PUT')
  HTTP/1.1 400 Bad Request
  ...
  team_owner_link: No such object "https://.../~admins".

Even a URL that identifies an object in the web service won't work, if
the object isn't the right kind of object. A bug can't own a team:

  >>> admins['team_owner_link'] = webservice.getAbsoluteUrl('/bugs/1')
  >>> print modify_person('admins', admins, 'PUT')
  HTTP/1.1 400 Bad Request
  ...
  team_owner_link: Expected a person.

And a bug can't be a duplicate of a person:

  >>> representation = { 'duplicate_of_link' :
  ...                    webservice.getAbsoluteUrl('/~sabdfl') }
  >>> print webservice.patch('/bugs/1', 'application/json',
  ...                        simplejson.dumps(representation))
  HTTP/1.1 400 Bad Request
  ...
  duplicate_of_link: Your value points to the wrong kind of object

And even if the URL identifies the right kind of object, it might
violate some other constraint. For instance, a team can't be its own
owner.

  >>> admins['team_owner_link'] = webservice.getAbsoluteUrl('/~admins')
  >>> print modify_person('admins', admins, 'PUT')
  HTTP/1.1 400 Bad Request
  ...
  team_owner_link: Constraint not satisfied.


=== Date formats ===

Launchpad's web service serves and parses dates in ISO 8601
format. Only UTC dates are allowed.

The tests that follow make a number of PATCH requests that include
values for a person's 'date_created' attribute.

  >>> salgado['date_created']
  u'2005-06-06T08:59:51.596025+00:00'

  >>> def patch_salgado_date_created(date):
  ...     "A helper method to try and change a date field."
  ...     return modify_person('salgado', {'date_created' : date}, 'PATCH')

These requests aren't actually trying to modify 'date_created', which
is read-only. They're asserting that 'date_created' is a certain
value. If the assertion succeeds (because 'date_created' does in fact
have that value), the response code is 200. If the assertion could not
be understood (because the date is in the wrong format), the response
code is 400, and the body is an error message about the date
format. If the assertion _fails_ (because 'date_created' happens to be
read-only), the response code is also 400, but the error message talks
about an attempt to modify a read-only attribute.

The two 400 error codes below are caused by a failure to understand
the assertion. The string used in the assertion might not be a date.

  >>> print patch_salgado_date_created('dummy')
  HTTP/1.1 400 Bad Request
  ...
  date_created: Value doesn't look like a date.

Or it might be a date that's not in UTC.

  >>> print patch_salgado_date_created(u'2005-06-06T13:59:51.596025+05:00')
  HTTP/1.1 400 Bad Request
  ...
  date_created: Time not in UTC.

There are five ways to specify UTC:

  >>> print patch_salgado_date_created(u'2005-06-06T08:59:51.596025Z')
  HTTP/1.1 209 Content Returned
  ...

  >>> print patch_salgado_date_created(u'2005-06-06T08:59:51.596025+00:00')
  HTTP/1.1 209 Content Returned
  ...

  >>> print patch_salgado_date_created(u'2005-06-06T08:59:51.596025+0000')
  HTTP/1.1 209 Content Returned
  ...

  >>> print patch_salgado_date_created(u'2005-06-06T08:59:51.596025-00:00')
  HTTP/1.1 209 Content Returned
  ...

  >>> print patch_salgado_date_created(u'2005-06-06T08:59:51.596025-0000')
  HTTP/1.1 209 Content Returned
  ...

A value with a missing timezone is treated as UTC.

  >>> print patch_salgado_date_created(u'2005-06-06T08:59:51.596025')
  HTTP/1.1 209 Content Returned
  ...

