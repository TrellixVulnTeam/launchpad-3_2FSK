= The Queue Builder =

QueueBuilder is a script to sanely initialize new build jobs. It
verifies each DistroArchSeries that is available for which we are
able to:

 * Build packages,
 * Repair broken Build entries, if it makes sense to do so,
 * Verify the packages pending to build,
 * Install the jobs in the BuildQueue table, and
 * Score the build according to a set of parameters, which will be
   discussed later.


== Setting up ==

    >>> import tempfile, os, operator
    >>> from canonical.buildmaster.master import (
    ...   BuilddMaster, determineArchitecturesToBuild)

Import the bunch of required database classes:

    >>> from canonical.launchpad.database import (
    ...      Build, BuildQueue, DistroArchSeries, DistroSeries,
    ...      PocketChroot, SecureSourcePackagePublishingHistory)

    >>> from canonical.launchpad.interfaces import (
    ...      PackagePublishingPocket, PackagePublishingStatus)

The Master side of Buildd requires access to Launchpad Database, the
user designed for this kind of access is 'fiera', see
test_system_documentation.py for more information.

    >>> import logging
    >>> logger = logging.getLogger()

Now that we have satisfied all of the needs for BuildMaster, let's
instantiate it.

If I pass the current 'transaction' to BuilddMaster it will call
commit() on it for it build created. It apparently mess with the
transaction manager is a way that the builds created in the sampledata
catch-up (line 103) do not persist for the test build creation (line
469). This issue results in new build records exactly for the same
souces and locations but with higher IDs.

    >>> class FakeZtm:
    ...     def commit(self):
    ...         flush_database_updates()

    >>> build_master = BuilddMaster(logger, FakeZtm())

Emulate a PocketChroot entry to validate the following
distroarchseries:

 * Ubuntu/Warty/i386/RELEASE
 * Ubuntu/Hoary/i386/RELEASE
 * Debian/Woody/i386/RELEASE

    >>> warty = DistroSeries.selectOneBy(name="warty")
    >>> unused = PocketChroot(distroarchseries=warty['i386'], chroot=1)

    >>> hoary = DistroSeries.selectOneBy(name='hoary')
    >>> unsused = PocketChroot(distroarchseries=hoary['i386'], chroot=1)
    >>> unused = PocketChroot(distroarchseries=hoary['hppa'], chroot=2)

    >>> ubuntu = hoary.distribution
    >>> breezy_autotest = ubuntu.getSeries('breezy-autotest')
    >>> breezy_autotest_i386 = breezy_autotest['i386']
    >>> unused = PocketChroot(
    ...     distroarchseries=breezy_autotest_i386, chroot=3)

    >>> woody = DistroSeries.selectOneBy(name='woody')
    >>> unused = PocketChroot(distroarchseries=woody['i386'], chroot=4)

Produce a set of available DistroArchSeries, for which the
build jobs will be created.

    >>> distroserieses = set()

    >>> for archseries in DistroArchSeries.select():
    ...     distroserieses.add(archseries.distroseries)
    ...     build_master.addDistroArchSeries(archseries)

    >>> distroserieses = sorted(
    ...     distroserieses, key=operator.attrgetter('name'))

Among all the available distroarchseries only the one with chroot will
be considered.

    >>> valid_archs = sorted(build_master._archserieses.keys(),
    ...                      key=operator.attrgetter('id'))
    >>> for arch in valid_archs:
    ...     print arch.title
    The Warty Warthog Release for i386 (x86)
    The Hoary Hedgehog Release for i386 (x86)
    WOODY for i386 (x86)
    Breezy Badger Autotest for i386 (x86)
    The Hoary Hedgehog Release for hppa (hppa)


== Ensure sampledata is processed ==

Kick off any pending builds we have to avoid any misleading result in
our tests (there are a couple that will be created based on our
sampledata).

This is to allow us to study carefully what is being added as we add
new series and builds.

    >>> for series in distroserieses:
    ...      build_master.createMissingBuilds(series)

Add the missing build queue entries.

    >>> build_master.addMissingBuildQueueEntries()

Store current status of the database:

    >>> old_build_ids = [build.id for build in Build.select()]
    >>> old_job_ids = [build_queue.id for build_queue in BuildQueue.select()]


== Create some series and publications ==

We will create a group of source publications that represent the
exact circumstances we want to test below.

    >>> from canonical.launchpad.interfaces import IPersonSet
    >>> cprov = getUtility(IPersonSet).getByName('cprov')

    >>> from canonical.database.sqlbase import commit
    >>> from canonical.launchpad.tests.test_publishing import (
    ...     SoyuzTestPublisher)
    >>> from canonical.testing.layers import LaunchpadZopelessLayer

    >>> commit()
    >>> LaunchpadZopelessLayer.switchDbUser('launchpad')

Let's use SoyuzTestPublisher to create a set of publications in the
exact state to expose the features that we want to test.

    >>> test_publisher = SoyuzTestPublisher()
    >>> test_publisher.prepareBreezyAutotest()

Publishing a source in debian/woody won't result in a new build
because this distroseries lacks 'nominatedarchindep'.

    >>> pub_woody = test_publisher.getPubSource(
    ...     sourcename='test-buildd-5', version='671', distroseries=woody,
    ...     architecturehintlist="hppa",
    ...     status=PackagePublishingStatus.PUBLISHED,
    ...     pocket=PackagePublishingPocket.RELEASE)

Several source publications for ubuntu/hoary/RELEASE, which is in
DEVELOPMENT state, so we expect builds to be created respecting
architecturehintlist and PAS restrictions. See details about the PAS
system below.

    >>> pub_all = test_publisher.getPubSource(
    ...     sourcename='test-buildd', version='667', distroseries=hoary,
    ...     status=PackagePublishingStatus.PUBLISHED,
    ...     pocket=PackagePublishingPocket.RELEASE)

    >>> pub_any = test_publisher.getPubSource(
    ...     sourcename='test-buildd-2', version='668', distroseries=hoary,
    ...     architecturehintlist="any",
    ...     status=PackagePublishingStatus.PUBLISHED,
    ...     pocket=PackagePublishingPocket.RELEASE)

    >>> pub_three = test_publisher.getPubSource(
    ...     sourcename='test-buildd-3', version='669', distroseries=hoary,
    ...     architecturehintlist="i386 hppa amd64",
    ...     status=PackagePublishingStatus.PUBLISHED,
    ...     pocket=PackagePublishingPocket.RELEASE)

    >>> pub_one = test_publisher.getPubSource(
    ...     sourcename='test-buildd-4', version='670', distroseries=hoary,
    ...     architecturehintlist="hppa",
    ...     status=PackagePublishingStatus.PUBLISHED,
    ...     pocket=PackagePublishingPocket.RELEASE)

The two publishing sources that are created in this block are only used
in the 'Check support for kernel notation in architecture hint list'
section.

    >>> pub_any_foo = test_publisher.getPubSource(
    ...     sourcename='test-buildd-6', version='672', distroseries=hoary,
    ...     architecturehintlist="any-hppa",
    ...     status=PackagePublishingStatus.PUBLISHED,
    ...     pocket=PackagePublishingPocket.RELEASE)

    >>> pub_linux_foo = test_publisher.getPubSource(
    ...     sourcename='test-buildd-7', version='673', distroseries=hoary,
    ...     architecturehintlist="linux-i386",
    ...     status=PackagePublishingStatus.PUBLISHED,
    ...     pocket=PackagePublishingPocket.RELEASE)

Publishing a source in warty/UPDATES, a stable release update (SRU),
will result in a build. Once a distroseries is released, only
source publications to post-RELEASE pockets (UPDATES, PROPOSED,
BACKPORTS, SECURITY) will be considered, preserving the RELEASE pocket
as it was at the release time.

    >>> pub_updates = test_publisher.getPubSource(
    ...     sourcename='test-updates', version='665', distroseries=warty,
    ...     status=PackagePublishingStatus.PUBLISHED,
    ...     pocket=PackagePublishingPocket.UPDATES)

A source published in warty/RELEASE will be ignored, i.e., it won't
result in a new build record because we cannot modify the RELEASE
pocket.

    >>> pub_ignored = test_publisher.getPubSource(
    ...     sourcename='test-buildd-not', version='666', distroseries=warty,
    ...     status=PackagePublishingStatus.PUBLISHED,
    ...     pocket=PackagePublishingPocket.RELEASE)

If we publish the same source in warty and hoary, and create a
corresponding build record that has failed to build in this context,
we see that the queue-builder triggers a rebuild in the new context
for published sources that have failed to build in previous
distroseries (see bug 181328).

    >>> pub_failed = test_publisher.getPubSource(
    ...     sourcename='test-failed', version='1.0', distroseries=warty,
    ...     status=PackagePublishingStatus.PUBLISHED,
    ...     pocket=PackagePublishingPocket.RELEASE)

    >>> copied_pub = pub_failed.copyTo(
    ...     hoary, PackagePublishingPocket.RELEASE, warty.main_archive)

    >>> from canonical.launchpad.interfaces import BuildStatus
    >>> failed_build = pub_failed.sourcepackagerelease.createBuild(
    ...     warty['i386'], PackagePublishingPocket.RELEASE,
    ...     warty.main_archive, status=BuildStatus.FAILEDTOBUILD)

In contrast with the previous case, if we publish the same source in
warty and hoary, and attach a successfully built build record in the
warty context we will see that the queue-builder won't create a new
build in the hoary context.

    >>> pub_success = test_publisher.getPubSource(
    ...     sourcename='test-success', version='1.0', distroseries=warty,
    ...     status=PackagePublishingStatus.PUBLISHED,
    ...     pocket=PackagePublishingPocket.RELEASE)

    >>> copied_pub = pub_success.copyTo(
    ...     hoary, PackagePublishingPocket.RELEASE, warty.main_archive)

    >>> ok_build = pub_success.sourcepackagerelease.createBuild(
    ...     warty['i386'], PackagePublishingPocket.RELEASE,
    ...     warty.main_archive, status=BuildStatus.FULLYBUILT)

If a source is published in Celso's PPA, a build will be created
for it respecting only 'architecturehintlist' and PPA-supported
architecture, it won't be submitted to P-a-s restrictions. It allows
PPA user to work on 'broken' ports of a given source, without
depending on lifting the PRIMARY archive PAS restrictions.

    >>> pub_hoary_ppa = test_publisher.getPubSource(
    ...     sourcename='test-ppa', version='674', distroseries=hoary,
    ...     architecturehintlist="i386 hppa", archive=cprov.archive,
    ...     status=PackagePublishingStatus.PUBLISHED,
    ...     pocket=PackagePublishingPocket.RELEASE)

We will remove the virtualization support from
ubuntu/breezy-autotest/i386, so we can verify that when a distroseries
exists but does not support any PPA archictecture the source
publications in PPA context are ignored; they don't result in any
build nor a misleading error in determineArchitectureToBuild.

    >>> from canonical.launchpad.ftests import syncUpdate
    >>> breezy_autotest_i386.supports_virtualized = False
    >>> syncUpdate(breezy_autotest_i386)

    >>> pub_breezy_autotest_ppa = test_publisher.getPubSource(
    ...     sourcename='test-no-ppa-support', version='999',
    ...     distroseries=breezy_autotest, archive=cprov.archive,
    ...     status=PackagePublishingStatus.PUBLISHED,
    ...     pocket=PackagePublishingPocket.RELEASE)

Before committing the previous changes, we have to annotated the
manually created build IDs so they can be excluded from subsequents
checks/counters within this test.

    >>> old_build_ids.append(failed_build.id)
    >>> old_build_ids.append(ok_build.id)

    >>> commit()
    >>> LaunchpadZopelessLayer.switchDbUser(test_dbuser)


== Package Architecture Specific ==

The Package-Architecture-Specific (PAS) module is a parser to a set
of restrictions to build packages based on archive-admin experiences.

Those restrictions overlap the metadata information from the source
packages (architecturehintlist).


=== Source PAS ===

    >>> from canonical.buildmaster.pas import BuildDaemonPackagesArchSpecific

Write a harness that lets us easily test PAS statements:

    >>> def getPASVerifier(pas_string, series=hoary):
    ...   """Build and return a PAS verifier based on the string provided."""
    ...   temp_dir = tempfile.mkdtemp()
    ...   pas_filename = os.path.join(temp_dir, "Packages-arch-specific")
    ...   pas_file = file(pas_filename, "w")
    ...   pas_file.write(pas_string)
    ...   pas_file.close()
    ...   pas_verify = BuildDaemonPackagesArchSpecific(temp_dir, series)
    ...   os.unlink(pas_filename)
    ...   return pas_verify

    >>> legal_archs = set(hoary.architectures)

First check a positive source listing:

    >>> pas_verify = getPASVerifier("%test-buildd-3: i386")
    >>> [arch.architecturetag for arch in
    ...  determineArchitecturesToBuild(pub_three, legal_archs, hoary,
    ...                                pas_verify)]
    [u'i386']

And now a negative source listing:

    >>> pas_verify = getPASVerifier("%test-buildd-3: !i386")
    >>> [arch.architecturetag for arch in
    ...  determineArchitecturesToBuild(pub_three, legal_archs, hoary,
    ...                                pas_verify)]
    [u'hppa']

And a source listing which causes us to produce no builds:

    >>> pas_verify = getPASVerifier("%test-buildd-3: sparc")
    >>> [arch.architecturetag for arch in
    ...  determineArchitecturesToBuild(pub_three, legal_archs, hoary,
    ...                                pas_verify)]
    []

PPA builds are not affected by PAS restrictions, i.e., they will
build for all requested architectures currently supported in the PPA
subsystem.

    >>> pas_verify = getPASVerifier("%test-ppa: hppa")
    >>> [arch.architecturetag for arch in
    ...  determineArchitecturesToBuild(pub_hoary_ppa, legal_archs,
    ...                                hoary, pas_verify)]
    [u'i386']

    >>> pas_verify = getPASVerifier("%test-ppa: !i386")
    >>> [arch.architecturetag for arch in
    ...  determineArchitecturesToBuild(pub_hoary_ppa, legal_archs,
    ...                                hoary, pas_verify)]
    [u'i386']


== Binary PAS ==

To check binary PAS listings we'll use a source publication for
iceweasel which produces mozilla-firefox binaries in warty and already
has its data set up.

    >>> firefox_pub = SecureSourcePackagePublishingHistory.get(28)
    >>> print firefox_pub.sourcepackagerelease.title
    iceweasel - 1.0
    >>> print firefox_pub.sourcepackagerelease.architecturehintlist
    any
    >>> iceweasel_binaries = warty.getSourcePackage(
    ...     'iceweasel')['1.0'].binaries
    >>> [binary.title for binary in iceweasel_binaries]
    [u'mozilla-firefox-1.0']

    >>> legal_archs = set(warty.architectures)
    >>> sorted([arch.architecturetag
    ...         for arch in legal_archs], reverse=True)
    [u'i386', u'hppa']

Restrict iceweasel targets to i386 and sparc, since the latter is not
present in warty, we will only create a build for i386:

    >>> pas_verify = getPASVerifier(
    ...     "mozilla-firefox: i386 sparc", series=warty)
    >>> permitted_archs = determineArchitecturesToBuild(
    ...      firefox_pub, legal_archs, warty, pas_verify)
    >>> [arch.architecturetag for arch in permitted_archs]
    [u'i386']

And a binary PAS listing that tries to exclude i386 and hppa from an
arch-any build. The exclusion of i386 is ignored; see comment in
pas.py:_handleBinaryPAS for more information on why.

    >>> pas_verify = getPASVerifier(
    ...     "mozilla-firefox: !i386 !hppa", series=warty)
    >>> permitted_archs = determineArchitecturesToBuild(
    ...      firefox_pub, legal_archs, warty, pas_verify)
    >>> [arch.architecturetag for arch in permitted_archs]
    [u'i386']

XXX cprov 20071211: we can't properly test PPA binary-PAS right now
because there is no binary package published in PPA. The way the PAS
component is completely ignored for PPAs indicates that we are safe,
however, for now, we have to rely on the previous primary-archive tests.
See bug 189025.


== Check the architectures ==

See if the code which determines archs to build does the right thing for
each of these options:

    >>> legal_archs = set(hoary.architectures)
    >>> [arch.architecturetag for arch in
    ...  determineArchitecturesToBuild(pub_all, legal_archs, hoary)]
    [u'i386']
    >>> [arch.architecturetag for arch in
    ...  determineArchitecturesToBuild(pub_any, legal_archs, hoary)]
    [u'hppa', u'i386']
    >>> [arch.architecturetag for arch in
    ...  determineArchitecturesToBuild(pub_three, legal_archs, hoary)]
    [u'hppa', u'i386']
    >>> [arch.architecturetag for arch in
    ...  determineArchitecturesToBuild(pub_one, legal_archs, hoary)]
    [u'hppa']


== Check support for kernel notation in architecture hint list ==

dpkg supports the use of the '<kernel-><arch>' notation in the
'Architecture' field, where 'kernel-' is one of the kernel platform
available in debian systems: ['linux-', 'kfreebsd', 'hurd-', 'any-']

See bug 73761 and http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=268709
for further information about this dpkg feature.

Soyuz will consider only 'any-' and 'linux-' elements as the
corresponding architecture, since only linux is supported in ubuntu.

    >>> [arch.architecturetag for arch in
    ...  determineArchitecturesToBuild(pub_any_foo, legal_archs, hoary)]
    [u'hppa']
    >>> [arch.architecturetag for arch in
    ...  determineArchitecturesToBuild(pub_linux_foo, legal_archs, hoary)]
    [u'i386']


== PPA architectures ==

For virtualized archives only architectures with established support for
PPA will be considered when creating PPA builds. See distroarchseries.txt
for further information.

    >>> legal_archs = set(hoary.architectures)
    >>> sorted([arch.architecturetag for arch in legal_archs])
    [u'hppa', u'i386']

    >>> [arch.architecturetag for arch in
    ...  determineArchitecturesToBuild(pub_hoary_ppa, legal_archs, hoary)]
    [u'i386']

Conversely, for non-virtual archives, build records are created for all
architectures supported for the distroseries.

    >>> commit()
    >>> LaunchpadZopelessLayer.switchDbUser("launchpad")

    >>> pub_hoary_ppa.archive.require_virtualized = False
    >>> sorted([arch.architecturetag for arch in
    ...  determineArchitecturesToBuild(pub_hoary_ppa, legal_archs, hoary)])
    [u'hppa', u'i386']

Reset the virtualization flag.

    >>> pub_hoary_ppa.archive.require_virtualized = True

    >>> commit()
    >>> LaunchpadZopelessLayer.switchDbUser(test_dbuser)


== Create and verify the new builds ==

Create missing builds (packages w/o build entry) for those distroserieses.

We expect to have a couple of new builds for the sane hoary/RELEASE,
one for warty/UPDATES and one for hoary/RELEASE/PPA.

    >>> for series in distroserieses:
    ...      build_master.createMissingBuilds(series)

Check that we only created new Build entries for the new hoary releases:

    >>> new_builds = [build for build in Build.select()
    ...               if build.id not in old_build_ids]
    >>> for build in sorted(new_builds, key=operator.attrgetter('id')):
    ...   print build.title
    i386 build of test-buildd 667 in ubuntu hoary RELEASE
    hppa build of test-buildd-2 668 in ubuntu hoary RELEASE
    i386 build of test-buildd-2 668 in ubuntu hoary RELEASE
    hppa build of test-buildd-3 669 in ubuntu hoary RELEASE
    i386 build of test-buildd-3 669 in ubuntu hoary RELEASE
    hppa build of test-buildd-4 670 in ubuntu hoary RELEASE
    hppa build of test-buildd-6 672 in ubuntu hoary RELEASE
    i386 build of test-buildd-7 673 in ubuntu hoary RELEASE
    i386 build of test-failed 1.0 in ubuntu hoary RELEASE
    i386 build of test-ppa 674 in ubuntu hoary RELEASE
    i386 build of test-updates 665 in ubuntu warty UPDATES

And have a look at our architecture-independent-source's build:

    >>> arch_indep_build = Build.selectOneBy(
    ...     sourcepackagerelease=pub_all.sourcepackagerelease)

    >>> print arch_indep_build.title
    i386 build of test-buildd 667 in ubuntu hoary RELEASE


== Create and verify the new queue entries ==

BuildQueue records corresponding to the build records in NEEDSBUILD
state are immediately created.

    >>> active_jobs = [
    ...     build_queue for build_queue in BuildQueue.select(orderBy='id')
    ...     if build_queue.id not in old_job_ids]
    >>> len(active_jobs)
    11

The BuildQueue entries created are already 'scored', meaning the job
can be dispatched once operation is committed, i.e. dispatching can
happen in parallel with build creation.

    >>> build_queue = active_jobs[0]
    >>> print build_queue.build.title
    i386 build of test-buildd 667 in ubuntu hoary RELEASE
    >>> build_queue.lastscore
    1005

Check the published component name retriever, they might be different,
i.e., the published component can be different than the original component.

    >>> print build_queue.build.current_component.name
    main
    >>> print build_queue.build.sourcepackagerelease.component.name
    main

Missing BuildQueue records, resulting from given-back builds, are
created in the last stage of the queue-builder script.

    >>> given_back_build = build_queue.build
    >>> build_queue.destroySelf()
    >>> flush_database_updates()

    >>> print given_back_build.buildqueue_record
    None

    >>> build_master.addMissingBuildQueueEntries()

    >>> given_back_build.buildqueue_record is not None
    True
