=========================
Testing TALES expressions
=========================

Set up a 'test_tales(expression, **context)' function for testing various
TALES features.

    >>> from zope.app.pagetemplate.engine import Engine
    >>> class Context:
    ...     def __init__(self, **kw):
    ...         self.vars = kw
    ...
    >>> def test_tales(expression, **kw):
    ...     compiled_tales = Engine.compile(expression)
    ...     return compiled_tales(Context(**kw))
    ...


Test the 'count:' namespace.

count:len gives you a number which is len(thing).

    >>> test_tales('foo/count:len', foo=[])
    0
    >>> test_tales('foo/count:len', foo=[1, 2, 3])
    3
    >>> test_tales('foo/count:len', foo=object())
    Traceback (most recent call last):
    ...
    TypeError: len() of unsized object


Test the 'fmt:' namespace where the context is a datetime.

   >>> from datetime import datetime, timedelta
   >>> dt = datetime(2005, 4, 1, 16, 22)
   >>> test_tales('dt/fmt:date', dt=dt)
   '2005-04-01'
   >>> test_tales('dt/fmt:time', dt=dt)
   '16:22:00'
   >>> test_tales('dt/fmt:datetime', dt=dt)
   '2005-04-01 16:22:00'

Test 'fmt:exactduration' where the context is a timedelta.

   >>> td = timedelta(days=1, hours=2, minutes=3, seconds=4.567)
   >>> test_tales('td/fmt:exactduration', td=td)
   '1 day, 2 hours, 3 minutes, 4.6 seconds'
   >>> td = timedelta(days=1, minutes=3, seconds=4.567)
   >>> test_tales('td/fmt:exactduration', td=td)
   '1 day, 0 hours, 3 minutes, 4.6 seconds'
   >>> td = timedelta(minutes=3, seconds=4.567)
   >>> test_tales('td/fmt:exactduration', td=td)
   '3 minutes, 4.6 seconds'

Test plural and singular values in fmt:exactduration output.

   >>> td = timedelta(days=1, hours=1, minutes=1, seconds=1)
   >>> test_tales('td/fmt:exactduration', td=td)
   '1 day, 1 hour, 1 minute, 1.0 seconds'
   >>> td = timedelta(days=2, hours=2, minutes=2, seconds=2)
   >>> test_tales('td/fmt:exactduration', td=td)
   '2 days, 2 hours, 2 minutes, 2.0 seconds'


Test the 'lp:' namespace for presenting DBSchema classes.

    >>> from canonical.lp.dbschema import BinaryPackageFormat
    >>> deb = BinaryPackageFormat.DEB.value
    >>> test_tales('deb/lp:BinaryPackageFormat', deb=deb)
    'Ubuntu Package'


Test the 'fmt:' namespace where the context is a string.

    >>> test_tales('foo/fmt:shorten/8', foo='abcdefghij')
    'abcde...'

    >>> test_tales('foo/fmt:nl_to_br',
    ...             foo='icicle\nbicycle\ntricycle & troika')
    'icicle<br />\nbicycle<br />\ntricycle &amp; troika'

    >>> import pprint, textwrap
    >>> pprint.pprint(textwrap.wrap(
    ...     test_tales('foo/fmt:nice_pre', foo='hello & goodbye')
    ... ))
    ['<pre style="white-space: -moz-pre-wrap;white-space: -o-pre-wrap;word-',
     'wrap: break-word;">hello &amp; goodbye</pre>']

    >>> text = ('This is a paragraph.\n'
    ...         '\n'
    ...         'This is another paragraph.')
    >>> test_tales('foo/fmt:text-to-html', foo=text)
    '<p>This is a paragraph.</p>\n<p>This is another paragraph.</p>'

    >>> text = ('This is a line.\n'
    ...         'This is another line.')
    >>> test_tales('foo/fmt:text-to-html', foo=text)
    '<div>This is a line.</div>\n<div>This is another line.</div>'

    >>> text = (
    ...     'This is a paragraph that has been hard-wrapped by an e-mail'
    ...     ' application.\n'
    ...     'When copied and pasted into Launchpad, it should nevertheless'
    ...     ' still display\n'
    ...     'as a single paragraph. This helps these people:\n'
    ...     '* Fabio\n'
    ...     '* Asa'
    ...     )
    >>> print test_tales('foo/fmt:text-to-html', foo=text)
    <p>This is a paragraph that has been hard-wrapped by an e-mail application. When copied and pasted into Launchpad, it should nevertheless still display as a single paragraph. This helps these people:</p>
    <div>* Fabio</div>
    <div>* Asa</div>

    >>> text = (
    ...     " 1. And here's an opposite example\n"
    ...     ' 2. where a list is followed by a paragraph.\n'
    ...     '   Leading spaces in a line or paragraph are '
    ...     'presented, which means converting\n'
    ...     'them to &nbsp;. Trailing spaces are passed through '
    ...     'as-is, which means\n'
    ...     "browsers will ignore them, but that's fine, "
    ...     "they're not important anyway.\n"
    ...     '\n'
    ...     '   That last line was between 60 and 80 characters '
    ...     'long, but it was still treated as a paragraph '
    ...     'because it was followed by two newlines.'
    ...     )
    >>> print test_tales('foo/fmt:text-to-html', foo=text)
    <div>&nbsp;1. And here's an opposite example</div>
    <div>&nbsp;2. where a list is followed by a paragraph.</div>
    <p>&nbsp;&nbsp;&nbsp;Leading spaces in a line or paragraph are presented, which means converting them to &amp;nbsp;. Trailing spaces are passed through as-is, which means browsers will ignore them, but that's fine, they're not important anyway.</p>
    <p>&nbsp;&nbsp;&nbsp;That last line was between 60 and 80 characters long, but it was still treated as a paragraph because it was followed by two newlines.</p>

    >>> text = (
    ...     'This is a little paragraph all by itself. How cute!'
    ...     )
    >>> test_tales('foo/fmt:text-to-html', foo=text)
    '<p>This is a little paragraph all by itself. How cute!</p>'

The first line in the example below is 61 characters long, excluding the
newline.

    >>> text = (
    ...     'Here are two paragraphs with lots of whitespace between them.\n'
    ...     '\n'
    ...     '\n'
    ...     '\n'
    ...     '\n'
    ...     'But they\'re still just two paragraphs.')
    >>> print test_tales('foo/fmt:text-to-html', foo=text)
    <p>Here are two paragraphs with lots of whitespace between them.</p>
    <p>But they're still just two paragraphs.</p>


The _substitute_matchgroup_for_spaces() static method is part of the
fmt:text-to-html code.  It is a helper for writing regular expressions where
we want to replace a variable number of spaces with the same number of
&nbsp; entities.

    >>> from canonical.launchpad.webapp.tales import FormattersAPI
    >>> import re
    >>> matchobj = re.match('foo(.*)bar', 'fooX Ybar')
    >>> matchobj.groups()
    ('X Y',)
    >>> FormattersAPI._substitute_matchgroup_for_spaces(matchobj)
    '&nbsp;&nbsp;&nbsp;'


Test the 'fmt:' namespace where the context is a dict.

fmt:pagetitle takes a page template CONTEXTS dict, and gives you a string
for use in the <title> element of a page.

This case ought to apply only to a page template's CONTEXTS dict.  However, we
have to make this namespace available for all dicts, as there is no type
information to distinguish a page template CONTEXTS dict from any other dict.

    >>> class MockPageTemplateFile:
    ...     filename = '/blah/blah/debug-root-index.pt'
    ...
    >>> CONTEXTS = {'template': MockPageTemplateFile}
    >>> test_tales('foo/fmt:pagetitle', foo=CONTEXTS)
    'Launchpad Debug Home Page'


Test the 'fmt:url' namespace for canonical urls.

    >>> from canonical.launchpad.interfaces import ICanonicalUrlData
    >>> from zope.interface import implements
    >>> class ObjectThatHasUrl:
    ...     implements(ICanonicalUrlData)
    ...     path = 'bonobo/saki'
    ...     inside = None

    >>> object_having_url = ObjectThatHasUrl()
    >>> test_tales('foo/fmt:url', foo=object_having_url)
    'http://localhost:8086/bonobo/saki'

Now, we need to test that it gets the correct application URL from the
request.

Make a mock-up IBrowserRequest, and use this as the interaction.

    >>> from zope.publisher.interfaces.browser import \
    ...     IBrowserApplicationRequest
    >>> from zope.interface import implements
    >>> class MockBrowserRequest:
    ...     implements(IBrowserApplicationRequest)
    ...
    ...     interaction = None
    ...     principal = None
    ...
    ...     def getApplicationURL(self):
    ...         return 'https://mandrill.example.org:23'

    >>> participation = MockBrowserRequest()

    >>> login(ANONYMOUS, participation)

    >>> test_tales('foo/fmt:url', foo=object_having_url)
    'https://mandrill.example.org:23/bonobo/saki'


Test the 'fmt:' namespace where the context is None. In general, these
will return an empty string.  They are provided for ease of handling
NULL values from the database, which become None values for attributes
in content classes.

Everything you can do with 'something/fmt:foo', you should be able to
do with 'None/fmt:foo'.

    >>> test_tales('foo/fmt:shorten', foo=None)
    Traceback (most recent call last):
    ...
    TraversalError: 'you need to traverse a number after fmt:shorten'

    >>> test_tales('foo/fmt:shorten/8', foo=None)
    ''
    >>> test_tales('foo/fmt:nl_to_br', foo=None)
    ''
    >>> test_tales('foo/fmt:nice_pre', foo=None)
    ''
    >>> test_tales('foo/fmt:breadcrumbs', foo=None)
    ''
    >>> test_tales('foo/fmt:date', foo=None)
    ''
    >>> test_tales('foo/fmt:time', foo=None)
    ''
    >>> test_tales('foo/fmt:datetime', foo=None)
    ''
    >>> test_tales('foo/fmt:pagetitle', foo=None)
    ''
    >>> test_tales('foo/fmt:text-to-html', foo=None)
    ''
    >>> test_tales('foo/fmt:url', foo=None)
    ''
    >>> test_tales('foo/fmt:exactduration', foo=None)
    ''


Test the 'required:' namespace.  We're already logged in as the anonymous user,
and anonymous users can't edit any person:

    >>> from canonical.launchpad.interfaces import IPersonSet
    >>> person = getUtility(IPersonSet).getByName('sabdfl')
    >>> test_tales('person/required:launchpad.Edit', person=person)
    False

Anonymous users can do anything with the zope.Public permission.

    >>> test_tales('person/required:zope.Public', person=person)
    True

Queries about permissions that don't exist will raise an exception:

    >>> test_tales('person/required:mushroom.Badger', person=person)
    Traceback (most recent call last):
    ...
    ValueError: ('Undefined permission id', 'mushroom.Badger')


