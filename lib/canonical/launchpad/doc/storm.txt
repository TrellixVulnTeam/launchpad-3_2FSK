In addition to what Storm provides, we also have some Launchpad
specific Storm tools to cope with our master and slave store arrangement.

    >>> from canonical.launchpad.interfaces import (
    ...     EmailAddressStatus, IAccountSet, IEmailAddressSet,
    ...     IMasterObject, IMasterStore, ISlaveStore, IStore)
    >>> from canonical.launchpad.database import (
    ...     Account, AccountPassword, EmailAddress)
    >>> from lp.registry.model.person import Person
    >>> from zope.security.proxy import ProxyFactory


You need to use the correct master Store to make changes to
a Launchpad database object. You can use adapters to
retrieve the correct Store.

    >>> auth_master = IMasterStore(Account)
    >>> main_master = IMasterStore(Person)
    >>> auth_master is main_master
    False


You can read most tables from any Store, which is required for doing
fast joins in the database. However, when it is not necessary to
retrieve objects from the same store as another object, it is better to
explicitly use the explicit Store for its replication set. Some tables
are only available from this store, such as the AccountPassword table.

    >>> auth_slave = ISlaveStore(AccountPassword)
    >>> main_slave = ISlaveStore(Person)
    >>> auth_slave is main_slave
    False


You can detect if a store is writable by checking what interfaces it
provides.

    >>> IMasterStore.providedBy(auth_master)
    True
    >>> ISlaveStore.providedBy(auth_master)
    False


Changes to the slave Stores will lag behind the master Stores. If
you only need to read an object but require it to be in sync with the
master, you should use the default Store. Launchpad will give you the
slave store if it is sure all your recent changes have been replicated.
Otherwise, it gives you the master. See IStoreSelector for details.

    >>> main_default = IStore(Person)
    >>> main_master = IMasterStore(Person)
    >>> main_slave = ISlaveStore(Person)
    >>> main_default is main_master
    True
    >>> main_default is main_slave
    False


You can also adapt database object instances to Stores, although
this is less generally useful.

    >>> janitor = ISlaveStore(Person).find(Person, name='janitor').one()
    >>> ISlaveStore(janitor) is ISlaveStore(Person)
    True
    >>> IMasterStore(janitor) is IMasterStore(Person)
    True
    >>> IMasterStore(janitor) is ISlaveStore(Person)
    False


If we need the master copy of an object, we can adapt it to IMasterObject.
Good defensive programming is to use this adapter if you want to make
changes to an object, just in case you have been passed an instance
from a store other than the correct Master.

    >>> auth_slave = ISlaveStore(Account)
    >>> t = transaction.begin()
    >>> account = auth_slave.find(
    ...     Account, openid_identifier='mark_oid').one()
    >>> account.displayname = 'Cannot change'
    >>> transaction.commit()
    Traceback (most recent call last):
    ...
    InternalError: transaction is read-only

    >>> transaction.abort()
    >>> t = transaction.begin()
    >>> account = auth_slave.find(
    ...     Account, openid_identifier='mark_oid').one()
    >>> IMasterObject(account).displayname = 'Can change'
    >>> transaction.commit()


If the adapted object was security proxied, the master copy is
similarly wrapped.

    >>> from zope.security.proxy import removeSecurityProxy
    >>> account = getUtility(IAccountSet).getByEmail('no-priv@canonical.com')
    >>> removeSecurityProxy(account) is account
    False
    >>> account.displayname
    u'No Privileges Person'
    >>> account.password
    Traceback (most recent call last):
    ...
    Unauthorized: ...

    >>> account = IMasterObject(account)
    >>> removeSecurityProxy(account) is account
    False
    >>> account.displayname
    u'No Privileges Person'
    >>> account.password
    Traceback (most recent call last):
    ...
    Unauthorized: ...

    >>> account = IMasterObject(removeSecurityProxy(account))
    >>> removeSecurityProxy(account) is account
    True
    >>> account.displayname
    u'No Privileges Person'
    >>> account.password
    u'...'

Our objects may compare equal even if they have come from different
stores.

    >>> auth_master_email = IMasterStore(EmailAddress).find(
    ...     EmailAddress, Person.name == 'janitor',
    ...     EmailAddress.person==Person.id).one()
    >>> auth_slave_email = ISlaveStore(EmailAddress).find(
    ...     EmailAddress, Person.name == 'janitor',
    ...     EmailAddress.person==Person.id).one()
    >>> auth_master_email is auth_slave_email
    False
    >>> auth_master_email == auth_slave_email
    True
    >>> auth_master_email != auth_slave_email
    False

Comparison works for security wrapped objects too.

    >>> wrapped_email = getUtility(IEmailAddressSet).getByEmail(
    ...     auth_master_email.email)
    >>> removeSecurityProxy(wrapped_email) is auth_master_email
    True
    >>> wrapped_email is auth_master_email
    False
    >>> wrapped_email == auth_master_email
    True
    >>> wrapped_email != auth_master_email
    False

Objects not yet flushed to the database also compare equal.

    >>> unflushed = EmailAddress(
    ...     email='notflushed@example.com', status=EmailAddressStatus.NEW,
    ...     personID=1)
    >>> unflushed == unflushed
    True
    >>> unflushed != unflushed
    False
    >>> wrapped_unflushed = ProxyFactory(unflushed)
    >>> wrapped_unflushed is unflushed
    False
    >>> wrapped_unflushed == unflushed
    True
    >>> wrapped_unflushed != unflushed
    False

Objects differing by class never compare equal.

    >>> account_one = IMasterStore(Account).get(Account, 1)
    >>> person_one = IMasterStore(Account).get(Person, 1)
    >>> account_one == person_one
    False
    >>> account_one != person_one
    True

