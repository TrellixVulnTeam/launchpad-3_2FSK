== SourcePackagePublishingHistory ==

This class provides public access to publishing records via a SQL view.

    >>> from canonical.launchpad.database import SourcePackagePublishingHistory
    >>> from canonical.launchpad.database import BinaryPackagePublishingHistory

Select a publishing record from the sampledata (pmount is a
interesting one):

    >>> spph = SourcePackagePublishingHistory.get(8)
    >>> spph.sourcepackagerelease.name, spph.distroseries.name
    (u'pmount', u'hoary')

Verify if the object follows its interface contracts:

    >>> from canonical.launchpad.webapp.testing import verifyObject
    >>> from canonical.launchpad.interfaces import (
    ...     ISourcePackageRelease, IDistroSeries,
    ...     ISourcePackagePublishingHistory,
    ...     ISourcePackage,
    ...     IDistributionSourcePackageRelease)

    >>> verifyObject(ISourcePackagePublishingHistory, spph)
    True

 XXX cprov 20060322: None of the attributes below pass verifyObject().
 So, they claim to implement some thing they don't really have. Most
 of the problems are related with bad interface inheritance.

    >>> IDistroSeries.providedBy(spph.distroseries)
    True

    >>> ISourcePackageRelease.providedBy(spph.sourcepackagerelease)
    True

    >>> ISourcePackageRelease.providedBy(spph.supersededby)
    True

    >>> IDistributionSourcePackageRelease.providedBy(
    ...     spph.meta_sourcepackagerelease)
    True

    >>> IDistributionSourcePackageRelease.providedBy(spph.meta_supersededby)
    True

    >>> ISourcePackage.providedBy(spph.meta_sourcepackage)
    True


== Stanza generation ==

    >>> from canonical.launchpad.interfaces import (
    ...     IArchiveSafePublisher, ISourcePackageFilePublishing,
    ...     ISecureSourcePackagePublishingHistory,
    ...     ISecureBinaryPackagePublishingHistory)

Retrieve any SourcePackagePublishingHistory entry.

    >>> spph = SourcePackagePublishingHistory.get(10)

    >>> verifyObject(ISourcePackagePublishingHistory, spph)
    True

    >>> print spph.displayname
    alsa-utils 1.0.8-1ubuntu1 in warty

A 'stanza' is the name given to a group of attributes related to one
source or binary package in the archive index file, it provides
information to APT, things like, package name, pool path, DSC format,
files checksum, etc.

The archive index should contain one entry for each source or binary
currently published in the archive, it is usually partionated by
component:

<mirror_url_base>/ubuntu/edgy/main/binary-i386/Packages
<mirror_url_base>/ubuntu/edgy/main/source/Sources

The archive index is also available in in compressed formats.

    >>> print spph.getIndexStanza() #doctest: -NORMALIZE_WHITESPACE
    Package: alsa-utils
    Binary: alsa-mixer
    Version: 1.0.8-1ubuntu1
    Section: base
    Maintainer: Mark Shuttleworth <sabdfl@hbd.com>
    Architecture: all
    Standards-Version: 3.6.2
    Format: 1.0
    Directory: pool/main/a/alsa-utils
    Files:
     01234567890123456789012345678925 3 alsa-utils_1.0.8-1ubuntu1.dsc

Empty fields like are suppressed, like 'Build-Depends' or
'Build-Depends-Indep' to avoid extra charge on download.
See sourcepackagerelease.txt for further information about the fields
in question.

Files published are accessible via the files property:

    >>> any_pub_file = spph.files[-1]
    >>> ISourcePackageFilePublishing.providedBy(any_pub_file)
    True

    >>> [(pub_file.libraryfilealias.filename, pub_file.file_type_name,
    ...   pub_file.archive_url) for pub_file in spph.files]
    [(u'alsa-utils_1.0.8-1ubuntu1.dsc', 'dsc',
      u'http://launchpad.dev/ubuntu/pool/main/a/alsa-utils/alsa-utils_1.0.8-1ubuntu1.dsc')]


== Deletion and obsolescence ==

ArchivePublisherBase, which is common to SourcePackagePublishingHistory
and BinaryPackagePublishingHistory, contains the methods requestDeletion
and requestObsolescence.  These will change the publishing record to
the states DELETED and OBSOLETE respectively.

requestDeletion requires a removed_by (IPerson) and optionally a
removal_comment argument.

    >>> from canonical.launchpad.interfaces import IPersonSet
    >>> from zope.component import getUtility
    >>> sabdfl = getUtility(IPersonSet).getByName('sabdfl')
    >>> modified_spph = spph.requestDeletion(sabdfl, "testing deletion")

Inspecting the modified record shows it's ready for domination:

    >>> from canonical.database.sqlbase import get_transaction_timestamp
    >>> transaction_timestamp = get_transaction_timestamp()

    >>> modified_spph.status
    <DBItem PackagePublishingStatus.DELETED, (4) Deleted>

    >>> modified_spph.datesuperseded == transaction_timestamp
    True

    >>> print modified_spph.removed_by.name
    sabdfl

    >>> print modified_spph.removal_comment
    testing deletion

requstObsolescence takes no additional arguments:

    >>> modified_spph = spph.requestObsolescence()

Inspecting the modified record shows it's ready for death row (obsoleted
publications skip domination because domination only works in post-release
pockets for stable distroseries):

    >>> modified_spph.status
    <DBItem PackagePublishingStatus.OBSOLETE, (5) Obsolete>

    >>> modified_spph.scheduleddeletiondate == transaction_timestamp
    True


== Copying and published binarypackages lookup ==

ISourcePackagePublishingHistory provides the getPublishedBinaries
which returns all published binaries build from a source in the pocket
it is published.

We will use SoyuzTestPublisher to generate coherent publications to
test this feature.

    >>> from canonical.launchpad.tests.test_publishing import (
    ...      SoyuzTestPublisher)
    >>> test_publisher = SoyuzTestPublisher()

    >>> from canonical.launchpad.ftests import login
    >>> login('foo.bar@canonical.com')

    >>> test_publisher.prepareBreezyAutotest()

We will create a publication for a source (foo) and two
architecture-independent binaries in ubuntu/breezy-autotest.

    >>> from canonical.launchpad.interfaces import (
    ...     PackagePublishingStatus, PackagePublishingPocket)
    >>> source = test_publisher.getPubSource(
    ...     status=PackagePublishingStatus.PUBLISHED,
    ...     pocket=PackagePublishingPocket.PROPOSED)
    >>> binaries = test_publisher.getPubBinaries(
    ...     pub_source=source,
    ...     status=PackagePublishingStatus.PUBLISHED,
    ...     pocket=PackagePublishingPocket.PROPOSED)

    >>> print source.displayname
    foo 666 in breezy-autotest

    >>> for bin in binaries:
    ...     print bin.displayname
    foo-bin 666 in breezy-autotest i386
    foo-bin 666 in breezy-autotest hppa

Using the source publication, ISecureSourcePackagePublishingHistory, we
can obtain the published binaries.

    >>> created_ids = [bin.id for bin in binaries]
    >>> retrieved_ids = [bin.id for bin in source.getPublishedBinaries()]
    >>> sorted(created_ids) == sorted(retrieved_ids)
    True

We can also inspect the builds created for a source publication
without retrieving its binaries.

    >>> for build in source.getBuilds():
    ...     print build.title
    i386 build of foo 666 in ubuntutest breezy-autotest PROPOSED

Now that we know how to retrieve generated binary publication related
to a source publication we can exercise the API provided to copy
publications across suites and/or archives.

One of the most common use-cases for copying a publication is when
archive-admins wants to release for public audience a Stable Release
Update (SRU) which was successfully tested in PROPOSED pocket. This
procedure will consist of a source copy from PROPOSED to UPDATES
including its binaries.

'distroseries' and 'archive' will be constant.

    >>> distroseries = source.distroseries
    >>> archive = source.archive

'pocket' will be UPDATES.

    >>> pocket = PackagePublishingPocket.UPDATES

Let's perform the copy of the source and all its binaries.

    >>> copied_source = source.copyTo(distroseries, pocket, archive)

    >>> copied_binaries = []
    >>> for bin in binaries:
    ...     copied_binaries.append(
    ...          bin.copyTo(distroseries, pocket, archive))

The 'copied' records are instance of Secure{Source,
Binary}PackagePublishingHistory:

    >>> ISecureSourcePackagePublishingHistory.providedBy(copied_source)
    True

    >>> [ISecureBinaryPackagePublishingHistory.providedBy(bin)
    ...  for bin in copied_binaries]
    [True, True]

Copied publications are created as PENDING, so the publisher will have
a chance to verify it's contents and include it in the destination
archive index.

    >>> print copied_source.status.name
    PENDING

    >>> for bin in copied_binaries:
    ...     print bin.status.name
    PENDING
    PENDING

Let's retrieve the 'insecure' corresponding publishing records since
only they provide the API we are interested in.

    >>> copied_source = SourcePackagePublishingHistory.get(copied_source.id)

    >>> copied_binaries = [BinaryPackagePublishingHistory.get(bin.id)
    ...                    for bin in copied_binaries]

When we call createMissingBuilds method on the copied sources it won't
create any builds since the binaries were copied over too.

    >>> copied_source.createMissingBuilds()
    []

Now we can observe that both, the original and the copied sources are
related only with their corresponding binaries, see bug #181834 for
previous broken implementation in this area.

    >>> for bin in source.getPublishedBinaries():
    ...     print bin.displayname, bin.pocket.name, bin.status.name
    foo-bin 666 in breezy-autotest hppa PROPOSED PUBLISHED
    foo-bin 666 in breezy-autotest i386 PROPOSED PUBLISHED

    >>> for bin in copied_source.getPublishedBinaries():
    ...     print bin.displayname, bin.pocket.name, bin.status.name
    foo-bin 666 in breezy-autotest hppa UPDATES PENDING
    foo-bin 666 in breezy-autotest i386 UPDATES PENDING

Note that even PENDING binary publications are returned by
getPublishedBinaries(), it considers both PENDING and PUBLISHED status
as active, SUPERSEDED, DELETED and OBSOLETE are excluded. Differently,
getBuiltBinaries() follows binaries in any state.

    >>> len(source.getPublishedBinaries())
    2

    >>> len(source.getBuiltBinaries())
    2

Note that getPublishedBinaries() return a SelectResult and
getBuiltBinaries() returns a list.

When we supersede one of the original binary publications, it gets
excluded from the getPublishedBinaries() results, but not from the
getBuiltBinaries() result.

    >>> from canonical.launchpad.ftests import syncUpdate

    >>> a_binary = source.getPublishedBinaries()[0]
    >>> superseded = a_binary.supersede()
    >>> syncUpdate(superseded)

    >>> len(source.getPublishedBinaries())
    1

    >>> len(source.getBuiltBinaries())
    2

The same happens when we delete the i386 binary, so no binaries are
published in the original location.

    >>> deleted = source.getPublishedBinaries()[0].requestDeletion(
    ...     sabdfl, "go")
    >>> syncUpdate(deleted)

    >>> len(source.getPublishedBinaries())
    0

    >>> len(source.getBuiltBinaries())
    2

Finally we will mark both copied binary publication as obsolete and
verify that the getPublishedBinaries() result is also empty after that.

    >>> len(copied_source.getPublishedBinaries())
    2

    >>> for bin in copied_source.getPublishedBinaries():
    ...     obsoleted = bin.requestObsolescence()
    ...     syncUpdate(obsoleted)

    >>> len(copied_source.getPublishedBinaries())
    0

    >>> len(copied_source.getBuiltBinaries())
    2

Additionally to find all built binaries regardless of their states,
getBuiltBinaries() also excludes the duplications generated by
overrides.

Before performing an overriding we will move the all built binaries in
the copied location to PUBLISHED, so they can be visible again for
getPublishedBinaries().

    >>> for pub in copied_source.getBuiltBinaries():
    ...     secure_record = pub.secure_record
    ...     secure_record.status = PackagePublishingStatus.PUBLISHED
    ...     secure_record.scheduleddeletiondate = None
    ...     syncUpdate(secure_record)

Now we override the first binary publication, the hppa one, to
component 'universe'.

    >>> from canonical.launchpad.interfaces import IComponentSet
    >>> universe = getUtility(IComponentSet)['universe']

    >>> first_binary = copied_source.getPublishedBinaries()[0]
    >>> override = first_binary.changeOverride(new_component=universe)

Not only do the two copied binaries show up in getPublishedBinaries(),
but also the override just done.

    >>> for pub in copied_source.getPublishedBinaries():
    ...     print pub.displayname, pub.component.name
    foo-bin 666 in breezy-autotest hppa universe
    foo-bin 666 in breezy-autotest hppa main
    foo-bin 666 in breezy-autotest i386 main

The publication duplication is solved in the publishing pipeline,
specifically in the 'domination' state. See
`archivepublisher.tests.test_dominator` for more information.

On the other hand, getBuiltBinaries() will return only 2 binary
publications and the hppa one is the overridden one.

    >>> for pub in copied_source.getBuiltBinaries():
    ...     print pub.displayname, pub.component.name
    foo-bin 666 in breezy-autotest hppa universe
    foo-bin 666 in breezy-autotest i386 main

We have to re-publish the superseded and the deleted publications above
because it's used below.

    >>> superseded.status = PackagePublishingStatus.PUBLISHED
    >>> syncUpdate(superseded)
    >>> deleted.status = PackagePublishingStatus.PUBLISHED
    >>> syncUpdate(deleted)

Another common copy use-case is rebuild the same source in another
suite. To simulate this we will create a publication in Celso's PPA.

    >>> from canonical.launchpad.interfaces import IPersonSet
    >>> cprov = getUtility(IPersonSet).getByName('cprov')

    >>> ppa_source = test_publisher.getPubSource(
    ...     archive=cprov.archive,
    ...     status=PackagePublishingStatus.PUBLISHED)
    >>> ppa_binaries = test_publisher.getPubBinaries(
    ...     pub_source=ppa_source,
    ...     status=PackagePublishingStatus.PUBLISHED)

    >>> print ppa_source.displayname, ppa_source.archive.title
    foo 666 in breezy-autotest PPA for Celso Providelo

    >>> for bin in ppa_binaries:
    ...     print bin.displayname, bin.archive.title
    foo-bin 666 in breezy-autotest i386 PPA for Celso Providelo
    foo-bin 666 in breezy-autotest hppa PPA for Celso Providelo

Now we will copy only the source from Celso's PPA breezy-autotest to
hoary-test.

    >>> breezy_autotest = ppa_source.distroseries
    >>> hoary_test = breezy_autotest.distribution.getSeries(
    ...     'hoary-test')
    >>> hoary_test.nominatedarchindep = hoary_test["i386"]
    >>> fake_chroot = test_publisher.addMockFile('fake_chroot.tar.gz')
    >>> trash = hoary_test["i386"].addOrUpdateChroot(fake_chroot)

Perform the source-only copy.

    >>> ppa_copied_source = ppa_source.copyTo(
    ...     hoary_test, PackagePublishingPocket.RELEASE, cprov.archive)

    >>> ppa_copied_source = SourcePackagePublishingHistory.get(
    ...     ppa_copied_source.id)

Since it's a rebuild we can immediately create the corresponding
builds.

    >>> builds = ppa_copied_source.createMissingBuilds()

    >>> for build in builds:
    ...     print build.title
    i386 build of foo 666 in ubuntutest hoary-test RELEASE

If createMissingBuilds get called again on either sources no builds
will get created.

    >>> ppa_source.createMissingBuilds()
    []

    >>> ppa_copied_source.createMissingBuilds()
    []

In the sampledata, both, hoary-test and breezy-autotest derives from
ubuntu/warty. To make it more realistic we will make hoary-test derive
from breezy-autotest and test if the build algorithm copes with it.

This simulates a rebuild in of the same source in a more recent
distroseries, like rebuilding SRUs for constant sources.

    >>> breezy_autotest.parent_series = None
    >>> hoary_test.parent_series = breezy_autotest

    >>> ppa_source.createMissingBuilds()
    []

    >>> ppa_copied_source.createMissingBuilds()
    []

Now, let's check the opposite, as if the copy was from a more recent
distroseries to a older one, like a backport rebuild.

    >>> breezy_autotest.parent_series = hoary_test
    >>> hoary_test.parent_series = None

    >>> ppa_source.createMissingBuilds()
    []

    >>> ppa_copied_source.createMissingBuilds()
    []

It is also possible to copy sources and binaries to another
distroseries within the same PPA. That's usually the case for
architecture-independent sources.

    >>> ppa_source = test_publisher.getPubSource(
    ...     archive=cprov.archive, version="999",
    ...     status=PackagePublishingStatus.PUBLISHED)

    >>> ppa_binaries = test_publisher.getPubBinaries(
    ...     pub_source=ppa_source,
    ...     status=PackagePublishingStatus.PUBLISHED)

Let's perform the copy of the source and its i386 binary.

    >>> series = hoary_test
    >>> pocket = PackagePublishingPocket.RELEASE
    >>> archive = cprov.archive

    >>> copied_source = ppa_source.copyTo(series, pocket, archive)

    >>> ppa_binary_i386 = ppa_binaries[0]
    >>> print ppa_binary_i386.displayname
    foo-bin 999 in breezy-autotest i386

    >>> copied_binary = ppa_binary_i386.copyTo(series, pocket, archive)

The source and binary are present in hoary-test:

    >>> copied_source = SourcePackagePublishingHistory.get(copied_source.id)
    >>> print copied_source.displayname
    foo 999 in hoary-test

    >>> for bin in copied_source.getPublishedBinaries():
    ...     print bin.displayname
    foo-bin 999 in hoary-test i386

So, no builds are created.

    >>> copied_source.createMissingBuilds()
    []


== getSourceAndBinaryLibraryFiles ==

This method retrieves LibraryFileAlias records for all source and binary
files associated with this publication.

Using the same Ubuntu source publishing example as above:

    >>> for file in source.getSourceAndBinaryLibraryFiles():
    ...     print file.filename
    foo-bin_all.deb
    foo.dsc

We can also publish a package in a PPA and query on its files:

    >>> ppa_source = test_publisher.getPubSource(
    ...     status=PackagePublishingStatus.PUBLISHED,
    ...     archive=cprov.archive)
    >>> ppa_binaries= test_publisher.getPubBinaries(
    ...     pub_source=ppa_source,
    ...     status=PackagePublishingStatus.PUBLISHED)

    >>> for file in ppa_source.getSourceAndBinaryLibraryFiles():
    ...     print file.filename
    foo-bin_all.deb
    foo.dsc

Notice that some files appear twice if they are published in more than one
architecture (e.g. for arch-all files).


== Publishing records age ==

Both ISourcePackagePublishingHistory and IBinaryPackagePublishingHistory
implement the 'age' property which return a timedelta representing
"NOW - datecreated".

    >>> ppa_source.age
    datetime.timedelta(...)

    >>> ppa_binaries[0].age
    datetime.timedelta(...)


== Secure Source Publishing ==

'secure_record' returns a ISecureSourcePackagePublishing instance
corresponding to this publication. This instance also implements
IArchiveSafePublisher.

    >>> sspph = spph.secure_record
    >>> ISecureSourcePackagePublishingHistory.providedBy(sspph)
    True
    >>> verifyObject(IArchiveSafePublisher, sspph)
    True
    >>> sspph.embargo
    False


== Binary and Binary File Publishing ===

Symmetric behaviour is offered for BinaryPackagePublishing,
BinaryPackageFile and ISecureBinaryPackagePublishingHistory

    >>> from canonical.launchpad.interfaces import (
    ...     IBinaryPackagePublishingHistory, IBinaryPackageFilePublishing)

    >>> bpph = BinaryPackagePublishingHistory.get(15)
    >>> print bpph.displayname
    mozilla-firefox 0.9 in woody i386

    >>> IBinaryPackagePublishingHistory.providedBy(bpph)
    True

Generating respective "Packages" stanzas:

    >>> print bpph.getIndexStanza() #doctest: -NORMALIZE_WHITESPACE
    Package: mozilla-firefox
    Source: mozilla-firefox
    Priority: important
    Section: editors
    Maintainer: Mark Shuttleworth <mark@canonical.com>
    Architecture: i386
    Version: 0.9
    Recommends: gcc-3.4-base, libc6 (>= 2.3.2.ds1-4), gcc-3.4 (>= 3.4.1-4sarge1), gcc-3.4 (<< 3.4.2), libstdc++6-dev (>= 3.4.1-4sarge1)
    Replaces: gnome-mozilla-browser
    Suggests: firefox-gnome-support (= 1.0.7-0ubuntu20), latex-xft-fonts, xprint
    Provides: mozilla-firefox
    Depends: gcc-3.4-base, libc6 (>= 2.3.2.ds1-4), gcc-3.4 (>= 3.4.1-4sarge1), gcc-3.4 (<< 3.4.2), libstdc++6-dev (>= 3.4.1-4sarge1)
    Conflicts: firefox, mozilla-web-browser
    Pre-Depends: pmount, foo
    Enhances: pmount, bar
    Breaks: pmount, baz
    Filename: pool/universe/m/mozilla-firefox/mozilla-firefox_0.9_i386.deb
    Size: 3
    MD5sum: 01234567890123456789012345678926
    Description: Mozilla Firefox Web Browser
     Mozilla Firefox Web Browser is .....

    >>> sbpph = bpph.secure_record
    >>> ISecureBinaryPackagePublishingHistory.providedBy(sbpph)
    True
    >>> verifyObject(IArchiveSafePublisher, sbpph)
    True
    >>> sbpph.embargo
    False

    >>> any_file = bpph.files[-1]
    >>> IBinaryPackageFilePublishing.providedBy(any_file)
    True

    >>> [pub_file.libraryfilealias.filename for pub_file in bpph.files]
    [u'mozilla-firefox_0.9_i386.deb']

    >>> [pub_file.archive_url for pub_file in bpph.files]
    [u'http://launchpad.dev/debian/pool/universe/m/mozilla-firefox/mozilla-firefox_0.9_i386.deb']


== IPublishingSet ==

This utility is implements the following methods:

 * getBuildsForSources();
 * getFilesForSources();
 * getBinaryPublicationsForSources();

They receive a list of `SourcePackagePublishingHistory` database IDs
and fetch the corresponding information for all of them.

Their returned `ResultSet` (they all use storm natively) follows a
pattern:

 * (`SourcePackagePublishingHistory`, <object>, [prejoins,])

This way the useful references gets cached and the callsites can group
the results as necessary.

The `IPublishingSet` methods are also used to implement the corresponding
features in `ISourcePackagePublishingHistory`:

 * getBuilds -> IPublishingSet.getBuildsForSources;
 * getSourceAndBinaryLibraryFiles -> IPublishingSet.getFilesForSources;
 * getPublishedBinaries -> IPublishingSet.getBinaryPublicationsForSources;

So, they were already tested implicitly before in this file, but only
passing a list with a single source publication ID. Now we will
document how they work for multiple source publications.

IPublishingSet is a essential component for
`ArchiveSourcePublications` feature, see further information in
archivesourcepublications.txt.

    >>> from canonical.launchpad.interfaces.publishing import (
    ...     IPublishingSet)
    >>> publishing_set = getUtility(IPublishingSet)

We will assembly a list of source publications based on what was
ever published in Celso's PPA.

    >>> cprov = getUtility(IPersonSet).getByName('cprov')
    >>> cprov_sources_ids = [
    ...    pub.id for pub in cprov.archive.getPublishedSources()]

    >>> len(cprov_sources_ids)
    8

Now that we have a set of source publications let's get the builds in
its context.

    >>> cprov_builds = publishing_set.getBuildsForSources(cprov_sources_ids)

It returns a `ResultSet` and it contains triples as
`SourcePackagePublishingHistory`, `Build` and `DistroArchseries` for
each build found.

    >>> cprov_builds.count()
    7

The `ResultSet` is ordered by ascending
`SourcePackagePublishingHistory.id` and ascending
`DistroArchseries.architecturetag` in this order.

    >>> source_pub, build, arch = cprov_builds.last()

    >>> print source_pub.displayname
    foo 666 in breezy-autotest

    >>> print build.title
    i386 build of foo 666 in ubuntutest breezy-autotest RELEASE

    >>> print arch.displayname
    ubuntutest Breezy Badger Autotest i386

Now we retrieve all binary publications for Celso's PPA sources.

    >>> cprov_binaries = publishing_set.getBinaryPublicationsForSources(
    ...     cprov_sources_ids)

The returned `ResultSet` contains 5-element tuples as
(`SourcePackagePublishingHistory`, `BinaryPackagePublishingHistory`,
 `BinaryPackageRelease`, `BinaryPackageName`, `DistroArchSeries`).

    >>> cprov_binaries.count()
    10

This result is ordered by ascending
`SourcePackagePublishingHistory.id`, ascending `BinaryPackageName.name`,
ascending `DistroArchSeries.architecturetag and descending
`BinaryPackagePublishingHistory.id`.

    >>> (source_pub, binary_pub, binary, binary_name,
    ...  arch) = cprov_binaries.last()

    >>> print source_pub.displayname
    foo 666 in breezy-autotest

    >>> print binary_pub.displayname
    foo-bin 666 in breezy-autotest i386

    >>> print binary.title
    foo-bin-666

    >>> print binary_name.name
    foo-bin

    >>> print arch.displayname
    ubuntutest Breezy Badger Autotest i386

Finally we can retrieve all files related with Celso's PPA
publications.

    >>> cprov_files = publishing_set.getFilesForSources(
    ...     cprov_sources_ids)

This `ResultSet` contains triples as
(`SourcePackagePublishingHistory`, `LibraryFileAlias`,
`LibraryFileContent`)

    >>> cprov_files.count()
    14

This result are not ordered since it comes from SQL UNION, so call
sites are responsible to order them appropriately. So, can can only
check that they unpack as specified, a triple.

    >>> source, file, content = cprov_files.any()

    >>> ordered_filenames = sorted([
    ...    file.filename for source, file, content in cprov_files])

    >>> print ordered_filenames[-1]
    firefox-0.9.2.orig.tar.gz
