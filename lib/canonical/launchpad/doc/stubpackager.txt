= Stub Packager Utility =

StubPackager allow us to easily create minimal debian packages to be
used in tests.

    >>> import os
    >>> from canonical.launchpad.interfaces import IStubPackager
    >>> from canonical.launchpad.components.stubpackager import StubPackager

== Setup and reset ==

When StubPackager is initialised it automatically creates a temporary
directory we call 'sandbox'. It's where the packages will get created.

    >>> packager = StubPackager()

    >>> print packager.sandbox_path
    /tmp/stubpackager-...

    >>> os.path.exists(packager.sandbox_path)
    True

Source 'name' and 'version' and 'gpg_key_id' are empty.

    >>> packager = StubPackager()

    >>> print packager.name
    None

    >>> print packager.version
    None

    >>> print packager.gpg_key_id
    None

The 'upstream_directory' can't be calculated at this stage since it
depends on the upstream source name and version.

    >>> print packager.upstream_directory
    Traceback (most recent call last):
    ...
    AssertionError: Undefined name and version.

Defining them via setSourceNameAndVersion method, allow us to know
the 'upstream_directory' path, but it is not yet created.

    >>> packager.setSourceNameAndVersion('biscuit', '1.0')

    >>> print packager.upstream_directory
    /tmp/stubpackager-.../biscuit-1.0

    >>> os.path.exists(packager.upstream_directory)
    False

We can now play with the reset method. It purges the current sandbox
directory and creates a new one. It also clears StubPackager's
'name' and 'version', avoid inconsistent states.

    >>> previous_sandbox_path = packager.sandbox_path

    >>> os.path.exists(previous_sandbox_path)
    True

    >>> packager.reset()

    >>> os.path.exists(previous_sandbox_path)
    False

    >>> packager.sandbox_path != previous_sandbox_path
    True

    >>> os.path.exists(packager.sandbox_path)
    True

    >>> print packager.name
    None

    >>> print packager.version
    None


== Creating Packages ==

First we define a source upstream name and version.

    >>> packager.setSourceNameAndVersion('biscuit', '1.0')

Then we create it on disk based on the StubPackager templates.

    >>> packager.buildUpstream(build_orig=False)

It results in a buildable source package with the suffix '-1' appended
to the upstream version in the upstream_directory path.

    >>> os.path.exists(packager.upstream_directory)
    True

    >>> print sorted(os.listdir(packager.sandbox_path))
    ['biscuit-1.0']

    >>> print sorted(os.listdir(packager.debian_path))
    ['changelog', 'control', 'copyright', 'rules']

We will reset the packager so we can generate a new upstream directory
with a corresponding original tarball.

    >>> packager.reset()

    >>> packager.setSourceNameAndVersion('biscuit', '1.0')
    >>> packager.buildUpstream()

    >>> print sorted(os.listdir(packager.sandbox_path))
    ['biscuit-1.0', 'biscuit_1.0.orig.tar.gz']

    >>> print sorted(os.listdir(packager.debian_path))
    ['changelog', 'control', 'copyright', 'rules']

Now we can build the source package using the generated tarball.

    >>> packager.buildSource(signed=False)

    >>> for changesfile in packager.listAvailableUploads():
    ...     print changesfile
    /tmp/stubpackager-.../biscuit_1.0-1_source.changes

    >>> changesfile_path = packager.listAvailableUploads()[0]
    >>> changesfile = open(changesfile_path)
    >>> print changesfile.read()
    Format: 1.7
    Date: ...
    Source: biscuit
    Binary: biscuit
    Architecture: source
    Version: 1.0-1
    Distribution: hardy
    Urgency: low
    Maintainer: Launchpad team <launchpad@lists.canonical.com>
    Changed-By: Foo Bar <foo.bar@canonical.com>
    Description:
     biscuit    - Stuff for testing
    Changes:
     biscuit (1.0-1) hardy; urgency=low
     .
       * Initial Upstream package
    Files:
     ... devel optional biscuit_1.0-1.dsc
     ... devel optional biscuit_1.0.orig.tar.gz
     ... devel optional biscuit_1.0-1.diff.gz
    <BLANKLINE>

When we try to build an incompatible package version an error will be
raised indicating it could not created.

    >>> packager.buildVersion('2.0-2', changelog_text="version on crack.")
    Traceback (most recent call last):
    ...
    AssertionError: New versions should start with the upstream version: 1.0

Using a proper version, let's build a new source package version, but
now signing the DSC and the changesfile.

    >>> packager.buildVersion(
    ...    '1.0-2', changelog_text="Waar ligt de sleutel ?")
    >>> packager.buildSource(include_orig=True)
    Traceback (most recent call last):
    ...
    AssertionError: Cannot build signed packages because the key is not set.

The error was raised because no signing key was set.

    >>> print packager.gpg_key_id
    None

A GPG key can be set using 'setGPGKey' method and it accepts a
filename available in our test_keys directory (see
launchpad/ftests/keys_for_tests.py)

    >>> packager.setGPGKey('foo.bar@canonical.com-passwordless.sec')

GPG key set, now we are able to build a signed version.

    >>> print packager.gpg_key_id
    0x5D147547

StubPackager also allows us to include as many versions it needs
before building the package. It helps when the content of the
changelog matters in the test context.

    >>> packager.buildVersion('1.0-2', changelog_text="cookies")
    >>> packager.buildVersion('1.0-3', changelog_text="butter cookies")
    >>> packager.buildSource(include_orig=False)

The generated changesfile contains a valid signature done by the
preset GPG key. All the job is done by `debuild` here, we are
basically checking we pass the right arguments to it.

    >>> changesfile_path = packager.listAvailableUploads()[1]
    >>> print os.path.basename(changesfile_path)
    biscuit_1.0-3_source.changes

    >>> content = open(changesfile_path).read()

    >>> from zope.component import getUtility
    >>> from canonical.launchpad.interfaces import IGPGHandler
    >>> gpghandler = getUtility(IGPGHandler)
    >>> sig = gpghandler.verifySignature(content)

    >>> sig.fingerprint[-8:] == packager.gpg_key_id[2:]
    True

Continuing in the same 'sandbox', we can generate subsequent packages
for the same upstream source.

    >>> packager.buildVersion('1.0-4', changelog_text="uhmmm, leker")
    >>> packager.buildSource(include_orig=False)

Or, at any time, change to another upstream source.

    >>> packager.setSourceNameAndVersion('zeca', '1.0')
    >>> packager.buildUpstream()
    >>> packager.buildSource()

    >>> packager.buildVersion('1.0-2', changelog_text="cookies")
    >>> packager.buildSource(include_orig=False)

And get back to the previous source.

    >>> packager.setSourceNameAndVersion('biscuit', '1.0')
    >>> packager.buildVersion('1.0-5', changelog_text="we, together, again.")
    >>> packager.buildSource(include_orig=False)

All generated changesfile and their corresponding files are available
in the sandbox directory.

    >>> for changesfile in packager.listAvailableUploads():
    ...     print changesfile
    /tmp/stubpackager-.../biscuit_1.0-1_source.changes
    /tmp/stubpackager-.../biscuit_1.0-3_source.changes
    /tmp/stubpackager-.../biscuit_1.0-4_source.changes
    /tmp/stubpackager-.../zeca_1.0-1_source.changes
    /tmp/stubpackager-.../zeca_1.0-2_source.changes

Finally, an error is raised if we try to build a source package before
creating the upstream directory.

    >>> packager.setSourceNameAndVersion('canjica', '1.0')
    >>> packager.buildSource()
    Traceback (most recent call last):
    ...
    AssertionError: Selected upstream directory does not exist: canjica-1.0
