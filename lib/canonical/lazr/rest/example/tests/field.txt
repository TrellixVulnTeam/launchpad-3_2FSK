= Field resources =

It's possible to get the value of one particular field. You can get a
JSON or XHTML-fragment representation.

    >>> from canonical.lazr.testing.webservice import CookbookWebServiceCaller
    >>> webservice = CookbookWebServiceCaller()

    >>> from urllib import quote
    >>> cookbook_url = quote("/cookbooks/The Joy of Cooking")
    >>> field_url = cookbook_url + "/cuisine"

    >>> import simplejson
    >>> def set_cuisine(cuisine):
    ...     """Sets the cuisine for "The Joy of Cooking"."""
    ...     representation = {'cuisine': cuisine}
    ...     ignore = webservice(cookbook_url, 'PATCH',
    ...                         simplejson.dumps(representation))

    >>> set_cuisine("<b>General</b>")

    >>> print webservice.get(field_url)
    HTTP/1.1 200 Ok
    ...
    Content-Type: application/json
    ...

    >>> print webservice.get(field_url).jsonBody()
    <b>General</b>

    >>> print webservice.get(field_url, 'application/xhtml+xml')
    HTTP/1.1 200 Ok
    ...
    Content-Type: application/xhtml+xml
    ...
    &lt;b&gt;General&lt;/b&gt;

    >>> set_cuisine("General")


= Supported methods =

Field resources are read-only.

    >>> for method in ['HEAD', 'POST', 'PUT', 'DELETE', 'OPTIONS']:
    ...     print webservice(field_url, method)
    HTTP/1.1 405 Method Not Allowed
    Allow: GET
    ...
    HTTP/1.1 405 Method Not Allowed
    Allow: GET
    ...
    HTTP/1.1 405 Method Not Allowed
    Allow: GET
    ...
    HTTP/1.1 405 Method Not Allowed
    Allow: GET
    ...
    HTTP/1.1 405 Method Not Allowed
    Allow: GET
    ...


= Conditional GET =

Field resources have ETags independent of their parent entries. They
respond to conditional GET.

    >>> response = webservice.get(cookbook_url)
    >>> cookbook_etag = response._response.getHeader('ETag')

    >>> response = webservice.get(field_url)
    >>> etag = response._response.getHeader('ETag')

    >>> cookbook_etag == etag
    False

    >>> print webservice.get(field_url, headers={'If-None-Match': etag})
    HTTP/1.1 304 Not Modified
    ...

    >>> set_cuisine("new cuisine")
    >>> print webservice.get(field_url,
    ...                      headers={'If-None-Match': etag})
    HTTP/1.1 200 Ok
    ...

    >>> set_cuisine("General")


= Custom representations =

Every entry has an XHTML representation. The default representation is
a simple text node.

  >>> print webservice.get(field_url, 'application/xhtml+xml')
  HTTP/1.1 200 Ok
  ...
  General

But it's possible to define a custom HTML renderer for a particular
object and field type. Here's a simple renderer that bolds whatever
value it's given.

  >>> from zope import component
  >>> from zope.interface import implementer
  >>> from zope.schema.interfaces import ITextLine
  >>> from canonical.lazr.interfaces.rest import (
  ...     IFieldHTMLRenderer, IWebServiceClientRequest)
  >>> from canonical.lazr.rest.example.interfaces import ICookbook

  >>> @component.adapter(ICookbook, ITextLine, IWebServiceClientRequest)
  ... @implementer(IFieldHTMLRenderer)
  ... def dummy_renderer(context, field, request):
  ...     """Create a simple renderer that bolds the original string."""
  ...     def render(value):
  ...         return "<b>%s</b>" % value.encode("utf-8")
  ...     return render

Register the renderer as the IFieldHTMLRenderer adapter for an
ITextLine field of an IPerson entry...

  >>> from zope.component import getGlobalSiteManager
  >>> manager = getGlobalSiteManager()
  >>> manager.registerAdapter(dummy_renderer)

...and the XHTML representation of an ICookbook's cuisine will be the
result of calling a dummy_renderer object.

  >>> print webservice.get(field_url, 'application/xhtml+xml')
  HTTP/1.1 200 Ok
  ...
  <b>General</b>

In fact, that adapter will be used for every ITextLine field of an
ICookbook.

  >>> print webservice.get(cookbook_url +'/name', 'application/xhtml+xml')
  HTTP/1.1 200 Ok
  ...
  <b>The Joy of Cooking</b>

Note that the XHTML is not escaped, as it is when the default adapter
is used. Escaping user-entered XHTML, and distinguishing it from
system-generated XHTML, is the responsibility of each adapter.

The adapter will not be used for ITextLine fields of other interfaces:

  >>> dish_field_url = quote('/dishes/Roast%20chicken/name')
  >>> print webservice.get(dish_field_url, 'application/xhtml+xml')
  HTTP/1.1 200 Ok
  ...
  Roast chicken

It will not be used for non-text fields of ICookbook.

  >>> print webservice.get(cookbook_url + '/copyright_date',
  ...                      'application/xhtml+xml')
  HTTP/1.1 200 Ok
  ...
  1995-01-01

Before we continue, here's some cleanup code to remove the custom
renderer we just defined.

  >>> ignored = getGlobalSiteManager().unregisterAdapter(dummy_renderer)

  >>> print webservice.get(field_url, 'application/xhtml+xml')
  HTTP/1.1 200 Ok
  ...
  General


== Defining a custom representation for a single field ==

It's also possible to define a custom HTML representation of one
particular field, by registering a view on the field. This code
creates a custom renderer for IPerson.display_name, by registering
a view on IPerson called "display_name".

  >>> manager.registerAdapter(dummy_renderer, name='cuisine')

  >>> print webservice.get(field_url, 'application/xhtml+xml')
  HTTP/1.1 200 Ok
  ...
  <b>General</b>

Unlike what happened when we registered an renderer for
ICookbook/ITextLine, other ITextLine fields of ICookbook are not affected.

  >>> print webservice.get(cookbook_url + '/name', 'application/xhtml+xml')
  HTTP/1.1 200 Ok
  ...
  The Joy of Cooking

The XHTML representation of an entry incorporates any custom XHTML
representations of that entry's fields.

  >>> print webservice.get(cookbook_url, 'application/xhtml+xml')
  HTTP/1.1 200 Ok
  ...
  <dt>cuisine</dt>
  <dd><b>General</b></dd>
  ...

Before we continue, here's some code to unregister the view.

  >>> ignored = getGlobalSiteManager().unregisterAdapter(
  ...      dummy_renderer, name='cuisine')

  >>> print webservice.get(field_url, 'application/xhtml+xml')
  HTTP/1.1 200 Ok
  ...
  General
