= TranslationMessage =

Let's do some imports we will need to test this class.

    >>> from zope.component import getUtility
    >>> from canonical.launchpad.webapp.testing import verifyObject
    >>> from canonical.launchpad.database import (
    ...     POTemplate, POTMsgSet, TranslationMessage)
    >>> from canonical.launchpad.interfaces import (
    ...     ILanguageSet, IPersonSet, IProductSet, ITranslationMessage)

    >>> potemplate = POTemplate.get(1)
    >>> potmsgsets = potemplate.getPOTMsgSets()
    >>> potmsgset = potmsgsets[0]

This class links the translations submitted by a translator with the associated
POFile and POTMsgSet.  TranslationMessage and DummyTranslationMessage both
implement ITranslationMessage interface:

    >>> translationmessage = TranslationMessage.get(1)
    >>> verifyObject(ITranslationMessage, translationmessage)
    True

    >>> serbian = getUtility(ILanguageSet)['sr']
    >>> dummy_translationmessage = potmsgset.getCurrentDummyTranslationMessage(
    ...     serbian)
    >>> verifyObject(ITranslationMessage, dummy_translationmessage)
    True


== plural_forms ==

This property returns a number of plural forms needed for a
TranslationMessage to be 'complete', i.e. contain all the necessary
translations.

We can look at a POTMsgSet with no plural forms:

    >>> potmsgset_no_plural = POTMsgSet.select("msgid_plural IS NULL")[0]
    >>> print potmsgset_no_plural.plural_text
    None

Any TranslationMessage for such a POTMsgSet returns a single plural form in
the translation, no matter the number of plural forms defined for the
language:

    >>> serbian = getUtility(ILanguageSet)['sr']
    >>> serbian.pluralforms
    3
    >>> current_sr = potmsgset_no_plural.getCurrentDummyTranslationMessage(
    ...     serbian)
    >>> current_sr.plural_forms
    1

    >>> divehi = getUtility(ILanguageSet)['dv']
    >>> print divehi.pluralforms
    None
    >>> current_dv = potmsgset_no_plural.getCurrentDummyTranslationMessage(
    ...     divehi)
    >>> current_dv.plural_forms
    1

For any POTMsgSet using plural forms, we get a defined number of plural
forms per language (3 for Serbian, as specified in the language).

    >>> potmsgset_plural = POTMsgSet.select("msgid_plural IS NOT NULL")[0]
    >>> potmsgset_plural.plural_text is not None
    True
    >>> serbian.pluralforms
    3
    >>> current_sr = potmsgset_plural.getCurrentDummyTranslationMessage(
    ...     serbian)
    >>> current_sr.plural_forms
    3

In case the language doesn't have number of plural forms defined, we return
a default of 2, which is the most common number of plural forms:

    >>> print divehi.pluralforms
    None
    >>> current_dv = potmsgset_plural.getCurrentDummyTranslationMessage(
    ...     divehi)
    >>> current_dv.plural_forms
    2

    >>> login('foo.bar@canonical.com')


== is_hidden ==

This property tells if a TranslationMessage is actually shown in the
web translation interface or not.

We have to commit transaction for every message update so we end up
with different timestamps on messages.

    >>> import transaction

    >>> from datetime import datetime
    >>> import pytz
    >>> UTC = pytz.timezone('UTC')

We are working with Evolution POFile.

    >>> evolution = getUtility(IProductSet).getByName('evolution')
    >>> evolution_trunk = evolution.getSeries('trunk')
    >>> evolution_potemplate = evolution_trunk.getPOTemplate('evolution-2.2')

We will be working with Serbian (sr) translations, with the new PO file.

    >>> pofile_sr = evolution_potemplate.newPOFile('sr')
    >>> serbian = pofile_sr.language
    >>> potmsgset = evolution_potemplate.getPOTMsgSetByMsgIDText(
    ...     u'evolution addressbook')

A non-privileged user can only submit a suggestion, which will not be
hidden.

    >>> nopriv = getUtility(IPersonSet).getByName('no-priv')
    >>> login('no-priv@canonical.com')

    >>> new_suggestion = potmsgset.updateTranslation(
    ...     pofile_sr, nopriv, {0: u'suggestion'}, is_fuzzy=False,
    ...     is_imported=False, lock_timestamp=datetime.now(UTC))
    >>> transaction.commit()
    >>> new_suggestion.is_hidden
    False

Carlos is a privileged translator that will do the updates.

    >>> carlos = getUtility(IPersonSet).getByName('carlos')
    >>> login('carlos@canonical.com')

An imported translation is not hidden when submitted.

    >>> imported_translation = potmsgset.updateTranslation(
    ...     pofile_sr, carlos, {0: u'foo'}, is_fuzzy=False,
    ...     is_imported=True, lock_timestamp=datetime.now(UTC))
    >>> transaction.commit()
    >>> imported_translation.is_hidden
    False

A previous suggestion is now hidden.

    >>> new_suggestion.is_hidden
    True

A newly submitted non-imported translation is not hidden either.

    >>> current_translation = potmsgset.updateTranslation(
    ...     pofile_sr, carlos, {0: u'bar'}, is_fuzzy=False,
    ...     is_imported=False, lock_timestamp=datetime.now(UTC))
    >>> transaction.commit()
    >>> current_translation.is_hidden
    False

However, previous imported translation is not hidden yet.

    >>> imported_translation.is_hidden
    False

If a new current translation is submitted, the old one is hidden.

    >>> new_current_translation = potmsgset.updateTranslation(
    ...     pofile_sr, carlos, {0: u'new'}, is_fuzzy=False,
    ...     is_imported=False, lock_timestamp=datetime.now(UTC))
    >>> transaction.commit()
    >>> new_current_translation.is_hidden
    False
    >>> current_translation.is_hidden
    True

    >>> new_current_translation.is_hidden
    False
    >>> imported_translation.is_hidden
    False

If a non-privileged user submits another suggestion, it's not hidden,
and last current translation is not hidden either.

    >>> nopriv = getUtility(IPersonSet).getByName('no-priv')
    >>> login('no-priv@canonical.com')

    >>> another_suggestion = potmsgset.updateTranslation(
    ...     pofile_sr, nopriv, {0: u'another suggestion'}, is_fuzzy=False,
    ...     is_imported=False, lock_timestamp=datetime.now(UTC))
    >>> transaction.commit()
    >>> another_suggestion.is_hidden
    False
    >>> new_current_translation.is_hidden
    False

== translations & all_msgstrs ==

    >>> message = potmsgset.getCurrentTranslationMessage(serbian)
    >>> message.translations
    [u'new']

The all_msgstrs attribute gives us the full list of translations for
all supported plural forms, even if they are None.

    >>> for translation in message.all_msgstrs:
    ...     if translation is None:
    ...         print 'None'
    ...     else:
    ...         print translation.translation
    new
    None
    None
    None

== destroySelf ==

(Note: keep this test last because of tearDown())

With this method, we allow to remove a submission, it comes from SQLObject,
but we test it here to be sure it appears in our public interface.

We will need extra permissions to use this method.

    >>> from canonical.launchpad.ftests.harness import (
    ...     LaunchpadFunctionalTestSetup)
    >>> LaunchpadFunctionalTestSetup(dbuser='rosettaadmin').setUp()

Select an existing ITranslationMessage and try to remove it.

    >>> translationmessage = TranslationMessage.get(1)
    >>> translationmessage.destroySelf()

It should not exist now.

    >>> translationmessage = TranslationMessage.get(1)
    Traceback (most recent call last):
    ...
    SQLObjectNotFound:...

    # NOTE: Once this has executed, you may experience strange
    # failures.  Keep this test at the bottom.
    >>> LaunchpadFunctionalTestSetup().tearDown()


== Composing SQL involving plural forms ==

SQL Queries involving the TranslationMessage.msgstr* attributes often
get repetitive.  We have some helper functions to make it easier on the
eyes.

    >>> from canonical.launchpad.database.translationmessage import (
    ...     make_plurals_fragment, make_plurals_sql_fragment)

The helper function make_plurals_fragment repeats a fragment of text
for the number of plural forms we support (starting at zero).

    >>> print make_plurals_fragment("x%(form)dx", ", ")
    x0x,
    x1x,
    x2x,
    x3x

Composing text like this happens most in WHERE clauses of SQL queries.
The make_plurals_sql_fragment helper adds some parentheses and spaces
where you might otherwise forget them--or want to.

    >>> print make_plurals_sql_fragment("msgstr%(form)d IS NOT NULL")
    (msgstr0 IS NOT NULL) AND
    (msgstr1 IS NOT NULL) AND
    (msgstr2 IS NOT NULL) AND
    (msgstr3 IS NOT NULL)

The sub-clauses don't have to be tied together with AND:

    >>> print make_plurals_sql_fragment("msgstr%(form)d IS NULL", "OR")
    (msgstr0 IS NULL) OR
    (msgstr1 IS NULL) OR
    (msgstr2 IS NULL) OR
    (msgstr3 IS NULL)

