= BuildQueue =

BuildQueue class represents the run-time-records of builds being
processed.

See buildd-queuebuilder.txt for more information about the BuildQueue
initialisation.

BuildQueue should provide all the information needed for dispatching
and collecting build results.

As soon as a build job is processed succesfully (dispatched &
collected) the BuildQueue record representing it is removed.

 >>> from canonical.launchpad.webapp.testing import verifyObject
 >>> from canonical.launchpad.interfaces import IBuildQueue
 >>> from canonical.launchpad.interfaces import IBuildQueueSet

Get an instance of Builder from the current sampledata using the
IBuildQueueSet zope utility. The zope utility itself will be
documented later on this document, we are only using it to retrive an
IBuildQueue record with the security proxies in place:

 >>> bq = getUtility(IBuildQueueSet).get(1)

Instances returned by IBuildQueueSet provides the IBuildQueue interface:

 >>> verifyObject(IBuildQueue, bq)
 True

The IBuild record related to this job is provided by the 'build'
attribute:

 >>> bq.build.id
 8
 >>> bq.build.buildstate.name
 'BUILDING'

The static timestamps, representing when the record was initialised
(inserted) and when the job was dispatched are provided as datetime
instances:

 >>> bq.created
 datetime.datetime(...)

 >>> bq.buildstart
 datetime.datetime(...)

Check Builder foreign key, which indicated which builder 'is processing'
the job in question:

The 'builder' attribute provides the IBuilder instance of the builder
currently processing this job:

 >>> bq.builder.name
 u'bob'

'logtail' is a text field which stores up to 1 Kbyte of the last
logged actions during the build process, it is updated according the
frequency set in buildd-slavescanner, normally 10 seconds, see
buildd-slavescanner.txt for further information:

 >>> bq.logtail
 u'Dummy sampledata entry, not processing'

'lastscore' is the heuristic index generated by queuebuilder to order
the dispatching process, see more information in
buildd-queuebuilder.txt:

 >>> bq.lastscore
 1

'manual' is a boolean, which is meant to suppress the auto-scoring
procedure, i.e., when it is set the job do not get re-scored, it is
used to manually reorder jobs via the web UI:

 >>> bq.manual
 False

BuildQueue provides a property which calculates the partial duration
of the build procedure (NOW - buildstart), it's mainly used in the UI.

 >>> bq.buildduration
 datetime.timedelta(...)

Published component name, it looks over the publishing records and
find the current publication of the source in question.

 >>> bq.component_name
 u'main'

it is not necessary the same than the:

 >>> bq.build.sourcepackagerelease.component.name
 u'main'

which is the component the source was originally uploaded to, before
any overriding action.

Some local properties inherited from related content classes:

 >>> bq.archseries.id == bq.build.distroarchseries.id
 True
 >>> bq.urgency == bq.build.sourcepackagerelease.urgency
 True
 >>> bq.archhintlist == bq.build.sourcepackagerelease.architecturehintlist
 True
 >>> bq.name == bq.build.sourcepackagerelease.name
 True
 >>> bq.version == bq.build.sourcepackagerelease.version
 True
 >>> bq.files.count() == bq.build.sourcepackagerelease.files.count()
 True
 >>> bq.builddependsindep == bq.build.sourcepackagerelease.builddependsindep
 True

BuildQueue provides the name for the logfile resulting from the build:

 >>> bq.getLogFileName()
 u'buildlog_ubuntu-hoary-i386.mozilla-firefox_0.9_BUILDING.txt'
 
BuildQueue provides a method to handle "manual scoring" procedure
properly, in order to retain the manually set score we need to
set 'manual' attribute atomically. For this we use manualScore:

 >>> pending_bq = getUtility(IBuildQueueSet).get(2)

 >>> pending_bq.manual, pending_bq.lastscore
 (False, 10)
 >>> pending_bq.manualScore(1000)

 >>> pending_bq.manual, pending_bq.lastscore
 (True, 1000)


Now perform the tests for the BuildQueue zope utility, BuildQueueSet.
Check if the instance returned as utility corresponds to its
respective interface:

 >>> bqset = getUtility(IBuildQueueSet)
 >>> verifyObject(IBuildQueueSet, bqset)
 True

IBuildQueueSet utility is iterable:

 >>> for bq in bqset:
 ...     bq.id
 1
 2

Also provides a getter:

 >>> bqset[1].id
 1

a 'get' method:

 >>> bqset.get(2).id
 2

and a full counter:

 >>> bqset.count()
 2

IBuildQueueSet provides a method to retrieve the active job:

 >>> for bq in bqset.getActiveBuildJobs():
 ...     bq.id, bq.builder.name
 (1, u'bob')

A method to fetch all BuildQueue instances inside a list of ids (see
build.txt):

 >>> for bq in bqset.fetchByBuildIds([1, 2, 8]):
 ...     bq.id, bq.build.id
 (1, 8)

Another method to fetch the BuildQueue being processed for a builder,
there should be only one since the builders are sigle-task
applications:

 >>> from canonical.launchpad.interfaces import IBuilderSet
 >>> bob = getUtility(IBuilderSet)['bob']

 >>> current_job = bqset.getByBuilder(bob)
 >>> current_job.builder.name
 u'bob'

BuildQueueSet provides a method used in the builddmaster context to
calculate retrieve every instance in given state for a set of
distroarchseriess.

 >>> from canonical.lp.dbschema import BuildStatus
 >>> state = BuildStatus.NEEDSBUILD

 >>> from canonical.launchpad.interfaces import IDistributionSet
 >>> hoary_i386 = getUtility(IDistributionSet)['ubuntu']['hoary']['i386']
 >>> archserieses = [hoary_i386]

 >>> for bq in bqset.calculateCandidates(archserieses, state):
 ...     bq.id, bq.build.buildstate.name, bq.build.distroarchseries.title
 (2, 'NEEDSBUILD', u'The Hoary Hedgehog Release for i386 (x86)')

This method tolerates broken arguments, even None or an empty list
result in a valid SQLResult, empty though.

 >>> bqset.calculateCandidates(None, state).count()
 0
 >>> bqset.calculateCandidates([], state).count()
 0
