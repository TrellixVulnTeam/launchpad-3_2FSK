= User-to-user direct email contact =

A Launchpad user can contact another Launchpad user directly, even if the
recipient is hiding their email addresses.

    >>> def create_view(sender, recipient, form=None):
    ...     if form is None:
    ...         method = 'GET'
    ...     else:
    ...         method = 'POST'
    ...     return create_initialized_view(
    ...         recipient, '+contactuser',
    ...         form=form, method=method, principal=sender)

For example, let's say No Privileges Person wants to contact Salgado...

    >>> from zope.component import getUtility
    >>> from canonical.launchpad.interfaces.person import IPersonSet
    >>> person_set = getUtility(IPersonSet)
    >>> no_priv = person_set.getByName('no-priv')
    >>> salgado = person_set.getByName('salgado')

...No Priv would start by going to Salgado's +contactuser page.

    >>> from canonical.launchpad.ftests import login
    >>> login(no_priv.preferredemail.email)
    >>> view = create_view(no_priv, salgado)

This contact is allowed.

    >>> print view.label
    Contact Guilherme Salgado
    >>> view.contact_is_allowed
    True

No Priv changes her mind though.

    >>> print view.cancel_url
    http://launchpad.dev/~salgado

No Priv decides, what the heck, let's contact Salgado after all.

    >>> view = create_view(
    ...     no_priv, salgado, {
    ...     'field.field.from_': 'no-priv@canonical.com',
    ...     'field.subject': 'Hello Salgado',
    ...     'field.message': 'Can you tell me about your project?',
    ...     'field.actions.send': 'Send',
    ...     })
    >>> for notification in view.request.notifications:
    ...     print notification.message
    Message sent to Guilherme Salgado

    # Capture the date of the last contact for later.
    >>> from canonical.config import config
    >>> from canonical.launchpad.database.message import UserToUserEmail
    >>> from canonical.lazr.config import as_timedelta
    >>> from storm.locals import Store
    >>> first_contact = Store.of(no_priv).find(
    ...     UserToUserEmail,
    ...     UserToUserEmail.sender == no_priv).one()
    >>> expires = first_contact.date_sent + as_timedelta(
    ...     config.launchpad.user_to_user_throttle_interval)

No Priv sends two more messages to Salgado.  Each of these are allowed too.

    >>> view = create_view(
    ...     no_priv, salgado, {
    ...     'field.field.from_': 'no-priv@canonical.com',
    ...     'field.subject': 'Hello Salgado',
    ...     'field.message': 'Can you tell me about your project?',
    ...     'field.actions.send': 'Send',
    ...     })
    >>> for notification in view.request.notifications:
    ...     print notification.message
    Message sent to Guilherme Salgado

    >>> view = create_view(
    ...     no_priv, salgado, {
    ...     'field.field.from_': 'no-priv@canonical.com',
    ...     'field.subject': 'Hello Salgado',
    ...     'field.message': 'Can you tell me about your project?',
    ...     'field.actions.send': 'Send',
    ...     })
    >>> for notification in view.request.notifications:
    ...     print notification.message
    Message sent to Guilherme Salgado

Now however, No Priv had reached her quota for direct user-to-user contact and
is not allowed to send a fourth message today.

    >>> view = create_view(no_priv, salgado)
    >>> view.contact_is_allowed
    False

No Priv can try again later.

    >>> view.next_try == expires
    True

As a corner case, let's say the number of notifications allowed was greater
yesterday than it was today.

    >>> config.push('seven_allowed', """\
    ... [launchpad]
    ... user_to_user_max_messages: 7
    ... """)

No Priv can actually try again right now.

    >>> from datetime import datetime
    >>> import pytz
    >>> view.next_try <= datetime.now(pytz.timezone('UTC'))
    True

So, No Priv sends four more emails.

    >>> for i in range(4):
    ...     assert create_view(no_priv, salgado).contact_is_allowed, (
    ...         'Contact was not allowed? %s' % i)
    ...     view = create_view(
    ...         no_priv, salgado, {
    ...         'field.field.from_': 'no-priv@canonical.com',
    ...         'field.subject': 'Hello Salgado',
    ...         'field.message': 'Can you tell me about your project?',
    ...         'field.actions.send': 'Send',
    ...         })
    ...     for notification in view.request.notifications:
    ...         print notification.message
    Message sent to Guilherme Salgado
    Message sent to Guilherme Salgado
    Message sent to Guilherme Salgado
    Message sent to Guilherme Salgado

No Priv has once again reached her limit of emails.

    >>> view = create_view(no_priv, salgado)
    >>> view.contact_is_allowed
    False
    >>> view.next_try == expires
    True

The configuration changes back to allow only three emails.

    >>> config.pop('seven_allowed')
    (...)
    >>> contacts = Store.of(no_priv).find(
    ...     UserToUserEmail,
    ...     UserToUserEmail.sender == no_priv)
    >>> contact = list(contacts)[4]
    >>> expires = contact.date_sent + as_timedelta(
    ...     config.launchpad.user_to_user_throttle_interval)


== Non-ASCII names ==

Carlos has non-ASCII characters in his name.  When he sends a message to a
user, his real name will be properly RFC 2047 encoded.

    >>> transaction.abort()
    >>> from canonical.launchpad.mail import stub
    >>> del stub.test_emails[:]
    >>> len(stub.test_emails)
    0

    >>> carlos = person_set.getByName('carlos')
    >>> login('carlos@canonical.com')
    >>> view = create_view(
    ...     carlos, no_priv, {
    ...     'field.field.from_': 'carlos@canonical.com',
    ...     'field.subject': 'Hello No Priv',
    ...     'field.message': 'I see funny characters',
    ...     'field.actions.send': 'Send',
    ...     })
    >>> transaction.commit()

    >>> len(stub.test_emails)
    1
    >>> from_addr, to_addrs, raw_msg = stub.test_emails.pop()
    >>> print raw_msg
    Content-Type: text/plain; charset="us-ascii"
    ...
    From: =?utf-8?q?Carlos_Perell=C3=B3_Mar=C3=ADn?= <carlos@canonical.com>
    To: No Privileges Person <no-priv@canonical.com>
    ...

Similarly, if Carlos is the recipient of a message, his real name will be
properly RFC 2047 encoded as well.

    >>> del stub.test_emails[:]

    >>> login('no-priv@canonical.com')
    >>> view = create_view(
    ...     no_priv, carlos, {
    ...     'field.field.from_': 'no-priv@canonical.com',
    ...     'field.subject': 'Hello Carlos',
    ...     'field.message': 'I see funny characters',
    ...     'field.actions.send': 'Send',
    ...     })
    >>> transaction.commit()

    >>> len(stub.test_emails)
    1
    >>> from_addr, to_addrs, raw_msg = stub.test_emails.pop()
    >>> print raw_msg
    Content-Type: text/plain; charset="us-ascii"
    ...
    From: No Privileges Person <no-priv@canonical.com>
    To: =?utf-8?q?Carlos_Perell=C3=B3_Mar=C3=ADn?= <carlos@canonical.com>
    ...


== Hidden addresses ==

Salgado decides to hide his email addresses.

    >>> login_person(salgado)
    >>> salgado.hide_email_addresses = True

Anne contacts Salgado even though his email addresses are hidden.

    >>> anne = factory.makePerson(email='anne@example.com', name='anne')
    >>> logout()
    >>> login_person(anne)

    >>> view = create_view(
    ...     anne, salgado, {
    ...         'field.field.from_': 'anne@example.com',
    ...         'field.subject': 'Hello Salgado',
    ...         'field.message': 'It is nice to meet you',
    ...         'field.actions.send': 'Send',
    ...         })
    >>> for notification in view.request.notifications:
    ...     print notification.message
    Message sent to Guilherme Salgado
