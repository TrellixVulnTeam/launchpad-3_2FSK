= Navigation components =

To say how objects get traversed, how their breadcrumbs appear, and what their
canonical url looks like, you use navigation components.  These are defined
in `canonical/launchpad/browser/`, alongside the view classes.

To define a navigation component, write a class that derives from
canonical.launchpad.webapp.Navigation.

    >>> from canonical.launchpad.webapp import Navigation

When you write a navigation class, you can do four kinds of things.

 - Say what object is stepped to when a particular name is the next step.
   Example, for the root object:

   @stepto('malone')
   def malone(self):
       return getUtility(IMaloneApplication)

 - Say how traversal works when you going through the next step onto the one
   after it.
   Example, for a Product:

   @stepthrough('+bug')
   def traverse_bug(self, name):
       return self.context.getBug(name)

 - Say that particular steps result in a redirection to some other name.
   Example, for a Product:

   redirection('+bug', '+bugs')

 - Say how traversal works for anything not handled by the other rules.
   Example:

   def traverse(self, name):
       return self.context[name]

Note that when you say you want to step to some name, then the method is
named after the name you're stepping to.  When you say you want to step
through some name, then you name the method 'traverse_name' as in
'traverse_bug' above.  This is because the method takes a 'name' argument
and you're saying how traversal is interpreted.  This is similar to the
catch-all 'traverse()' method.


== Demonstrating a navigation class ==


In order to demonstrate a navigation class, we need to create an interface
for the thing being navigated.  Rather than use a standard Launchpad interface,
we'll define one here.

    >>> from zope.interface import Interface, Attribute, implements

    >>> class IThingSet(Interface):
    ...     """An interface we're using in this doctest."""
    ...
    ...     def getThing(name):
    ...         """Returns the thing that has the given name.
    ...
    ...         Returns None if there is no thing.
    ...         """

    >>> from zope.publisher.interfaces.browser import IBrowserRequest

    >>> class Response(object):
    ...
    ...     redirected_to = None
    ...
    ...     def redirect(self, name):
    ...         self.redirected_to = name

    >>> class Request(object):
    ...     implements(IBrowserRequest)
    ...
    ...     def __init__(self):
    ...         self.traversal_stack = []
    ...         self._traversed_names = []
    ...         self.response = Response()
    ...
    ...     def getTraversalStack(self):
    ...         return self.traversal_stack
    ...
    ...     def setTraversalStack(self, stack):
    ...         self.traversal_stack = stack

    >>> request = Request()

    >>> class IThing(Interface):
    ...
    ...     value = Attribute('the value of the thing')

    >>> class Thing(object):
    ...     implements(IThing)
    ...
    ...     def __init__(self, value):
    ...         self.value = value
    ...
    ...     def __repr__(self):
    ...         return "Thing '%s'" % self.value

    >>> class ThingSet(object):
    ...     implements(IThingSet)
    ...
    ...     def getThing(self, name):
    ...         if name.startswith('t'):
    ...             return Thing(name.upper())
    ...         else:
    ...             return None

    >>> thingset = ThingSet()

    >>> class INewLayer(Interface):
    ...     """New layer for the request."""


Navigation components look up the next object to traverse to according to
the following rules.

    0. Before traversal, set a new layer, if required.
    1. Look up views on the context object.
    2. See if the name is registered as a 'stepto' traversal.  If so, do it.
    3. See if the name is registered as a 'stepthrough' traversal.  If so,
       do it.
    4. Check whether a view is registered for that name.  If it is, use it.
    5. If a redirection is registered for that name, do the redirection.
    6. Finally, use the `traverse()` method.
    7. If the `traverse()` method returns None or raises NotFoundError,
       then issue a NotFound error page.

To demonstrate the navigation rules, we'll start off with a simple
navigation class, and gradually add in more complex traversal as we go.


== Simple navigation class ==

The first simple navigation class traverses according to the following
rules:

    0. Before traversal, set a new layer, if required.
    1. Look up views on the context object.
    6. Finally, use the `traverse()` method.
    7. If the `traverse()` method returns None or raises NotFoundError,
       then issue a NotFound error page.

The 'traverse' method returns the object that is traversed to.  It can get
the context and the request as `self.context` and `self.request`, as in view
classes.  The method can either return `None` or raise NotFoundError (or a
subclass of NotFoundError) to indicate that the object is not found.  Although
in Python we usually aim for having just one way to do something, often we're
dealing with traversing content objects using a variety of methods, some of
which return None to indicate 'not found' and some that raise NotFoundError.

    >>> class ThingSetNavigation(Navigation):
    ...
    ...     usedfor = IThingSet
    ...
    ...     newlayer = INewLayer
    ...
    ...     def traverse(self, name):
    ...         return self.context.getThing(name)

    >>> navigation = ThingSetNavigation(thingset, request)

The name doesn't begin with a 't', so it isn't found.

    >>> INewLayer.providedBy(request)
    False
    >>> navigation.publishTraverse(request, 'xxx')
    Traceback (most recent call last):
    ...
    NotFound: ...ThingSet...name: 'xxx'

Also, note that the request has been put onto the INewLayer layer.

    >>> INewLayer.providedBy(request)
    True

The name begins with a 't', so the thing's value is TTT.

    >>> navigation.publishTraverse(request, 'ttt')
    Thing 'TTT'

The name begins with a 't', so the thing's value is THINGVIEW.

    >>> navigation.publishTraverse(request, 'thingview')
    Thing 'THINGVIEW'


== ZCML for browser:navigation ==

The zcml processor `browser:navigation` processes navigation classes.

    >>> class ThingSetView:
    ...
    ...     def __call__(self):
    ...         return "a view on a thingset"

    >>> import canonical.launchpad.ftests
    >>> canonical.launchpad.ftests.ThingSetView = ThingSetView
    >>> canonical.launchpad.ftests.ThingSetNavigation = ThingSetNavigation
    >>> canonical.launchpad.ftests.IThingSet = IThingSet

    >>> from zope.configuration import xmlconfig
    >>> zcmlcontext = xmlconfig.string("""
    ... <configure xmlns:browser="http://namespaces.zope.org/browser">
    ...   <include file="lib/canonical/launchpad/webapp/meta.zcml" />
    ...   <include file="lib/zope/app/meta.zcml" />
    ...   <browser:navigation
    ...       module="canonical.launchpad.ftests"
    ...       classes="ThingSetNavigation"
    ...       />
    ...   <browser:page
    ...       for="canonical.launchpad.ftests.IThingSet"
    ...       name="thingview"
    ...       class="canonical.launchpad.ftests.ThingSetView"
    ...       attribute="__call__"
    ...       permission="zope.Public"
    ...       />
    ... </configure>
    ... """)

This time, we get the view object for the page that was registered.

    >>> navigation.publishTraverse(request, 'thingview')
    <...ThingSetView object...>
    >>> navigation.publishTraverse(request, 'thingview')()
    'a view on a thingset'

== stepto traversals ==

You can say that there is a traversal to a fixed name that is handled by
a particular method.  Use the function decorator @stepto('name') for this.

This is step two:

    2. See if the name is registered as a 'stepto' traversal.  If so, do it.

Let's create a subclass of ThingSetNavigation, and add a 'stepto'.

    >>> from canonical.launchpad.webapp import stepto

    >>> class ThingSetNavigation2(ThingSetNavigation):
    ...
    ...     @stepto('thistle')
    ...     def thistle(self):
    ...         return 'A little thistle'

    >>> navigation2 = ThingSetNavigation2(thingset, request)

    >>> navigation2.publishTraverse(request, 'ttt')
    Thing 'TTT'
    >>> navigation2.publishTraverse(request, 'thingview')()
    'a view on a thingset'
    >>> navigation2.publishTraverse(request, 'thistle')
    'A little thistle'


== stepthrough traversals ==

You can say that there is a traversal to particular subobjects that occurs
through a particular "namespace", such as '+bug' or '+language'.

This is step three:

    3. See if the name is registered as a 'stepthrough' traversal.  If so,
       do it.

Let's create another subclass and add a stepthrough.

    >>> from canonical.launchpad.webapp import stepthrough

    >>> class ThingSetNavigation3(ThingSetNavigation):
    ...
    ...     @stepthrough('toad')
    ...     def traverse_toad(self, name):
    ...         return 'the toad called %s' % name

    >>> request.traversal_stack = ['prince', 'charming']
    >>> navigation3 = ThingSetNavigation3(thingset, request)
    >>> navigation3.publishTraverse(request, 'toad')
    'the toad called charming'

Check that the request's state is as it should be.

    >>> request.traversal_stack
    ['prince']
    >>> request._traversed_names
    ['charming']


== redirection ==

You can register that particular names are to be redirected to other names.
You do this using the class advisor function redirection(namefrom, nameto).

This is step five:

    5. If a redirection is registered for that name, do the redirection.

Let's make another navigation class to test redirection.

    >>> from canonical.launchpad.webapp import redirection

    >>> class ThingSetNavigation4(ThingSetNavigation):
    ...
    ...     redirection('tree', 'trees')
    ...     redirection('toad', 'toads')

    >>> navigation4 = ThingSetNavigation4(thingset, request)
    >>> navigation4.publishTraverse(request, 'tree')
    <...RedirectionView...>
    >>> navigation4.publishTraverse(request, 'tree')()
    ''
    >>> request.response.redirected_to
    'trees'

    >>> navigation4.publishTraverse(request, 'toad')()
    ''
    >>> request.response.redirected_to
    'toads'

Make a clean request.

    >>> request = Request()


== Putting it all together ==

One of the advantages of using classes for traversal is that you can define
a mix-in class that defines traversal and redirection for a particular
namespace, and then mix this in where needed.  An example from Launchpad is
to define a mix-in navigation class for bug targets that defines traversal
stepping through '+bug' and also redirection from '+bug' to '+bugs'.

Such a class can be mixed into the navigation class of any object that
functions as a bug target.  Note that such a class will usually not be a
Navigation class; that is, it should not derive from Navigation.

Let's define one of those, using all the navigation classes we have made
so far, and also defining some more stepthroughs and steptos and redirections.

    >>> class UberEverythingThingNavigation(
    ...     ThingSetNavigation2, ThingSetNavigation3, ThingSetNavigation4):
    ...
    ...     @stepto('teeth')
    ...     def teeth(self):
    ...         return 'some teeth'
    ...
    ...     @stepthrough('diplodocus')
    ...     def traverse_diplodocus(self, name):
    ...         return 'diplodocus called %s' % name
    ...
    ...     redirection('topology', 'topologies')

    >>> ubernav = UberEverythingThingNavigation(thingset, request)

Check out the traversals defined directly.

    >>> ubernav.publishTraverse(request, 'teeth')
    'some teeth'

    >>> ubernav.publishTraverse(request, 'diplodocus')
    Traceback (most recent call last):
    ...
    NotFound: ...ThingSet...name: 'diplodocus'

    >>> request.traversal_stack = ['frank']
    >>> ubernav.publishTraverse(request, 'diplodocus')
    'diplodocus called frank'

    >>> ubernav.publishTraverse(request, 'topology')()
    ''
    >>> request.response.redirected_to
    'topologies'

Check those from ThingSetNavigation, implicitly:

    >>> ubernav.publishTraverse(request, 'ttt')
    Thing 'TTT'

    >>> ubernav.publishTraverse(request, 'thingview')()
    'a view on a thingset'

Check those from ThingSetNavigation2:

    >>> ubernav.publishTraverse(request, 'thistle')
    'A little thistle'

Check those from ThingSetNavigation3:

    >>> request.traversal_stack = ['prince', 'charming']
    >>> ubernav.publishTraverse(request, 'toad')
    'the toad called charming'

    >>> request.traversal_stack = []

Check those from ThingSetNavigation4:

    >>> ubernav.publishTraverse(request, 'tree')()
    ''
    >>> request.response.redirected_to
    'trees'

    >>> ubernav.publishTraverse(request, 'toad')()
    ''
    >>> request.response.redirected_to
    'toads'

== Testing that multiple inheritence involving decorator advisors works ==

    >>> class A:
    ...
    ...     @stepto('foo')
    ...     def traverse_foo(self):
    ...         return 'foo'

    >>> class B:
    ...
    ...     @stepto('bar')
    ...     def traverse_bar(self):
    ...         return 'bar'

    >>> class C(Navigation, A, B):
    ...
    ...     @stepto('baz')
    ...     def traverse_baz(self):
    ...         return 'baz'

    >>> instance_of_c = C(thingset, request)
    >>> instance_of_c.publishTraverse(request, 'foo')
    'foo'
    >>> instance_of_c.publishTraverse(request, 'bar')
    'bar'
    >>> instance_of_c.publishTraverse(request, 'baz')
    'baz'

