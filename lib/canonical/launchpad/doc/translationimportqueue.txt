TranslationImportQueueEntry
===========================

The TranslationImportQueueEntry is an entry of the queue that will be imported
into Rosetta.

guessed_pofile
--------------

This property gives us the IPOFile where we think we should import this entry.

To test it, we need to add an entry to the queue.

Here we have some imports and utility fetch.

    >>> import transaction
    >>> from zope.component import getUtility
    >>> from canonical.database.sqlbase import flush_database_updates
    >>> from canonical.launchpad.interfaces import ITranslationImportQueue
    >>> from canonical.launchpad.interfaces import ILaunchpadCelebrities
    >>> from canonical.launchpad.database import ProductSeries
    >>> from canonical.launchpad.database import DistroRelease
    >>> from canonical.launchpad.database import SourcePackageName
    >>> from canonical.launchpad.ftests import login
    >>> from canonical.lp.dbschema import RosettaImportStatus
    >>> translationimportqueue = getUtility(ITranslationImportQueue)
    >>> rosetta_expert = getUtility(ILaunchpadCelebrities).rosetta_expert

First, we are going to try to do the guess against the Evolution product. That
means that we are going to use the ProductSeries.id = 3

    >>> evolution_productseries = ProductSeries.get(3)

Attach the file to the product series, without associate it with any potemplate.

    >>> entry = translationimportqueue.addOrUpdateEntry(
    ...     'po/sr.po', 'foo', True, rosetta_expert,
    ...      productseries=evolution_productseries)

This entry has no information about the IPOFile where it should be attached to:

    >>> entry.import_into == None
    True

And the guessing algorithm will not be able to guess anything as there is no
IPOFiles on the same path and we have two IPOTemplates on the same path where
this IPOFile is located ('po/')

    >>> entry.guessed_pofile == None
    True

Now let's try the same against the evolution sourcepackage that only has an
IPOTemplate.

    >>> hoary_distrorelease = DistroRelease.get(3)
    >>> evolution_sourcepackagename = SourcePackageName.get(9)
    >>> entry = translationimportqueue.addOrUpdateEntry(
    ...     'po/sr.po', 'foo', True, rosetta_expert,
    ...      distrorelease=hoary_distrorelease,
    ...      sourcepackagename=evolution_sourcepackagename)
    >>> transaction.commit()

This entry has no information about the IPOFile where it should be attached to:

    >>> entry.import_into == None
    True

And the guessing algorithm is able to give us an IPOFile where it should be
imported.

    >>> entry.guessed_pofile == None
    False

    >>> entry.guessed_pofile.title
    u'Serbian (sr) translation of evolution-2.2 in Ubuntu Hoary package "evolution"'


Let's try now to update the entries.

We need to know the status that the entry has.

    >>> entry.status.title
    'Needs Review'

And store current creation and status change date:

    >>> previous_dateimported = entry.dateimported
    >>> previous_date_status_changed = entry.date_status_changed

Now, we do a new upload.

    >>> entry = translationimportqueue.addOrUpdateEntry(
    ...     'po/sr.po', 'foo', True, rosetta_expert,
    ...      distrorelease=hoary_distrorelease,
    ...      sourcepackagename=evolution_sourcepackagename)
    >>> transaction.commit()

And the new status is

    >>> entry.status.title
    'Needs Review'

The dateimported remains the same as it was already waiting to be imported.

    >>> entry.dateimported == previous_dateimported
    True

And the date_status_changed is newer

    >>> entry.date_status_changed > previous_date_status_changed
    True

Let's change now its status to imported and see what happens. To do it,
we need to be logged in as an admin.

    >>> login('carlos@canonical.com')
    >>> entry.status = RosettaImportStatus.IMPORTED

Need to update our saved date_status_changed to detect if it changes now.

    >>> previous_date_status_changed = entry.date_status_changed

Do the new upload.

    >>> po_sr_entry = translationimportqueue.addOrUpdateEntry(
    ...     'po/sr.po', 'foo', True, rosetta_expert,
    ...      distrorelease=hoary_distrorelease,
    ...      sourcepackagename=evolution_sourcepackagename)

And the new status is

    >>> po_sr_entry.status.title
    'Needs Review'

The dateimported remains the same as it was already waiting to be imported.

    >>> po_sr_entry.dateimported > previous_dateimported
    True

And the date_status_changed is newer

    >>> po_sr_entry.date_status_changed > previous_date_status_changed
    True

First, we import a new .pot file.

    >>> pot_entry = translationimportqueue.addOrUpdateEntry(
    ...     'po/evolution-2.2.pot', 'foo', True, rosetta_expert,
    ...      distrorelease=hoary_distrorelease,
    ...      sourcepackagename=evolution_sourcepackagename)

Reset any pofile/potemplate information we have for the po_sr_entry.

    >>> po_sr_entry.potemplate = None

Change the pofile.path value

    >>> pofile = po_sr_entry.guessed_pofile
    >>> if pofile is not None:
    ...     pofile.path = u'po/sr-old.po'

XXX: CarlosPerelloMarin 20060331 If flush_database_updates is removed from
here we don't see the pofile.path change and the internal code path that we
want to check here doesn't work. For more information, see bug #3989

    >>> flush_database_updates()
    >>> transaction.commit()

Now, let's check that we cannot find the pot_entry as a POTemplate because
the way our code works, we cannot guess it while we have a .pot file pending
to be imported.

    >>> pot_entry.status.title
    'Needs Review'
    >>> po_sr_entry.guessed_pofile is not None
    False

But if that entry is imported, the guessing algorithm works.

    >>> pot_entry.status = RosettaImportStatus.IMPORTED
    >>> po_sr_entry.guessed_pofile is not None
    True

guessed_pofile with KDE
-----------------------

KDE has a non standard layout where the .pot files are stored inside the
sourcepackage with the binaries that will use it and the translations are
stored in external packages following the same language pack ideas that we
use with Ubuntu. This layout breaks completely Rosetta because we don't have
a way to link the .po and .pot files coming from different packages. For this
case, we use some extra information to get that link between different
sourcepackages.

The info we use is:
    - The sourcepackagename: All KDE language packs have
      the sourcepackagename following this pattern:
      kde-i18n-LANGCODE. We get from here the language where the .po
      files belong.
    - The .po filename: All .po files are stored using the translation
      domain as its filename. This information helps us to get the
      IPOTemplate where we should associate this .po file.

To do this test, we are going to do all in a single transaction and will
rollback it when it's finished.


First, we are going to add three new sourcepackagenames for this test,
kdebase, kde-i18n-es and kde-i18n-srlatn. The first is from where the .pot
file come and the others have .po files.

    >>> from canonical.launchpad.interfaces import ISourcePackageNameSet
    >>> sourcepackagenameset = getUtility(ISourcePackageNameSet)
    >>> kdebase = sourcepackagenameset.new('kdebase')
    >>> kde_i18n_es = sourcepackagenameset.new('kde-i18n-es')
    >>> kde_i18n_srlatn = sourcepackagenameset.new('kde-i18n-srlatn')

Let's attach the .pot file

    >>> kde_pot_entry = translationimportqueue.addOrUpdateEntry(
    ...     'po/kdebugdialog.pot', 'foo content', True, rosetta_expert,
    ...      distrorelease=hoary_distrorelease,
    ...      sourcepackagename=kdebase)

Create the template name and attach this new import to it.

    >>> from canonical.launchpad.interfaces import IPOTemplateNameSet
    >>> from canonical.launchpad.interfaces import IPOTemplateSet
    >>> potemplatenameset = getUtility(IPOTemplateNameSet)
    >>> kdebugdialog_template_name = potemplatenameset.new(
    ...     'kdebugdialog', 'kdebugdialog')
    >>> potemplateset = getUtility(IPOTemplateSet)
    >>> subset = potemplateset.getSubset(
    ...     distrorelease=hoary_distrorelease, sourcepackagename=kdebase)
    >>> kde_pot_entry.potemplate = subset.new(
    ...     kdebugdialog_template_name, 'po/kdebugdialog.pot', rosetta_expert)
    >>> kde_pot_entry.potemplate.title
    u'Template "kdebugdialog" in Ubuntu Hoary package "kdebase"'

And set this entry as already imported.

    >>> kde_pot_entry.status = RosettaImportStatus.IMPORTED
    >>> flush_database_updates()

Let's attach a .po file from kde-i18n-es

    >>> es_entry = translationimportqueue.addOrUpdateEntry(
    ...     'messages/kdebase/kdebugdialog.po', 'foo content', True,
    ...     rosetta_expert, distrorelease=hoary_distrorelease,
    ...      sourcepackagename=kde_i18n_es)

And we will get the right IPOFile.

    >>> es_entry.guessed_pofile.title
    u'Spanish (es) translation of kdebugdialog in Ubuntu Hoary package "kdebase"'

The kde-i18n-srlatn is a bit special, the language is sr@Latn and we should be
able to know that.

    >>> srlatn_entry = translationimportqueue.addOrUpdateEntry(
    ...     'messages/kdebase/kdebugdialog.po', 'foo content', True,
    ...     rosetta_expert, distrorelease=hoary_distrorelease,
    ...      sourcepackagename=kde_i18n_srlatn)

And we will get the right IPOFile.

    >>> srlatn_entry.guessed_pofile.title
    u'Serbian (sr) translation of kdebugdialog in Ubuntu Hoary package "kdebase"'
    >>> srlatn_entry.guessed_pofile.variant
    u'Latn'

Finally, we abort the transaction to undo all changes done.

    >>> transaction.abort()


executeOptimisticBlock
---------------------

This method looks on the queue to find entries to block based on other .pot
entries that are stored on the same directory and are already blocked.

Check the number of entries on the queue.

    >>> len(translationimportqueue)
    3

First, let's check the status of the existing entries.

    >>> entry1 = translationimportqueue.get(1)
    >>> entry1.path
    u'po/sr.po'
    >>> entry1.status == RosettaImportStatus.NEEDS_REVIEW
    True

    >>> entry2 = translationimportqueue.get(2)
    >>> entry2.path
    u'po/sr.po'
    >>> entry2.status == RosettaImportStatus.NEEDS_REVIEW
    True

    >>> entry3 = translationimportqueue.get(3)
    >>> entry3.path
    u'po/evolution-2.2.pot'

We need it blocked for this test.

    >>> entry3.status = RosettaImportStatus.BLOCKED

Let's see how many entries are blocked.

    >>> translationimportqueue.executeOptimisticBlock()
    1

Now is time to check that we only have one item on the NeedsReview status.

    >>> entry1 = translationimportqueue.get(1)
    >>> entry1.path
    u'po/sr.po'

This entry is form a productseries, and it's not blocked because the blocked
.pot entry is for a distrorelease-sourcepackagename.

    >>> entry1.status == RosettaImportStatus.NEEDS_REVIEW
    True

On the other hand, this other one is for the same
distrorelease/sourcepackagename than the .pot file we have so it's also blocked.

    >>> entry2 = translationimportqueue.get(2)
    >>> entry2.path
    u'po/sr.po'
    >>> entry2.status == RosettaImportStatus.BLOCKED
    True

And the .pot entry is still blocked.

    >>> entry3 = translationimportqueue.get(3)
    >>> entry3.path
    u'po/evolution-2.2.pot'
    >>> entry3.status == RosettaImportStatus.BLOCKED
    True


TranslationImportQueue
======================

The translation import queue is the place where the new translation imports
end before being imported into Rosetta.


getTemplatesOnSameDirectory
---------------------------

This method allows us to get the set of .pot files we have on the same
directory that a given entry.

For the first entry, we don't have any .pot file on that directory.

    >>> entry1.status = RosettaImportStatus.NEEDS_REVIEW
    >>> entries = entry1.getTemplatesOnSameDirectory()
    >>> entries.count()
    0

For the second entry, we have one.

    >>> entry2.status = RosettaImportStatus.NEEDS_REVIEW
    >>> entries = entry2.getTemplatesOnSameDirectory()
    >>> entries.count()
    1

Which is blocked.

    >>> entries[0].status == RosettaImportStatus.BLOCKED
    True

And finally, the .pot entry doesn't have other .pot in the same directory and
obviously, we are not returning it as being at the same directory as it makes
no sense at all.

    >>> entry3.status = RosettaImportStatus.NEEDS_REVIEW
    >>> entries = entry3.getTemplatesOnSameDirectory()
    >>> entries.count()
    0
