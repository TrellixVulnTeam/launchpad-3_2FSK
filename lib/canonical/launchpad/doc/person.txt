= Person =

The Person class is overloaded to represent both people and teams. Let's
log in as Robert Collins to ensure we have the privileges to do what
we're going to demonstrate.

    >>> from zope.component import getUtility
    >>> from zope.interface.verify import verifyObject
    >>> from canonical.database.sqlbase import sqlvalues, flush_database_updates
    >>> from canonical.launchpad.interfaces import (
    ...     IPersonSet, IPerson, IEmailAddressSet)
    >>> from canonical.launchpad.ftests import login, ANONYMOUS
    >>> from canonical.launchpad.helpers import contactEmailAddresses
    >>> from canonical.lp.dbschema import EmailAddressStatus

    >>> login(ANONYMOUS)

    >>> personset = getUtility(IPersonSet)
    >>> emailset = getUtility(IEmailAddressSet)

Verify that foobar (a Person object) correctly implements IPerson.

    >>> foobar = personset.getByName('name16')
    >>> verifyObject(IPerson, foobar)
    True

== The IPersonSet utility ==

Access to people (Persons or Teams) is done through the IPersonSet
utility:

You can create a new person using the createPersonAndEmail method of
IPersonSet. All you need for that is a valid email address. You can also
hide the user email addresses.

Some of our scripts may create Person entries, and in these cases they must
provide a rationale and a comment (optional) for the creation of that Person
entry. These are displayed on the home pages of unvalidated Launchpad
profiles, to make it clear that those profiles were not created by the
people they represent and why they had to be created. Because the comment
will be displayed verbatim in a web page, it must start with the word "when"
followed by a description of the action that caused the entry to be created.

    >>> from canonical.lp.dbschema import PersonCreationRationale
    >>> p, email = personset.createPersonAndEmail(
    ...     'randomuser@randomhost.com', PersonCreationRationale.POFILEIMPORT,
    ...     comment='when importing the Portuguese translation of firefox',
    ...     hide_email_addresses=True)
    >>> p.teamowner is None
    True
    >>> email.status == EmailAddressStatus.NEW
    True
    >>> p.is_valid_person # Not valid because no preferred email address
    False
    >>> p.hide_email_addresses
    True

When a new sourcepackage is imported and a Person entry has to be created
because we don't know about the maintainer of that package, the code to create
the person should look like this:

    >>> person, emailaddress = personset.createPersonAndEmail(
    ...     'random@random.com', PersonCreationRationale.SOURCEPACKAGEIMPORT,
    ...     comment='when the ed package was imported into Ubuntu Breezy')
    >>> person.is_valid_person
    False
    >>> person.creation_comment
    u'when the ed package was imported into Ubuntu Breezy'


In case of failure of creating a new person or email the method returns
(None, None). Let's demonstrate this trying to create a person with
an invalid email.

    >>> p2, invalid_email = personset.createPersonAndEmail(
    ...     'test#canonical.com', PersonCreationRationale.UNKNOWN)
    >>> p2, invalid_email
    (None, None)

And now with the same name of a existing account

    >>> p3, invalid_email = personset.createPersonAndEmail(
    ...     'randomemail@randomhost.com', PersonCreationRationale.UNKNOWN,
    ...     name='name12')
    >>> p3, invalid_email
    (None, None)

    >>> vcs_imports = personset.getByName('vcs-imports')
    >>> vcs_imports.teamowner is None
    False
    >>> vcs_imports.is_valid_person # Not valid person because it is a team
    False
    >>> lifeless = personset.getByName('lifeless')
    >>> lifeless.teamowner is None
    True

=== Ubunteros ===

Anybody who signed the last version of Ubuntu's Code of Conduct is considered
an Ubuntero.  To list all Ubunteros, use IPersonSet.getUbunteros():

    >>> [p.name for p in personset.getUbunteros()]
    [u'name16']

To check if a person is an Ubuntero, use IPerson.is_ubuntero:

    >>> foobar.is_ubuntero
    True

== Teams ==

As we said above, the Person class is overloaded to represent teams so
we may have Person objects which are, in fact, teams. To find out
whether a given object is a person or a team we can use the isTeam()
method of IPerson or check if the object provides the ITeam interface.

    >>> from canonical.launchpad.interfaces import ITeam
    >>> ddaa = personset.getByName('ddaa')
    >>> ddaa.isTeam()
    False
    >>> ITeam.providedBy(ddaa)
    False

    >>> landscape_devs = personset.getByName('landscape-developers')
    >>> landscape_devs.isTeam()
    True
    >>> ITeam.providedBy(landscape_devs)
    True

=== Team members ===

The relationship between a person and a team is stored in TeamMemberships
table. TeamMemberships have a status (which can be any item of
TeamMembershipStatus) and represent the current state of the relationship
between that person and that team. Only TeamMembershipStatus with an ADMIN
or APPROVED status are considered active.

    >>> [member.displayname for member in landscape_devs.approvedmembers]
    [u'Guilherme Salgado']
    >>> [member.displayname for member in landscape_devs.adminmembers]
    [u'Sample Person']

The IPerson.activemembers property will always include all approved and admin
members of that team.

    >>> [member.displayname for member in landscape_devs.activemembers]
    [u'Guilherme Salgado', u'Sample Person']

TeamMemberships with a PROPOSED or INVITED status represent a person/team
which has proposed himself as a member or which has been invited to join
the team.

    >>> [member.displayname for member in landscape_devs.proposedmembers]
    [u'Foo Bar']
    >>> [member.displayname for member in landscape_devs.invited_members]
    [u'Launchpad Developers']

Similarly, we have IPerson.pendingmembers which includes both invited and
proposed members.

    >>> [member.displayname for member in landscape_devs.pendingmembers]
    [u'Foo Bar', u'Launchpad Developers']

Finally, we have EXPIRED and DEACTIVATED TeamMemberships, which represent
former (inactive) members of a team.

    >>> [member.displayname for member in landscape_devs.expiredmembers]
    [u'Karl Tilbury']
    >>> [member.displayname for member in landscape_devs.deactivatedmembers]
    [u'No Privileges Person']

We can get a list of all inactive members of a team with the
IPerson.inactivemembers property.

    >>> [member.displayname for member in landscape_devs.inactivemembers]
    [u'Karl Tilbury', u'No Privileges Person']

We can also iterate over the TeamMemberships themselves, which is useful
when we want to display details about them rather than just the member.

    >>> [(membership.person.displayname, membership.status.name)
    ...  for membership in landscape_devs.getActiveMemberships()]
    [(u'Guilherme Salgado', 'APPROVED'), (u'Sample Person', 'ADMIN')]
    >>> [(membership.person.displayname, membership.status.name)
    ...  for membership in landscape_devs.getInvitedMemberships()]
    [(u'Launchpad Developers', 'INVITED')]
    >>> [(membership.person.displayname, membership.status.name)
    ...  for membership in landscape_devs.getProposedMemberships()]
    [(u'Foo Bar', 'PROPOSED')]
    >>> [(membership.person.displayname, membership.status.name)
    ...  for membership in landscape_devs.getInactiveMemberships()]
    [(u'Karl Tilbury', 'EXPIRED'), (u'No Privileges Person', 'DEACTIVATED')]

An IPerson has an inTeam method to allow us to easily check if a
person is a member (directly or through other teams) of a team. It
accepts an object implementing IPerson, which is the common use case
when checking permissions.

    >>> ddaa.is_valid_person
    True
    >>> lifeless.inTeam(vcs_imports) and ddaa.inTeam(vcs_imports)
    True

That method can also be used to check that a given IPerson is a member of
itself. We can do that because people and teams have TeamParticipation
entries for themselves.

    >>> ddaa.inTeam(ddaa)
    True
    >>> ddaa.hasParticipationEntryFor(ddaa)
    True

    >>> vcs_imports.inTeam(vcs_imports)
    True
    >>> vcs_imports.hasParticipationEntryFor(vcs_imports)
    True

The inTeam method is cached to avoid unnecessary database lookups - this
was a cause of a number of timeouts

    >>> from zope.security.proxy import removeSecurityProxy
    >>> naked_lifeless = removeSecurityProxy(lifeless)
    >>> naked_lifeless._inTeam_cache[vcs_imports.id]
    True
    >>> naked_lifeless._inTeam_cache[vcs_imports.id] = False
    >>> lifeless.inTeam(vcs_imports)
    False
    >>> naked_lifeless._inTeam_cache[vcs_imports.id] = True
    >>> lifeless.inTeam(vcs_imports)
    True

=== Email notifications to teams ===

If a team has a contact email address, all notifications we send to the
team will go to that address.

    >>> ubuntu_team = personset.getByName('ubuntu-team')
    >>> ubuntu_team.preferredemail.email
    u'support@ubuntu.com'
    >>> contactEmailAddresses(ubuntu_team)
    set(['support@ubuntu.com'])

On the other hand, if a team doesn't have a contact email address, all
notifications we send to the team will go to the preferred email of
each direct member of that team.

    >>> vcs_imports.preferredemail is None
    True
    >>> sorted(member.preferredemail.email
    ...        for member in vcs_imports.activemembers)
    [u'david.allouche@canonical.com', u'foo.bar@canonical.com',
     u'robertc@robertcollins.net']
    >>> sorted(contactEmailAddresses(vcs_imports))
    ['david.allouche@canonical.com', 'foo.bar@canonical.com',
     'robertc@robertcollins.net']


== Renaming persons ==

All persons have a unique name in launchpad, so to allow them to change their
names, we must make sure that name is not already in use by someone else.

    >>> from canonical.launchpad.interfaces.person import PersonNameField
    >>> field = PersonNameField(__name__='name', title=u'Unique name',
    ...                         description=u'', readonly=False, required=True)
    >>> field = field.bind(lifeless)
    >>> field.context == lifeless
    True

You can always use your own name.

    >>> field.validate(lifeless.name)

Or a name that is not already in use.

    >>> field.validate(u'namenotinuse')

But you can't use Mark's name, of course. ;)

    >>> field.validate(u'sabdfl')
    Traceback (most recent call last):
      ...
    LaunchpadValidationError: ...sabdfl is already in use by another
    person or team...


== Searching ==

You can search based on a person's name or displayname, or any of the email
addresses that belongs to a person using the methods provided by IPersonSet.

While we don't have Full Text Indexes in the emailaddress table, we'll be
trying to match the text only against the beginning of an email address:

    >>> results = personset.find('ubuntu')
    >>> for person in results:
    ...     emails = [email.email for email in emailset.getByPerson(person)]
    ...     (person.displayname, person.name, emails)
    (u'Mirror Administrators', u'ubuntu-mirror-admins', [])
    (u'Sigurd Gartmann', u'sigurd-ubuntu', [u'sigurd-ubuntu@brogar.org'])
    (u'Ubuntu Gnome Team', u'name18', [])
    (u'Ubuntu Team', u'ubuntu-team', [u'support@ubuntu.com'])
    (u'Ubuntu Translators', u'ubuntu-translators', [])

    >>> results = personset.find('steve.alexander')
    >>> for person in results:
    ...     emails = [email.email for email in emailset.getByPerson(person)]
    ...     (person.displayname, person.name, emails)
    (u'Steve Alexander', u'stevea', [u'steve.alexander@ubuntulinux.com'])

Searching only for People based on their names or email addresses:

    >>> results = personset.findPerson('james.blackwell')
    >>> for person in results:
    ...     emails = [email.email for email in emailset.getByPerson(person)]
    ...     (person.displayname, person.name, emails)
    (u'James Blackwell', u'jblack', [u'james.blackwell@ubuntulinux.com'])

    >>> results = personset.findPerson('dave')
    >>> for person in results:
    ...     emails = [email.email for email in emailset.getByPerson(person)]
    ...     (person.displayname, person.name, emails)
    (u'Dave Miller', u'justdave', [u'dave.miller@ubuntulinux.com', u'justdave@bugzilla.org'])

Searching only for Teams based on their names or email addresses:

    >>> results = personset.findTeam('support')
    >>> for person in results:
    ...     emails = [email.email for email in emailset.getByPerson(person)]
    ...     (person.displayname, person.name, emails)
    (u'Ubuntu Team', u'ubuntu-team', [u'support@ubuntu.com'])

    >>> results = personset.findTeam('translators')
    >>> for person in results:
    ...     emails = [email.email for email in emailset.getByPerson(person)]
    ...     (person.displayname, person.name, emails)
    (u'Ubuntu Translators', u'ubuntu-translators', [])


== Packages related to a person ==

To obtain the packages a person is related to, we can use the
latestMaintainedPackages() and latestUploadedButNotMaintainedPackages()
methods of IPersonSet. The former will return the latest
SourcePackageReleases a person uploaded in which he is listed as the
Maintainer. The latter will return the latest SourcePackageReleases a
person uploaded (where he isn't the maintainer).

    >>> sabdfl = personset.getByName('sabdfl')
    >>> for sprelease in sabdfl.latestMaintainedPackages():
    ...     print (sprelease.name, sprelease.uploaddistroseries.fullseriesname,
    ...            sprelease.version)
    (u'alsa-utils', u'Debian Sid', u'1.0.9a-4')
    (u'pmount', u'Ubuntu Hoary', u'0.1-2')
    (u'netapplet', u'Ubuntu Warty', u'0.99.6-1')
    (u'netapplet', u'Ubuntu Hoary', u'1.0-1')
    (u'alsa-utils', u'Ubuntu Warty', u'1.0.8-1ubuntu1')
    (u'mozilla-firefox', u'Ubuntu Hoary', u'0.9')
    (u'evolution', u'Ubuntu Hoary', u'1.0')

    >>> for sprelease in sabdfl.latestUploadedButNotMaintainedPackages():
    ...     print (sprelease.name, sprelease.uploaddistroseries.fullseriesname,
    ...            sprelease.version)
    (u'language-pack-de', u'Ubuntu Breezy-autotest', u'1.0')
    (u'foobar', u'Ubuntu Breezy-autotest', u'1.0')
    (u'cdrkit', u'Ubuntu Breezy-autotest', u'1.0')
    (u'cnews', u'Ubuntu Breezy-autotest', u'1.0')
    (u'libstdc++', u'Ubuntu Hoary', u'b8p')
    (u'cnews', u'Ubuntu Hoary', u'cr.g7-37')
    (u'linux-source-2.6.15', u'Ubuntu Hoary', u'2.6.15.3')
    (u'at', u'Ubuntu Hoary', u'0.00')
    (u'alsa-utils', u'Ubuntu Hoary', u'1.0.9a-4ubuntu1')


== Translations ==

The IPerson interface offers a way of returning POFileTranslator records
for a Person:

  >>> carlos = getUtility(IPersonSet).getByName('carlos')
  >>> [pt.pofile.title for pt in carlos.translation_history]
  [u'Spanish (es) translation of alsa-utils in alsa-utils trunk',
   u'Spanish (es) translation of man in Ubuntu Hoary package "evolution"',
   u'Spanish (es) translation of evolution-2.2 in Evolution trunk',
   u'Japanese (ja) translation of evolution-2.2 in Ubuntu Hoary package "evolution"',
   u'Spanish (es) translation of evolution-2.2 in Ubuntu Hoary package "evolution"']

The IPersonSet component contains a few convenience methods to return
Person objects that have contributed translations.

  >>> from canonical.launchpad.database import POFile
  >>> pofile = POFile.get(12)
  >>> [p.name for p in personset.getPOFileContributors(pofile)]
  [u'carlos', u'name16', u'tsukimi']

getPOFileContributorsByDistroSeries gives the list of people that did
contributions to templates that are current in the given IDistroSeries
and ILanguage.

  >>> from canonical.launchpad.database import DistroSeries, Language
  >>> hoary = DistroSeries.selectOneBy(name="hoary")
  >>> spanish = Language.selectOneBy(code="es")
  >>> [p.name for p in personset.getPOFileContributorsByDistroSeries(hoary, spanish)]
  [u'jorge-gonzalez-gonzalez', u'carlos', u'valyag', u'danner', u'name16',
   u'name12', u'tsukimi']

  # We can see that there is another translator that doesn't appear in
  # previous list because the template he translated is not current.
  >>> non_current_pofile = POFile.get(31)
  >>> non_current_pofile.potemplate.iscurrent
  False
  >>> [p.name for p in personset.getPOFileContributors(non_current_pofile)]
  [u'jordi']
  >>> non_current_pofile.potemplate.distroseries == hoary
  True
  >>> non_current_pofile.language == spanish
  True


== Specification Lists ==

We should be able to generate lists of specifications for people based on
certain criteria:

First, Carlos does not have any completed specifications assigned to him:

    >>> from canonical.lp.dbschema import SpecificationFilter
    >>> carlos.specifications(filter=[
    ...     SpecificationFilter.ASSIGNEE, SpecificationFilter.COMPLETE]).count()
    0

Next, Carlos has three incomplete specs *related* to him:

    >>> filter = []
    >>> for spec in carlos.specifications(filter=filter):
    ...     print spec.name, spec.is_complete, spec.informational
    svg-support False False
    extension-manager-upgrades False True
    media-integrity-check False False

Carlos has 2 specifications assigned to him:

    >>> for spec in carlos.assigned_specs:
    ...     print spec.name
    svg-support
    extension-manager-upgrades

But from these two, only one has started.

    >>> [(spec.name, spec.is_started)
    ...  for spec in carlos.assigned_specs_in_progress]
    [(u'svg-support', True)]

Just for fun, lets check the SAB. He should have one spec for which he
is the approver.

    >>> sabdfl = getUtility(IPersonSet).getByName('sabdfl')
    >>> filter = [SpecificationFilter.APPROVER]
    >>> for spec in sabdfl.specifications(filter=filter):
    ...     print spec.name
    extension-manager-upgrades

The Foo Bar person has a single spec which has feedback requested:

    >>> filter = [SpecificationFilter.FEEDBACK]
    >>> for spec in foobar.specifications(filter=filter):
    ...     print spec.name
    e4x

But has registered 5 of them:

    >>> filter = [SpecificationFilter.CREATOR]
    >>> print foobar.specifications(filter=filter).count()
    5

Now Celso, on the other hand, has 2 specs related to him:

    >>> cprov = personset.getByName('cprov')
    >>> cprov.specifications().count()
    2

On one of those, he is the approver:

    >>> filter = [SpecificationFilter.APPROVER]
    >>> for spec in cprov.specifications(filter=filter):
    ...     print spec.name
    svg-support

And on another one, he is the drafter

    >>> filter = [SpecificationFilter.DRAFTER]
    >>> for spec in cprov.specifications(filter=filter):
    ...     print spec.name
    e4x

We can filter for specifications that contain specific text:

    >>> for spec in cprov.specifications(filter=['svg']):
    ...     print spec.name
    svg-support

Inactive products are excluded from the listings.

    >>> from canonical.database.sqlbase import flush_database_updates
    >>> from canonical.launchpad.interfaces import IProductSet
    >>> from canonical.launchpad.ftests import login
    >>> firefox = getUtility(IProductSet).getByName('firefox')
    >>> login("foo.bar@canonical.com")
    >>> firefox.active = False
    >>> flush_database_updates()
    >>> cprov.specifications(filter=['svg']).count()
    0

Reset firefox so we don't mess up later tests.

    >>> firefox.active = True
    >>> flush_database_updates()


Translators for a given language
--------------------------------

We can get the list of translators that did some translation in Launchpad and
expressed their interest for a concrete language.

  >>> from canonical.launchpad.interfaces import (
  ...     ILanguageSet, IPersonSet, IKarmaCacheManager)

  # Sample data is not complete for this test, so we need to note that another
  # Spanish translator expressed its interest on doing Spanish translations.
  # That other person is Foo Bar (name16).
  >>> personset = getUtility(IPersonSet)
  >>> foo_bar = personset.getByName('name16')
  >>> print foo_bar.displayname
  Foo Bar
  >>> languageset = getUtility(ILanguageSet)
  >>> spanish = languageset.getLanguageByCode('es')
  >>> foo_bar.addLanguage(spanish)
  >>> translators = personset.getTranslatorsByLanguage(spanish)
  >>> for translator in translators:
  ...     karma = 0
  ...     for karma_category_cache in translator.karma_category_caches:
  ...         if (karma_category_cache.category.name == 'translations'):
  ...             karma = karma_category_cache.karmavalue
  ...     print (translator.displayname, karma)
  (u'Foo Bar', 164)
  (u'Carlos Perell\xf3 Mar\xedn', 9)


Branches
--------

** See branch.txt for API related to branches.

