PO Imports
----------

The tale of a PO template and a PO file and how they get imported into
Rosetta.

    >>> from zope.app import datetimeutils

Here are some imports we need to get this test running.

    >>> from canonical.launchpad.ftests import syncUpdate
    >>> from canonical.launchpad.interfaces import ITranslationImportQueue
    >>> from canonical.launchpad.interfaces import IPersonSet
    >>> from canonical.launchpad.interfaces import ILaunchpadCelebrities
    >>> from canonical.launchpad.database import (
    ...     POTemplateSubset, SourcePackageName)
    >>> from canonical.launchpad.scripts.po_import import (
    ...     AutoApproveProcess, ImportProcess)
    >>> import datetime
    >>> import pytz
    >>> UTC = pytz.timezone('UTC')

We need this for the Librarian to work properly.

    >>> import transaction

And also, the DBSchema to change the imports status

    >>> from canonical.launchpad.interfaces import RosettaImportStatus

Then, let's get a handle to our mailer. This is the thing we'll examine to show
what email has been sent, to whom, and what the body of the message contains:

    >>> import email
    >>> from canonical.launchpad.mail import stub

Here's a fake logger to capture any errors that happen.

    >>> from canonical.launchpad.scripts import FakeLogger

Login as an admin to be able to do changes to the import queue.

    >>> login('carlos@canonical.com')

Now, is time to create the new potemplate

    >>> from canonical.launchpad.database import ProductRelease
    >>> release = ProductRelease.get(3)
    >>> release.productseries.product.name
    u'firefox'
    >>> series = release.productseries
    >>> subset = POTemplateSubset(productseries=series)

Here's the person who'll be doing the import.

    >>> person_set = getUtility(IPersonSet)
    >>> person = person_set.getByName('sabdfl')

And this is the POTemplate where the import will be done.

    >>> potemplate = subset.new(
    ...     name='firefox',
    ...     path='po/firefox.pot',
    ...     owner=person)

This is the file that'll get imported.

    >>> potemplate_contents = r'''
    ... msgid ""
    ... msgstr ""
    ... "POT-Creation-Date: 2004-07-11 16:16+0900\n"
    ... "Content-Type: text/plain; charset=CHARSET\n"
    ... "Plural-Forms: nplurals=INTEGER; plural=EXPRESSION;\n"
    ... "X-Rosetta-Export-Date: %s\n"
    ...
    ... msgid "foo"
    ... msgstr ""
    ...
    ... msgid "bar"
    ... msgstr ""
    ...
    ... #: test.c:13
    ... msgid "baz"
    ... msgstr ""
    ...
    ... #, c-format
    ... msgid "Foo %%s"
    ... msgstr ""
    ...
    ... #, c-format
    ... msgid "Singular %%d"
    ... msgid_plural "Plural %%d"
    ... msgstr[0] ""
    ... msgstr[1] ""
    ... ''' % datetime.datetime.now(UTC).isoformat()

Attach the import to the translations import queue:

    >>> translation_import_queue = getUtility(ITranslationImportQueue)
    >>> entry = translation_import_queue.addOrUpdateEntry(
    ...     potemplate.path, potemplate_contents, True, potemplate.owner,
    ...     productseries=series, potemplate=potemplate)

The file data is stored in the Librarian, so we have to commit the transaction
to make sure it's stored properly.

    >>> transaction.commit()

Since we haven't approved our entry yet, if we go through an import run now,
nothing happens.

    >>> original_import_status = entry.status
    >>> potemplate.importFromQueue(FakeLogger())
    >>> entry.status == original_import_status
    True

That also means we do not get an email about the import, though we will later.

    >>> transaction.commit()
    >>> len(stub.test_emails)
    0

Now the entry gets approved, so it'll be imported next time.

    >>> entry.status = RosettaImportStatus.APPROVED
    >>> syncUpdate(entry)

    >>> import datetime
    >>> import pytz
    >>> UTC = pytz.timezone('UTC')
    >>> saved_date = datetime.datetime.now(UTC)


Now, we tell the PO template to import from the file data it has.

    >>> potemplate.importFromQueue(FakeLogger())

Our request has now been serviced.

    >>> print entry.status.name
    IMPORTED

The last update date is the one we got.

    >>> potemplate.date_last_updated > saved_date
    True

A successful import is confirmed by email.

    >>> transaction.commit()
    >>> len(stub.test_emails)
    1
    >>> from_addr, to_addrs, raw_message = stub.test_emails.pop()
    >>> msg = email.message_from_string(raw_message)
    >>> msg["Subject"]
    'Translation template import - firefox in Mozilla Firefox trunk'
    >>> print msg.get_payload(decode=True)
    Hello Mark Shuttleworth,
    <BLANKLINE>
    On ..., you uploaded a translation
    template for firefox in Mozilla Firefox trunk in Launchpad.
    <BLANKLINE>
    The template has now been imported successfully.
    <BLANKLINE>
    Thank you,
    <BLANKLINE>
    The Launchpad team

The correct message IDs now show up in the template.

    >>> potmsgsets = list(potemplate.getPOTMsgSets())
    >>> [potmsgset.msgid for potmsgset in potmsgsets]
    [u'foo', u'bar', u'baz', u'Foo %s', u'Singular %d']

The file references field should be there

    >>> potmsgsets[2].filereferences
    u'test.c:13'

Now let's get a PO file to import.

    >>> pofile = potemplate.newPOFile('cy')
    >>> pofile_id = pofile.id

By default, we got a safe path to prevent collisions with other IPOFile.

    >>> pofile.path
    u'po/firefox-cy.po'

Let's override the default good path with one we know is the right one.

    >>> pofile.path = u'po/cy.po'

It's newly created, so it has no message sets yet.

    >>> pofile.currentMessageSets().count()
    0

And the statistics reflect it.

    >>> pofile.currentCount()
    0

Here are the contents of the file we'll be importing. It has some validation
errors.

    >>> pofile_with_errors = r'''
    ... msgid ""
    ... msgstr ""
    ... "PO-Revision-Date: 2005-06-03 19:41+0100\n"
    ... "Last-Translator: Carlos Perello Marin <carlos@canonical.com>\n"
    ... "Content-Type: text/plain; charset=UTF-8\n"
    ... "Plural-Forms: nplurals=4; plural=n==1) ? 0 : n==2 ? 1 : (n != 8 || n != 11) ? 2 : 3;\n"
    ... "X-Rosetta-Export-Date: %s\n"
    ...
    ... msgid "foo"
    ... msgstr "blah"
    ...
    ... #, fuzzy
    ... msgid "bar"
    ... msgstr "heffalump"
    ...
    ... msgid "balloon"
    ... msgstr "blah"
    ...
    ... #, c-format
    ... msgid "Foo %%s"
    ... msgstr "blah %%i"
    ...
    ... #, c-format
    ... msgid "Singular %%d"
    ... msgid_plural "Plural %%d"
    ... msgstr[0] "Foos %%d"
    ... msgstr[1] "Bars %%d"
    ... msgstr[2] "Welsh power! %%d"
    ... msgstr[3] "We have four! %%d"
    ... ''' % datetime.datetime.now(UTC).isoformat()

This is the dbschema that controls the validation of a translation.
    >>> from canonical.launchpad.interfaces import TranslationValidationStatus

The process of importing a PO file is much like that of importing a PO
template. Remember, we need to tell the system that this po file is a
"published" one.

    >>> entry = translation_import_queue.addOrUpdateEntry(
    ...     pofile.path, pofile_with_errors, True, person,
    ...     productseries=series, potemplate=potemplate)
    >>> transaction.commit()

The guess IPOFile should be the same we already had.

    >>> entry.getGuessedPOFile().id == pofile.id
    True

Set it as the place where the entry should be imported.

    >>> entry.pofile = entry.getGuessedPOFile()

We must approve the entry to be able to import it.

    >>> entry.status = RosettaImportStatus.APPROVED
    >>> syncUpdate(entry)

And we do the import.

    >>> pofile.importFromQueue(FakeLogger())
    >>> flush_database_updates()

The status is now IMPORTED:

    >>> print entry.status.name
    IMPORTED

And the statistics reflect it.

    >>> pofile.currentCount()
    3

Here's a current message set: i.e. it has a corresponding current message set
in the PO template. It should not be publishedfuzzy.

    >>> messageSets = list(pofile.currentMessageSets())
    >>> messageSets[0].potmsgset.msgid
    u'foo'
    >>> messageSets[0].publishedfuzzy
    False

And should be accepted by our validator.

    >>> published = messageSets[0].getPublishedSubmission(0)
    >>> published.validationstatus == TranslationValidationStatus.OK
    True

And here's a non-current message set. It shouldn't be fuzzy either.

    >>> messageSets = list(pofile.getPOMsgSetsNotInTemplate())
    >>> messageSets[0].potmsgset.msgid
    u'balloon'
    >>> messageSets[0].publishedfuzzy
    False

This message set should be fuzzy, however.

    >>> messageSet = pofile.getPOMsgSet(u'bar')
    >>> messageSet.publishedfuzzy
    True

And as we don't have a translation for it over the web, it should
be the same for the active translation.

    >>> messageSet.isfuzzy
    True

And this one should have the validation status with an error.

    >>> messageSet = pofile.getPOMsgSet(u'Foo %s')
    >>> published = messageSet.getPublishedSubmission(0)
    >>> published.validationstatus == TranslationValidationStatus.UNKNOWNERROR
    True

Check that the plural form was imported correctly.

    >>> messageSet = pofile.getPOMsgSet(u'Singular %d')
    >>> published = messageSet.getPublishedSubmission(0)
    >>> published.validationstatus == TranslationValidationStatus.OK
    True
    >>> messageSet.published_texts
    [u'Foos %d', u'Bars %d', u'Welsh power! %d', u'We have four! %d']

The owner for those translations should be Carlos, instead of the person
that did the upload, because the imported file states that Carlos is the
translator.

    >>> published.person.displayname
    u'Carlos Perell\xf3 Mar\xedn'

Now, is time to check the notification email.

    >>> transaction.commit()

    >>> len(stub.test_emails)
    1

    >>> from_addr, to_addrs, raw_message = stub.test_emails.pop()
    >>> to_addrs
    ['mark@hbd.com']
    >>> msg = email.message_from_string(raw_message)
    >>> msg["Subject"]
    'Translation problems - Welsh (cy) - firefox in Mozilla Firefox trunk'
    >>> print msg.get_payload(decode=True)
    Hello Mark Shuttleworth,
    <BLANKLINE>
    On ..., you uploaded 5
    Welsh (cy) translations for firefox in Mozilla Firefox trunk in Launchpad.
    <BLANKLINE>
    There were problems with 1 of these translations.
    <BLANKLINE>
    4.  [msg 4]
    "format specifications in 'msgid' and 'msgstr' for argument 1 are not the same":
    <BLANKLINE>
    #, c-format
    msgid "Foo %s"
    msgstr "blah %i"
    <BLANKLINE>
    <BLANKLINE>
    <BLANKLINE>
    The other 4 translations have been accepted.
    <BLANKLINE>
    ...

Now, let's import one without errors.

    >>> rosetta_experts = getUtility(ILaunchpadCelebrities).rosetta_expert
    >>> pofile_without_errors = r'''
    ... msgid ""
    ... msgstr ""
    ... "PO-Revision-Date: 2005-06-03 20:41+0100\n"
    ... "Last-Translator: Foo <no-priv@canonical.com>\n"
    ... "Content-Type: text/plain; charset=UTF-8\n"
    ... "Plural-Forms: nplurals=4; plural=n==1) ? 0 : n==2 ? 1 : (n != 8 || n != 11) ? 2 : 3;\n"
    ... "X-Rosetta-Export-Date: %s\n"
    ...
    ... msgid "foo"
    ... msgstr "blah"
    ... ''' % datetime.datetime.now(UTC).isoformat()
    >>> entry = translation_import_queue.addOrUpdateEntry(
    ...     pofile.path, pofile_without_errors, True, rosetta_experts,
    ...     productseries=series, potemplate=potemplate)
    >>> transaction.commit()

The guess IPOFile should be the same we already had.

    >>> entry.getGuessedPOFile().id == pofile.id
    True

Set it as the place where the entry should be imported.

    >>> entry.pofile = entry.getGuessedPOFile()

We must approve the entry to be able to import it.

    >>> entry.status = RosettaImportStatus.APPROVED
    >>> syncUpdate(entry)

We do the import.

    >>> pofile.importFromQueue(FakeLogger())

The status is now IMPORTED:

    >>> print entry.status.name
    IMPORTED

And the statistics reflect it.

    >>> pofile.currentCount()
    1
    >>> pofile.updatesCount()
    0
    >>> pofile.rosettaCount()
    1

Check the notification email about the success of this import without errors.

    >>> transaction.commit()

    >>> len(stub.test_emails)
    1

    >>> from_addr, to_addrs, raw_message = stub.test_emails.pop()
    >>> msg = email.message_from_string(raw_message)
    >>> msg["Subject"]
    'Translation import - Welsh (cy) - firefox in Mozilla Firefox trunk'
    >>> print msg.get_payload(decode=True)
    Hello Rosetta Administrators,
    <BLANKLINE>
    ...

Check to be sure that we notify when a msgid_plural is changed without touch
the msgid

    >>> pofile_content = r'''
    ... msgid ""
    ... msgstr ""
    ... "PO-Revision-Date: 2005-06-04 20:41+0100\n"
    ... "Last-Translator: Foo <no-priv@canonical.com>\n"
    ... "Content-Type: text/plain; charset=UTF-8\n"
    ... "Plural-Forms: nplurals=2; plural=n==1 ? 0;\n"
    ... "X-Rosetta-Export-Date: %s\n"
    ...
    ... #, c-format
    ... msgid "Singular %%d"
    ... msgid_plural "Plurals %%d"
    ... msgstr[0] ""
    ... msgstr[1] ""
    ... ''' % datetime.datetime.now(UTC).isoformat()
    >>> entry = translation_import_queue.addOrUpdateEntry(
    ...     pofile.path, pofile_content, True, rosetta_experts,
    ...     productseries=series, potemplate=potemplate)
    >>> transaction.commit()
    >>> entry.pofile = entry.getGuessedPOFile()
    >>> entry.status = RosettaImportStatus.APPROVED
    >>> syncUpdate(entry)
    >>> pofile.importFromQueue(FakeLogger())
    >>> print entry.status.name
    IMPORTED

Now, is time to check the notification email.

    >>> transaction.commit()

    >>> len(stub.test_emails)
    1

    >>> from_addr, to_addrs, raw_message = stub.test_emails.pop()
    >>> msg = email.message_from_string(raw_message)
    >>> msg["Subject"]
    'Translation problems - Welsh (cy) - firefox in Mozilla Firefox trunk'
    >>> print msg.get_payload(decode=True)
    Hello Rosetta Administrators,
    <BLANKLINE>
    ...
    5.  [msg 0]
    "The msgid_plural field has changed since the last time this file was
    generated, please report this error to ...
    <BLANKLINE>
    #, c-format
    msgid "Singular %d"
    msgid_plural "Plurals %d"
    msgstr[0] ""
    msgstr[1] ""
    ...

We tested already that the functionality works. Now it's time to know if the
cronscript has any problem.

First, we are going to reactivate the entries that were already imported or
failed. Note that we'll only reactivate the entries we use in this test;
We don't touch entries that were in the queue previously.

    >>> for entry in translation_import_queue:
    ...     if (entry.status == RosettaImportStatus.IMPORTED or
    ...         entry.status == RosettaImportStatus.FAILED) and (
    ...         entry.productseries == series):
    ...         entry.status = RosettaImportStatus.APPROVED
    ...     syncUpdate(entry)
    >>> transaction.commit()

And run the import script.

    >>> process = ImportProcess(transaction, FakeLogger())
    >>> process.run()
    INFO    Importing: Template "firefox" in Mozilla Firefox trunk
    INFO    Importing: Welsh (cy) translation of firefox in Mozilla Firefox trunk
    WARNING Got an old version for Welsh (cy) translation of firefox in Mozilla Firefox trunk
    INFO    Importing: Welsh (cy) translation of firefox in Mozilla Firefox trunk
    INFO    Import requests completed.

Now the auto-approval script runs.  This can happen anytime, since it's
asynchronous to the po-import script.  The script tries to approve any entries
that have not been approved, but look like they could be, without human
intervention.  This involves a bit of guesswork about what the imported file
is and where it belongs.  It similarly blocks entries that it thinks should be
blocked, and also purges deleted or complted entries from the queue.  Running
at this point, all it does is purge the two hand-approved Welsh translations
that have just been imported.

    >>> process = AutoApproveProcess(transaction, FakeLogger())
    >>> process.run()
    INFO    Removed 2 entries from the queue.
    >>> transaction.commit()

It's time to test the import queue.

Here, we are going to test that if a file is imported twice, both are imported
following the order the users uploaded them.

    >>> first_pofile_content = r'''
    ... msgid ""
    ... msgstr ""
    ... "PO-Revision-Date: 2005-06-04 20:41+0100\n"
    ... "Last-Translator: Foo <no-priv@canonical.com>\n"
    ... "Content-Type: text/plain; charset=UTF-8\n"
    ... "X-Rosetta-Export-Date: %s\n"
    ...
    ... msgid "Foo"
    ... msgstr "Bar"
    ... ''' % datetime.datetime.now(UTC).isoformat()

    >>> second_pofile_content = r'''
    ... msgid ""
    ... msgstr ""
    ... "PO-Revision-Date: 2005-06-04 21:41+0100\n"
    ... "Last-Translator: Jordi Mallach <jordi@canonical.com>\n"
    ... "Content-Type: text/plain; charset=UTF-8\n"
    ... "X-Rosetta-Export-Date: %s\n"
    ...
    ... msgid "Foo"
    ... msgstr "Bars"
    ... ''' % datetime.datetime.now(UTC).isoformat()

We flush the entry contents.

    >>> for entry in translation_import_queue:
    ...     translation_import_queue.remove(entry)
    >>> translation_import_queue.entryCount()
    0

Attach the first version of the file.

    >>> entry = translation_import_queue.addOrUpdateEntry(
    ...     pofile.path, first_pofile_content, False, rosetta_experts,
    ...     sourcepackagename=pofile.potemplate.sourcepackagename,
    ...     distroseries=pofile.potemplate.distroseries,
    ...     productseries=pofile.potemplate.productseries)
    >>> transaction.commit()

It's in the queue now.

    >>> translation_import_queue.entryCount()
    1

For the second version, we need a new importer, in this case, Jordi.

    >>> jordi = person_set.getByName('jordi')

Attach the second version of the file.

    >>> entry = translation_import_queue.addOrUpdateEntry(
    ...     pofile.path, second_pofile_content, False, jordi,
    ...     sourcepackagename=pofile.potemplate.sourcepackagename,
    ...     distroseries=pofile.potemplate.distroseries,
    ...     productseries=pofile.potemplate.productseries)
    >>> transaction.commit()

It's in the queue now.

    >>> translation_import_queue.entryCount()
    2
    >>> print entry.status.name
    NEEDS_REVIEW

The auto-approval script runs again.  This time it sees the two submitted
translations and approves them for import based on some heuristic
intelligence.

    >>> process = AutoApproveProcess(transaction, FakeLogger())
    >>> process.run()
    INFO    The automatic approval system approved some entries.
    >>> print entry.status.name
    APPROVED
    >>> syncUpdate(entry)

Now that these submissions have been approved, the next run of the import
script picks them up and processes them.

    >>> process = ImportProcess(transaction, FakeLogger())
    >>> process.run()
    INFO    Importing: Welsh (cy) translation of firefox in Mozilla Firefox trunk
    INFO    Importing: Welsh (cy) translation of firefox in Mozilla Firefox trunk
    INFO    Import requests completed.

    >>> print entry.status.name
    IMPORTED
    >>> syncUpdate(entry)

And there are no more entries to import

    >>> translation_import_queue.getFirstEntryToImport() is None
    True

Imports so far have been associated with a product series.  We can also submit
translations for a distroseries.

    >>> from canonical.launchpad.interfaces.distribution import (
    ...     IDistributionSet)
    >>> ubuntu = getUtility(IDistributionSet).getByName('ubuntu')
    >>> warty = ubuntu.getSeries('warty')
    >>> print warty.name
    warty
    >>> firefox_name = SourcePackageName.byName('mozilla-firefox')
    >>> subset = POTemplateSubset(sourcepackagename=firefox_name,
    ...     distroseries=warty)
    >>> potemplate = subset.new(
    ...     name='firefox-warty',
    ...     path='po/firefox.pot',
    ...     owner=person)


As it happens, the administrator has blocked imports to warty, e.g. because an
in-database update of its translations has been scheduled and we don't want
interference from queued imports while that happens.  It doesn't really matter
whether entries still get auto-approved, but we can't accept new translation
imports just now.

    >>> warty.defer_translation_imports = True
    >>> syncUpdate(warty)

Nevertheless, someone submits an import request for warty, not knowing or
caring that imports are deferred.  The entry still gets approved as normal:

    >>> entry = translation_import_queue.addOrUpdateEntry(
    ...     potemplate.path, potemplate_contents, True, potemplate.owner,
    ...     sourcepackagename=firefox_name, distroseries=warty,
    ...     potemplate=potemplate)
    >>> entry.status = RosettaImportStatus.APPROVED
    >>> syncUpdate(entry)
    >>> transaction.commit()

Since imports for warty are suspended, and the only entry we happen to have
waiting right now is for warty, the queue has no importable entries for us.

    >>> warty.getFirstEntryToImport() is None
    True

So if we try to import now, nothing happens.  Our request remains on the queue,
but doesn't become a candidate for processing until warty imports are resumed.

    >>> pofile.importFromQueue(FakeLogger())

    >>> print entry.status.name
    APPROVED

Once imports are allowed again, the import is done after all.

    >>> warty.defer_translation_imports = False
    >>> syncUpdate(warty)
    >>> potemplate.importFromQueue(FakeLogger())

    >>> print entry.status.name
    IMPORTED


