= Blueprint dependencies =

Blueprints support the idea of dependencies. So, one blueprint can
require that another blueprint has been implemented before its own
implementation can begin. We record those dependencies in Launchpad.

Lets look at the dependencies of the "canvas" blueprint for Firefox. It depends
on another blueprint, "e4x". No blueprints depend on "canvas" itself.

  >>> admin_browser.open('http://blueprints.launchpad.dev/firefox/+spec/canvas')
  >>> print find_main_content(admin_browser.contents)
  <...
  ...Support E4X in EcmaScript...
  >>> 'Blocks' not in (admin_browser.contents)
  True

let's add a new dependency for the "canvas" blueprint. We'll add the
"extension-manager-upgrades" blueprint as a dependency. First, we confirm we can
see the page to add a dependency.

  >>> admin_browser.getLink('Add dependency').click()
  >>> admin_browser.url
  'http://blueprints.launchpad.dev/firefox/+spec/canvas/+linkdependency'

Now, lets POST the form, saying we want extension-manager-upgrades as the
dependency.

  >>> admin_browser.getControl(
  ...     'Depends On').value = 'extension-manager-upgrades'
  >>> admin_browser.getControl('Continue').click()
  >>> admin_browser.url
  'http://blueprints.launchpad.dev/firefox/+spec/canvas'

But we don't want to keep that, so we will remove it as a dependency. First
we make sure we can see the link to remove a dependency. We need to be
authenticated.

  >>> admin_browser.getLink('Remove dependency').click()
  >>> admin_browser.url
  'http://blueprints.launchpad.dev/firefox/+spec/canvas/+removedependency'

Now, we make sure we can load the page. It should show two potential
dependencies we could remove. The extension manager one, and "e4x".

  >>> admin_browser.getControl('Dependency').displayOptions
  ['Extension Manager System Upgrades', 'Support E4X in EcmaScript']

We'll POST the form selecting "extension-manager-upgrades" for removal. We
expect to be redirected to the blueprint page.

  >>> admin_browser.getControl(
  ...     'Dependency').value = ['extension-manager-upgrades']
  >>> admin_browser.getControl('Continue').click()
  >>> admin_browser.url
  'http://blueprints.launchpad.dev/firefox/+spec/canvas'

Blueprints can only depend on blueprints in the same project. To
show this, we register a blueprint for a different project.

  >>> admin_browser.open(
  ...     'http://blueprints.launchpad.dev/jokosher/+addspec')
  >>> admin_browser.getControl('Name').value = 'test-blueprint'
  >>> admin_browser.getControl('Title').value = 'Test Blueprint'
  >>> admin_browser.getControl('Summary').value = (
  ...     'Another blueprint in a different project')
  >>> admin_browser.getControl('Register Blueprint').click()
  >>> admin_browser.url
  'http://blueprints.launchpad.dev/jokosher/+spec/test-blueprint'

We then try to make the canvas blueprint in firefox depend on the
blueprint we registered in jokosher.

  >>> admin_browser.open(
  ...     'http://blueprints.launchpad.dev/firefox/'
  ...     '+spec/canvas/+linkdependency')
  >>> admin_browser.getControl(
  ...     'Depends On').value = 'test-blueprint'
  >>> admin_browser.getControl('Continue').click()
  >>> 'no blueprint named "test-blueprint"' in admin_browser.contents
  True

In order to prevent circular dependencies, it is impossible to mark a
blueprint A as depending on blueprint B, if B is already marked as
depending on A.

We know that "canvas" depends on "e4x". We try to make "e4x" depend on
"canvas".

  >>> admin_browser.open(
  ...     'http://blueprints.launchpad.dev/firefox/+spec/e4x/+linkdependency')
  >>> admin_browser.getControl(
  ...     'Depends On').value = 'canvas'
  >>> admin_browser.getControl('Continue').click()
  >>> 'no blueprint named "canvas"' in admin_browser.contents
  True

We know that no blueprints depend on "canvas", but "canvas" depends on "e4x"
and "e4x" depends on "svg-support". So the big picture is that "canvas"
needs to have both "e4x" and "svg-support" implemented before it can be
implemented, and nothing depends on having "canvas" implemented. The
"dependency tree" page for "canvas" should show exactly that.

  >>> anon_browser.open('http://launchpad.dev/firefox/+spec/canvas/+deptree')
  >>> print '----'; print anon_browser.contents
  ----
  ...Blueprints that must be implemented first...
  ...Support Native SVG Objects...
  ...Support E4X in EcmaScript...
  ...This blueprint...
  ...Support &lt;canvas&gt; Objects...
  ...Blueprints that can then be implemented...
  ...No blueprints depend on this one...

Also, since we have these blueprints with their priorities and dependencies
mapped out, we should be able to see a project plan for Mozilla Firefox.

  >>> anon_browser.open('http://launchpad.dev/firefox/+roadmap')

We have some nice tools to display the dependency tree as a client side
image and map.

With some versions of graphviz, the <area> for the current spec (canvas) does
not have a URL.  In other versions, there is no <area> for the current spec at
all.  To accomodate both these cases, that part of the output is elided.
Rendering a imagemap with non-ascii characters also works.

  >>> anon_browser.open('http://launchpad.dev/firefox/+spec/canvas/+deptreeimgtag')
  >>> print anon_browser.contents
  <img src="deptree.png" usemap="#deptree" />
  <map id="deptree" name="deptree"...
  <area shape="rect"
  href="http://blueprints.launchpad.dev/firefox/+spec/e4x" title="Support E4X in EcmaScript" alt="" coords="..." />
  <area shape="rect"
  href="http://blueprints.launchpad.dev/firefox/+spec/svg&#45;support" title="Support Native SVG Objects" alt="" coords="..." />
  </map>


Get the dependency chart, and check that it is a PNG.

  >>> anon_browser.open('http://launchpad.dev/firefox/+spec/canvas/deptree.png')
  >>> anon_browser.contents.startswith('\x89PNG')
  True
  >>> anon_browser.headers['content-type']
  'image/png'


We can also get the DOT output for a blueprint dependency graph.  This is useful
for experimenting with the dot layout using production data.

  >>> anon_browser.open('http://launchpad.dev/firefox/+spec/canvas/+deptreedotfile')
  >>> anon_browser.headers['content-type']
  'text/plain;charset=utf-8'
  >>> print anon_browser.contents
  digraph "deptree" {
  ...


Let's look at blueprints targetting a distribution, rather than a product.
We create two blueprints in `ubuntu`.

  >>> admin_browser.open('http://blueprints.launchpad.dev/ubuntu/+addspec')
  >>> admin_browser.getControl('Name').value = 'distro-blueprint-a'
  >>> admin_browser.getControl('Title').value = 'A blueprint for a distro'
  >>> admin_browser.getControl('Summary').value = (
  ...     'This is a blueprint for the Ubuntu distribution')
  >>> admin_browser.getControl('Register Blueprint').click()
  >>> print admin_browser.url
  http://blueprints.launchpad.dev/ubuntu/+spec/distro-blueprint-a

  >>> admin_browser.open('http://blueprints.launchpad.dev/ubuntu/+addspec')
  >>> admin_browser.getControl('Name').value = 'distro-blueprint-b'
  >>> admin_browser.getControl('Title').value = (
  ...     'Another blueprint for a distro')
  >>> admin_browser.getControl('Summary').value = (
  ...     'This is a blueprint for the Ubuntu distribution')
  >>> admin_browser.getControl('Register Blueprint').click()
  >>> print admin_browser.url
  http://blueprints.launchpad.dev/ubuntu/+spec/distro-blueprint-b

  >>> admin_browser.getLink('Add dependency').click()
  >>> print admin_browser.url
  http.../ubuntu/+spec/distro-blueprint-b/+linkdependency
  
  >>> admin_browser.getControl('Depends On').value = 'distro-blueprint-a'
  >>> admin_browser.getControl('Continue').click()

The blueprint was linked successfully, and it appears in the dependency
image map.

  >>> find_tag_by_id(admin_browser.contents, 'deptree')
  <...A blueprint for a distro...>
