= ExternalBugTracker: DebBugs =

Differently from Bugzilla, debbugs watch syncing is done by reading from
a local database, so we can use a real class for testing: we just need
to point it to our test debbugs db. Let's set up the db location for our
test:

    >>> import os.path
    >>> from canonical.launchpad.components.ftests import __file__
    >>> from canonical.config import config
    >>> OLD_DEBBUGS_LOCATION = config.malone.debbugs_db_location
    >>> test_db_location = os.path.join(
    ...     os.path.dirname(__file__), 'debbugs_db')
    >>> config.malone.debbugs_db_location = test_db_location

You can specify the db_location explicitly:

    >>> from canonical.launchpad.components.externalbugtracker import (
    ...     DebBugs)
    >>> from canonical.testing import LaunchpadZopelessLayer
    >>> txn = LaunchpadZopelessLayer.txn
    >>> external_debbugs = DebBugs(
    ...     'http://example.com/', db_location=test_db_location)
    >>> external_debbugs.db_location == test_db_location
    True

Or, if we create a DebBugs instance without specifying a db location, it
will use the config value:

    >>> external_debbugs = DebBugs('http://example.com/')
    >>> external_debbugs.db_location == config.malone.debbugs_db_location
    True


== Retrieving bug status from the debbugs database ==

The retrieval of the remote status is done through the
getRemoteStatus() method. If we pass a bug number that doesn't exist in
the debbugs db, BugNotFound is raised.

    >>> external_debbugs.getRemoteStatus('42')
    Traceback (most recent call last):
    ...
    BugNotFound: 42

If we pass a non-integer bug id, InvalidBugId is raised.

    >>> external_debbugs.getRemoteStatus('foo')
    Traceback (most recent call last):
    ...
    InvalidBugId: Debbugs bug number not an integer: foo

The debbugs database has two subdirectories in it. The db-h directory
contains current bugs, while the archive contains older bugs that have
been moved there manually. The DebBugs wrapper fetches bugs from them
transparently. Bug 237001 lives in db-h:

    >>> external_debbugs.getRemoteStatus('237001')
    'open normal'

Bug 563 resides in the archive. It is also fetchable:

    >>> external_debbugs.getRemoteStatus('563')
    'done normal'


== Getting the time ==

We don't have acccess to the Debian servers exact time, but we trust it
being correct.

    >>> external_debbugs.getCurrentDBTime()
    datetime.datetime(...)


== Checking debbugs bug watches ==

    >>> from canonical.launchpad.interfaces import IBugTrackerSet
    >>> debbugs = getUtility(IBugTrackerSet).getByName('debbugs')
    >>> bug_watches = list(debbugs.getBugWatchesNeedingUpdate(23))
    >>> len(bug_watches)
    5

Log in and kick off the update. The importing of comments, which is
controlled by a configuration option, is disabled here and will be
tested later.

    >>> from canonical.launchpad.scripts.checkwatches import BugWatchUpdater
    >>> bug_watch_updater = BugWatchUpdater(txn)
    >>> external_debbugs.import_comments = False
    >>> bug_watch_ids = [bug_watch.id for bug_watch in bug_watches]
    >>> bug_watch_updater.updateBugWatches(external_debbugs, bug_watches)
    INFO:...:Updating 5 watches on http://...

    >>> from canonical.launchpad.interfaces import IBugWatchSet
    >>> for bug_watch_id in bug_watch_ids:
    ...     bug_watch = getUtility(IBugWatchSet).get(bug_watch_id)
    ...     print "%s: %s" % (bug_watch.remotebug, bug_watch.remotestatus)
    280883: done grave woody security
    304014: open important
    308994: open important
    327452: done critical patch security
    327549: open important security

The lastchecked attribute got updated for each bug watch, so no more
watches are in need of an update:

    >>> flush_database_updates()
    >>> debbugs.getBugWatchesNeedingUpdate(23).count()
    0

And the linked bugtasks got updated:

    >>> import operator
    >>> bugtasks = []
    >>> for bug_watch in bug_watches:
    ...     bugtasks += list(bug_watch.bugtasks)
    >>> for bugtask in sorted(bugtasks, key=operator.attrgetter('id')):
    ...     print bugtask.bug.id, bugtask.bugtargetname, bugtask.status.title,
    ...     print bugtask.importance.title
    1 mozilla-firefox (Debian) New Unknown
    3 mozilla-firefox (Debian Sarge) New Unknown
    7 evolution (Debian) Fix Released Unknown
    15 thunderbird New Unknown

Sometimes the severity field is missing in the bug summary. That will
cause importance to be set to medium, equivalent to the default normal severity
in debbugs.

    >>> import email
    >>> summary = email.message_from_file(
    ...     open(os.path.join(
    ...         test_db_location, 'db-h', '01', '237001.summary')))
    >>> 'Severity' not in summary
    True

    >>> external_debbugs.getRemoteStatus('237001')
    'open normal'


== Debbugs status conversions ==

Let's take closer look at the status conversion. Debbugs has basically
only two statuses, 'open' and 'done', so in order to get a more fine
grained mapping to Malone statuses, we need to look at the tags as
well. The most simple mapping is from 'done', in debbugs it means that
the bug has been fixed and a new package with the fix has been
uploaded, so it maps to 'Fix Released.

    >>> print external_debbugs.convertRemoteStatus('done normal').title
    Fix Released

If the status is simply 'open', we map it to 'New', since
there's no way of knowing if the bug is confirmed or not.

    >>> print external_debbugs.convertRemoteStatus('open normal').title
    New

If the 'wontfix' tag is present we map it to "Won't Fix". The 'wontfix'
tag takes precedence over the confimed tags (help, confirmed, upstream,
fixed-upstream) since 'wontfix' is the state after confirmed. The 'wontfix'
tag also takes precedence over the fix-committed tags (pending, fixed,
fixed-in-experimental) since the malone status will correctly change to
fix-released when the debbugs status changes to 'done', so a nonsensical
combination of 'fixed' & 'wontfix' tags will only affect the malone status
temporarily.

    >>> print external_debbugs.convertRemoteStatus(
    ...         'open normal pending fixed fixed-in-experimental'
    ...         ' wontfix help confirmed upstream fixed-upstream').title
    Won't Fix

If the 'moreinfo' tag is present, we map the status to 'Needs Info'.

    >>> print external_debbugs.convertRemoteStatus(
    ...     'open normal moreinfo').title
    Incomplete

Of course, if the 'moreinfo' tag is present and the status is 'done',
we still map to 'Fix Released'.

    >>> print external_debbugs.convertRemoteStatus(
    ...     'done normal moreinfo').title
    Fix Released

If the 'help' tag is present, it means that the maintainer is
requesting help with the bug, so it's most likely a confirmed bug.

    >>> print external_debbugs.convertRemoteStatus('open normal help').title
    Confirmed

The 'pending' tag means that a fix is about to be uploaded, so it maps
to 'Fix Committed'.

    >>> print external_debbugs.convertRemoteStatus('open normal pending').title
    Fix Committed

The 'fixed' tag means that the bug has been either fixed or work around
somehow, but there's still an issue to be solved. We map it to 'Fix
Committed', so that people can see that a fix is available.

    >>> print external_debbugs.convertRemoteStatus('open normal fixed').title
    Fix Committed

If the bug is forwarded upstream, it should mean that it's a confirmed
bug.

    >>> print external_debbugs.convertRemoteStatus(
    ...     'open normal upstream').title
    Confirmed

And of course, if the maintainer marked the bug as 'confirmed'.

    >>> print external_debbugs.convertRemoteStatus(
    ...     'open normal confirmed').title
    Confirmed


If it has been fixed upstream, it's definitely a confirmed bug.

    >>> print external_debbugs.convertRemoteStatus(
    ...     'open normal fixed-upstream').title
    Confirmed

If it has been fixed in experimental, we mark it 'Fix Committed' until
the fix has reached the unstable distribution.

    >>> print external_debbugs.convertRemoteStatus(
    ...     'open normal fixed-in-experimental').title
    Fix Committed

All other tags we map to 'New'.

    >>> print external_debbugs.convertRemoteStatus(
    ...     'open normal unreproducible lfs woody').title
    New

If we pass in a malformed status string an UnknownRemoteStatusError will
be raised.

    >>> print external_debbugs.convertRemoteStatus('open')
    Traceback (most recent call last):
      ...
    UnknownRemoteStatusError


== Importing bugs ==

The Debbugs ExternalBugTracker can import a Debian bug into Launchpad.

    >>> from canonical.launchpad.webapp.testing import verifyObject
    >>> from canonical.launchpad.interfaces import ISupportsBugImport
    >>> verifyObject(ISupportsBugImport, external_debbugs)
    True

The bug reporter gets taken from the From field in the debbugs bug
report.

    >>> report = email.message_from_file(
    ...     open(os.path.join(
    ...         test_db_location, 'db-h', '35', '322535.report')))
    >>> print report['From']
    Moritz Muehlenhoff <jmm@inutil.org>

    >>> name, email = external_debbugs.getBugReporter('322535')
    >>> print name
    Moritz Muehlenhoff
    >>> print email
    jmm@inutil.org

The getBugSummaryAndDescription method reads the bug report from the
debbugs db, and returns the debbugs subject as the summary, and the
description as the description.

    >>> print report['Subject']
    evolution: Multiple format string vulnerabilities in Evolution

    >>> print report.get_payload(decode=True)
    Package: evolution
    Severity: grave
    Tags: security
    <BLANKLINE>
    Multiple exploitable format string vulnerabilities have been found in
    Evolution. Please see
    http://www.securityfocus.com/archive/1/407789/30/0/threaded
    for details. 2.3.7 fixes all these issues.
    ...

    >>> summary, description = external_debbugs.getBugSummaryAndDescription(
    ...     '322535')
    >>> print summary
    evolution: Multiple format string vulnerabilities in Evolution

    >>> print description
    Package: evolution
    Severity: grave
    Tags: security
    <BLANKLINE>
    Multiple exploitable format string vulnerabilities have been found in
    Evolution. Please see
    http://www.securityfocus.com/archive/1/407789/30/0/threaded
    for details. 2.3.7 fixes all these issues.
    ...

Which package to file the bug against is determined by the
getBugTargetName() method.

    >>> print external_debbugs.getBugTargetName('322535')
    evolution


== Importing Comments ==

Along with importing debian bug reports, comments on those bug reports
can also be imported. The DebBugs class implements the
ISupportsCommentImport interface.

    >>> from canonical.launchpad.components.externalbugtracker import (
    ...     get_external_bugtracker)
    >>> from canonical.launchpad.interfaces import (
    ...     BugTrackerType, ISupportsCommentImport)
    >>> from canonical.launchpad.ftests.externalbugtracker import (
    ...     new_bugtracker)
    >>> external_debbugs = get_external_bugtracker(
    ...     new_bugtracker(BugTrackerType.DEBBUGS))

    >>> ISupportsCommentImport.providedBy(external_debbugs)
    True

ISupportsCommentImport defines four methods: getCommentIds(),
fetchComments(), getPosterForComment() and getMessageForComment().
DebBugs implements all of these.

    >>> from canonical.launchpad.ftests.externalbugtracker import (
    ...     TestDebBugs, TestDebianBug)
    >>> from canonical.launchpad.interfaces import IBugSet, IPersonSet
    >>> no_priv = getUtility(IPersonSet).getByName('no-priv')
    >>> bug = getUtility(IBugSet).get(4)
    >>> bug_watch = bug.addWatch(debbugs, '1234', no_priv)
    >>> external_debbugs = TestDebBugs(
    ...     'http://example.com/', {'1234': TestDebianBug(
    ...         package='evolution', id=1234)})

getCommentIds() will return a list of the comment IDs for a given remote
bug. DebBugs comment IDs are RFC822 message IDs.

    >>> comment_ids = external_debbugs.getCommentIds(bug_watch)
    >>> print comment_ids
    ['<20040309081430.98BF411EE67@tux>']

fetchComments() will load up the comments whose IDs are specified in the
comment_ids parameter so that they can then be imported. This allows us
to import only the comments that are necessary - i.e. only those which
we haven't already imported. We ask it to load all of them for us here.

    >>> external_debbugs.fetchComments(comment_ids)

getPosterForComment() will return a tuple of displayname, email for a
given comment ID.

    >>> comment_id = comment_ids[0]
    >>> poster_name, poster_email = external_debbugs.getPosterForComment(
    ...     bug_watch, comment_id)
    >>> print "%s <%s>" % (poster_name, poster_email)
    Teun Vink <teun@tux.office.luna.net>

getMessageForComment() will return an imported comment as a Launchpad
Message. It requires a Person instance to be used as the Message's
owner, so we'll turn Teun Vink into a Person.

    >>> from canonical.launchpad.interfaces import (
    ...     IPersonSet, PersonCreationRationale)
    >>> poster = getUtility(IPersonSet).ensurePerson(
    ...     poster_email, poster_name, PersonCreationRationale.BUGIMPORT,
    ...     comment='when importing comments for %s.' % bug_watch.title)

    >>> message = external_debbugs.getMessageForComment(
    ...     bug_watch, comment_id, poster)

    >>> print message.owner.displayname
    Teun Vink

    >>> print message.text_contents
    Things happen.


=== Script for importing Debian bugs, linking them to Ubutu ===

There's a script called `import-debian-bugs.py`, which accepts a list of
bug numbers to be imported. It will link the bugs to the debbugs bug
tracker.

    >>> from canonical.database.sqlbase import commit
    >>> from canonical.launchpad.interfaces import ILaunchpadCelebrities
    >>> debbugs = getUtility(ILaunchpadCelebrities).debbugs
    >>> [bug.title for bug in debbugs.getBugsWatching('237001')]
    []
    >>> [bug.title for bug in debbugs.getBugsWatching('322535')]
    []
    >>> commit()

    >>> import subprocess
    >>> process = subprocess.Popen(
    ...     'scripts/import-debian-bugs.py 237001 322535', shell=True,
    ...     stdin=subprocess.PIPE, stdout=subprocess.PIPE,
    ...     stderr=subprocess.PIPE)
    >>> (out, err) = process.communicate()
    >>> process.returncode
    0
    >>> print err
    INFO    Updating 1 watches on http://bugs.debian.org
    INFO    Imported 4 comments for remote bug 237001...
    INFO    Imported debbugs #237001 as Launchpad bug #...
    INFO    Imported debbugs #322535 as Launchpad bug #...
    INFO    Committing the transaction.

    >>> commit()
    >>> debbugs = getUtility(ILaunchpadCelebrities).debbugs
    >>> [bug.title for bug in debbugs.getBugsWatching('237001')]
    [u'evolution mail crashes on opening an email with a TIFF attachment']
    >>> [bug.title for bug in debbugs.getBugsWatching('322535')]
    [u'evolution: Multiple format string vulnerabilities in Evolution']

In addition to simply importing the bugs and linking it to the debbugs
bug, it will also create an Ubuntu task for the imported bugs. This will
allow Ubuntu triagers to go through all the imported bugs and decide
whether they affects Ubuntu.

    >>> [imported_bug] = debbugs.getBugsWatching('237001')
    >>> for bugtask in imported_bug.bugtasks:
    ...     print "%s: %s" % (bugtask.bugtargetname, bugtask.status.name)
    evolution (Ubuntu): NEW
    evolution (Debian): NEW


==== Importing bugs twice ====

If a Debian bug already exists in Launchpad (i.e it has a bug watch), it
won't be imported again. A warning is logged so that the person runnning
the script gets notified about it.

    >>> from canonical.launchpad.scripts.importdebianbugs import (
    ...     import_debian_bugs)
    >>> [bug.id for bug in debbugs.getBugsWatching('304014')]
    [1]
    >>> import_debian_bugs(['304014'])
    WARNING:...:Not importing debbugs #304014, since it's already
                linked from LP bug(s) #1.
    >>> [bug.id for bug in debbugs.getBugsWatching('304014')]
    [1]


== Wrapping up ==

Restore the database path:

    >>> config.malone.debbugs_db_location = OLD_DEBBUGS_LOCATION

