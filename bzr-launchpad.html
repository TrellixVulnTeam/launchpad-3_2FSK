<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

  
  
  <html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>DRAFT Launchpad's Bazaar DRAFT</title><link rel="stylesheet" href="texmacs.css" type="text/css" /></head><body>
    
      <h1><span class="dark-red">DRAFT</span> Launchpad's Bazaar <span class="dark-red">DRAFT</span></h1>
    
    
    <p>
      This document explains what are the existing components of
      <a href="https://wiki.launchpad.canonical.com/TheBazaar">TheBazaar</a>,
      the Bazaar integration in Launchpad, how they relate to one another, and
      some of the future plans. It was written by David Allouche at the end of
      January 2006.
    </p>
    
    <p>
      There is a strong bias towards the internal details of the components
      I'm familiar with and the issues I know about, and this documentation
      does not pretend being complete by any mean. Corrections and additions
      are welcome.
    </p>
    
    <p>
      <span class="dark-red"><span class="small-caps">Work in progress!</span> This document is
      still incomplete. In particular, the RCS Importer is not covered in any
      detail yet. It is published so developers can provide early
      feedback.</span>
    </p>
    
    
      <h2>1. Bazaar Overview</h2>
    
    
    <p>
      First, let's have a bird eye's view of the various moving parts
      providing Bazaar integration in Launchpad. That's simplistic, but that
      gives us a place to start.
    </p>
    
    
      <div class="figure-body"><img src="launchpad-bzr.png" alt="launchpad-bzr.png" /></div><div class="figure-caption"><b>Figure 1: </b>Don't
      panic</div>
    
    
    <p>
      There is a dotted arrow in this diagram, it means ``handwaving here''.
      The details of what it means will be covered a bit later.
    </p>
    
    <p>
      The dashed line is the Launchpad system boundary. Anything that is
      inside the dashed box we control and we run. Anything that is outside
      the dashed box is out there on the wild internet.
    </p>
    
    <p>
      The two important storage areas are:
    </p>
    
    
      <ul>
        <li>
          Launchpad, the all-encompassing database. You know it, you
          can use its schema to cover the walls of a very large conference
          room. Every component in the system is driven by Lauchpad data.
        </li>
        
        <li>
          Supermirror, essentially just a big hard drive that stores
          Bazaar branches. It is represented here because it is an important
          information bus.
        </li>
      </ul>
    
    
    <p>
      The important world-facing systems are:
    </p>
    
    
      <ul>
        <li>
          Branch Puller, periodically runs <tt>bzr
          pull</tt> to copy remote branches registered in Launchpad onto
          the Supermirror. It is the specific service for ``pull branches''.
        </li>
        
        <li>
          SFTP Server, allows <tt>bzr</tt> to directly push
          branches on Launchpad, effectively providing a free community
          hosting service for Bazaar branches. It is the specific service for
          ``push branches''.
        </li>
        
        <li>
          Branch publisher, exposes a HTTP server from which all
          branches stored on the Supermirror can be checked out. It is the
          Supermirror front-end, serving Bazaar goodness to the world, whereas
          the the Branch Puller and the SFTP Server are back-ends used to
          place data on the Supermirror.
        </li>
        
        <li>
          RCS importer, sucks the living CPU out of CVS and Subversion
          server out there to free source code from the centralized versioning
          oppression. It produces Bazaar branches from upstream repositories
          specified in Launchpad and stuff the Supermirror with the resulting
          gigabytes of uninteresting historical details.
        </li>
      </ul>
    
    
    <p>
      Finally, the Branch Syncher in an internal system that scans branches
      stored on the Supermirror and stores summary historical information into
      the Launchpad database.
    </p>
    
    
      <h2>2. Break up by service</h2>
    
    
    <p>
      The scary diagram at the beginning is actually the superimposition of
      diagrams for several nearly independent services. Before examining
      individual components and their relations, we will have a quick tour of
      each service.
    </p>
    
    
      <h3>2.1. Pull branch mirroring</h3>
    
    
    <p>
      One of the services is the mirroring of remote branches. Remote branches
      registered in Launchpad are pulled onto the Supermirror and published on
      <tt>bazaar.launchpad.net</tt>.
    </p>
    
    
      <div class="figure-body"><img src="pull-branch.png" alt="pull-branch.png" /></div><div class="figure-caption"><b>Figure 2: </b>Pull
      branch mirroring</div>
    
    
    <p>
      Pull branches on the Supermirror are periodically updated on the
      Supermirror by the Branch Puller. The Branch Publisher serves the
      Supermirror data to Bazaar clients that want to use the Supermirror
      rather than accessing the master branch.
    </p>
    
    
      <h3>2.2. Push branch hosting</h3>
    
    
    <p>
      Launchpad provides a hosting service for Bazaar branch. A Bazaar user
      wishing to publish a branch, but unable use a personal web space, can
      push the branch on <tt>bazaar.launchpad.net</tt> using the
      SFTP transport.
    </p>
    
    
      <div class="figure-body"><img src="push-branch.png" alt="push-branch.png" /></div><div class="figure-caption"><b>Figure 3: </b>Push
      branch hosting</div>
    
    
    <p>
      The SFTP server writes to a private filesystem. The Branch Puller is
      used to copy branches from the private SFTP area to the Supermirror,
      ensuring that only usable Bazaar branch data gets copied to the
      Supermirror.
    </p>
    
    <p>
      Once it is stored on the Supermirror, the branch is published in the
      same way as for pull branches.
    </p>
    
    
      <h3>2.3. RCS imports</h3>
    
    
    <p>
      The famous RCS import service produces a publicly accessible Bazaar
      branches from the source code history stored in a remote centralized
      VCS.
    </p>
    
    
      <div class="figure-body"><img src="rcs-import.png" alt="rcs-import.png" /></div><div class="figure-caption"><b>Figure 4: </b>RCS
      import</div>
    
    
    <p>
      A bit earlier, I told you not to worry about the dotted line. Now is the
      minute of truth where its meaning will be uncovered. The RCS import
      branches must be published on the Supermirror so they will be accessible
      to the Branch Syncher, and served on the same host as the other branches
      on the Supermirror. But the way the import branches will be copied on
      the Supermirror is still undecided at the moment.
    </p>
    
    <p>
      A full explanation of the issue would be quite lengthy and technical. We
      will do it later when we are looking really closely at the RCS Importer.
    </p>
    
    
      <h3>2.4. Branch scanning</h3>
    
    
    <p>
      The last service in the system, at the moment at least, is the Branch
      Syncher. It update the Launchpad database record of the ancestry of all
      branches present on the Supermirror.
    </p>
    
    
      <div class="figure-body"><img src="branch-scan.png" alt="branch-scan.png" /></div><div class="figure-caption"><b>Figure 5: </b>Branch
      scanning</div>
    
    
    <p>The ancestry record in Launchpad is currently only used to display the most recent revisions on each branch. But many future features will use this data as well. For example measuring the activity of branches, grouping branches, marking merged branches, etc. </p>
    
    
      <h2>3. Break up by component</h2>
    
    
    <p>
      At this point, you should have a reasonable feeling of how the various
      components relate to one another. So we can start with the really
      technical stuff.
    </p>
    
    
      <h3>3.1. Branch Publisher</h3>
    
    
    
      <div class="figure-body"><img src="branch-publisher.png" alt="branch-publisher.png" /></div><div class="figure-caption"><b>Figure 6: </b>Branch
      Publisher</div>
    
    
    <p>
      The Branch Publisher is the web server on
      <tt>bazaar.launchpad.net</tt>. It only provides web
      resources for use by <tt>bzr</tt>, and no resource meant for
      direct human consumption.
    </p>
    
    <p>
      The only resources are Bazaar branches. The Branch Publisher has no
      knowledge of the Bazaar branch format, it is a dump HTTP server. Each
      published branch is associated to a Branch object in the Launchpad
      database. Branches are served as
      <tt>http://bazaar.launchpad.net/~owner/product/branch</tt>.
    </p>
    
    
      <ul>
        <li>
          <tt>owner</tt> is the string
          <tt>branch.owner.name</tt>.
        </li>
        
        <li>
          <tt>product</tt> is the string
          <tt>branch.product.name</tt>, or
          <tt>\"+junk\"</tt> if the branch is not associated to a
          Product.
        </li>
        
        <li>
          <tt>branch</tt> is the string
          <tt>branch.name</tt>.
        </li>
      </ul>
    
    
    <p>
      The URL where a branch is served changes when any of those values
      change: because the branch, product or owner's name attribute change, or
      a branch gets associated to a different owner or product.
    </p>
    
    <p>
      The Supermirror filesystem hierarchy was designed to be indifferent to
      those renamings. Branches on the Supermirror are stored by database id.
      Specifically, if a branch's id is <tt>0x89ABCDEF</tt>, the
      branch is a directory whose path is of the form
      <tt>$base/89/ab/cd/ef</tt>.
    </p>
    
    <p>
      The mapping between filesystem names and URL is done by a
      <tt>mod_rewrite</tt> rule which is periodically updated from
      the Launchpad branch data.
    </p>
    
    <p>
      <strong>Relation: </strong>Branch Publisher serves branches stored
      on the Supermirror.
    </p>
    
    <p>
      <strong>Relation: </strong>Branch Publisher reads Launchpad Branch
      details to rewrites public URLs requested by Bazaar clients into
      Supermirror filesystem names. Only branches with an associated Branch
      database record are published.
    </p>
    
    <p>
      <strong>Constraint: </strong>The public name of branches can change
      at any time.
    </p>
    
    <p>
      <strong>Constraint: </strong>The Supermirror filesystem hierarchy
      should be encapsulated. Launchpad branch ids must not be exposed to the
      user.
    </p>
    
    <p>
      <strong>Constraint: </strong>Branches stored on the Supermirror
      must be valid at all times. The only legal way to modify branch data on
      the Supermirror filesystem is using <tt>bzr push</tt>.
    </p>
    
    
      <h3>3.2. SFTP Server</h3>
    
    
    
      <div class="figure-body"><img src="sftp-server.png" alt="sftp-server.png" /></div><div class="figure-caption"><b>Figure 7: </b>SFTP
      Server</div>
    
    
    <p>
      The SFTP server allows Launchpad users to host their branches on
      Launchpad. It is a custom SFTP server based on Twisted. A user can log
      in using a SSH key whose public key is registered in Launchpad. Only
      paths of the form <tt>~owner/product/branch</tt> (as for the
      Branch Publisher) can be used, where <tt>owner</tt>
      identifies the user whose SSH keys are used for authentication. If
      <tt>owner</tt> is a team, the SSH keys of all members of the
      team can be used.
    </p>
    
    <p>
      <strong>Relation: </strong>SFTP Server asks Launchpad for team
      members and SSH public keys or users.
    </p>
    
    <p>
      The SFTP servers writes to a private filesystem that uses the same
      layout as the Supermirror. The mapping from the virtual filesystem
      exposed by SFTP and the actual filesystem layout is performed during
      authentication. That makes the SFTP server robust against branch renames
      occurring concurrently to a SFTP session.
    </p>
    
    <p>
      <strong>Relation: </strong>SFTP Server asks Launchpad for name, id
      and product name of branches owned by a person and the teams it belongs
      to.
    </p>
    
    <p>
      Existing branches with a non-<tt>NULL</tt> URLs are pull
      branches. Their associated directories are inaccessible on the SFTP
      server. Branches with a <tt>NULL</tt> URL are push branches
      and are associated to writable directories. When a user tries to create
      a non-existent branch <tt>~owner/product/branch</tt>, and
      <tt>owner</tt> is the authenticated user or a team it
      belongs to, and the named product exists (or is
      <tt>+junk</tt>), a branch is automatically created in the
      Launchpad database with the given owner, product and name and with no
      title or description.
    </p>
    
    <p>
      <strong>Relation: </strong>SFTP creates Branch records in
      Launchpad.
    </p>
    
    
      <p class="dark-red">
          <strong>Note. </strong>Andrew Bennetts remarked that SFTP
          Server does not talk to Launchpad directly. Instead it goes through
          the AuthServer, which is becoming the all-purposes internal XMLRPC
          server. Andrew, please amend this document and the sftp-server
          picture to accurately represent the relations the SFTP Server
          participates to.
        </p>
    
    
    
      <h3>3.3. Branch Puller</h3>
    
    
    
      <div class="figure-body"><img src="branch-puller.png" alt="branch-puller.png" /></div><div class="figure-caption"><b>Figure 8: </b>Branch
      Puller</div>
    
    
    
      <h4>3.3.1. Branch Puller and Launchpad</h4>
    
    
    <p>
      The Branch Puller is the component that writes to the Supermirror. It
      processes two kinds of branches:
    </p>
    
    
      <ul>
        <li>
          Remote branches, from untrusted public servers on the
          internet, using URLs registered in the Launchpad database.
        </li>
        
        <li>
          SFTP branches, on the filesystem of the SFTP server, using
          the id of Launchpad branches without an URL.
        </li>
      </ul>
    
    
    <p>
      <strong>Relation: </strong>Branch Puller asks Launchpad for Branch
      ids and URLs.
    </p>
    
    <p>
      <strong>Relation: </strong>Branch Puller pulls
      <tt>bzr</tt> branches from the private SFTP Server
      filesystem and from public web spaces on the internet.
    </p>
    
    <p>
      At the time of writing (2005-01-31), the Branch Puller gets its branch
      data from Launchpad by reading the
      <tt>/supermirror-pull-list.txt</tt> page.
    </p>
    
    
      <h4>3.3.2. Branch Puller and Supermirror</h4>
    
    
    <p>
      The Branch Puller writes directly to the id-based Supermirror
      filesystem.
    </p>
    
    <p>
      It uses <tt>bzr get</tt> to create new branches on the
      Supermirror and <tt>bzr pull --overwrite</tt> to update
      existing branches. The use of <tt>bzr</tt> to copy the data
      ensures that only vaguely sane Bazaar branch data is stored on the
      Supermirror. Warez swappers would need to use bzr to be published, and
      blatantly corrupt branch data would not be published.
    </p>
    
    <p>
      <strong>Relation: </strong>Branch Puller writes sanitized branch
      data on the Supermirror.
    </p>
    
    
      <h3>3.4. Branch Syncher</h3>
    
    
    
      <div class="figure-body"><img src="branch-syncher.png" alt="branch-syncher.png" /></div><div class="figure-caption"><b>Figure 9: </b>Branch
      Syncher</div>
    
    
    <p>
      <strong>Relation: </strong>Branch Syncher asks Launchpad for a list
      of branches to scan.
    </p>
    
    <p>
      <strong>Relation: </strong>Branch Syncher reads the
      revision-history and revision entries from published branches.
    </p>
    
    <p>
      The Branch Syncher does not access the Supermirror filesystem directly.
      Instead it uses a special rewriting rule of the Branch Publisher that
      gives it access to branches by hexadecimal id but hides the details of
      the real filesystem layout.
    </p>
    
    <p>
      <strong>Relation: </strong>Branch Syncher updates the Revision,
      RevisionNumber and RevisionParent tables in the Launchpad database.
    </p>
    
    <p>
      In particular, the Branch Syncher needs to be able to delete
      RevisionNumber records because the revision-history of a branch is not
      append-only. However, Revision and RevisionParent records are never
      deleted or modified.
    </p>
    
    <p>
      Since the published branches were sanitized by the Branch Puller, the
      Branch Syncher should not normally fail.
    </p>
    
    <p>
      This process is separate from the Branch Puller for two reasons:
    </p>
    
    
      <ul>
        <li>
          It needs database permissions, in particular
          <tt>DELETE</tt> permissions, which are not required by
          the Branch Puller, and the Branch Puller is considered compromised
          because it handles untrusted data and communicates directly with
          potentially hostile web servers.
        </li>
        
        <li>
          The Branch Puller and Branch Syncher were developed and
          deployed by different individuals. Keeping them separate prevents
          crossing responsibility boundaries.
        </li>
      </ul>
    
    
    
      <h3>3.5. RCS Importer</h3>
    
    
    
      <div class="figure-body"><img src="rcs-importer.png" alt="rcs-importer.png" /></div><div class="figure-caption"><b>Figure 10: </b>RCS
      Importer</div>
    
    
    <p>
      The RCS Importer creates and update Bazaar branches from the historical
      information available in third party version control systems. Currently,
      imports from CVS and Subversion are supported. It is also known as
      <tt>importd</tt>, and uses Buildbot and CSCVS.
    </p>
    
    <p>
      This is the oldest component of the system, and predates Launchpad
      itself. It is still importing into <tt>baz</tt> branches and
      the transition to <tt>bzr</tt> is in progress. Over time, it
      has accumulated many design and implementation problems that prevent
      delivering a good quality of service and make maintenance painful.
    </p>
    
    <p>
      <strong>Relation: </strong>RCS Importer asks Launchpad for RCS to
      import from and branches to import into.
    </p>
    
    <p>
      <strong>Relation: </strong>RCS Importer gets and update import
      status in Launchpad.
    </p>
    
    <p>
      <strong>Relation: </strong>RCS Importer retrieves version control
      history from remote repositories.
    </p>
    
    <p>
      <strong>Relation: </strong>RCS Importer publish imported branches
      on the Supermirror.
    </p>
    
    <p>
      <strong>Relation: </strong>RCS Importer retrieves published branch
      from the Supermirror for rollback.
    </p>
    
    <p>
      Historically, the role of the Branch Syncher was performed in the RCS
      Importer, by a component called Taxi. When the Launchpad database schema
      was updated to model Bazaar branch instead of Arch branches, Taxi was
      removed.
    </p>
    
    <p>
      RCS Import is a very expensive and time consuming task that is bound on
      network, CPU and disk I/O at different times.
    </p>
    
    
      <ul>
        <li>
          It is network bound when checking out trees from remote RCS
          repositories, retrieving historical data from remote servers and
          publishing imports.
        </li>
        
        <li>
          It is CPU bound when synthetizing changesets from CVS log and
          when committing revisions.
        </li>
        
        <li>
          It is I/O bound when comitting revisions and doing
          consistency checks.
        </li>
      </ul>
    
    
    <p>
      The initial import of a branch can take up to several days if the source
      tree is large, the history is long, or the remote server is slow. Also,
      these issues tend to come in groups: projects with a large source tree
      often have a long history and an overloaded server, leading to initial
      imports taking up to several weeks.
    </p>
    
    
      <h4>3.5.1. Buildbot, Importd, and CSCVS</h4>
    
    
    <p>
      The components of the RCS Importer Buildbot, Importd, and CSCVS.
    </p>
    
    <p>
      Buildbot's is used as an abstract build control system. It implements a
      master/slave architecture wher a single master process (run on
      macquarie) sends tasks to several slave systems. Its roles are:
    </p>
    
    
      <ul>
        <li>
          Control conversion tasks, and automatically run periodic
          conversions.
        </li>
        
        <li>
          Spread tasks on multiple slave systems.
        </li>
        
        <li>
          Provide a web-accessible control panel, to manually start
          conversions and report historical conversion status and logs.
        </li>
      </ul>
    
    
    <p>
      Importd specializes Buildbot to:
    </p>
    
    
      <ul>
        <li>
          Load jobs from Launchpad.
        </li>
        
        <li>
          Prepare data and run CSCVS.
        </li>
        
        <li>
          Update the importstatus in Launchpad.
        </li>
        
        <li>
          Register and publish branches.
        </li>
        
        <li>
          Display jobs in Buildbot's web control panel.
        </li>
      </ul>
    
    
    <p>
      CSCVS is an independent system that performs the actual RCS conversion.
      Its roles are:
    </p>
    
    
      <ul>
        <li>
          Create initial Bazaar branches recording all the history of
          an upstream RCS.
        </li>
        
        <li>
          Update import branches for new commits in the upstream RCS.
        </li>
        
        <li>
          Check that imported source is consistent with source stored
          in the upstream RCS.
        </li>
      </ul>
    
    
    
      <h4>3.5.2. ProductSeries and Branches</h4>
    
    
    <p>
      The upstream RCS details required for an import are stored in the
      ProductSeries table. This table also stores details about the status of
      an import.
    </p>
    
    <p>
      <strong>Arch legacy: </strong>The ProductSeries targetarchsomething
      fields are used to record the Arch name of the import branch.
    </p>
    
    <p>
      When an the initial import of a RCS has succeeded and the branch is
      published, a corresponding Branch record must be created and linked from
      the branch field of the ProductSeries.
    </p>
    
    <p>
      <strong>Opinion: </strong>David Allouche thinks the coupling of RCS
      imports with ProductSeries is unecessary. Most of the time, users that
      want to get a RCS import do not care about ProductSeries and their
      baggage. Instead, RCS import details should be recorded in a separate
      table, and it should be possible associate a Branch and ProductSeries
      manually. This would require a specification.
    </p>
    
    
      <h4>3.5.3. Import Status</h4>
    
    
    <p>
      RCS imports have historically followed a workflow recorded by the
      <tt>importstatus</tt> field and a number of timestamps in
      the ProductSeries table. The state machine of
      <tt>importstatus</tt> is documented on
      <a href="https://wiki.launchpad.canonical.com/SourceSourceRefactoring">SourceSourceRefactoring</a>.
    </p>
    
    
      <div class="figure-body"><img src="importstatus.png" alt="importstatus.png" /></div><div class="figure-caption"><b>Figure 11: </b>ProductSeries.importstatus</div>
    
    
    <p>
      The critical transition is the <em>manual review</em> between
      <tt>AUTOTESTED</tt> and <tt>PROCESSING</tt>.
      This manual review is needed for a few reasons:
    </p>
    
    
      <ul>
        <li>
          As policy, the RCS import service is only provided for
          products for which a reasonably good product description was
          created. It is the reponsibility of the Launchpad administrator to
          communicate with the user to get a better description if needed and
          mark the product as reviewed.
        </li>
        
        <li>
          To perform an import that can published, we need to allocate
          a Arch namespace. To help keep the namespace used for imports
          vaguely organised, and prevent conflicts, namespace allocation was
          done by Buttsource administrators.
        </li>
      </ul>
    
    
    <p>
      <strong>Arch legacy: </strong>The second point is no longer
      relevant with Bazaar. Blatantly misnamed branches with useless data can
      be published, renamed and removed without problem.
    </p>
    
    
      <h4>3.5.4. Roomba and Hoover</h4>
    
    
    <p>
      <em>Roomba</em> and <em>Hoover</em> are two Importd instances that use
      separate slave systems. That separation was required so large numbers of
      lengthy test imports could be run without blocking daily updates of
      syncing im ports. Buildbot scheduling is not flexible enough to meet
      this goal with a single instance.
    </p>
    
    <p>
      <strong>Arch legacy: </strong>This separation was useful for
      privilege separation: the Roomba slaves do not (should not?) have the
      SFTP key to publish branches or the privileges for Taxi to write
      revision information to the database. The only information coming out of
      test imports is status changes in ProductSeries effected by the Buildbot
      master. That helped guarantee that no branch would leak out before being
      validated by a Buttsource administrator.
    </p>
    
    
      <div class="figure-body"><img src="importd-deployment.png" alt="importd-deployment.png" /></div><div class="figure-caption"><b>Figure 12: </b>Importd
      deployment</div>
    
    
    <p>
      The elements in gray in the Importd deployment diagram represent the way
      branches were historically published: they were uploaded to
      <tt>bazaar.ubuntu.com</tt>, where the Arch Supermirror
      automatically registered and published them.
    </p>
    
    <p>
      Communication with the Launchpad database are not displayed on this
      diagram. Only macquarie, galapagos and neumayer accessed the database.
      Macquarie so the Botmasters could load jobs and update import status in
      ProductSeries. Galapagos and Neumayer so Taxi could create Branch and
      Revision records.
    </p>
    
    <p>
      The Roomba and Hoover botmaster each exposed a web user interface to
      monitor import progress, examine past logs, initiate manual builds, and
      reload the job list.
    </p>
    
    
      <h4>3.5.5. Import Validation</h4>
    
    
    <p>
      Before publishing an imported branch, the source contents of the latest
      imported revision are compared to the source retrieved from the Upstream
      RCS at the start of the import. Deviations in the imported history are
      tolerated as it is impossible to retrieve past full tree revision from
      CVS in the general case.
    </p>
    
    <p>
      <strong>Open issue: </strong>Better sanity checking could be
      performed. On CVS, comparison of annotated source could be reliably
      implemented. On Subversion it is generally possible to retrieve past
      full tree revisions.
    </p>
    
    
      <h4>3.5.6. Import Workflow</h4>
    
    
    <p>
      The workflow of an import starts by a user setting up RCS details in
      Launchpad, and ends by the registration and publication of the import
      branch. The following diagram illustrate the simplest set of interaction
      in that workflow, in the case where no failure occur.
    </p>
    
    
      <div class="figure-body"><img src="import-workflow.png" alt="import-workflow.png" /></div><div class="figure-caption"><b>Figure 13: </b>Import
      workflow</div>
    
    
    <p>
      First the User sets up RCS details in Launchpad. That sets the
      <tt>importstatus</tt> of the ProductSeries to
      <tt>TESTING</tt>. Then nothing happens until Roomba is
      ``reloaded''.
    </p>
    
    <p>
      The operator must ``reload'' Roomba by posting a form in the Buildbot
      web UI. This will update the job list from the database. Only
      ProductSeries that are <tt>TESTING</tt> or
      <tt>TESTFAILED</tt> create Roomba jobs. Jobs in
      <tt>TESTING</tt> state are started automatically shortly
      after reloading. When the Roomba job succeeds, the ProductSeries is set
      to <tt>AUTOTESTED</tt> and awaits human review.
    </p>
    
    <p>
      <strong>Arch legacy: </strong>If a ProductSeries does not specify
      the <tt>targetarchsomething</tt> fields, the branch name was
      automatically generated. The automatic branch name generation sometimes
      produced invalid names, causing autotest jobs to never succeed unless
      debugged, but that is now longer a problem with Bazaar.
    </p>
    
    <p>
      The operator must also periodically review ProductSeries that have
      passed autotest. Launchpad provides a user interface in
      <tt>https://launchpad.net/bazaar/series</tt> to easily view
      all the ProductSeries with a given <tt>importstatus</tt>
      value. After a number of click, the occasional editorial work, sometimes
      chatting with the User to ask for clarifications or improvements in the
      product description, the Product is marked as ``reviewed'' in the
      <tt>$product/+review</tt> form and the ProductSeries is set
      to <tt>PROCESSING</tt> in the
      <tt>$series/+sourceadmin</tt> form.
    </p>
    
    <p>
      <strong>Arch legacy: </strong>This review step was the point where
      a Buttsource administrator was required to attribute Canonical branch
      name to the import branch.
    </p>
    
    <p>
      Then the operator must ~reload Hoover to create the job for the newly
      approved import. When the initial import completes, the
      <tt>importstatus</tt> is set to <tt>SYNCING</tt>
      and an entirely distasteful hack is used to update the job in place
      without having to wait for a manual reload, and to immediately start the
      initial sync job. At the end of the sync job, the Branch record is
      created in Launchpad and the import branch is published.
    </p>
    
    <p>
      <strong>Arch legacy: </strong>The initial import starts from
      scratch, so a branch had to be fully imported twice before being
      published: once in Roomba and once on Hoover. That was necessary with
      Arch since the branch name generally changed during the review step.
    </p>
    
    <p>
      That could obviously use some streamlining, and I have not even
      mentioned the work required when one of the jobs fails.
    </p>
    
    <p>
      <strong>Open issue: </strong>A Launchpag bug exists related to the
      support of the <tt>importstatus</tt> workflow in the
      Launchpad user interface: <a href="https://launchpad.net/products/launchpad/+bug/378">bug
      378</a>.
      It was partially and incorrectly implemented: it is currently entirely
      impossible (even for a Buttsource member) to update the RCS import
      details for a ProductSeries whose status is
      <tt>SYNCING</tt>. However it is possible to update those
      details by direct database manipulation as the
      <tt>importd</tt> user.
    </p>
    
    
      <h4>3.5.7. Importd Rollback</h4>
    
    
    <p>
      When an import fails, the Upstream RCS checkout and the partially
      converted branch are left in place to allow diagnosing the failure.
    </p>
    
    <p>
      Some conversion errors are detected only after committing an incorrect
      revision: for example a later revision attempts to patch an non-existing
      file, or the error is is only detected at validation time. After CSCVS
      is fixed to correct the error, Importd needs ``rollback'': revert the
      branch to a previous known-good state. There are three different cases
      of rollback:
    </p>
    
    
      <dl>
        <dt>Import</dt><dd>
          An import starts from scratch, the branch
          where the conversion will be published must not exist yet.
        </dd>
        
        <dt>Sync</dt><dd>
          A sync starts from the currently published
          branch. The branch must already be published.
        </dd>
        
        <dt>Initial sync</dt><dd>
          Since branches are published on
          sync, the initial sync cannot rollback. Instead, it will update the
          branch produced by the import step. The initial sync is not allowed
          to fail, if it does, the <tt>importstatus</tt> must be
          manually reverted to <tt>PROCESSING</tt> and the import
          must be restarted.
        </dd>
      </dl>
    
    
    <p>
      <strong>Open issue: </strong>An import branch is only published
      after the initial sync. If the initial sync fails, the subsequent sync
      has no published branch data to rollback to, and all subsequent syncs
      will fail, or worse, the branch will eventually be published with known
      bad data. Branch should be published after Import.
    </p>
    
    
      <h4>3.5.8. Persistent CSCVS data</h4>
    
    
    <p>
      Running a CSCVS sync on a system without local data involves a few
      steps:
    </p>
    
    
      <ul>
        <li>
          Get a copy of the target Bazaar branch from the publication
          site.
        </li>
        
        <li>
          Checkout the Upstream RCS branch.
        </li>
        
        <li>
          Build the CSCVS cache. That is the part where CSCVS does dark
          magic to conjure changesets out of a CVS log.
        </li>
        
        <li>
          Commit the missing changesets to the Bazaar branch.
        </li>
        
        <li>
          Validate the import by comparing the final Bazaar branch to
          the Upstream RCS checkout.
        </li>
      </ul>
    
    
    <p>
      The Upstream RCS checkout and, in particular, the CSCVS cache build are
      expensive tasks whose cost is independent of the amount of new changes,
      but dependent on the tree size and history size.
    </p>
    
    <p>
      They are optimized by updating the Upstream RCS checkout (for example
      with <tt>cvs up</tt>) and the cache (with the appropriate
      <tt>cscvs</tt> invokation) when they are available.
    </p>
    
    
      <h4>3.5.9. The Split Changeset Bug</h4>
    
    
    <p>
      Preserving the CSCVS cache is not just an optimisation, it is also
      required to work around a CSCVS bug.
    </p>
    
    <p>
      CSCVS identifies CVS changesets with a sequential id and creates them by
      grouping related commits from the same user, with the same message, and
      occuring within a short time period. When a sync occurs concurrently to
      a group of related CVS commits, the part of the commit group that is
      completed at the time of the sync is interpreted as a changeset, and the
      rest of group is interpreted as a separate changeset on the next sync. I
      will call this situation a ``split changeset''.
    </p>
    
    <p>
      If the cache is generated from scratch at a later date, the changeset
      get properly grouped in the cache. But since the split changeset was
      imported in two commits by the previous syncs, all subsequent changesets
      do not have matching ids in the branch an in the cache. If the was one
      split commit, the first new changeset to import has, in the cache, the
      id of the last committed changeset in the branch, so the first new
      changeset is not imported.
    </p>
    
    <p>
      In principle it should be possible to ignore recent commits that may be
      grouped with future commits, but David Allouche looked at the problem in
      the past and was unable to understand how changesets where generated.
    </p>
    
    <p>
      Regardless, it is almost certain that several import branches now
      contain such split changesets. So being able to delete the CSCVS cache
      would require a way to deal with existing split changesets, just
      preventing the creation of new ones would not be sufficient.
    </p>
    
    <p>
      Publishing split changesets is not a big problem in itself, so this
      fixing this bug needs not be a high priority.
    </p>
    
    
      <h4>3.5.10. The Renaming Bug</h4>
    
    
    <p>
      Importd spreads jobs on slaves by hashing the job name, which is of the
      form <tt>[<i>project</i>-]<i>product</i>-<i>series</i></tt>. Since projects, products and
      series can be renamed, and their associations can change, the slave
      assigned to a RCS import job can change.
    </p>
    
    <p>
      Because of the Split Changest Bug, we need to transport the CSCVS cache
      when migrating a job between slaves. Since we do not know what was the
      previous name of a job, we do not know which slave to download and
      remove this data from. In the current situation, supporting job
      migration would require maintaining a central repository of CSCVS caches
      and updating it with <tt>rsync</tt> after each import or
      sync. Ensuring Arch namespace consisency also required that the local
      master archive also be migrated. This functionality is not implemented,
      therefore job migration require careful manual operation.
    </p>
    
    <p>
      Since job migration would currently require manual operation some
      ``undocumented features'' in Importd, related to Arch archive
      registration, have not been fixed since they effectively provide early
      failure in the cases where a manual job migration need to be done.
    </p>
    
    <p>
      This the reason why renaming or reassociating ProductSeries associated
      to a RCS import are strongly discouraged. They generally break the RCS
      import.
    </p>
    
    
      <h3>3.6. RCS Importer Transition to Bazaar</h3>
    
    
    
      <p class="dark-red">
          <strong>Todo: </strong>Document tools that have been
          implemented for the bzr transition so far.
        </p>
    
    
    
      <h2>4. Future Plans and Open Issues</h2>
    
    
    
      <h3>4.1. Branch Puller's Future</h3>
    
    
    <p>
      <strong>Open issue: </strong>The Bazaar branch data on remote
      branches and on the SFTP server can be altered in essentially arbitrary
      ways. A branch can be replaced by a completely unrelated branch. More
      practically, branches can be altered to remove ``Nuclear Launch Codes'',
      ``Nuclear Waste'' and garbage revisions that are not part of the
      branch's ancestry. However, although <tt>bzr pull
      --overwrite</tt> treats the revision-history as rewritable, it
      treats the store as append only. The Branch Puller would need explicit
      support to allow users to remove with Nuclear Launch Codes and Nuclear
      Waste from their branch on the Supermirror.
    </p>
    
    
      <h4>4.1.1. Future plan: Launchpad reporting</h4>
    
    
    <p>
      The Branch Puller should be able to store reporting information in
      Launchpad. The information that would be useful to store include:
    </p>
    
    
      <ul>
        <li>
          Date of latest successful pull.
        </li>
        
        <li>
          Date of latest pull attempt.
        </li>
        
        <li>
          Success status of the latest pull attempt.
        </li>
        
        <li>
          Diagnostic data for the latest pull attempt if it was a
          failure. In the simplest case, that could be a simple Pyhon
          backtrace.
        </li>
      </ul>
    
    
    <p>
      Internal system failures, like failed communication with Launchpad, must
      be reported to the <tt>launchpad-error-reports</tt> mailing
      list and not recorded in the database.
    </p>
    
    <p>
      Normal pull failures should also be reported to the mailing list to
      allow fast response to users. That would allow James Blackwell to notice
      that an interesting new branch is failing and to contact the branch
      owner directly to fix the problem.
    </p>
    
    <p>
      This error reporting is mentioned as the
      <tt>branchPulled</tt> XMLRPC call in
      <a href="https://wiki.launchpad.canonical.com/SupermirrorXmlRpc">SupermirrorXmlRpc</a>
      and
      <a href="https://wiki.launchpad.canonical.com/BranchXmlRpc">BranchXmlRpc</a>,
      and as an open issue on
      <a href="https://wiki.launchpad.canonical.com/BazaarTaskList">BazaarTaskList</a>.
    </p>
    
    <p>
      <strong>Relation: </strong>Branch Pullers stores status reports in
      Launchpad.
    </p>
    
    
      <h4>4.1.2. Future plan: Ignore expected failures</h4>
    
    
    <p>
      In normal usage, some branches are not worth trying to pull. Mainly,
      restricted branches like those stored on
      <tt>sftp://chinstrap.ubuntu.com/</tt>, but also blatantly
      incorrect branches, like those pointing to a Subversion repository.
    </p>
    
    <p>
      Those branches are characterized by pull attempts that are never
      successful. The details of how the successive failures are counted, and
      how they affect pull frequency, are still a bit uncertain. Eventually, a
      branch that is never successfully pulled will no longer be attempted.
      Otherwise error reports would quickly be drowned in expected failures.
    </p>
    
    <p>
      This is mentioned as an open issue on
      <a href="https://wiki.launchpad.canonical.com/BazaarTaskList">BazaarTaskList</a>.
    </p>
    
    
      <h4>4.1.3. Future plan: Pull now</h4>
    
    
    <p>
      Daniel registered a <tt>bzr</tt> branch of
      <tt>gedit</tt> to support MoinMoin syntax highlighting, then
      he comes back a couple of weeks later to find that his branch was never
      successfully pulled: all attempts failed with a 403 HTTP error because
      there was a bug in the <tt>.htaccess</tt> file on his
      webspace. In the meantime, all the pull attempts on that branch have
      failed and it was classified as an expected failure. Daniel fixes the
      <tt>.htaccess</tt> setting, requests a new pull attempt, and
      monitors the outcome of the pull.
    </p>
    
    <p>
      Henry has a branch of <tt>gnome-panel</tt> that preserves
      layout when changing the screen resolution. He publishes it using the
      Launchpad SFTP Server. Immediately after publishing he goes on the
      <tt>#gnome-devel</tt> IRC chat room to ask people to look at
      the fix and gives the URL of his branch page:
      <tt>https://launcphad.net/people/henry/+branches/gnome-panel/layout-bugfix</tt>.
      A GNOME developer commit want to review the changes, looks at the page
      and sees that a pull is pending, then waits until the pull is complete
      to merge that branch into a fresh import of mainline and review the
      changes.
    </p>
    
    <p>
      Both those use cases require some new functionality:
    </p>
    
    
      <ul>
        <li>
          Requesting an immediate branch pull through the Launchpad UI
          or through the SFTP Server.
        </li>
        
        <li>
          Feedback in the Launchpad UI when a pull is in progress.
        </li>
      </ul>
    
    
    <p>
      Part of this functionality is addressed in
      <a href="https://wiki.launchpad.canonical.com/SupermirrorXmlRpc">SupermirrorXmlRpc</a>
      and
      <a href="https://wiki.launchpad.canonical.com/BranchXmlRpc">BranchXmlRpc</a>.
    </p>
    
    
      <h4>4.1.4. Future plan: Concurrent tasks</h4>
    
    
    <p>
      Pulling a branch is a network-bound task that can take a long time. It
      can also be CPU intensive in some cases.
    </p>
    
    <p>
      To allow pull-now requests to be handled quickly, it would be necessary
      to implement the Branch Puller as a service, as opposed to a
      <tt>cron</tt> job, which would be able to schedule tasks in
      a flexible way. Long running tasks should not prevent new tasks from
      running.
    </p>
    
    <p>
      This needs to be taken into account in the design of
      <a href="https://wiki.launchpad.canonical.com/ImportdRefactoring">Buildd-NG</a>.
    </p>
    
    
      <h3>4.2. Branch Syncher's Future</h3>
    
    
    
      <h4>4.2.1. Future plan: Launchpad reporting</h4>
    
    
    <p>
      The date of the latest successful synch should be displayed in the
      Launchpad UI to explain that the displayed branch details might be out
      of date.
    </p>
    
    
      <h4>4.2.2. Future plan: Sync now</h4>
    
    
    <p>
      The Branch Puller should be able to report when a branch on the
      Supermirror has changed and needs to be scanned again. Currently, all
      branches are scanned periodically by a <tt>cron</tt> job.
      This takes a significant time (one hour as of 2005-01-31), so synching
      is done every two hour.
    </p>
    
    <p>
      Marking branches that needs to be synched allows reducing the run time
      of a synching batch, increasing the frequency of the periodic job,
      therefore reducing the latency in the common case.
    </p>
    
    <p>
      The ``branch changed'' information would be set by the
      <tt>branchPulled</tt> XMLRPC call described in
      <a href="https://wiki.launchpad.canonical.com/SupermirrorXmlRpc">SupermirrorXmlRpc</a>
      and
      <a href="https://wiki.launchpad.canonical.com/BranchXmlRpc">BranchXmlRpc</a>.
    </p>
    
    
      <h4>4.2.3. Future plan: Concurrent tasks</h4>
    
    
    <p>
      The Branch Syncher needs to traverse the complete ancestry of branches
      so old revisions can be created in the database in response to ghost
      filling in a Supermirror branch. This process is database-bound and can
      take a significant amount of time (probably several tens of minutes for
      very large branches).
    </p>
    
    <p>
      To allow sync-now requests to be handled quickly, it would be necessary
      to implement the Branch Syncher as a service with flexible scheduling
      abilities. Long running tasks should not prevent new tasks from running.
    </p>
    
    <p>
      This needs to be taken into account in the design of
      <a href="https://wiki.launchpad.canonical.com/ImportdRefactoring">Buildd-NG</a>.
    </p>
    
    
      <h3>4.3. RCS Importer's Future</h3>
    
    
    
      <p class="dark-red">
          <strong>Todo: </strong>Flesh out this section.
        </p>
    
    
    <p>
      <strong>Open Issue: </strong>Number of sync failures.
    </p>
    
    <p>
      <strong>Open Issue: </strong>Failure triage.
    </p>
    
    <p>
      <strong>Open Issue: </strong>Workflow of new imports, removing
      review step?
    </p>
    
    <p>
      <strong>Open Issue: </strong>Restarting imports.
    </p>
  </body></html>
  
  
  
  
  
  

