= Nickname =

For each Person we create a unique nickname that must be generated using
generate_nick.

A valid nick can contain lower case letters, dashes, and numbers,
must start with a letter or a number, and must be a minimum of
four characters.

    >>> from canonical.launchpad.database.person import generate_nick
    >>> generate_nick("foop@example@com")
    Traceback (most recent call last):
        ...
    NicknameGenerationError: foop@example@com is not a valid email address
    >>> generate_nick("foop@example.com")
    'foop'
    >>> generate_nick("bar@example.com")
    'bar'
    >>> generate_nick("spam@example.com")
    'spam'
    >>> generate_nick("foo.bar@canonical.com")
    'foo-bar'
    >>> generate_nick("foo+bar@example.com")
    'foo+bar'
    >>> generate_nick("--foo@example.com")
    'foo'

We already have a salgado, so generate_nick needs to try a little harder.

    >>> generate_nick("salgado@async.co.br")
    'salgado-async'

And it needs to maintain a minimum length

    >>> generate_nick("i@tv")
    'i-tv'

    >>> _counter = 0
    >>> from zope.security.proxy import removeSecurityProxy
    >>> def new_person(email):
    ...     from canonical.launchpad.interfaces import IPersonSet
    ...     from canonical.launchpad.interfaces import IEmailAddressSet
    ...     from canonical.launchpad.interfaces.person import (
    ...         PersonCreationRationale)
    ...     UNKNOWN = PersonCreationRationale.UNKNOWN
    ...     person_set = getUtility(IPersonSet)
    ...     person, ignored = person_set.createPersonAndEmail(
    ...         email, UNKNOWN)
    ...     # Switch the email to avoid conflicts when generating clashing names
    ...     email_address_set = getUtility(IEmailAddressSet)
    ...     global _counter
    ...     for email_address in email_address_set.getByPerson(person):
    ...         removeSecurityProxy(email_address).email = (
    ...             'nodupe%d@example.com' % _counter)
    ...         _counter += 1
    ...     flush_database_updates()
    ...     assert email_address_set.getByEmail(email) is None, 'Oops'
    ...     return person

The email address is used to generate nicknames. If domain is used to
attempt to avoid clashes.

    >>> new_person('bongo@example.com').name
    u'bongo'
    >>> new_person('bongo@example.com').name
    u'bongo-example'
    >>> new_person('bongo@example.com').name
    u'bongo-example-com'

It should be nearly impossible to make the method fail even in the
extreme cases where using all components of the domain name fails.
If nicknames still clash, random suffixes are tried:

    >>> new_person('bongo@example.com').name
    u'bongo-example-com-c'

Random prefixes are tried:

    >>> new_person('bongo@example.com').name
    u'q-bongo-example-com'

And random mutations are tried:

    >>> new_person('bongo@example.com').name
    u'bongo-examale-com'

The only way it can fail is if some idiot admin goes and registers a
'match-everything' pattern in the blacklist:

    >>> from canonical.database.sqlbase import cursor
    >>> cur = cursor()
    >>> cur.execute("INSERT INTO NameBlacklist (regexp) VALUES ('.')")
    >>> generate_nick("foo@example.com")
    Traceback (most recent call last):
    ...
    NicknameGenerationError: No nickname could be generated...
