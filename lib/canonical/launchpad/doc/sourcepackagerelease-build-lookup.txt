== Creating & Looking for Build records ==

ISourcePackageRelease has the ability to create Build records,
however it needs fully support to treat architecturehintlist and P-a-s
information, see further information in buildd-queuebuilder.txt.

ISourcePackageRelease also provides a 'getBuildByArch' method which
allow the applications to lookup for Build records in a given
DistroArchSeries and Archive.

    >>> from zope.component import getUtility
    >>> from canonical.launchpad.interfaces import IDistributionSet

    >>> ubuntu = getUtility(IDistributionSet)['ubuntu']
    >>> hoary = ubuntu['hoary']
    >>> hoary_i386 = hoary['i386']
    >>> hoary_hppa = hoary['hppa']

    >>> from canonical.launchpad.interfaces import IPersonSet
    >>> cprov = getUtility(IPersonSet).getByName('cprov')

    >>> from canonical.launchpad.interfaces import (
    ...    PackagePublishingPocket)
    >>> pocket_release = PackagePublishingPocket.RELEASE

The base method createBuild() is able to create build to a given
distroarchseries, pocket and archive.

Build.buildstate, by default is set to NEEDSBUILD, but you can
optionally provide another status.

    >>> hoary_evo_sp = hoary.getSourcePackage('evolution')
    >>> evo_spr = hoary_evo_sp['1.0'].sourcepackagerelease

    >>> from canonical.launchpad.interfaces import BuildStatus
    >>> evo_build_i386 = evo_spr.createBuild(
    ...     hoary_i386, pocket_release, ubuntu.main_archive,
    ...     status=BuildStatus.FULLYBUILT)

    >>> print evo_build_i386.buildstate.name
    FULLYBUILT

    >>> evo_build_i386.distroarchseries.architecturetag
    u'i386'

    >>> print evo_build_i386.archive.title
    Primary Archive for Ubuntu Linux

The build record can be retrieved via getBuildByArch on hoary/i386
architecture.

    >>> test_build_i386 = evo_spr.getBuildByArch(
    ...     hoary_i386, ubuntu.main_archive)
    >>> test_build_i386 == evo_build_i386
    True

However a hoary/hppa is not available.

    >>> test_build_hppa = evo_spr.getBuildByArch(
    ...     hoary_hppa, ubuntu.main_archive)
    >>> print test_build_hppa
    None


== Sources inherited during distroseries initialization ==

We will copy the evolution source to ubuntu/breezy-autotest as if it
was inherited in the initialization.

    >>> breezy_autotest = ubuntu['breezy-autotest']
    >>> breezy_autotest_i386 = breezy_autotest['i386']

    >>> print breezy_autotest.parent_series.title
    The Hoary Hedgehog Release

    >>> hoary_evo_dsspr = hoary_evo_sp['1.0']
    >>> copied_pub = hoary_evo_dsspr.current_published.copyTo(
    ...     breezy_autotest, pocket_release, breezy_autotest.main_archive)

    >>> breezy_autotest_evo_sp = breezy_autotest.getSourcePackage('evolution')
    >>> breezy_autotest_evo_dsspr = breezy_autotest_evo_sp['1.0']
    >>> evo_spr == breezy_autotest_evo_dsspr.sourcepackagerelease
    True

Since evolution source was already built on ubuntu/hoary/i386, the
parent series, it should be found by a build lookup happening on
ubuntu/breezy-autotest/i386.

In practical terms it means that another build is not necessary in
this context.

    >>> breezy_autotest_build = evo_spr.getBuildByArch(
    ...     breezy_autotest_i386, ubuntu.main_archive)
    >>> print breezy_autotest_build.title
    i386 build of evolution 1.0 in ubuntu hoary RELEASE


== Sources copied from PRIMARY to PPAs ==

Sources published (uploaded or copied) to the PPA do not share builds
with the distribution main archive (PRIMARY/PARTNER). They should have
a build record representing the building context for the specific PPA
where they are published.

Let's start by copying a PRIMARY archive source to Celso's PPA.

    >>> copy = hoary_evo_sp['1.0'].current_published.copyTo(
    ...    hoary, pocket_release, cprov.archive)

Then we can creating a build record representing the intent to build
the copied source using the current PPA context. The PPA build context
is a merge between the PRIMARY archive context and the differences
introduced by the PPA itself, like new package or new dependency
versions, so the resulted binary will be influenced by the PPA
contents at the time it was built.

    >>> evo_build_i386_ppa = copy.sourcepackagerelease.createBuild(
    ...     hoary_i386, pocket_release, cprov.archive)

    >>> evo_build_i386_ppa.buildstate.name
    'NEEDSBUILD'

    >>> print evo_build_i386_ppa.archive.title
    PPA for Celso Providelo

The copied source build lookup in the PPA returns the build created in
the PPA context, not the PRIMARY archive one.

    >>> test_build_i386_ppa = copy.sourcepackagerelease.getBuildByArch(
    ...     hoary_i386, cprov.archive)
    >>> test_build_i386_ppa == evo_build_i386_ppa
    True

As expected, the hoary/hppa build is still missing in both archives.

    >>> test_build_hppa_ppa = copy.sourcepackagerelease.getBuildByArch(
    ...     hoary_hppa, cprov.archive)
    >>> print test_build_hppa_ppa
    None

When we create a hoary/hppa build in the PPA context, it will continue
to be missing in the PRIMARY archive context.

    >>> evo_build_hppa_ppa = copy.sourcepackagerelease.createBuild(
    ...     hoary_hppa, pocket_release, cprov.archive)

    >>> test_build_hppa_ppa = copy.sourcepackagerelease.getBuildByArch(
    ...     hoary_hppa, cprov.archive)

    >>> print test_build_hppa_ppa.title
    hppa build of evolution 1.0 in ubuntu hoary RELEASE

    >>> test_build_hppa = evo_spr.getBuildByArch(
    ...     hoary_hppa, ubuntu.main_archive)
    >>> print test_build_hppa
    None


== Build lookup for sources & binaries copied across PPAs ==

Launchpad also allow copies from published sources including
corresponding binaries from PRIMARY archive to PPA or from one PPA to
other.

In order to be independent of the sampledata we will use the
SoyuzTestPublisher helper to create fake but complete publications for
this test.

    >>> from canonical.launchpad.tests.test_publishing import (
    ...     SoyuzTestPublisher)
    >>> test_publisher = SoyuzTestPublisher()

    >>> name16 = getUtility(IPersonSet).getByName('name16')
    >>> test_publisher.person = name16

We will create a foo_1.0 source, build and i386 binary published in
hoary PRIMARY archive.

    >>> from canonical.launchpad.interfaces import (
    ...    PackagePublishingStatus)

    >>> foo_pub_src = test_publisher.getPubSource(
    ...     version="0.1", architecturehintlist='i386',
    ...     distroseries=hoary, archive=ubuntu.main_archive,
    ...     status=PackagePublishingStatus.PUBLISHED)

    >>> foo_pub_binaries = test_publisher.getPubBinaries(
    ...     distroseries=hoary, pub_source=foo_pub_src,
    ...     status=PackagePublishingStatus.PUBLISHED)

    >>> foo_source_release = foo_pub_src.sourcepackagerelease

    >>> build_primary = foo_source_release.getBuildByArch(
    ...     hoary_i386, ubuntu.main_archive)

    >>> print build_primary.title
    i386 build of foo 0.1 in ubuntu hoary RELEASE

    >>> print build_primary.archive.title
    Primary Archive for Ubuntu Linux

Then we can copy source and binary from PRIMARY archive to Celso's PPA:

    >>> cprov_src = foo_pub_src.copyTo(
    ...    hoary, pocket_release, cprov.archive)
    >>> cprov_bin = foo_pub_binaries[0].copyTo(
    ...    hoary, pocket_release, cprov.archive)

A build record is clearly not required here, since both, source and
binary got copied from PRIMARY archive, however the system is not able
to identify this situation and cannot locate the the original build
(See bug #181736.)

    >>> cprov_spr = cprov_src.sourcepackagerelease
    >>> cprov_build = cprov_spr.getBuildByArch(
    ...     hoary_i386, cprov.archive)
    >>> print cprov_build
    None

Now we can also copy the source and its binary from Celso's PPA to
Mark Shuttleworth's PPA.

    >>> from canonical.database.sqlbase import flush_database_updates
    >>> cprov_src.status = PackagePublishingStatus.PUBLISHED
    >>> cprov_bin.status = PackagePublishingStatus.PUBLISHED
    >>> flush_database_updates()
    >>> cprov_foo_src = cprov.archive.getPublishedSources(name='foo')[0]
    >>> cprov_foo_bin = cprov_foo_src.getPublishedBinaries()[0]

    >>> sabdfl = getUtility(IPersonSet).getByName('sabdfl')
    >>> sabdfl_src = cprov_foo_src.copyTo(
    ...    hoary, pocket_release, sabdfl.archive)

    >>> sabdfl_bin = cprov_foo_bin.copyTo(
    ...    hoary, pocket_release, sabdfl.archive)

The same problem happens here, the system is not able to locate the
original build.

    >>> sabdfl_spr = sabdfl_src.sourcepackagerelease
    >>> sabdfl_build = sabdfl_spr.getBuildByArch(
    ...     hoary_i386, sabdfl.archive)
    >>> print sabdfl_build
    None


== Sources with architecture-independent and specific binaries ==

Even if the source package builds a architecture-independent package,
no Build record will be returned by getBuildByArch() if arch-specific
binary packages were not built (see bug #65712 for further
information).

Let's create and publish a source which produces an
architecture-independent binary.

    >>> foo_pub_src = test_publisher.getPubSource(
    ...     version="1.0", architecturehintlist='all',
    ...     distroseries=hoary, archive=ubuntu.main_archive,
    ...     status=PackagePublishingStatus.PUBLISHED)

    >>> foo_pub_binaries = test_publisher.getPubBinaries(
    ...     distroseries=hoary, pub_source=foo_pub_src,
    ...     status=PackagePublishingStatus.PUBLISHED)

The build record for foo in hoary/i386 was created.

    >>> test_build_i386 = foo_pub_src.sourcepackagerelease.getBuildByArch(
    ...     hoary_i386, ubuntu.main_archive)
    >>> print test_build_i386.title
    i386 build of foo 1.0 in ubuntu hoary RELEASE

And despite of having a architecture-independent binary published in
hoary hppa, the build lookup n this architecture return None, i.e, the
build doesn't exist.

    >>> for pub in foo_pub_binaries:
    ...     print pub.displayname
    foo-bin 1.0 in hoary i386
    foo-bin 1.0 in hoary hppa

    >>> test_build_hppa = foo_pub_src.sourcepackagerelease.getBuildByArch(
    ...     hoary_hppa, ubuntu.main_archive)
    >>> print test_build_hppa
    None

