
The canonical.database.adapter module provides a Zope database adapter
that can prevent SQL statements from being executed if a request takes
longer than length of time to execute.

Imports and test setup:

    >>> import threading
    >>> import time
    >>> import psycopg
    >>> from zope.component import getUtility
    >>> from zope.app.rdb.interfaces import IZopeDatabaseAdapter
    >>> from sqlos.interfaces import IConnectionName
    >>> from canonical.config import config
    >>> from canonical.launchpad.webapp.adapter import *

    >>> from canonical.launchpad.ftests.harness import (
    ...     LaunchpadFunctionalTestSetup)
    >>> LaunchpadFunctionalTestSetup().setUp()


The Launchpad database connection is created by getting the
IZopeDatabaseAdapter for the connection name in question.  The
LaunchpadDatabaseAdapter class is registered for the connection name
SQLOS uses:

    >>> name = getUtility(IConnectionName)
    >>> da = getUtility(IZopeDatabaseAdapter, name.name)
    >>> isinstance(da, LaunchpadDatabaseAdapter)
    True


Statement Timeout
=================

The timeout is set in launchpad.conf file.  By default it is unset,
which corresponds to no timeout:

    >>> print config.launchpad.db_statement_timeout
    None

Connections created with the database adapter will use this timeout as
the Postgres statement timeout (a value of zero means no timeout):

    >>> conn = da()
    >>> cursor = conn.cursor()
    >>> cursor.execute('show statement_timeout')
    >>> print cursor.fetchone()[0]
    0
    >>> da.disconnect()


Now we set the timeout to 5000 milliseconds:

    >>> config.launchpad.db_statement_timeout = 5000
    >>> conn = da()
    >>> cursor = conn.cursor()
    >>> cursor.execute('show statement_timeout')
    >>> print cursor.fetchone()[0]
    5000


Request Timeout
===============

While the postgres statement timeout can help cut short some out of
control requests, it will not help when a request performs a large
number of small requests.

To help with this, the set_request_started() and
clear_request_started() functions are provided as hooks for the web
publisher.  If a request exceeds the timeout, execute() method on
cursors will start raising an exception.

Signal the start of a request:

    >>> set_request_started()

Perform an operation before the time limit expires:

    >>> cursor.execute('SELECT 1')

Once the request has been completed, clear_request_started() should be
called:

    >>> clear_request_started()


The request start time can also be passed to set_request_started().
Set the request start time to 1 minute in the past, and execute
another query:

    >>> set_request_started(time.time() - 60)
    >>> cursor.execute('SELECT 1')
    Traceback (most recent call last):
    ...
    RequestExpired: SELECT 1


When a RequestExpired exception is raised, the current database
transaction will be doomed, and future queries will fail:

    >>> clear_request_started()
    >>> try:
    ...     cursor.execute('SELECT 1')
    ... except psycopg.DatabaseError, e:
    ...     print str(e)
    ERROR:  current transaction is aborted, commands ignored until end of transaction block
    <BLANKLINE>
    SELECT 1

Cleanup:

    >>> conn.rollback()

The LaunchpadDatabaseAdapter assumes that each thread services a
different request, so a request timing out on one thread will not
affect other threads:

    >>> started_request = threading.Event()
    >>> statement_issued = threading.Event()
    >>> def foo():
    ...     set_request_started(time.time() - 60) # timed out
    ...     started_request.set()
    ...     statement_issued.wait()
    ...
    >>> set_request_started()
    >>> thread = threading.Thread(target=foo)
    >>> thread.start()
    >>> started_request.wait()
    >>> cursor.execute('SELECT 1')
    >>> statement_issued.set()
    >>> thread.join()
    >>> clear_request_started()

Similarly, starting a new request in another thread will not reset the
remove the timout:

    >>> started_request = threading.Event()
    >>> statement_issued = threading.Event()
    >>> def foo():
    ...     set_request_started()
    ...     started_request.set()
    ...     statement_issued.wait()
    ...
    >>> set_request_started(time.time() - 60)
    >>> thread = threading.Thread(target=foo)
    >>> thread.start()
    >>> started_request.wait()
    >>> cursor.execute('SELECT 1')
    Traceback (most recent call last):
    ...
    RequestExpired: (('SELECT 1',), {})
    >>> statement_issued.set()
    >>> thread.join()
    >>> clear_request_started()
    >>> conn.rollback()


If no timeout has been set, then requests will not time out:

    >>> config.launchpad.db_statement_timeout = None
    >>> da.disconnect()
    >>> conn = da()
    >>> cursor = conn.cursor()
    >>> set_request_started(time.time() - 60)
    >>> cursor.execute('SELECT 1')
    >>> clear_request_started()


Customizing the database adapter also lets us easily tweak the current
connection. For example we can make it read only:

    >>> cursor.execute("""
    ...     INSERT INTO SourcePackageName(name) VALUES ('fnord')
    ...     """)
    >>> da.readonly()
    >>> cursor.execute("""
    ...     INSERT INTO SourcePackageName(name) VALUES ('fnord2')
    ...     """)
    Traceback (most recent call last):
    ...
    ProgrammingError: ERROR:  transaction is read-only
    ...

The read only status only lasts until the end of the transaction.:

    >>> import transaction
    >>> transaction.abort()
    >>> cursor = da().cursor()
    >>> cursor.execute("""
    ...     INSERT INTO SourcePackageName(name) VALUES ('fnord2')
    ...     """)
    >>> transaction.abort()

We can also change the user we are connected as, which is useful in tests.
You should only change the user at the start of a transaction, or else any
uncommitted changes made may be lost:

    >>> da.switchUser(config.statistician.dbuser)
    >>> cursor = da().cursor()
    >>> cursor.execute("SELECT current_user")
    >>> cursor.fetchone()[0] == config.statistician.dbuser
    True
    >>> cursor.execute("""
    ...     INSERT INTO SourcePackageName(name) VALUES ('fnord4')
    ...     """)
    Traceback (most recent call last):
    ...
    ProgrammingError: ERROR:  permission denied for relation sourcepackagename
    ...

Unlike readonly, this is not reset at the end of the transaction:

    >>> transaction.abort()
    >>> cursor = da().cursor()
    >>> cursor.execute("SELECT current_user")
    >>> cursor.fetchone()[0] == config.statistician.dbuser
    True
    >>> cursor.execute("""
    ...     INSERT INTO SourcePackageName(name) VALUES ('fnord4')
    ...     """)
    Traceback (most recent call last):
    ...
    ProgrammingError: ERROR:  permission denied for relation sourcepackagename
    ...
    >>> transaction.abort()

So you need to explicity set the user back:

    >>> da.switchUser()
    >>> cursor = da().cursor()
    >>> cursor.execute("""
    ...     INSERT INTO SourcePackageName(name) VALUES ('fnord4')
    ...     """)
    >>> cursor.execute("SELECT current_user")
    >>> cursor.fetchone()[0] == config.launchpad.dbuser
    True

Cleanup:

    >>> LaunchpadFunctionalTestSetup().tearDown()
