Introduction
============

Bugs are problems reported in software. Bugs can be assigned to packages and
products to be fixed. People can "subscribe" to bugs. This document is about
people subscribing to bugs.

Accessing Bug Subscriber Lists
==============================

Sometimes you'll want to know which people are subscribed to a bug. For
example, you might want to send out a notification email to everyone that is
Cc'd on a bug when something changes. For the purposes of this document, let's
pretend we're logged in as Foo Bar:

    >>> from canonical.launchpad.ftests import login
    >>> login("foo.bar@canonical.com")

To get the set of subscriptions to a bug, you can access the
IBug.subscriptions attribute:

    >>> from canonical.launchpad.interfaces import IBugSet
    >>> from zope.component import getUtility
    >>> bugset = getUtility(IBugSet)
    >>> bug = bugset.get(1)
    >>> bug.subscriptions.count()
    2

This is slightly misleading though, because this only gives us the
list of explicit subscriptions on the bug, when in fact, there are
special cases where one can be "implicitly" subscribed to a bug.

Implicit vs. Explicit Subscriptions
-----------------------------------

An explicit subscription means that there's a row in the
BugSubscription for that subscription. An implicit subscription does not
have a corresponding row in the BugSubscription table.

To get the entire list of email addresses that should receive a
notification email on a bug, call
IBug.notificationRecipientAddresses().

   >>> bug.notificationRecipientAddresses()
   ['mark@hbd.com', 'test@canonical.com']

To find out if someone is already explicitly subscribed to a bug, call
IBug.isSubscribed, passing in an IPerson:

    >>> from canonical.launchpad.interfaces import IPersonSet
    >>> personset = getUtility(IPersonSet)
    >>> bug.isSubscribed(personset.get(16))
    False
    >>> bug.isSubscribed(personset.get(12))
    True

Subscribing and Unsubscribing
=============================

To subscribe people to and unsubscribe people from a bug, use
IBug.subscribe and IBug.unsubscribe:

    >>> foobar = personset.get(16)
    >>> subscribed_people = [s.person.id for s in bug.subscriptions]
    >>> 16 not in subscribed_people
    True
    >>> bug.subscribe(foobar)
    <BugSubscription at ...>
    >>> subscriptions = [s.person.id for s in bug.subscriptions]
    >>> 16 in subscriptions
    True

Automatic Subscriptions on Bug Creation
=======================================

When a new bug is opened, the following people are automatically added as
explicit Cc subscribers to the bug:

  * The bug reporter

  * The distribution bug contact, if there is one

  * The product bug contact, if there is one

  * The package bug contact(s). There may be zero, one or more package
    bug contacts.

XXX: Brad Bollenbach, 2005-11-25: These bits need real sample data. See
https://launchpad.net/bugs/5484.

Let's have a look at an example for a distribution bug:

    >>> from canonical.launchpad.interfaces import IDistributionSet
    >>> ubuntu = getUtility(IDistributionSet).get(1)
    >>> sample_person = personset.get(12)
    >>> ubuntu.bugcontact = sample_person

    >>> from canonical.launchpad.interfaces import IBugSet

    >>> new_bug = getUtility(IBugSet).createBug(
    ...     title="a test bug", comment="a test description",
    ...     owner=foobar, distribution=ubuntu)

    >>> sorted(new_bug.notificationRecipientAddresses())
    ['foo.bar@canonical.com', 'test@canonical.com']

The distro contact will *not* be subscribed to private bugs:

    >>> new_bug = getUtility(IBugSet).createBug(
    ...     title="a test bug", comment="a test description",
    ...     owner=foobar, distribution=ubuntu, private=True)

    >>> sorted(new_bug.notificationRecipientAddresses())
    ['foo.bar@canonical.com']

Another example, this time for an upstream:

    >>> from canonical.launchpad.interfaces import IProductSet
    >>> sabdfl = personset.get(1)
    >>> firefox = getUtility(IProductSet).get(4)
    >>> firefox.bugcontact = sabdfl

    >>> new_bug = getUtility(IBugSet).createBug(
    ...     title="a test bug", comment="a test description",
    ...     owner=foobar, product=firefox)

    >>> sorted(new_bug.notificationRecipientAddresses())
    ['foo.bar@canonical.com', 'mark@hbd.com']

If we create a bug task on Ubuntu in the same bug, the Ubuntu bug
contact will be subscribed:

    >>> from canonical.launchpad.interfaces import IBugTaskSet
    >>> ubuntu_task = getUtility(IBugTaskSet).createTask(
    ...     bug=new_bug, distribution=ubuntu, owner=sabdfl)

    >>> sorted(new_bug.notificationRecipientAddresses())
    ['foo.bar@canonical.com', 'mark@hbd.com', 'test@canonical.com']

When an upstream does *not* have a specific bug contact set, the
product.owner is used instead. So, if Firefox's bugcontact is unset,
Sample Person, the Firefox "owner" will get subscribed instead:

    >>> firefox.bugcontact = None

    >>> new_bug = getUtility(IBugSet).createBug(
    ...     title="a test bug", comment="a test description",
    ...     owner=foobar, product=firefox)

    >>> sorted(new_bug.notificationRecipientAddresses())
    ['foo.bar@canonical.com', 'test@canonical.com']

The upstream bug contact will *not* be automatically subscribed to
private bugs:

    >>> new_bug = getUtility(IBugSet).createBug(
    ...     title="a test bug", comment="a test description",
    ...     owner=foobar, product=firefox, private=True)

    >>> sorted(new_bug.notificationRecipientAddresses())
    ['foo.bar@canonical.com']

Now let's create a bug on a specific package, which has no package bug
contacts:

    >>> evolution = ubuntu.getSourcePackage("evolution")
    >>> evolution.bugcontacts
    []

    >>> new_bug = getUtility(IBugSet).createBug(
    ...     title="another test bug",
    ...     comment="another test description",
    ...     owner=foobar, distribution=ubuntu,
    ...     sourcepackagename=evolution.sourcepackagename)

    >>> sorted(new_bug.notificationRecipientAddresses())
    ['foo.bar@canonical.com', 'test@canonical.com']

Adding a package bug contact for evolution will mean that that package
bug contact gets subscribed to all bugmail on bugs filed after the point
that the bug contact was set.

So, if the Ubuntu team is added as a bug contact to evolution:

    >>> ubuntu_team = personset.get(17)
    >>> evolution.addBugContact(ubuntu_team)

The team will still *not* be a recipient of bugmail from the previous
bug we created:

    >>> sorted(new_bug.notificationRecipientAddresses())
    ['foo.bar@canonical.com', 'test@canonical.com']

But the team will be subscribed to bugmail for future bugs:

    >>> new_bug = getUtility(IBugSet).createBug(
    ...     title="yet another test bug",
    ...     comment="yet another test description",
    ...     owner=foobar, distribution=ubuntu,
    ...     sourcepackagename=evolution.sourcepackagename)

    >>> sorted(new_bug.notificationRecipientAddresses())
    ['foo.bar@canonical.com', 'support@ubuntu.com', 'test@canonical.com']

The distribution and package contacts do not get subscribed to private
bug reports automatically:

    >>> new_bug = getUtility(IBugSet).createBug(
    ...     title="yet another test bug",
    ...     comment="yet another test description",
    ...     owner=foobar, distribution=ubuntu,
    ...     sourcepackagename=evolution.sourcepackagename,
    ...     private=True)

    >>> sorted(new_bug.notificationRecipientAddresses())
    ['foo.bar@canonical.com']
