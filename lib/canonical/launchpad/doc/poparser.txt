= Tests for our PO parser =

The core of Rosetta is the PO parser, it allows to communicate with the
external world importing files and exporting them.

Let's import some needed objects...

  >>> from canonical.launchpad.components.poparser import (
  ...     POMessage, POHeader, POParser)


== POParser ==

First we get the needed imports.

  >>> from canonical.launchpad.components.poparser import POParser

We should be completely sure that a .po file with an empty header is reported.

  >>> parser = POParser()
  >>> parser.write('msgid "foo"\nmsgstr ""\n')
  >>> parser.finish()
  Traceback (most recent call last):
  ...
  POSyntaxError:...


== POHeader ==

A POHeader is a representation of a special message that all .po files have.
That first message has as the msgid the empty string ("") and as the
translation of it some metadata.


=== getPORevisionDate ===

Test that the function does not fails if the date field has unicode chars:

  >>> header = POHeader(msgstr="""
  ... Project-Id-Version: foo
  ... Report-Msgid-Bugs-To: foo@bar.com
  ... POT-Creation-Date: 2005-01-26 01:01+0100
  ... PO-Revision-Date: \xc3\xa1 2004-03-06 20:06+0100
  ... Last-Translator: Foo translator <footranslator@bar.com>
  ... MIME-Version: 1.0
  ... Content-Type: text/plain; charset=UTF-8
  ... Content-Transfer-Encoding: 8bit
  ... """)
  >>> header.updateDict()
  >>> header.getPORevisionDate()
  (u'\xe1 2004-03-06 20:06+0100', None)
  >>> header.getPluralFormExpression() == None
  True


== Parsing a PO template ==

Parsing a PO template:

  >>> content = """
  ... msgid ""
  ... msgstr ""
  ... "Project-Id-Version: Foobar 1.0\\n"
  ... "Report-Msgid-Bugs-To: \\n"
  ... "POT-Creation-Date: 2004-05-11 20:22+0800\\n"
  ... "PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\\n"
  ... "Last-Translator: FULL NAME <EMAIL@ADDRESS>\\n"
  ... "Language-Team: LANGUAGE <LL@li.org>\\n"
  ... "MIME-Version: 1.0\\n"
  ... "Content-Type: text/plain; charset=CHARSET\\n"
  ... "Content-Transfer-Encoding: 8bit\\n"
  ... #: foo/bar.c:42
  ... msgid "Foo"
  ... msgstr ""
  ... """

  >>> parser = POParser()
  >>> parser.write(content)
  >>> parser.finish()

  >>> print parser.header['project-id-version']
  Foobar 1.0
  >>> print parser.header['content-type']
  text/plain; charset=CHARSET
  >>> len(parser.messages)
  1
  >>> print parser.messages[0].msgid
  Foo

PO templates, and other PO files that do not specify their encoding,
are parsed as ASCII text.  If they contain 8 bit characters, parsing
errors occur:

  >>> chunk2 = """
  ... #:foo/bar.c:42
  ... msgid "Bar"
  ... msgstr "ab\xc5"
  ... #:foo/baz.c:42
  ... msgid "Baz"
  ... msgstr "abcdef"
  ... """

  >>> parser = POParser()
  >>> parser.write(content)
  >>> parser.write(chunk2)
  Traceback (most recent call last):
    ...
  POInvalidInputError: could not decode input from ASCII


== Split Multibyte Sequences ==

The PO file parser can incrementally parse files.  When multibyte
character encodings are used, this opens up the possibility that a
chunk fed to the parser will start or end with part of a character.

The PO parser handles this case correctly:

  >>> chunk1 = """
  ... msgid ""
  ... msgstr ""
  ... "POT-Creation-Date: 2004-05-11 20:22+0800\\n"
  ... "PO-Revision-Date: 2004-05-11 20:22+0800\\n"
  ... "Content-Type: text/plain; charset=UTF-8\\n"
  ... "Content-Transfer-Encoding: 8bit\\n"
  ... #: foo/bar.c: 42
  ... msgid "Foo"
  ... msgstr "\xE2"""
  >>> chunk2 = """\x96\x84"
  ... """

  >>> parser = POParser()
  >>> parser.write(chunk1)
  >>> parser.write(chunk2)
  >>> parser.finish()

  >>> len(parser.messages)
  1
  >>> parser.messages[0].msgid
  u'Foo'
  >>> parser.messages[0].msgstr
  u'\u2584'


== Evil Big5 Multibyte Sequences ==

To parse a PO file, it is necessary to know what encoding it is in,
which is specified in the PO file header.

This is particularly important with some encodings such as Big5, which
may include backslashes inside multibyte sequences.  These backslashes
must be interpreted as part of the character rather than as an escape
character.

  >>> content = """
  ... msgid ""
  ... msgstr ""
  ... "Last-Translator:  \xb5\x7b\xa6\xa1\xbf\xf9\xbb\x7e\\n"
  ... "Content-Type: text/plain; charset=Big5\\n"
  ... "Content-Transfer-Encoding: 8bit\\n"
  ... #: lib/regex.c:1367
  ... msgid "Success"
  ... msgstr "\xa6\xa8\xa5\\"
  ... """

  >>> parser = POParser()
  >>> parser.write(content)
  >>> parser.finish()

Check that Big5 characters in the PO header have been correctly
converted:

  >>> parser.header['last-translator']
  u'\u7a0b\u5f0f\u932f\u8aa4'

Check that the translation of the first message has been interpreted
correctly, despite the backslash in the second multibyte sequence:

  >>> parser.messages[0].msgstr
  u'\u6210\u529f'


== Newline Formats ==

Not everyone is using UNIX systems, so some submitted PO files will
not use standard UNIX newlines.

Windows style '\r\n' newlines don't cause much trouble since those
files just appear to have some additional whitespace at the end of
lines.

Macintosh style '\r' newlines don't contain a '\n' character at all,
which would cause problems if we naively use '\n' as a line separator.

Change the last PO file to use Mac-style newlines:

  >>> content = content.replace('\n', '\r')

Verify that it still parses:

  >>> parser = POParser()
  >>> parser.write(content)
  >>> parser.finish()

  >>> parser.messages[0].msgstr
  u'\u6210\u529f'


== Escape Characters in Strings ==

Message strings in PO files can contain C string escape sequences. Some of
them have special meaning like 'new line': '\n' or 'tabs' '\t' and others are
just the numeric representation of a character in the declared encoding by
the Content-Type field of the header.

  >>> content = """
  ... msgid ""
  ... msgstr ""
  ... "POT-Creation-Date: 2004-05-11 20:22+0800\\n"
  ... "PO-Revision-Date: 2004-05-11 20:22+0800\\n"
  ... "Content-Type: text/plain; charset=UTF-8\\n"
  ... "Content-Transfer-Encoding: 8bit\\n"
  ... #: foo/bar.c: 42
  ... msgid "Foo\\n"
  ... "Bar\\n"
  ... msgstr "\\a\\b\\v\\f\\t\\v\\\\\\"\\'\\n"
  ... "\\70 \\070 \\0700 \\x70\\n"
  ...
  ... #: foo/bar.c: 50
  ... msgid "view \\302\\253${version_title}\\302\\273"
  ... msgstr ""
  ... """

  >>> parser = POParser()
  >>> parser.write(content)
  >>> parser.finish()

The special symbols and numeric representations of the chars '8', '80' and 'p'
are decoded correctly.

  >>> parser.messages[0].msgstr
  u'\x07\x08\x0b\x0c\t\x0b\\"\'\n8 8 80 p\n'

In this case, the numeric representation are UTF-8 only characters and we can
see that we get its Unicode equivalent.

  >>> parser.messages[1].msgid
  u'view \xab${version_title}\xbb'
