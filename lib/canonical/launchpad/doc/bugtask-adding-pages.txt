Adding BugTasks
===============

If a bug occurs in more than one place, you can request a fix in some
other software. You can request a fix in either a product or a
distribution. Let's start with a product, this is done using
+upstreamtask.

    >>> login('test@canonical.com')
    >>> from zope.component import getView
    >>> from canonical.launchpad.interfaces import IBugSet
    >>> bug_four = getUtility(IBugSet).get(4)
    >>> len(bug_four.bugtasks)
    1
    >>> firefox_task = bug_four.bugtasks[0]
    >>> from canonical.launchpad.webapp.servers import LaunchpadTestRequest
    >>> request = LaunchpadTestRequest()

Some of the setup is done just before the view is rendered. Let's
create a helper function that makes sure the view is set up properly.
We don't care about the actual rendering of the page, so we override
the view.template().

    >>> def get_and_setup_view(context, name, request):
    ...     view = getView(context, name, request)
    ...     view.index = lambda: ''
    ...     view()
    ...     return view
    >>> add_task_view = get_and_setup_view(
    ...     firefox_task, '+upstreamtask', request)

We haven't posted the form, so process_status will be empty.

    >>> add_task_view.process_status
    ''

If we POST the form without entering any information, it will complain
that product is required:

    >>> request = LaunchpadTestRequest(form={'FORM_SUBMIT': ''})
    >>> add_task_view = get_and_setup_view(
    ...     firefox_task, '+upstreamtask', request)
    >>> add_task_view.process_status
    u'Please fix the problems below and try again.'
    >>> add_task_view.errors
    MissingInputError: ('product', u'Product', 'the field is required')

In order to show that all the events get fired off, let's create an
event listener and register it:

    >>> from zope.interface import Interface
    >>> from canonical.launchpad.ftests.event import TestEventListener
    >>> from canonical.launchpad.event.interfaces import ISQLObjectCreatedEvent
    >>> def on_created_event(object, event):
    ...     print "SQLObjectCreatedEvent: %r" % object
    >>> on_created_listener = TestEventListener(
    ...     Interface, ISQLObjectCreatedEvent, on_created_event)


If we specify a valid product, no errors will occur, and a bugtask will
be created:

    >>> request = LaunchpadTestRequest(
    ...     form={'FORM_SUBMIT': '', 'field.product': 'thunderbird'})
    >>> add_task_view = get_and_setup_view(
    ...     firefox_task, '+upstreamtask', request)
    SQLObjectCreatedEvent: <BugTask at ...>

The Thunderbird bug task was added to the bug:

    >>> for bugtask in bug_four.bugtasks:
    ...     print bugtask.targetname
    firefox (upstream)
    thunderbird (upstream)

Since Thunderbird doesn't use Malone, the status and importance are set to
Unknown. They will be set later, if it's linked to a bug watch.

    >>> thunderbird_task = bug_four.bugtasks[1]
    >>> thunderbird_task.target.official_malone
    False
    >>> thunderbird_task.status.title
    'Unknown'
    >>> thunderbird_task.importance.title
    'Unknown'

At the same form, we can add a bug watch. If we specify a remote bug
tracker, but omit the remote bug number, an error message is given:

    >>> request = LaunchpadTestRequest(
    ...     form={'FORM_SUBMIT': '', 'field.product': 'evolution',
    ...           'field.bugtracker-empty-marker': '1',
    ...           'field.bugtracker': '2'})
    >>> add_task_view = get_and_setup_view(
    ...     firefox_task, '+upstreamtask', request)
    >>> add_task_view.process_status
    u'Please fix the problems below and try again.'
    >>> add_task_view.top_of_page_errors
    LaunchpadValidationError:
    ...Please specify the remote bug number in the remote bug tracker...

Note that this caused the transaction to be aborted, thus the bugtask
that got added earlier is now gone:

    >>> len(bug_four.bugtasks)
    1

If we specify a remote bug number as well, both the task and the bug
watch will be added:

    >>> request = LaunchpadTestRequest(
    ...     form={'FORM_SUBMIT': '', 'field.product': 'evolution',
    ...           'field.bugtracker-empty-marker': 1, 'field.bugtracker': 2,
    ...           'field.remotebug': '42'})
    >>> add_task_view = get_and_setup_view(
    ...     firefox_task, '+upstreamtask', request)
    SQLObjectCreatedEvent: <BugWatch at ...>
    SQLObjectCreatedEvent: <BugTask at ...>

    >>> for bugtask in bug_four.bugtasks:
    ...     print bugtask.targetname
    evolution (upstream)
    firefox (upstream)

    >>> for bugwatch in bug_four.watches:
    ...     print "%s: %s" % (bugwatch.bugtracker.title, bugwatch.remotebug)
    GnomeGBug GTracker: 42

Since Evolution uses Malone as its official bug tracker, the bug watch
didn't get linked to the created task:

    >>> evolution_task = bug_four.bugtasks[0]
    >>> evolution_task.product.official_malone
    True
    >>> evolution_task.bugwatch is None
    True

However, if we add a bug watch together with a product which doesn't
use Malone, the bug watch will be linked to the task, since the task
will use the watch to keep track of its status:

    >>> request = LaunchpadTestRequest(
    ...     form={'FORM_SUBMIT': '', 'field.product': 'thunderbird',
    ...           'field.bugtracker-empty-marker': 1, 'field.bugtracker': 2,
    ...           'field.remotebug': '84'})
    >>> add_task_view = get_and_setup_view(
    ...     firefox_task, '+upstreamtask', request)
    SQLObjectCreatedEvent: <BugWatch at ...>
    SQLObjectCreatedEvent: <BugTask at ...>

    >>> for bugtask in bug_four.bugtasks:
    ...     print bugtask.targetname
    evolution (upstream)
    firefox (upstream)
    thunderbird (upstream)

    >>> for bugwatch in bug_four.watches:
    ...     print "%s: %s" % (bugwatch.bugtracker.title, bugwatch.remotebug)
    GnomeGBug GTracker: 42
    GnomeGBug GTracker: 84

    >>> thunderbird_task = bug_four.bugtasks[2]
    >>> thunderbird_task.product.official_malone
    False
    >>> thunderbird_task.bugwatch == bug_four.watches[1]
    True

    >>> on_created_listener.unregister()
