= RESTful Web Services =

LAZR builds on Zope conventions to make it easy to expose your
business objects as RESTful HTTP resources. I'll demonstrate these
features by defining some business objects for managing recipes, and
then publishing them as resources through a web service.


== Example business objects ==

Here's the interface for a simple business object that contains a
recipe. This is the kind of business object you'd find in any Zope
application, with no special knowledge of web services.

    >>> # All classes defined in this test should be new-style classes.
    >>> __metaclass__ = type

    >>> from zope.interface import Interface
    >>> from zope.schema import Int, TextLine
    >>> class IRecipe(Interface):
    ...     name = Int(title=u"Unique ID", required=True)
    ...     name = TextLine(title=u"Name", required=True)

Here's the interface for the 'set' object that manages the individual
recipes:

    >>> class IRecipeSet(Interface):
    ...     def getAll(self):
    ...         "Get all recipes."

Here's a simple implementation of Recipe.

    >>> from zope.interface import implements
    >>> class Recipe:
    ...     implements(IRecipe)
    ...     def __init__(self, id, name):
    ...         self.id = id
    ...         self.name = name

Here are the "business objects" themselves:

    >>> R1 = Recipe(1, "Green eggs and ham")
    >>> R2 = Recipe(7, "Steak au poivre")
    >>> R3 = Recipe(10, "Raw celery")

Here's a simple RecipeSet with a predefined list of recipes.

    >>> class RecipeSet:
    ...     implements(IRecipeSet)
    ...     def __init__(self):
    ...         self.recipes = [R1, R2, R3]
    ...
    ...     def getAll(self):
    ...         return self.recipes
    ...
    ...     def get(self, id):
    ...         match = [r for r in self.recipes if r.id == id]
    ...         if len(match) > 0:
    ...             return match[0]
    ...         return None


== Defining the resources ==

LAZR provides an interface, IEntry, for the individual business object
exposed through the resource. Right now it's just a marker interface,
but it's expected to define a number of data fields: the same kind of
fields defined by a business object interface like IRecipe.

If we wanted to expose our IRecipe business objects through the web
service exactly as they are, we could simply define a class that
includes both interfaces.

    >>> from canonical.lazr.interfaces import IEntry
    >>> class IRecipeEntry1(IEntry, IRecipe):
    ...     """An IRecipe exposed as an entry."""

But most of the time, we don't want to expose our business objects
directly through the web service. There will be fields we don't want
to expose, synthetic fields we do want to expose, fields we want to
expose under a different name, and so on. In that case, our IEntry
subclass will define the interface we _do_ want to expose through the
web service. Here, we're exposing an IEntry that exposes the
underlying recipe's name but not its ID:

    >>> class IRecipeEntry(IEntry):
    ...     """The part of a recipe that we expose through the web service."""
    ...     name = IRecipe.get('name')

Here's the implementation of IRecipeEntry: a simple decorator on the
original business object. It subclasses Entry, a simple base class
that defines a constructor.

    >>> from zope.component import adapts
    >>> from canonical.lp import decorates
    >>> from canonical.lazr.rest import Entry
    >>> class RecipeEntry(Entry):
    ...     """A recipe, as exposed through the web service."""
    ...     adapts(IRecipe)
    ...     decorates(IRecipeEntry)
    ...     schema = IRecipeEntry
    ...
    ...     parent_collection_name = 'recipes'
    ...
    ...     def fragment(self):
    ...         """Use the recipe's ID as its URI fragment."""
    ...         return str(self.context.id)


The "schema" attribute points to the interface class that defines the
attributes exposed through the web service. In this case, it's
IRecipeEntry, which exposes only 'name'.

We need to register RecipeEntry as an adapter from IRecipe to
IRecipeEntry. In ZCML it would look like this.

    <adapter
        for="canonical.launchpad.interfaces.IRecipe"
        provides="canonical.launchpad.interfaces.IRecipeEntry"
        factory="canonical.launchpad.rest.RecipeEntry"
        />

Since we're in the middle of a Python test we need to do the equivalent
in Python code:

    >>> from zope.component import provideAdapter
    >>> provideAdapter(RecipeEntry, [IRecipe], IRecipeEntry)

LAZR also defines an interface and a base class for collections of
objects. I'll use it to expose the RecipeSet collection through the
web service. A collection must define a method called find(), which
returns the business objects in the collection.

    >>> from canonical.lazr.rest import Collection
    >>> class RecipeCollection(Collection):
    ...     """A collection of recipes, as exposed through the web service."""
    ...
    ...     def find(self):
    ...        """Find all the recipes."""
    ...        return self.context.getAll()
    ...
    ...     def lookupEntry(self, id):
    ...        """Find a single recipe by ID."""
    ...        return self.context.get(int(id))

    >>> from canonical.lazr.interfaces import ICollection
    >>> provideAdapter(RecipeCollection, [IRecipeSet], ICollection)

As with Entry, Collection is a simple base class that defines a
constructor.


== Resource objects ==

LAZR's Resource objects are the objects that actually handle incoming
HTTP requests. There are a few very common types of HTTP resources,
and LAZR defines classes for some of them. For instance, there's the
"collection" resource that responds to GET (to get the items in the
collection) and POST (to add a new item to the collection). LAZR
implements this as a CollectionResource which uses the HTTP arguments
to drive Collection methods like find() and createNew() (createNew()
isn't implemented yet).

Of course, a CollectionResource has to expose a collection _of_
something. That's why each CollectionResource is associated with some
concrete implementation of ICollection, like RecipeCollection. All you
have to do is define the behavior of the collection, and
CollectionResource takes care of exposing the collection through HTTP.
Similarly, you can implement RecipeEntry to the IEntry interface, and
expose it through the web as an EntryResource.


== The Service Root ==

How are these Resource objects connected to the web? Through the
ServiceRoot. This is an object that represents the web
service itself.

    >>> from canonical.lazr.rest import ServiceRoot
    >>> from canonical.launchpad.interfaces import IWebServiceApplication
    >>> class MyServiceRoot(ServiceRoot):
    ...    implements(IWebServiceApplication)
    ...    top_level_collections = { 'recipes' : RecipeSet }
    ...    rootsite = 'api'


The service root can act as a resource. If you call it and pass in an
HTTP request, it will act as though you had performed a GET on the URL
'http://api.launchpad.net/'.

    >>> from canonical.launchpad.webapp.servers import LaunchpadTestRequest
    >>> from canonical.launchpad.webapp.servers import WebServicePublication
    >>> request = LaunchpadTestRequest()
    >>> request.setPublication(WebServicePublication(None))
    >>> request.setApplicationServer('api.launchpad.dev')
    >>> app = MyServiceRoot()
    >>> from canonical.launchpad.interfaces import IOpenLaunchBag
    >>> getUtility(IOpenLaunchBag).add(app)

The ServiceRoot has a list of top-level collections and implements
IPublishTraverse, so that a request to a registered collection is
delegated to the appropriate CollectionResource. Here's an example,
equivalent to requesting 'http://api.launchpad.net/recipes/'.

    >>> collection = app.publishTraverse(request, "recipes")
    >>> collection
    <canonical.lazr.rest.resource.CollectionResource object ...>
    >>> from canonical.launchpad.webapp import canonical_url
    >>> canonical_url(collection, request=request)
    u'http://api.launchpad.dev/recipes'

    >>> import simplejson
    >>> representation = simplejson.loads(collection())
    >>> len(representation)
    3
    >>> representation[0]['self_resource']
    u'http://api.launchpad.dev/recipes/1'
    >>> representation[0]['name']
    u'Green eggs and ham'

Calling the CollectionResource object makes it process the incoming
request. Since this is a GET request, calling the resource publishes
the resource to the web. A CollectionResource is made up of a bunch of
EntryResources, and the base EntryResource class knows how to use the
entry schema class (in this case, IRecipeEntry) to publish a JSON
document.

A CollectionResource object also implements publishTraverse(): you can
navigate from a collection to one of the entries in that collection.
It's the corresponding Collection's job to implement lookupEntry() so
that (for instance) /recipes/10 is mapped to the "Raw celery" Entry.

    >>> entry = collection.publishTraverse(request, "10")
    >>> entry
    <canonical.lazr.rest.resource.EntryResource object ...>
    >>> canonical_url(entry, request=request)
    u'http://api.launchpad.dev/recipes/10'

    >>> simplejson.loads(entry())
    {u'self_resource': u'http://api.launchpad.dev/recipes/10',
     u'name': u'Raw celery'}

If the user tries to traverse to a nonexistent object, the result is a
NotFound exception:

    >>> from zope.publisher.interfaces import NotFound
    >>> try:
    ...     app.publishTraverse(request, "nosuchcollection")
    ... except NotFound, e:
    ...     print "Not found."
    Not found.

    >>> try:
    ...     collection.publishTraverse(request, "104")
    ... except NotFound, e:
    ...     print "Not found."
    Not found.

Eventually, an entry will be responsible for implementing
publishTraverse() to related entries (/recipes/10/owner) and
collections (/recipes/10/ingredients).
