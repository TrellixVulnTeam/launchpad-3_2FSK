= Package sets =

The `Packageset` table allows the specification of a package set. These
facilitate the grouping of packages for purposes like the control of upload
permissions, the calculation of build and runtime package dependencies etc.

Initially, package sets will be used to enforce upload permissions to source
packages. Later they may be put to other uses as well. Please see also the
following URL for user stories and scenarios:
https://dev.launchpad.net/VersionThreeDotO/Soyuz/StoryCards#packagesetacl

It is also possible to define hierarchical relationships between package
sets i.e. include package sets into other package sets and remove them
respectively.

This effectively allows the users to arrange package sets in a directed
acyclic graph (DAG, http://en.wikipedia.org/wiki/Directed_acyclic_graph)
where each arc/edge (A,B) carries the following meaning:
package set 'A' includes another package set 'B' as a subset.

The following passage may also make it easier to understand the nomenclature
used (from http://en.wikipedia.org/wiki/Glossary_of_graph_theory):

    "If v is reachable from u, then u is a predecessor of v and v is a
     successor of u. If there is an arc/edge from u to v, then u is a direct
     predecessor of v, and v is a direct successor of u."


== Package set basics ==

So, let's start by creating a few package sets.

    >>> from zope.component import getUtility
    >>> from canonical.launchpad.interfaces.packageset import (
    ...     IPackagesetSet)

    >>> login('foo.bar@canonical.com')

    >>> person1 = factory.makePerson(
    ...     name='hacker', displayname=u'Happy Hacker')
    >>> person2 = factory.makePerson(
    ...     name='juergen', displayname=u'J\xc3\xbcrgen Schmidt',
    ...     email='js@example.com')
    >>> ps_factory = getUtility(IPackagesetSet)
    >>> umbrella_ps = ps_factory.new(
    ...     u'umbrella', u'Umbrella set, contains all packages', person1)
    >>> kernel_ps = ps_factory.new(
    ...     u'kernel', u'Contains all OS kernel packages', person2)

Now 'juergen' and 'hacker' have a package set each.

    >>> len(ps_factory.getByOwner(person1)) == 1
    True
    >>> len(ps_factory.getByOwner(person2)) == 1
    True

In a next step we will associate source package names with the package sets
just created.

    >>> from canonical.launchpad.webapp.interfaces import (
    ...     IStoreSelector, MAIN_STORE, DEFAULT_FLAVOR, MASTER_FLAVOR)
    >>> from lp.registry.model.sourcepackagename import SourcePackageName
    >>> store = getUtility(IStoreSelector).get(MAIN_STORE, DEFAULT_FLAVOR)

First associate *all* source package names with the umbrella package set.

    >>> all_spns = store.find(SourcePackageName)
    >>> umbrella_ps.add(all_spns)

Let's see what we got:

    >>> import operator
    >>> def sort_by_id(iterable):
    ...     return sorted(iterable, key=operator.attrgetter('id'))
    >>> def print_data(iterable):
    ...     for datum in sort_by_id(iterable):
    ...          print('%3d -> %s' % (datum.id, datum.name))
    >>> umbrella_spns = umbrella_ps.sourcesIncluded(direct_inclusion=True)
    >>> print_data(umbrella_spns)
     1 -> mozilla-firefox
     9 -> evolution
    10 -> netapplet
    14 -> pmount
    15 -> a52dec
    16 -> mozilla
    17 -> at
    18 -> thunderbird
    19 -> alsa-utils
    20 -> cnews
    21 -> libstdc++
    22 -> linux-source-2.6.15
    23 -> foobar
    24 -> cdrkit
    25 -> language-pack-de
    26 -> iceweasel
    27 -> commercialpackage

Now let's put a few selected source package names into the 'kernel' package
set:

    >>> kernel_spns = store.find(
    ...     SourcePackageName, SourcePackageName.name.like('li%'))
    >>> kernel_ps.add(kernel_spns)
    >>> kernel_spns = kernel_ps.sourcesIncluded(direct_inclusion=True)
    >>> print_data(kernel_spns)
    21 -> libstdc++
    22 -> linux-source-2.6.15

Adding source package names to a package set repeatedly has no effect.

    >>> umbrella_ps.add(kernel_spns)
    >>> umbrella_spns2 = umbrella_ps.sourcesIncluded(direct_inclusion=True)
    >>> sort_by_id(umbrella_spns) == sort_by_id(umbrella_spns2)
    True

Removing source package names is easy.

    >>> umbrella_ps.remove(kernel_spns)
    >>> reduced = umbrella_ps.sourcesIncluded(direct_inclusion=True)
    >>> sort_by_id(umbrella_spns) == sort_by_id(reduced + kernel_spns)
    True

Trying to remove source package names that are *not* associated with a
package set from the latter has no effect.

    >>> umbrella_ps.remove(kernel_spns)
    >>> (sort_by_id(reduced) ==
    ...  sort_by_id(umbrella_ps.sourcesIncluded(direct_inclusion=True)))
    True

Add the removed source package names back to 'umbrella'.

    >>> umbrella_ps.add(kernel_spns)


== Package set hierarchies ==

The next step in organizing package sets is to arrange them in a hierarchy
i.e. for package sets to include others as subsets.

We need more package sets to play with however.

    >>> gnome_ps = ps_factory.new(
    ...     u'gnome', u'Contains all gnome desktop packages', person2)
    >>> mozilla_ps = ps_factory.new(
    ...     u'mozilla', u'Contains all mozilla packages', person2)
    >>> firefox_ps = ps_factory.new(
    ...     u'firefox', u'Contains all firefox packages', person2)
    >>> thunderbird_ps = ps_factory.new(
    ...     u'thunderbird', u'Contains all thunderbird packages', person2)
    >>> languagepack_ps = ps_factory.new(
    ...     u'languagepack', u'Contains all language packs', person2)
    >>> store.commit()

Now we can set up the package set hierarchy.

    >>> umbrella_ps.add((gnome_ps,))
    >>> mozilla_ps.add((firefox_ps, thunderbird_ps, languagepack_ps))
    >>> umbrella_ps.add((mozilla_ps,))
    >>> gnome_ps.add((languagepack_ps,))

The 'umbrella' package set has two *direct* successors..

    >>> print_data(umbrella_ps.setsIncluded(direct_inclusion=True))
     3 -> gnome
     4 -> mozilla

.. but five successors in total. The 'firefox' and 'thunderbird' package
sets are included via 'mozilla' whereas the 'languagepack' package set comes
in via 'gnome' and/or 'mozilla'.

    >>> u_successors = umbrella_ps.setsIncluded()
    >>> print_data(u_successors)
     3 -> gnome
     4 -> mozilla
     5 -> firefox
     6 -> thunderbird
     7 -> languagepack

These are the *direct* predecessors of the 'languagepack' package set.

    >>> print_data(languagepack_ps.setsIncludedBy(direct_inclusion=True))
     3 -> gnome
     4 -> mozilla

These are *all* predecessors of the 'languagepack' package set. Please not
that the 'umbrella' package set is listed as well.

    >>> print_data(languagepack_ps.setsIncludedBy())
     1 -> umbrella
     3 -> gnome
     4 -> mozilla

When 'mozilla' stops including 'languagepack' it is still included by
'umbrella' (via the 'gnome' package set).

    >>> mozilla_ps.remove((languagepack_ps,))
    >>> print_data(languagepack_ps.setsIncludedBy(direct_inclusion=True))
     3 -> gnome
    >>> print_data(languagepack_ps.setsIncludedBy())
     1 -> umbrella
     3 -> gnome

The 'umbrella' successors are still the same ('languagepack' is still
included via 'gnome').

    >>> sort_by_id(u_successors) == sort_by_id(umbrella_ps.setsIncluded())
    True

Removing direct successors is pretty tolerant i.e. if you try to remove 'Q'
from 'P' and 'Q' is *not* a *direct* successor of 'P' nothing will happen.

    >>> umbrella_ps.remove((languagepack_ps,))
    >>> sort_by_id(u_successors) == sort_by_id(umbrella_ps.setsIncluded())
    True

What happens if we remove a package set from the database?

    >>> print_data(umbrella_ps.setsIncluded())
      3 -> gnome
      4 -> mozilla
      5 -> firefox
      6 -> thunderbird
      7 -> languagepack

    >>> store = getUtility(IStoreSelector).get(MAIN_STORE, MASTER_FLAVOR)
    >>> store.remove(gnome_ps)

We removed the 'gnome' package set and see that all the relationships it
participated in were cleaned up as well.

It does not show up as a predecessor for the 'languagepack' package set
any more.

    >>> print_data(languagepack_ps.setsIncludedBy(direct_inclusion=True))
    >>> print_data(languagepack_ps.setsIncludedBy())

It is also not included by the 'umbrella' package set any longer. Please
note that 'languagepack' also ceased to be included by 'umbrella' because
the link between them ('gnome') is gone.

    >>> print_data(umbrella_ps.setsIncluded())
      4 -> mozilla
      5 -> firefox
      6 -> thunderbird


== Package set hierarchies and source names ==

In order to demonstrate how included package sets play together
with source package names we'll "populate" the former.

    >>> def populate(packageset, pattern):
    ...     rs = store.find(
    ...         SourcePackageName, SourcePackageName.name.like(pattern))
    ...     packageset.add(rs)

    >>> populate(mozilla_ps, 'moz%a')
    >>> print_data(mozilla_ps.sourcesIncluded(direct_inclusion=True))
    16 -> mozilla

    >>> populate(firefox_ps, '%fire%')
    >>> populate(firefox_ps, '%ice%')
    >>> print_data(firefox_ps.sourcesIncluded(direct_inclusion=True))
     1 -> mozilla-firefox
    26 -> iceweasel

    >>> populate(thunderbird_ps , '%thunder%')
    >>> populate(thunderbird_ps , '%ice%')
    >>> print_data(thunderbird_ps.sourcesIncluded(direct_inclusion=True))
    18 -> thunderbird
    26 -> iceweasel

When looking at *all* source package names the 'mozilla' package set is
associated with we see

    * 'mozilla' i.e. the source package name it is *directly* associated
      with but also
    * the union set of source package names of its successor package sets

    >>> print_data(mozilla_ps.sourcesIncluded())
     1 -> mozilla-firefox
    16 -> mozilla
    18 -> thunderbird
    26 -> iceweasel

We extend the package set hierarchy by including 'languagepack' into
'thunderbird' ..

    >>> populate(languagepack_ps , 'lang%')
    >>> thunderbird_ps.add((languagepack_ps,))

.. and see that the 'thunderbird' package set is (indirectly) associated
with the 'language-pack-de' source package name.

    >>> print_data(thunderbird_ps.sourcesIncluded(direct_inclusion=True))
    18 -> thunderbird
    26 -> iceweasel
    >>> print_data(thunderbird_ps.sourcesIncluded())
    18 -> thunderbird
    25 -> language-pack-de
    26 -> iceweasel

Furthermore, the 'language-pack-de' source package name is picked up by its
predecessor 'mozilla' as well.

    >>> print_data(mozilla_ps.sourcesIncluded())
     1 -> mozilla-firefox
    16 -> mozilla
    18 -> thunderbird
    25 -> language-pack-de
    26 -> iceweasel

Let's see what sources the 'umbrella' and the 'mozilla' package set have in
common:

    >>> print_data(umbrella_ps.sourcesSharedBy(mozilla_ps))
      1 -> mozilla-firefox
     16 -> mozilla
     18 -> thunderbird
     25 -> language-pack-de
     26 -> iceweasel

If we ask the question the other way around the answer should be the same.

    >>> print_data(mozilla_ps.sourcesSharedBy(umbrella_ps))
      1 -> mozilla-firefox
     16 -> mozilla
     18 -> thunderbird
     25 -> language-pack-de
     26 -> iceweasel

Now we only want to see the directly included sources they have in common.

    >>> print_data(
    ...     umbrella_ps.sourcesSharedBy(mozilla_ps, direct_inclusion=True))
     16 -> mozilla
    
Again, asking the question the other way around works as well.

    >>> print_data(
    ...     mozilla_ps.sourcesSharedBy(umbrella_ps, direct_inclusion=True))
     16 -> mozilla
    
How many sources are in the 'mozilla' package set but not in 'umbrella'?

    >>> len(mozilla_ps.sourcesNotSharedBy(umbrella_ps)) == 0
    True

What sources are included by the 'mozilla' package set but not by 'firefox'?

    >>> print_data(mozilla_ps.sourcesNotSharedBy(firefox_ps))
     16 -> mozilla
     18 -> thunderbird
     25 -> language-pack-de

What sources are *directly* included by 'mozilla' but not by 'firefox'?

    >>> print_data(
    ...     mozilla_ps.sourcesNotSharedBy(firefox_ps, direct_inclusion=True))
     16 -> mozilla


== Various errors ==

Here's what happens if we try to add something that is not a source package
name or package set:

    >>> mozilla_ps.add('This will fail'.split())
    Traceback (most recent call last):
    ...
    AssertionError: Not all data was handled.

Likewise for removal:

    >>> mozilla_ps.remove(range(10))
    Traceback (most recent call last):
    ...
    AssertionError: Not all data was handled.

An attempt to add cycles to the package set graph also results in a failure:

    >>> mozilla_ps.add((umbrella_ps,))
    Traceback (most recent call last):
    ...
    InternalError: Package set umbrella already includes mozilla.
    Adding (mozilla -> umbrella) would introduce a cycle in the
    package set graph (DAG).
    <BLANKLINE>

    >>> store.rollback()

== Amending package sets ==

There are some methods that will enable the caller to add and delete
package sets.  They currently require launchpad.Edit permission to
use, which enforces the user to be an admin or a member of the "techboard"
(Ubuntu Technical Board) team.

    >>> from zope.security.checker import canAccess
    >>> restricted_methods = ('new',)

If, for some reason, the techboard team is missing, the security adapter
will not allow access and generates an OOPS.

    >>> from canonical.launchpad.interfaces import (
    ...     IPersonSet, TeamSubscriptionPolicy)
    >>> personset = getUtility(IPersonSet)
    >>> login('js@example.com')
    >>> from zope.app.error.interfaces import IErrorReportingUtility
    >>> report = getUtility(IErrorReportingUtility).getLastOopsReport()
    >>> canAccess(ps_factory, 'new')
    False
    >>> report2 = getUtility(IErrorReportingUtility).getLastOopsReport()
    >>> print report.id == report2.id
    False
    >>> print report2.value
    'techboard' team is missing, has it been renamed?

Set up the techboard team:

    >>> login("foo.bar@canonical.com")
    >>> owner = personset.getByName("name16")
    >>> techboard = personset.newTeam(
    ...     owner, "techboard", "techboard",
    ...     subscriptionpolicy=TeamSubscriptionPolicy.OPEN)

Ordinary users have no access:

    >>> login('js@example.com')
    >>> canAccess(ps_factory, 'new')
    False

Admins have access:

    >>> login("foo.bar@canonical.com")
    >>> canAccess(ps_factory, 'new')
    True

Now add "test@canonical.com" to the techboard team and log in as him.

    >>> person2.join(techboard)
    >>> login_person(person2)

Create a new package set.

    >>> kde_ps = ps_factory.new(
    ...     u'kde', u'Contains all KDE packages', person2)
