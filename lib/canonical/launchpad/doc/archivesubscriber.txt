= ArchiveSubscriber =

This content class represents a subscription by a person to an IArchive.
The subscription represents that person's ability to download items from
the archive's repository.  The subscription is granted by a person who
has upload permission to the archive.  Once created the subscription is only
viewable by other uploaders and the person in the subscription.

See also archiveauthtoken.txt.

First, create a person 'joesmith' and a team 'team_cprov':

    >>> login('foo.bar@canonical.com')
    >>> joesmith = factory.makePerson(name="joesmith", displayname="Joe Smith",
    ...     password="test", email="joe@example.com")
    >>> from canonical.launchpad.interfaces.person import IPersonSet
    >>> cprov = getUtility(IPersonSet).getByName("cprov")
    >>> team_cprov = factory.makeTeam(cprov, "Team Cprov")
    >>> logout()

== Creating new subscriptions ==

New subscriptions are created using IArchive.newSubscription()

Operations with subscriptions are security protected, so to start with we'll
log in as an unprivileged user.

    >>> login("no-priv@canonical.com")

We can create a new subscription for joesmith to access cprov's PPA like this:

    >>> new_sub = cprov.archive.newSubscription(joesmith, cprov)
    Traceback (most recent call last):
    ...
    Unauthorized:...

That failed because only people who have launchpad.Append (basically, upload
access) on the context archive are allowed to create subscriptions.

Users cannot create their own subscriptions either.  Log in as joesmith:

    >>> login("joe@example.com")
    >>> new_token = cprov.archive.newSubscription(joesmith, cprov)
    Traceback (most recent call last):
    ...
    Unauthorized:...

If we log in as cprov it will work:

    >>> login("celso.providelo@canonical.com")
    >>> new_sub = cprov.archive.newSubscription(
    ...     joesmith, cprov, description=u"subscription for joesmith")

The new subscription is returned and reflects the data:

    >>> print new_sub.archive.title
    PPA for Celso Providelo

    >>> print new_sub.subscriber.name
    joesmith

    >>> print new_sub.registrant.name
    cprov

    >>> print new_sub.description
    subscription for joesmith

    >>> print new_sub.status.name
    CURRENT

Add another subscription for the test user, this time to sabdfl's ppa:

    >>> login("mark@hbd.com")
    >>> sabdfl = getUtility(IPersonSet).getByName("sabdfl")
    >>> new_sub_to_sabdfl_ppa = sabdfl.archive.newSubscription(
    ...     joesmith, sabdfl, description=u"subscription for joesmith")

And also a subscription for a Team:

    >>> new_team_sub_to_sabdfl_ppa = sabdfl.archive.newSubscription(
    ...     team_cprov, sabdfl, description=u"Access for cprov team")

Commit the new subscriptions to the database.

    >>> from storm.store import Store
    >>> Store.of(new_sub).commit()

Subscriptions also contain some date information:

    >>> new_sub.date_created is not None
    True

    >>> print new_sub.date_expires
    None


== Retrieving existing subscriptions ==

The ArchiveSubscriberSet utility allows you to retrieve subscriptions by
subscriber and archive.  To access subscriptions you need launchpad.View
privilege which applies to the person in the subscriptions and launchpad
admins.

    >>> from canonical.launchpad.interfaces.archivesubscriber import (
    ...     ArchiveSubscriberStatus, IArchiveSubscriberSet)
    >>> sub_set = getUtility(IArchiveSubscriberSet)

    >>> login("no-priv@canonical.com")

    >>> sub = sub_set.getBySubscriber(new_sub.subscriber)
    Traceback (most recent call last):
    ...
    Unauthorized:...

Log in as joesmith, who is the person in the subscription.

    >>> login("joe@example.com")

And retrieve the subscription by subscriber and archive:

    >>> print sub_set.getBySubscriber(new_sub.subscriber)[0].archive.title
    PPA for Celso Providelo

    >>> print sub_set.getByArchive(new_sub.archive)[0].subscriber.name
    joesmith

The getBySubscriber() method takes an optional archive parameter for
finding a subscription for a particular user in a particular archive:

    >>> print sub_set.getBySubscriber(
    ...     new_sub.subscriber, new_sub.archive)[0].archive.title
    PPA for Celso Providelo

By default the getBySubscriber() and getByArchive() methods return
all current subscriptions:

    >>> sub_set.getBySubscriber(new_sub.subscriber).count()
    2
    >>> sub_set.getByArchive(sabdfl.archive).count()
    2

If we cancel one of the subscriptions:

    >>> login("mark@hbd.com")
    >>> new_sub_to_sabdfl_ppa.status = ArchiveSubscriberStatus.CANCELLED
    >>> login("joe@example.com")

then the cancelled subscription no longer appears in the results
of getBySubscriber() and getByArchive():

    >>> sub_set.getBySubscriber(new_sub.subscriber).count()
    1
    >>> sub_set.getByArchive(sabdfl.archive).count()
    1

Unless we explicitly ask for all subscriptions - not just the current ones:

    >>> sub_set.getBySubscriber(
    ...     new_sub.subscriber, current_only=False).count()
    2
    >>> sub_set.getByArchive(sabdfl.archive, current_only=False).count()
    2

The getBySubscriber() method includes by default subscriptions for teams
to which the provided subscriber belongs:

    >>> joesmith.join(team_cprov)
    >>> for subscription in sub_set.getBySubscriber(joesmith):
    ...     print subscription.archive.title
    ...     print subscription.description
    PPA for Celso Providelo        subscription for joesmith
    PPA for Mark Shuttleworth      Access for cprov team

This can be overridden by explicitly not including team subscriptions when
calling getBySubscriber():

    >>> for subscription in sub_set.getBySubscriber(joesmith,
    ...     include_team_subscriptions=False):
    ...     print subscription.archive.title
    ...     print subscription.description
    PPA for Celso Providelo        subscription for joesmith

Finally, many callsites of getBySubscriber() will be interested not only
in each subscription of the subscriber, but also the generated
ArchiveAuthToken for each subscription of the subscriber. These can
be returned as well using the optional return_tokens param:

First create a token for joesmith's subscription for cprov's archive:

    >>> login("celso.providelo@canonical.com")
    >>> ignore = cprov.archive.newAuthToken(joesmith, u"test_token")
    >>> login("joe@example.com")

Now print out all subscriptions with their tokens for joesmith:

    >>> for subscription, token in sub_set.getBySubscriber(joesmith,
    ...     return_tokens=True):
    ...     if token:
    ...         token_text = token.token
    ...     else:
    ...         token_text = "None"
    ...     print subscription.archive.title
    ...     print token_text
    PPA for Celso Providelo            test_token
    PPA for Mark Shuttleworth          None

== Amending Subscriptions ==

Some of the properties of subscriptions can change after they are created.
To do this, the changer needs to have launchpad.Edit on the subscription,
or be an admin.

Trying to set the properties as the subscribed person will fail:

    >>> from canonical.database.constants import UTC_NOW
    >>> new_sub.date_expires = UTC_NOW
    Traceback (most recent call last):
    ...
    Unauthorized:...

Log in as someone with launchpad.Edit and it will work:

    >>> login("celso.providelo@canonical.com")
    >>> new_sub.date_expires = UTC_NOW

Other properties that might get modified later are status and description.
We can also do this as an admin.

    >>> login("admin@canonical.com")
    >>> new_sub.description = u"changed by admin"
    >>> from canonical.launchpad.interfaces.archivesubscriber import (
    ...     ArchiveSubscriberStatus)
    >>> new_sub.status = ArchiveSubscriberStatus.EXPIRED


== Cancelling subscriptions ==

Subscriptions can only be cancelled after they are created.  The calling user
also needs launchpad.Edit on the subscription, which means either someone with
IArchive launchpad.Append (as for creating new tokens) or an admin.

    >>> login("no-priv@canonical.com")
    >>> new_sub.cancel()
    Traceback (most recent call last):
    ...
    Unauthorized:...

    >>> login("celso.providelo@canonical.com")
    >>> new_sub.cancel(cprov)

Cancelling sets the date_cancelled value to the current date/time
and cancelled_by to the supplied person.  The status also changes to
CANCELLED.

    >>> new_sub.date_cancelled is not None
    True

    >>> print new_sub.cancelled_by.name
    cprov

    >>> print new_sub.status.name
    CANCELLED

We can do this as an admin too:

    >>> login("admin@canonical.com")
    >>> new_sub.cancel(cprov)
