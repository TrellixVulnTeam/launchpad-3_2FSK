Introduction
============

Vocabularies are lists of terms. In Launchpad's Component Architecture (CA), a
vocabulary is a list of terms that a widget (normally a selection style widget)
"speaks", i.e. its allowed values.

This document is about some of the vocabularies found in Launchpad.

    >>> from canonical.launchpad.ftests import login
    >>> from canonical.launchpad.interfaces import IPersonSet, IEmailAddressSet
    >>> from canonical.lp.dbschema import EmailAddressStatus
    >>> from canonical.database.sqlbase import flush_database_updates
    >>> login('foo.bar@canonical.com')

Values, Tokens, and Titles
==========================

In Launchpad, we generally use "tokenized vocabularies." Each term in a
vocabulary has a value, token and title. In human terms, a term would be
rendered in a select widget like this:

<option value="$token">$title</option>

The Value is probably the data you would store in your DB. The Token is used to
uniquely identify a Term, and the Title is the thing you display to the user.

Have a look at a few of the vocabularies below for clarification.

Launchpad Vocabularies
======================

There are two kinds of vocabularies in Launchpad: enumerable and
non-enumerable. In human terms, enumerable vocabularies are short and sweet
enough to render in a select widget, where non-enumerable vocabularies require
a special query interface to make it easy to choose just one or a couple of
options from several hundred, or several thousand, or more.

Vocabularies should not be imported - they can be retrieved from the
vocabulary registry.

    >>> from zope.component import getUtility
    >>> from zope.schema.vocabulary import getVocabularyRegistry
    >>> vocabulary_registry = getVocabularyRegistry()
    >>> product_vocabulary = vocabulary_registry.get(None, "Product")

Enumerable Vocabularies
=======================

Creating a new Enumeratable Vocabulary based on an existent dbschema
constant:

    >>> from canonical.lp import dbschema
    >>> from canonical.launchpad.vocabularies import vocab_factory
    >>> PackagingVocabulary = vocab_factory(dbschema.PackagingType)

The right place to do it is in the file vocabularies/dbschema.py.
Note: don't forget to registry your brand new instance for zope lookup
in configure.zcml.

o PackagingVocabulary - reflects the available constants for
  Packaging.packaging field.

In cases where we won't have many rows, some of the database
vocabularies can be enumerated over.

o DistroReleaseVocabulary - reflects the available distribution releases.
  Results are ordered by `name`

    >>> distrorelease_vocabulary = vocabulary_registry.get(
    ...     None,"DistroRelease")
    >>> for term in distrorelease_vocabulary:
    ...     print "%s %20s %s" % (term.value, term.token, term.title)
    7 debian/sarge         Sarge
    8 debian/sid           Sid
    6 debian/woody         WOODY
    9 guadalinex/2k5       Guada 2005
    4 redhat/7.0           Seven
    2 redhat/six           Six Six Six
    5 ubuntu/grumpy        The Grumpy Groundhog Release
    3 ubuntu/hoary         The Hoary Hedgehog Release
    1 ubuntu/warty         The Warty Warthog Release
    >>> distrorelease_vocabulary.getTermByToken('ubuntu/hoary').value
    3
    >>> [term.token for term in distrorelease_vocabulary.search('woody')]
    ['debian/woody']
    >>> [term.token for term in distrorelease_vocabulary.search('debian')]
    ['debian/sarge', 'debian/sid', 'debian/woody']
    >>> [term.token for term in distrorelease_vocabulary.search('invalid')]
    []
    >>> [term.token for term in distrorelease_vocabulary.search('')]
    []

Non-Enumerable Vocabularies
===========================

Although you technically *could* iterate over these, in launchpad it
would be stupid to do so due to their expected size on the production
database.

o ProjectVocabulary - the list of selectable projects. The results are
  ordered by displayname.

    >>> project_vocabulary = vocabulary_registry.get(None, "Project")
    >>> [p.title for p in project_vocabulary.search('mozilla')]
    [u'The Mozilla Project']
    >>> mozilla = project_vocabulary.getTermByToken('mozilla')
    >>> mozilla.title
    u'The Mozilla Project'

  The ProjectVocabulary does not list inactive projects.

    >>> from canonical.launchpad.interfaces import IProjectSet
    >>> moz_project = getUtility(IProjectSet)['mozilla']
    >>> moz_project in project_vocabulary
    True

    >>> [p.title for p in project_vocabulary.search('mozilla')]
    [u'The Mozilla Project']
    >>> moz_project.active = False
    >>> flush_database_updates()
    >>> moz_project in project_vocabulary
    False

    >>> [p.title for p in project_vocabulary.search('mozilla')]
    []
    >>> moz_project.active = True
    >>> flush_database_updates()

o ProductVocabulary - the list of selectable products. Results are
  ordered by displayname.

    >>> product_vocabulary = vocabulary_registry.get(None, "Product")
    >>> product_vocabulary.search(None)
    []
    >>> gnome_products = product_vocabulary.search("gnome")
    >>> l = [product_term.title for product_term in gnome_products]
    >>> l[:2]
    [u'The Evolution Groupware Application', u'The GNOME Terminal Emulator']
    >>> l[2:]
    [u'The Gnome Panel Applets', u'Ubuntu', u'Gnome Baker']
    >>> arch = product_vocabulary.getTermByToken("arch-mirrors")
    >>> arch.title 
    u'Arch archive mirrors'

  The ProductVocabulary does not list inactive products.

    >>> arch.value in product_vocabulary
    True

    >>> from canonical.launchpad.interfaces import IProductSet
    >>> arch_product = getUtility(IProductSet)['arch-mirrors']
    >>> arch_product in product_vocabulary
    True

    >>> [t.title for t in product_vocabulary.search('arch and archive')]
    [u'Arch archive mirrors']
    >>> arch_product.active = False
    >>> flush_database_updates()
    >>> arch_product in product_vocabulary
    False
    >>> [t.title for t in product_vocabulary.search('arch and archive')]
    []
    >>> arch_product.active = True
    >>> flush_database_updates()

o ProductReleaseVocabulary - the list of selectable products releases.

    >>> productrelease_vocabulary = vocabulary_registry.get(None,
    ...                                                     "ProductRelease")
    >>> list(productrelease_vocabulary.search(None))
    []
    >>> evolution_releases = productrelease_vocabulary.search("evolution")
    >>> l = [release_term.title for release_term in evolution_releases]
    >>> release = productrelease_vocabulary.getTermByToken(
    ...     "evolution/main/2.1.6")
    >>> release.title
    u'evolution main 2.1.6'

o PersonAccountToMergeVocabulary - all non-merged people. This vocabulary
  is meant to be used only in the people merge form.

    >>> vocab = vocabulary_registry.get(None, "PersonAccountToMerge")

    Searching for None returns an empty list.
    >>> vocab.search(None)
    []

    Searching for 'team' will return an empty list, because teams are not part
    of this vocabulary.
    >>> vocab.search('team')
    []

    A search using part of the email address of a team will also return an 
    empty list.
    >>> [t.token for t in vocab.search('support')]
    []

    Searching for a person without a preferred email will return that person's
    name.
    >>> [t.token for t in vocab.search('salgado')]
    ['salgado']

    A search using the beginning of a person's preferred email will return 
    that person's preferred email.
    >>> [t.token for t in vocab.search('foo.bar')]
    ['foo.bar@canonical.com']

    A search using part of the host of an email address will not return
    anything, as we only match against the beginning of an email address.
    >>> [t.token for t in vocab.search('canonical')]
    []

    Any person without a single email address is not part of the vocabulary.
    >>> fooperson, email = getUtility(IPersonSet).createPersonAndEmail(
    ...     'foobaz@bar.com', name='foobaz', displayname='foo baz')
    >>> email.destroySelf()
    >>> fooperson in vocab
    False
    >>> [t.token for t in vocab.search('foobaz')]
    []

    Adding an email address to this person will make him part of the
    vocabulary.
    >>> email = getUtility(IEmailAddressSet).new('foo@bar.com', fooperson.id)
    >>> flush_database_updates()
    >>> fooperson in vocab
    True
    >>> [t.token for t in vocab.search('foobaz')]
    ['foobaz']

    Any person that's already merged is not part of this vocabulary:
    # XXX: Here we cheat because IPerson.merged is a readonly attribute.
    >>> from zope.security.proxy import removeSecurityProxy
    >>> removeSecurityProxy(fooperson).merged = 1
    >>> flush_database_updates()
    >>> fooperson in vocab
    False

o ValidPersonOrTeam - all 'valid' persons or teams. This is currently defined
  as people with a password, a preferred email address and not merged
  (Person.merged is None) or any team.

    >>> vocab = vocabulary_registry.get(None, "ValidPersonOrTeam")
    >>> vocab.search(None)
    []

    Almost all teams have the word 'team' as part of their names, so a search
    for 'team' should give us some of them.
    >>> [t.token for t in vocab.search('team')]
    ['name21', 'name18', 'support@ubuntu.com', 'name19', 'name20', 'testing-spanish-team']

    A search for 'support' will give us only the persons which have support
    as part of their name/displayname/givenname/familyname or the beginning of
    one of its email addresses.
    >>> [t.token for t in vocab.search('support')]
    ['support@ubuntu.com']

    Dave hasn't validated his email address; he's not a valid Person.
    >>> [t.token for t in vocab.search('dave.miller')]
    []

    'foo.bar@canonical.com' is a valid Person.
    >>> [t.token for t in vocab.search('foo.bar')]
    ['foo.bar@canonical.com']

o ValidOwner - all valid persons and teams are also valid owners.

    >>> vocab = vocabulary_registry.get(None, "ValidOwner")
    >>> vocab.search(None)
    []

    Almost all teams have the word 'team' as part of their names, so a search
    for 'team' should give us some of them.
    >>> [t.token for t in vocab.search('team')]
    ['name21', 'name18', 'support@ubuntu.com', 'name19', 'name20', 'testing-spanish-team']

o ValidTeamMember - With the exception of all teams that have this team as a
  member and the team itself, all valid persons and teams are valid
  members.

    >>> team = getUtility(IPersonSet).getByName('name17')
    >>> team2 = getUtility(IPersonSet).getByName('guadamen')
    >>> person = getUtility(IPersonSet).getByName('name16')

    ValidTeamMember needs a context.
    >>> vocab = vocabulary_registry.get(None, "ValidTeamMember")
    Traceback (most recent call last):
    ...
    ValueError: ...

    ValidTeamMember's context must implement ITeam.
    >>> vocab = vocabulary_registry.get(person, "ValidTeamMember")
    Traceback (most recent call last):
    ...
    ValueError: ...
 
    'name16' is a valid member for 'name17'
    >>> vocab = vocabulary_registry.get(team, "ValidTeamMember")
    >>> person in vocab
    True
    >>> [t.token for t in vocab.search('foo.bar')]
    ['foo.bar@canonical.com']

    'name17' is not a valid member for itself
    >>> team in vocab
    False
    >>> [t.token for t in vocab.search('name17')]
    []

    'name17' is a member of 'guadamen', so 'guadamen' can't be a member of
    'name17'.
    >>> team2 in vocab
    False
    >>> [t.token for t in vocab.search('guadamen')]
    []

o ValidTeamOwner - With the exception of the team itself and all teams owned
  by that team, all valid persons and teams are valid owners for the team 
  in context.

    ValidTeamOwner needs a context.
    >>> vocab = vocabulary_registry.get(None, "ValidTeamOwner")
    Traceback (most recent call last):
    ...
    ValueError: ...

    ValidTeamOwner's context must be a team.
    >>> vocab = vocabulary_registry.get(person, "ValidTeamOwner")
    Traceback (most recent call last):
    ...
    ValueError: ...

    'name17' is not a valid owner for itself.
    >>> vocab = vocabulary_registry.get(team, "ValidTeamOwner")
    >>> team in vocab
    False
    >>> [t.token for t in vocab.search('name17')]
    []

    'name16' is a valid owner for 'name17'.
    >>> person in vocab
    True
    >>> [t.token for t in vocab.search('foo.bar')]
    ['foo.bar@canonical.com']

o Processor - all processors type available in Launchpad.

    >>> vocab = vocabulary_registry.get(None, "Processor")
    >>> stuff = vocab.search('386')
    >>> [t.token for t in stuff]
    ['386']

o SchemaVocabulary - launchpad Schema Vocabulary..

    >>> vocabulary = vocabulary_registry.get(None,"Schema")
    >>> list(vocabulary.search(None))
    []
    >>> schemas_vocabulary = vocabulary.search("m")
    >>> schemas = [schema.title for schema in schemas_vocabulary]
    >>> schemas
    [u'enema', u'mark', u'schema', u'trema']

XXX: document more vocabularies here, particularly when they break!
