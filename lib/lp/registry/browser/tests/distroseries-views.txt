= DistroSeries view classes =

    >>> from zope.component import getMultiAdapter
    >>> from canonical.launchpad.webapp.servers import LaunchpadTestRequest

Let's use ubuntu/hoary for these tests.

    >>> from canonical.launchpad.interfaces import IDistributionSet
    >>> ubuntu = getUtility(IDistributionSet).getByName('ubuntu')
    >>> hoary = ubuntu.getSeries('hoary')

We will use a function to print the details related with the
distroseries being tested.

    >>> def administrate_distroseries(distroseries, form):
    ...     request = LaunchpadTestRequest(form=form)
    ...     request.method = 'POST'
    ...     view = getMultiAdapter((hoary, request), name="+admin")
    ...     view.initialize()
    ...     print '%d errors' % len(view.errors)
    ...     for error in view.errors:
    ...         try:
    ...             name, title, message = error
    ...         except ValueError:
    ...             title, message = error
    ...         print '%s: %s' % (title, message)
    ...     print 'Name:', distroseries.name
    ...     print 'Version:', distroseries.version
    ...     print 'Changeslist:', distroseries.changeslist
    ...     print 'Status:', distroseries.status.name

    >>> form = {
    ...     'field.actions.change': 'Change',
    ...     'field.name': 'hoary',
    ...     'field.version': '5.04',
    ...     'field.changeslist': 'hoary-changes@ubuntu.com',
    ...     'field.status': 'DEVELOPMENT',
    ...     }

    >>> login('foo.bar@canonical.com')

    >>> administrate_distroseries(hoary, form)
    0 errors
    Name: hoary
    Version: 5.04
    Changeslist: hoary-changes@ubuntu.com
    Status: DEVELOPMENT

The distroseries 'changeslist' field only accept valid email addresses.

    >>> form['field.changeslist'] = ''
    >>> administrate_distroseries(hoary, form)
    1 errors
    E-mail changes to:
    Name: hoary
    Version: 5.04
    Changeslist: hoary-changes@ubuntu.com
    Status: DEVELOPMENT

    >>> form['field.changeslist'] = 'bRoKen_AdDreSs'
    >>> administrate_distroseries(hoary, form)
    1 errors
    E-mail changes to: Invalid email 'bRoKen_AdDreSs'.
    Name: hoary
    Version: 5.04
    Changeslist: hoary-changes@ubuntu.com
    Status: DEVELOPMENT

    >>> form['field.changeslist'] = 'foo@bar.com'
    >>> administrate_distroseries(hoary, form)
    0 errors
    Name: hoary
    Version: 5.04
    Changeslist: foo@bar.com
    Status: DEVELOPMENT

When the distroseries is released, i.e. when it goes from an unstable
status (FUTURE, EXPERIMENTAL, DEVELOPMENT, FROZEN) to CURRENT, its
'datereleased' field is set.

    >>> print hoary.datereleased
    None

    >>> form['field.status'] = 'CURRENT'
    >>> administrate_distroseries(hoary, form)
    0 errors
    Name: hoary
    Version: 5.04
    Changeslist: foo@bar.com
    Status: CURRENT

    >>> initial_datereleased = hoary.datereleased
    >>> initial_datereleased is not None
    True

Let's commit the current DB status, so errors can be triggered and
will not rollback the changes done until here.

    >>> import transaction
    >>> transaction.commit()

A stable distroseries cannot be made unstable again.

    >>> form['field.status'] = 'EXPERIMENTAL'
    >>> administrate_distroseries(hoary, form)
    1 errors
    Invalid value: token 'EXPERIMENTAL' not found in vocabulary
    Name: hoary
    Version: 5.04
    Changeslist: foo@bar.com
    Status: CURRENT

The 'datereleased' value is only set once, even if the distroseries is
modified to SUPPORTED or OBSOLETE and then set back to CURRENT its
initial value remains.

    >>> form['field.status'] = 'SUPPORTED'
    >>> administrate_distroseries(hoary, form)
    0 errors
    Name: hoary
    Version: 5.04
    Changeslist: foo@bar.com
    Status: SUPPORTED

    >>> hoary.datereleased == initial_datereleased
    True

    >>> form['field.status'] = 'CURRENT'
    >>> administrate_distroseries(hoary, form)
    0 errors
    Name: hoary
    Version: 5.04
    Changeslist: foo@bar.com
    Status: CURRENT

    >>> hoary.datereleased == initial_datereleased
    True


== Creating distroseries ==

The distroseries name is unique and it cannot contain spaces

    >>> view = create_view(ubuntu, '+addseries')
    >>> print view.page_title
    Register a series in Ubuntu
    >>> print view.label
    Register a new series

    >>> print view.cancel_url
    http://launchpad.dev/ubuntu
    >>> print view.next_url
    None

    >>> view.field_names
    ['name', 'displayname', 'title', 'summary', 'description', 'version',
     'parent_series']

A distroseries is created whent the required field are submitted.

    >>> form = {
    ...     'field.name': 'sane',
    ...     'field.displayname': 'Sane Name',
    ...     'field.title': 'Ubuntu Sane Name',
    ...     'field.summary': 'A stable series to introduce fnord.',
    ...     'field.description': 'I am board filling this out',
    ...     'field.version': '2009.06',
    ...     'field.parent_series': 'ubuntu/hoary',
    ...     'field.actions.create': 'Create Series',
    ...     }
    >>> view = create_initialized_view(ubuntu, '+addseries', form=form)
    >>> view.errors
    []
    >>> sane_distroseries = ubuntu.getSeries('sane')
    >>> print sane_distroseries.name
    sane

The distroseries name is unique.

    >>> view = create_initialized_view(ubuntu, '+addseries', form=form)
    >>> for error in view.errors:
    ...     print error[2]
    sane is already in use by another series.

The distroseries name cannot contain spaces.

    >>> form['field.name'] = 'insane name'
    >>> view = create_initialized_view(ubuntu, '+addseries', form=form)
    >>> for error in view.errors:
    ...     print error[2]
    Invalid name 'insane name'...


== Hiding translations ==

Each distroseries has a switch that allows administrators to either
reveal its translations to the public or hide them from the public.

    >>> from zope.security.proxy import removeSecurityProxy
    >>> from lp.registry.browser.distroseries import (
    ...     DistroSeriesView)
    >>> from canonical.launchpad.interfaces import (
    ...     ILaunchpadCelebrities, ITeamMembershipSet, TeamMembershipStatus)
    >>> from canonical.launchpad.webapp.interfaces import (
    ...     TranslationUnavailable)

    >>> def check_translations_access(distroseries):
    ...     """Return any objections to current user accessing
    ...     `distroseries` translations.'
    ...     """
    ...     request = LaunchpadTestRequest()
    ...     view = DistroSeriesView(distroseries, request)
    ...     view.initialize()
    ...
    ...     try:
    ...         view.checkTranslationsViewable()
    ...     except TranslationUnavailable, message:
    ...         return unicode(message)
    ...     return None

    >>> def check_effect_of_hiding(distroseries):
    ...     """Describe how hiding translations for `distroseries`
    ...     affects current user's access to them.
    ...     """
    ...     original_hide_flag = distroseries.hide_all_translations
    ...     distroseries = removeSecurityProxy(distroseries)
    ...
    ...     distroseries.hide_all_translations = False
    ...     objection = check_translations_access(distroseries)
    ...     if objection is None:
    ...         print "User can access revealed translations."
    ...     else:
    ...         print "No access to revealed translations!", objection
    ...
    ...     distroseries.hide_all_translations = True
    ...     objection = check_translations_access(distroseries)
    ...     if objection is None:
    ...         print "User can access hidden translations."
    ...     else:
    ...         print "User can not access hidden translations:", objection
    ...
    ...     distroseries.hide_all_translations = original_hide_flag

An administrator will be able to access the translations no matter what
happens.

    >>> login('foo.bar@canonical.com')
    >>> check_effect_of_hiding(hoary)
    User can access revealed translations.
    User can access hidden translations.

A Translations admin ("translations expert") can also still access the
translations even when they're hidden.

    >>> expert = factory.makePerson('expert@example.com')
    >>> expert_team = getUtility(ILaunchpadCelebrities).rosetta_experts
    >>> membership = getUtility(ITeamMembershipSet).new(
    ...     expert, expert_team, TeamMembershipStatus.APPROVED,
    ...     expert_team)
    >>> login_person(expert)
    >>> check_effect_of_hiding(hoary)
    User can access revealed translations.
    User can access hidden translations.

A regular user can no longer see the translations once they're hidden.

    >>> login('no-priv@canonical.com')
    >>> check_effect_of_hiding(hoary)
    User can access revealed translations.
    User can not access hidden translations: Translations for this
    release series are not currently available.  Please come back soon.

The same goes for anonymous users.

    >>> login(ANONYMOUS)
    >>> check_effect_of_hiding(hoary)
    User can access revealed translations.
    User can not access hidden translations: Translations for this
    release series are not currently available.  Please come back soon.
