= Code Import Results =

A CodeImportResult is a record of a completed code import job.  They
are accessed via a utility registered for the ICodeImportResultSet
interface.

    >>> from canonical.launchpad.interfaces import (
    ...     ICodeImportResult, ICodeImportResultSet)
    >>> result_set = getUtility(ICodeImportResultSet)
    >>> from canonical.launchpad.webapp.testing import verifyObject
    >>> verifyObject(ICodeImportResultSet, result_set)
    True

The ICodeImportResultSet interface defines methods for creating and
retrieving CodeImportResult objects.

CodeImports are hidden from regular users currently. David Allouche is a
member of the vcs-imports team and can access the objects freely.

    >>> login('david.allouche@canonical.com')

== Creating CodeImportResults ==

Creating CodeImportResult objects is usually done by the finishJob()
method of the CodeImportWorkflow utility, but here we directly use the
new() method of ICodeImportResultSet.  It takes as arguments:

 * the code import the job was performed for,
 * the machine it was run on,
 * the user who requested the import, if any,
 * an excerpt of the log, if any,
 * a link to the full log in the librarian, again if any,
 * a status code from CodeImportResultStatus, and
 * the date the job started.

We can find suitable values for the required parameters in the sample
data.

    >>> from canonical.launchpad.interfaces import (
    ...     ICodeImportSet, ICodeImportMachineSet)
    >>> sample_import = getUtility(ICodeImportSet).get(1)
    >>> sample_machine = getUtility(ICodeImportMachineSet).getByHostname(
    ...     'bazaar-importer')

Then create a result object.

    >>> from canonical.launchpad.testing import time_counter
    >>> from pytz import UTC
    >>> from datetime import datetime, timedelta
    >>> time_source = time_counter(
    ...     datetime(2008, 1, 1, tzinfo=UTC),
    ...     timedelta(days=1))
    >>> from canonical.launchpad.interfaces import CodeImportResultStatus
    >>> new_result = result_set.new(
    ...     sample_import, sample_machine, None, None, None,
    ...     CodeImportResultStatus.SUCCESS, time_source.next())
    >>> verifyObject(ICodeImportResult, new_result)
    True

CodeImportResult objects themselves have no behaviour, they are just
read-only records of what happened.

    >>> print new_result.code_import.id
    1
    >>> print new_result.machine.hostname
    bazaar-importer
    >>> print new_result.requesting_user
    None
    >>> print new_result.log_excerpt
    None
    >>> print new_result.log_file
    None
    >>> print new_result.status.name
    SUCCESS
    >>> from canonical.launchpad.ftests import print_date_attribute
    >>> print_date_attribute(new_result, 'date_job_started')
    2008-01-01  00:00:00+00:00
    >>> # date_job_finished does not exist in the DB, it is assumed to
    >>> # be the same as date_created.
    >>> print_date_attribute(new_result, 'date_created')
    UTC_NOW


== Retrieving CodeImportResults ==

The CodeImportResult objects for a given import can be retrieved, in
reverse chronological order (with respect to date_job_started:
although it doesn't matter in production, as there will never be two
jobs running for a particular import, it makes things easier to test)
with the getResultsForImport method.

We need to create a few result objects before we can test that this
method works as expected.

    >>> oldest_result = new_result
    >>> def make_result(date_job_started, code_import=sample_import):
    ...     """Create a CodeImportResult with the provided details."""
    ...     return result_set.new(
    ...        code_import, sample_machine, None, None, None,
    ...        CodeImportResultStatus.SUCCESS, date_job_started)
    >>> middle_result = make_result(time_source.next())
    >>> newest_result = make_result(time_source.next())

Results for other imports of course should not be present in the
results, so we should create one of those just to be sure that it's
not present.

    >>> result_for_other_import = make_result(
    ...     time_source.next(),
    ...     code_import=getUtility(ICodeImportSet).get(2))

Then we can test that the results are in the order expected.

    >>> list(result_set.getResultsForImport(sample_import)) == \
    ...     [newest_result, middle_result, oldest_result]
    True

