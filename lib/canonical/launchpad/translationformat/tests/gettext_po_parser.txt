= Tests for our PO parser =

Gettext PO parser allows to communicate with the external world importing
files and exporting them.

    >>> from zope.interface.verify import verifyObject
    >>> from canonical.launchpad.interfaces import (
    ...     ITranslationMessage, ITranslationHeader)
    >>> from canonical.launchpad.translationformat import TranslationMessage
    >>> from canonical.launchpad.translationformat.gettext_po_parser import (
    ...     PoHeader, PoParser)


== PoParser ==

We should be completely sure that a .po file with an empty header is reported.

  >>> parser = PoParser()
  >>> parser.parse('msgid "foo"\nmsgstr ""\n')
  Traceback (most recent call last):
  ...
  TranslationFormatSyntaxError:...


== PoHeader ==

A PoHeader is a representation of a special message that all .po files have.
That first message has as the msgid the empty string ("") and as the
translation of it some metadata.

It must implement ITranslationHeader.

    >>> content = """
    ...     msgid ""
    ...     msgstr ""
    ...     "Content-Type: text/plain; charset=ASCII\n"
    ...     """
    >>> verifyObject(ITranslationHeader, PoHeader(content))
    True

=== translation_revision_date ===

This attribute gives you a datetime object representing the
PO-Revision-Date field.

  >>> header = PoHeader("""
  ... Project-Id-Version: foo
  ... Report-Msgid-Bugs-To: foo@bar.com
  ... POT-Creation-Date: 2005-01-26 01:01+0100
  ... PO-Revision-Date: 2004-03-06 20:06+0100
  ... Last-Translator: Foo translator <footranslator@bar.com>
  ... MIME-Version: 1.0
  ... Content-Type: text/plain; charset=UTF-8
  ... Content-Transfer-Encoding: 8bit
  ... """)
  >>> header.translation_revision_date
  datetime.datetime(2004, 3, 6, 20, 6, tzinfo=tzinfo(60))

Even if the function has unicode chars we detect that as not having the
revision date:

  >>> header = PoHeader("""
  ... Project-Id-Version: foo
  ... Report-Msgid-Bugs-To: foo@bar.com
  ... POT-Creation-Date: 2005-01-26 01:01+0100
  ... PO-Revision-Date: \xc3\xa1 2004-03-06 20:06+0100
  ... Last-Translator: Foo translator <footranslator@bar.com>
  ... MIME-Version: 1.0
  ... Content-Type: text/plain; charset=UTF-8
  ... Content-Transfer-Encoding: 8bit
  ... """)
  >>> header.translation_revision_date is None
  True


== Parsing a PO template ==

Parsing a PO template:

  >>> content = """
  ... msgid ""
  ... msgstr ""
  ... "Project-Id-Version: Foobar 1.0\\n"
  ... "Report-Msgid-Bugs-To: \\n"
  ... "POT-Creation-Date: 2004-05-11 20:22+0800\\n"
  ... "PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\\n"
  ... "Last-Translator: FULL NAME <EMAIL@ADDRESS>\\n"
  ... "Language-Team: LANGUAGE <LL@li.org>\\n"
  ... "MIME-Version: 1.0\\n"
  ... "Content-Type: text/plain; charset=CHARSET\\n"
  ... "Content-Transfer-Encoding: 8bit\\n"
  ... #: foo/bar.c:42
  ... msgid "Foo"
  ... msgstr ""
  ... """

  >>> parser = PoParser()
  >>> translation_file = parser.parse(content)

  >>> print translation_file.header.charset
  CHARSET
  >>> len(translation_file.messages)
  1
  >>> print translation_file.messages[0].msgid
  Foo

PO templates, and other PO files that do not specify their encoding,
are parsed as ASCII text.  If they contain 8 bit characters, parsing
errors occur:

  >>> chunk2 = """
  ... #:foo/bar.c:42
  ... msgid "Bar"
  ... msgstr "ab\xc5"
  ... #:foo/baz.c:42
  ... msgid "Baz"
  ... msgstr "abcdef"
  ... """

  >>> parser.parse(content + chunk2)
  Traceback (most recent call last):
    ...
  TranslationFormatInvalidInputError: could not decode input from ASCII


== Evil Big5 Multibyte Sequences ==

To parse a PO file, it is necessary to know what encoding it is in,
which is specified in the PO file header.

This is particularly important with some encodings such as Big5, which
may include backslashes inside multibyte sequences.  These backslashes
must be interpreted as part of the character rather than as an escape
character.

  >>> content = """
  ... msgid ""
  ... msgstr ""
  ... "Last-Translator:  \xb5\x7b\xa6\xa1\xbf\xf9\xbb\x7e\\n"
  ... "Content-Type: text/plain; charset=Big5\\n"
  ... "Content-Transfer-Encoding: 8bit\\n"
  ... #: lib/regex.c:1367
  ... msgid "Success"
  ... msgstr "\xa6\xa8\xa5\\"
  ... """

  >>> translation_file = parser.parse(content)

Check that Big5 characters in the PO header have been correctly
converted:

  >>> translation_file.header.getRawContent()
  u'...Last-Translator:   \u7a0b\u5f0f\u932f\u8aa4\n...'

Check that the translation of the first message has been interpreted
correctly, despite the backslash in the second multibyte sequence:

  >>> translation_file.messages[0].translations
  [u'\u6210\u529f']


== Newline Formats ==

Not everyone is using UNIX systems, so some submitted PO files will
not use standard UNIX newlines.

Windows style '\r\n' newlines don't cause much trouble since those
files just appear to have some additional whitespace at the end of
lines.

Macintosh style '\r' newlines don't contain a '\n' character at all,
which would cause problems if we naively use '\n' as a line separator.

Change the last PO file to use Mac-style newlines:

  >>> content = content.replace('\n', '\r')

Verify that it still parses:

  >>> translation_file = parser.parse(content)
  >>> translation_file.messages[0].translations
  [u'\u6210\u529f']


== Escape Characters in Strings ==

Message strings in PO files can contain C string escape sequences. Some of
them have special meaning like 'new line': '\n' or 'tabs' '\t' and others are
just the numeric representation of a character in the declared encoding by
the Content-Type field of the header.

  >>> content = """
  ... msgid ""
  ... msgstr ""
  ... "POT-Creation-Date: 2004-05-11 20:22+0800\\n"
  ... "PO-Revision-Date: 2004-05-11 20:22+0800\\n"
  ... "Content-Type: text/plain; charset=UTF-8\\n"
  ... "Content-Transfer-Encoding: 8bit\\n"
  ... #: foo/bar.c: 42
  ... msgid "Foo\\n"
  ... "Bar\\n"
  ... msgstr "\\a\\b\\v\\f\\t\\v\\\\\\"\\'\\n"
  ... "\\70 \\070 \\0700 \\x70\\n"
  ...
  ... #: foo/bar.c: 50
  ... msgid "view \\302\\253${version_title}\\302\\273"
  ... msgstr ""
  ... """

  >>> translation_file = parser.parse(content)

The special symbols and numeric representations of the chars '8', '80' and 'p'
are decoded correctly.

  >>> translation_file.messages[0].translations
  [u'\x07\x08\x0b\x0c\t\x0b\\"\'\n8 8 80 p\n']

In this case, the numeric representation are UTF-8 only characters and we can
see that we get its Unicode equivalent.

  >>> translation_file.messages[1].msgid
  u'view \xab${version_title}\xbb'
