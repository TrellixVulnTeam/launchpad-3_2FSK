Package Bug Contact
===================

The package bug contact is zero, one, or more people or teams that get
explicitly Cc'd to all public bugs filed on a package.

The package bug contacts are obtained from looking at the
PackageBugContact table.

The list of package bug contacts are accessed through the
IDistributionSourcePackage.bugcontacts attribute. When there are no
contacts associated with a package, an empty list is returned:

    >>> from zope.component import getUtility
    >>> from canonical.launchpad.interfaces import (
    ...     IDistributionSet, IDistributionSourcePackage)

    >>> debian = getUtility(IDistributionSet).getByName("debian")
    >>> debian_firefox = debian.getSourcePackage("mozilla-firefox")

    >>> debian_firefox.bugcontacts
    []

Adding a package bug contact is done with the
IDistributionSourcePackage.addBugContact method. You have to be logged
in to call this method:

    >>> from canonical.launchpad.interfaces import IPersonSet
    >>> personset = getUtility(IPersonSet)
    >>> sample_person = personset.getByName("name12")

    >>> debian_firefox.addBugContact(sample_person)
    Traceback (most recent call last):
      ...
    Unauthorized: ...

Let's login then to add a bugcontact:

    >>> from canonical.launchpad.ftests import login
    >>> login("foo.bar@canonical.com")

    >>> debian_firefox.addBugContact(sample_person)
    >>> [pbc.bugcontact.name for pbc in debian_firefox.bugcontacts]
    [u'name12']

Trying to add a bug contact to a package when that person or team is
already one of the bug contacts on that package will raise a
DuplicateBugContactError.

    >>> debian_firefox.addBugContact(sample_person)
    Traceback (most recent call last):
      ...
    DuplicateBugContactError: ...

Let's add an ITeam as one of the bug contacts:

    >>> ubuntu_team = personset.getByName("ubuntu-team")
    >>> debian_firefox.addBugContact(ubuntu_team)

    >>> sorted([pbc.bugcontact.name for pbc in debian_firefox.bugcontacts])
    [u'name12', u'ubuntu-team']

To remove a bug contact, use IDistributionSourcePackage.removeBugContact:

    >>> debian_firefox.removeBugContact(sample_person)
    >>> sorted([pbc.bugcontact.id for pbc in debian_firefox.bugcontacts])
    [17]

Trying to remove a bug contact that doesn't exist on a source package raises a
DeleteBugContactError.

    >>> foobar = personset.getByName("name16")
    >>> debian_firefox.removeBugContact(foobar)
    Traceback (most recent call last):
      ...
    DeleteBugContactError: ...

To find out if an IPerson or ITeam is bug contact, use
IDistributionSourcePackage.isBugContact. For pragmatic reasons (in particular,
it makes the implementation of some of IDistributionSourcePackage's other
methods simpler) IDistributionSourcePackage.isBugContact will return either the
appropriate PackageBugContact record or False:

    >>> debian_firefox.isBugContact(ubuntu_team)
    <PackageBugContact ...>
    >>> debian_firefox.isBugContact(foobar)
    False

Package Bug Contacts and Bug Tasks
----------------------------------

Often a bug gets reported on package foo, when it should have been
reported on bar. When a user, likely a bug triager or developer, changes
the source package, the bug contacts for the new package get
subscribed. The bug contacts of the previous package also remain
subscribed.

To demonstrate, let's change the source package for bug #1 in
mozilla-firefox in Ubuntu to be pmount in Ubuntu, and see how the
subscribers list changes.

    >>> from canonical.launchpad.interfaces import IBugTaskSet

    >>> ubuntu = getUtility(IDistributionSet).getByName("ubuntu")

    >>> ubuntu_firefox = ubuntu.getSourcePackage("mozilla-firefox")
    >>> ubuntu_pmount = ubuntu.getSourcePackage("pmount")

    >>> bug_one_in_ubuntu_firefox = getUtility(IBugTaskSet).get(17)

Foo Bar, a package bug contact for ubuntu mozilla-firefox and ubuntu
pmount is currently not subscribed to bug 1.

    >>> def subscriber_names(bug):
    ...     subscribers = (
    ...         bug.getDirectSubscribers() + bug.getIndirectSubscribers())
    ...     return sorted(subscriber.displayname for subscriber in subscribers)

    >>> subscriber_names(bug_one_in_ubuntu_firefox.bug)
    [u'Foo Bar', u'Mark Shuttleworth', u'Sample Person', u'Steve Alexander',
     u'Ubuntu Team']

Changing the package for bug_one_in_ubuntu_firefox to pmount will
implicitly subscribe the new package's bug contacts to the bug. In
demonstrating this, we'll also make Sample Person a bug contact for
ubuntu pmount, to show that the subscription changes behave correctly
when a bug contact for the new package is already subscribed to the bug:

    >>> from zope.event import notify

    >>> import transaction
    >>> from canonical.launchpad.event.sqlobjectevent import (
    ...     SQLObjectToBeModifiedEvent, SQLObjectModifiedEvent)
    >>> from canonical.launchpad.webapp.snapshot import Snapshot
    >>> from canonical.launchpad.interfaces import (
    ...     IDistroBugTask, IDistroReleaseBugTask)
    >>> from canonical.launchpad.mail import stub

    >>> ubuntu_pmount.addBugContact(personset.getByName("daf"))
    >>> ubuntu_pmount.addBugContact(sample_person)

    >>> old_state = Snapshot(
    ...     bug_one_in_ubuntu_firefox, providing=IDistroBugTask)

    >>> bug_one_in_ubuntu_firefox.sourcepackagename = (
    ...     ubuntu_pmount.sourcepackagename)

    >>> source_package_changed = SQLObjectModifiedEvent(
    ...     bug_one_in_ubuntu_firefox, old_state,
    ...     ["id", "title", "sourcepackagename"])

    >>> notify(source_package_changed)
    >>> transaction.commit()

With the source package changed, we can see that daf is now subscribed:

    >>> subscriber_names(bug_one_in_ubuntu_firefox.bug)
    [u'Dafydd Harries', u'Foo Bar', u'Mark Shuttleworth',
     u'Sample Person', u'Steve Alexander', u'Ubuntu Team']

daf is sent an email giving him complete information about the bug that
has just been retargeted, including the title, description, status,
importance, etc.

    >>> import email

    >>> def by_to_addrs(a, b):
    ...     return cmp(a[1], b[1])

    >>> test_emails = list(stub.test_emails)
    >>> test_emails.sort(by_to_addrs)

    >>> len(test_emails)
    1
    >>> from_addr, to_addr, raw_message = test_emails.pop()
    >>> print from_addr
    bounces@canonical.com
    >>> print to_addr
    ['daf@canonical.com']

    >>> msg = email.message_from_string(raw_message)
    >>> msg['Subject']
    '[Bug 1] Firefox does not support SVG'
    >>> print msg.get_payload(decode=True)
    Public bug reported:
    <BLANKLINE>
    Firefox needs to support embedded SVG images, now that the standard has
    been finalised.
    <BLANKLINE>
    The SVG standard 1.0 is complete, and draft implementations for Firefox
    exist. One of these implementations needs to be integrated with the base
    install of Firefox. Ideally, the implementation needs to include support
    for the manipulation of SVG objects from JavaScript to enable
    interactive and dynamic SVG drawings.
    <BLANKLINE>
    ** Affects: firefox (upstream)
         Importance: Low
           Assignee: Mark Shuttleworth
             Status: Unconfirmed
    <BLANKLINE>
    ** Affects: pmount (Ubuntu)
         Importance: Medium
             Status: Unconfirmed
    <BLANKLINE>
    ** Affects: mozilla-firefox (Debian)
         Importance: Low
             Status: Confirmed
    <BLANKLINE>
    --
    Firefox does not support SVG
    http://launchpad.dev/bugs/1

    >>> stub.test_emails = []

Let's see that nothing unexpected happens when we set the source
package to None.

    >>> old_state = Snapshot(
    ...     bug_one_in_ubuntu_firefox, providing=IDistroBugTask)

    >>> bug_one_in_ubuntu_firefox.sourcepackagename = None

    >>> source_package_changed = SQLObjectModifiedEvent(
    ...     bug_one_in_ubuntu_firefox, old_state, ["sourcepackagename"])

    >>> notify(source_package_changed)
    >>> transaction.commit()
    >>> stub.test_emails = []

The package bug contacts, Daf and Foo Bar, are implicitly unsubscribed:

    >>> subscriber_names(bug_one_in_ubuntu_firefox.bug)
    [u'Mark Shuttleworth', u'Sample Person', u'Steve Alexander', u'Ubuntu Team']

This also works with distrorelease tasks. For example, bug #5 in Ubuntu
warty current has no subscribers:

    >>> bug_five_in_warty_firefox = getUtility(IBugTaskSet).get(16)
    >>> print bug_five_in_warty_firefox.distrorelease.name
    warty
    >>> list(bug_five_in_warty_firefox.bug.subscriptions)
    []

Reassigning this task to pmount will subscribe pmount's bug contacts:
Sample Person and daf.

    >>> old_state = Snapshot(
    ...     bug_five_in_warty_firefox, providing=IDistroReleaseBugTask)

    >>> bug_five_in_warty_firefox.sourcepackagename = (
    ...     ubuntu_pmount.sourcepackagename)

    >>> source_package_changed = SQLObjectModifiedEvent(
    ...     bug_five_in_warty_firefox, old_state, ["sourcepackagename"])

    >>> notify(source_package_changed)
    >>> transaction.commit()

    >>> subscriber_names(bug_five_in_warty_firefox.bug)
    [u'Dafydd Harries', u'Foo Bar', u'Sample Person']

Bug contacts are not limited to persons; teams are also allowed. Teams
are a bit different, since they might not have a contact address. Let's
add such a team as a bug contact.

    >>> ubuntu_gnome = personset.getByName("name18")
    >>> ubuntu_gnome.preferredemail is None
    True
    >>> ubuntu_pmount.addBugContact(ubuntu_gnome)

    >>> old_state = Snapshot(
    ...     bug_one_in_ubuntu_firefox, providing=IDistroBugTask)

    >>> bug_one_in_ubuntu_firefox.sourcepackagename = (
    ...     ubuntu_pmount.sourcepackagename)

    >>> source_package_changed = SQLObjectModifiedEvent(
    ...     bug_one_in_ubuntu_firefox, old_state, ["sourcepackagename"])

    >>> notify(source_package_changed)
    >>> transaction.commit()

The Ubuntu Gnome team was subscribed to the bug:

    >>> subscriber_names(bug_one_in_ubuntu_firefox.bug)
    [u'Dafydd Harries', u'Foo Bar', u'Mark Shuttleworth',
     u'Sample Person', u'Steve Alexander', u'Ubuntu Gnome Team',
     u'Ubuntu Team']

If a bug is private, no changes are made to the subscriber list when a
bug is reassigned to a different package.

    >>> notify(
    ...     SQLObjectToBeModifiedEvent(
    ...         bug_one_in_ubuntu_firefox.bug, {"private": True}))

    >>> bug_one_in_ubuntu_firefox.bug.private = True

So, if Martin Pitt becomes a bug contact for ubuntu mozilla-firefox:

    >>> pitti = personset.getByName("martin-pitt")
    >>> ubuntu_firefox.addBugContact(pitti)

and then the bug gets reassigned to mozilla firefox:

    >>> old_state = Snapshot(
    ...     bug_one_in_ubuntu_firefox, providing=IDistroBugTask)

    >>> bug_one_in_ubuntu_firefox.sourcepackagename = (
    ...     ubuntu_firefox.sourcepackagename)

    >>> source_package_changed = SQLObjectModifiedEvent(
    ...     bug_one_in_ubuntu_firefox, old_state,
    ...     ["id", "title", "sourcepackagename"])

    >>> notify(source_package_changed)
    >>> transaction.commit()
    >>> stub.test_emails = []

the bug contacts remain unchanged:

    >>> subscriber_names(bug_one_in_ubuntu_firefox.bug)
    [u'Dafydd Harries', u'Foo Bar', u'Mark Shuttleworth',
     u'Sample Person', u'Steve Alexander', u'Ubuntu Gnome Team',
     u'Ubuntu Team']

Product Bug Contacts and Bug Tasks
----------------------------------

Like reassigning a bug task to another package, reassigning a bug task
to another product will subscribe any new product bug contacts to the
bug that aren't already subscribed.

    >>> from canonical.launchpad.interfaces import IProductSet

    >>> mozilla_firefox = getUtility(IProductSet).get(4)

Let's make Foo Bar a bug contact for upstream firefox:

    >>> mozilla_firefox.bugcontact = foobar

Then we'll reassign bug #2 in Ubuntu to be in Firefox, noting that Foo
Bar gets subscribed to the bug in the process:

    >>> from canonical.launchpad.interfaces import IUpstreamBugTask

    >>> bug_two_in_ubuntu = getUtility(IBugTaskSet).get(3)
    >>> print bug_two_in_ubuntu.bug.id
    2
    >>> print bug_two_in_ubuntu.product.name
    ubuntu

    >>> sorted(
    ...     [subscription.person.displayname for subscription in
    ...      bug_two_in_ubuntu.bug.subscriptions])
    [u'Steve Alexander']

    >>> old_state = Snapshot(
    ...     bug_two_in_ubuntu, providing=IUpstreamBugTask)

    >>> bug_two_in_ubuntu.product = mozilla_firefox

    >>> product_changed = SQLObjectModifiedEvent(
    ...     bug_two_in_ubuntu, old_state, ["id", "title", "product"])

    >>> notify(product_changed)
    >>> transaction.commit()

With the product changed, we can see that Foo Bar is now subscribed:

    >>> subscriber_names(bug_two_in_ubuntu.bug)
    [u'Foo Bar', u'Sample Person', u'Steve Alexander', u'Ubuntu Team']

And Foo Bar gets an email containing complete information about the bug
report:

    >>> test_emails = list(stub.test_emails)
    >>> test_emails.sort(by_to_addrs)

    >>> len(test_emails)
    1
    >>> from_addr, to_addr, raw_message = test_emails.pop()
    >>> print from_addr
    bounces@canonical.com
    >>> print to_addr
    ['foo.bar@canonical.com']

    >>> msg = email.message_from_string(raw_message)
    >>> msg['Subject']
    '[Bug 2] Blackhole Trash folder'
    >>> print msg.get_payload(decode=True)
    Public bug reported:
    ...
    ** Affects: firefox (upstream)
    ...
