Bug Nomination
==============

Any logged-in user can nominate a bug to be fixed in a specific
distribution release or product series. Nominations are created by
calling IBug.addNomination.

    >>> from zope.component import getUtility
    >>> from zope.interface.verify import verifyClass
    >>> from canonical.launchpad.database import BugNomination
    >>> from canonical.launchpad.interfaces import (
    ...     IBugNomination, IBugSet, IDistributionSet, IPersonSet)

    >>> login("no-priv@canonical.com")

The BugNomination class implements IBugNomination.

    >>> verifyClass(IBugNomination, BugNomination)
    True

    >>> bugset = getUtility(IBugSet)
    >>> bug_one = bugset.get(1)

    >>> ubuntu = getUtility(IDistributionSet).getByName("ubuntu")
    >>> ubuntu_grumpy = ubuntu.getRelease("grumpy")
    >>> personset = getUtility(IPersonSet)
    >>> no_privs = personset.getByName("no-priv")

    >>> grumpy_nomination = bug_one.addNomination(
    ...     target=ubuntu_grumpy, owner=no_privs)

The nomination records the distro release or series for which the bug
was nominated and the user that submitted the nomination (the "owner".)

    >>> print grumpy_nomination.owner.name
    no-priv

    >>> print grumpy_nomination.distrorelease.fullreleasename
    Ubuntu Grumpy

Let's create another nomination, this time on a product series.

    >>> from canonical.launchpad.interfaces import IProductSet

    >>> firefox = getUtility(IProductSet).getByName("firefox")

    >>> firefox_trunk = firefox.getSeries("trunk")

    >>> no_privs = personset.getByName("no-priv")

    >>> firefox_ms_nomination = bug_one.addNomination(
    ...     target=firefox_trunk, owner=no_privs)

    >>> print firefox_ms_nomination.owner.name
    no-priv

    >>> print firefox_ms_nomination.productseries.title
    Mozilla Firefox Series: trunk

The target of a nomination can also be accessed through its target
attribute.

    >>> print grumpy_nomination.target.bugtargetname
    Ubuntu Grumpy

    >>> print firefox_ms_nomination.target.bugtargetname
    firefox trunk (upstream)

Use IBug.canBeNominatedFor to see if a bug can be nominated for a
particular distrorelease or productseries. This will consider whether
the bug has already been nominated for that release, or even already
targeted to that release without a nomination, which can happen for bugs
that were reported prior to the release management/nomination
functionality existing.

    >>> ubuntu_breezy_autotest = ubuntu.getRelease("breezy-autotest")

    >>> bug_one.canBeNominatedFor(firefox_trunk)
    False

    >>> bug_one.canBeNominatedFor(ubuntu_grumpy)
    False

    >>> bug_one.canBeNominatedFor(ubuntu_breezy_autotest)
    True

Bug five is already targeted to Ubuntu Warty, so even though it has no
Warty nominations, it cannot be targeted to Warty.

    >>> bug_five = bugset.get(5)
    >>> bug_five.getNominations()
    []

    >>> def by_bugtargetname(bugtask):
    ...     return bugtask.target.bugtargetname

    >>> tasks = sorted(bug_five.bugtasks, key=by_bugtargetname)

    >>> for task in tasks:
    ...     print task.target.bugtargetname
    firefox (upstream)
    mozilla-firefox (Ubuntu Warty)

    >>> ubuntu_warty = ubuntu.getRelease("warty")
    >>> bug_five.canBeNominatedFor(ubuntu_warty)
    False

The getNominationFor() method returns a nomination for a specific
productseries or distrorelease. If there is no nomination for the target
provided, a NotFoundError is raised.

    >>> bug_one.getNominationFor(firefox_trunk)
    <BugNomination ...>

    >>> bug_one.getNominationFor(ubuntu_grumpy)
    <BugNomination ...>

    >>> bug_one.getNominationFor(ubuntu_breezy_autotest)
    Traceback (most recent call last):
      ...
    NotFoundError: ...

IBug.getNominations() returns a list of all IBugNominations for a bug,
ordered by IBugTarget.bugtargetname.

    >>> nominations = bug_one.getNominations()

    >>> [nomination.target.bugtargetname for nomination in nominations]
    [u'firefox 1.0 (upstream)', u'firefox trunk (upstream)',
     u'Ubuntu Grumpy', u'Ubuntu Hoary']

This method also accepts a target argument, for further filtering.

    >>> nominations = bug_one.getNominations(firefox)

    >>> [nomination.target.bugtargetname for nomination in nominations]
    [u'firefox 1.0 (upstream)', u'firefox trunk (upstream)']

    >>> nominations = bug_one.getNominations(ubuntu)

    >>> [nomination.target.bugtargetname for nomination in nominations]
    [u'Ubuntu Grumpy', u'Ubuntu Hoary']

Nomination Status
-----------------

A nomination is created with an initial status of "Proposed".

    >>> ubuntu_breezy_autotest_nomination = bug_one.addNomination(
    ...     target=ubuntu_breezy_autotest, owner=no_privs)

    >>> print ubuntu_breezy_autotest_nomination.status.title
    Proposed
    >>> ubuntu_breezy_autotest_nomination.isProposed()
    True
    >>> ubuntu_breezy_autotest_nomination.isApproved()
    False
    >>> ubuntu_breezy_autotest_nomination.isDeclined()
    False

Nomination status changes have an associated workflow. For this reason,
setting status directly is not possible.

    >>> from canonical.lp.dbschema import BugNominationStatus

    >>> nomination.status = BugNominationStatus.APPROVED
    Traceback (most recent call last):
      ...
    ForbiddenAttribute: ...

The status of a nomination is changed by calling either the approve() or
decline() method. Only users with launchpad.Driver permission on the
nomination can approve or decline it.

    >>> from canonical.launchpad.helpers import check_permission
    >>> from canonical.launchpad.interfaces import ILaunchBag

    >>> current_user = getUtility(ILaunchBag).user

    >>> current_user == no_privs
    True
    >>> check_permission("launchpad.Driver", firefox_ms_nomination)
    False

    >>> firefox_ms_nomination.approve(no_privs)
    Traceback (most recent call last):
      ..
    Unauthorized: ...

    >>> firefox_ms_nomination.decline(no_privs)
    Traceback (most recent call last):
      ..
    Unauthorized: ...

(Log in as an admin to set the driver.)

    >>> login("foo.bar@canonical.com")

    >>> firefox_ms_nomination.target.driver = no_privs

    >>> login("no-priv@canonical.com")

Approving a nomination
----------------------

When a nomination is approved, the appropriate bugtask(s) are created on
the target of the nomination and the status is set to APPROVED.

For example, there are currently no bugtasks on the firefox_trunk
productseries.

    >>> from canonical.launchpad.interfaces import BugTaskSearchParams

    >>> params = BugTaskSearchParams(user=no_privs, bug=bug_one)
    >>> found_tasks = firefox_trunk.searchTasks(params)
    >>> found_tasks.count()
    0

When a nomination is approved, one task is created, targeted at
firefox_trunk.

    >>> firefox_ms_nomination.approve(no_privs)

    >>> firefox_ms_nomination.isApproved()
    True
    >>> firefox_ms_nomination.isProposed()
    False
    >>> firefox_ms_nomination.isDeclined()
    False

    >>> found_tasks.count()
    1
    >>> bugtask = found_tasks[0]
    >>> bugtask.target == firefox_trunk
    True
    >>> print bugtask.owner.name
    no-priv

When a distribution bug nomination is approved, a task is created for
each package the bug affects in that distro. For example, let's ensure
bug #1 affects more than one Ubuntu package.

    >>> from canonical.launchpad.interfaces import IBugTaskSet

    >>> ubuntu_tbird = ubuntu.getSourcePackage("thunderbird")

    >>> getUtility(IBugTaskSet).createTask(
    ...     bug=bug_one, owner=no_privs,
    ...     distribution=ubuntu,
    ...     sourcepackagename=ubuntu_tbird.sourcepackagename)
    <BugTask ...>

    >>> tasks = sorted(
    ...     bug_one.bugtasks, key=by_bugtargetname)

    >>> for task in tasks:
    ...     print task.target.bugtargetname
    firefox (upstream)
    firefox trunk (upstream)
    mozilla-firefox (Debian)
    mozilla-firefox (Ubuntu)
    thunderbird (Ubuntu)

When we approve the nomination, two more Ubuntu tasks are added for the
Grumpy release. The user that made the decision is stored in the decider
attribute. The date on which the decision was made is stored in the
date_decided attribute.

(Again, first we'll set the driver with an admin user, to ensure
no_privs can actually approve the nomination.)

    >>> login("foo.bar@canonical.com")
    >>> grumpy_nomination.target.driver = no_privs
    >>> login("no-priv@canonical.com")

    >>> grumpy_nomination.date_decided is None
    True
    >>> grumpy_nomination.approve(no_privs)
    >>> print grumpy_nomination.status.title
    Approved
    >>> print grumpy_nomination.decider.name
    no-priv
    >>> grumpy_nomination.date_decided
    datetime...

    >>> tasks = sorted(
    ...     bug_one.bugtasks, key=by_bugtargetname)

    >>> for task in tasks:
    ...     print task.target.bugtargetname
    firefox (upstream)
    firefox trunk (upstream)
    mozilla-firefox (Debian)
    mozilla-firefox (Ubuntu Grumpy)
    mozilla-firefox (Ubuntu)
    thunderbird (Ubuntu Grumpy)
    thunderbird (Ubuntu)

Declining a nomination
----------------------

Declining a nomination simply sets its status to DECLINED. No tasks are
created.

    >>> login("foo.bar@canonical.com")
    >>> ubuntu_breezy_autotest_nomination.target.driver = no_privs
    >>> login("no-priv@canonical.com")

    >>> ubuntu_breezy_autotest_nomination.date_decided is None
    True
    >>> print ubuntu_breezy_autotest_nomination.status.title
    Proposed

    >>> ubuntu_breezy_autotest_nomination.decline(no_privs)

    >>> print ubuntu_breezy_autotest_nomination.status.title
    Declined

    >>> ubuntu_breezy_autotest_nomination.isDeclined()
    True
    >>> ubuntu_breezy_autotest_nomination.isApproved()
    False
    >>> ubuntu_breezy_autotest_nomination.isProposed()
    False
    >>> print ubuntu_breezy_autotest_nomination.decider.name
    no-priv
    >>> ubuntu_breezy_autotest_nomination.date_decided
    datetime...

Automatic targeting of new source packages
------------------------------------------

If a another distribution task is added, and nomination for that
distribution's releases already exists, the nominations will be valid
for the new task as well, and bugtasks will be created for all accepted
ones.

The nominations are per distrorelease, they are not source package
specific, so they are automatically valid for new bugtasks. What's
important are the accepted nominations. Bug one has an accepted
nomination for Grumpy:

    >>> accepted_nominations = [
    ...     nomination for nomination in bug_one.getNominations(ubuntu)
    ...     if nomination.isApproved()]
    >>> for nomination in accepted_nominations:
    ...     print nomination.distrorelease.displayname
    Grumpy

So if we create a new bugtask on evolution (Ubuntu), a task for
evolution (Ubuntu Grumpy) will be created automatically.

    >>> ubuntu_evolution = ubuntu.getSourcePackage('evolution')
    >>> getUtility(IBugTaskSet).createTask(
    ...     bug=bug_one, owner=no_privs,
    ...     distribution=ubuntu,
    ...     sourcepackagename=ubuntu_evolution.sourcepackagename)
    <BugTask at ...>

    >>> tasks = sorted(
    ...     bug_one.bugtasks, key=by_bugtargetname)

    >>> for task in tasks:
    ...     print task.target.bugtargetname
    evolution (Ubuntu Grumpy)
    evolution (Ubuntu)
    firefox (upstream)
    firefox trunk (upstream)
    mozilla-firefox (Debian)
    mozilla-firefox (Ubuntu Grumpy)
    mozilla-firefox (Ubuntu)
    thunderbird (Ubuntu Grumpy)
    thunderbird (Ubuntu)

Bug Nomination Set
------------------

IBugNominationSet is used to fetch bug nominations by ID. This is useful
mainly in traversal code.

    >>> from canonical.launchpad.interfaces import IBugNominationSet

    >>> getUtility(IBugNominationSet).get(1)
    <BugNomination at ...>

If a nomination is not found, a NotFoundError is raised.

    >>> getUtility(IBugNominationSet).get(-1)
    Traceback (most recent call last):
      ...
    NotFoundError: ...

Error Handling
--------------

Trying to nominate a bug for a release for which it's already nominated
or targeted raises a NominationError.

    >>> bug_one.addNomination(
    ...     target=ubuntu_grumpy, owner=no_privs)
    Traceback (most recent call last):
      ..
    NominationError: ...

    >>> bug_one.addNomination(
    ...     target=firefox_trunk, owner=no_privs)
    Traceback (most recent call last):
      ..
    NominationError: ...

Nominating a bug for an obsolete distrorelease raises a
NominationReleaseObsoleteError. Let's mark warty obsolete to
demonstrate.

    >>> from canonical.lp.dbschema import DistributionReleaseStatus

(Temporarily log in as an admin user to change the release status.)

    >>> login("foo.bar@canonical.com")
    >>> ubuntu_warty.releasestatus = DistributionReleaseStatus.OBSOLETE
    >>> login("no-priv@canonical.com")

    >>> bug_one.addNomination(target=ubuntu_warty, owner=no_privs)
    Traceback (most recent call last):
      ..
    NominationReleaseObsoleteError: ...

    >>> logout()
