Bugs in Malone
==============

This document describes what a Bug is in Malone, and provides some (currently
rather incomplete) info on how to poke at bugs through the Component
Architecture.

Working with Bugs
-----------------

Bugs are created and retrieved via IBugSet.

    >>> from zope.component import getUtility
    >>> from canonical.launchpad.interfaces import IBugSet
    >>> bugset = getUtility(IBugSet)

To retrieve a specific Bug, use IBugSet.get:

    >>> firefox_crashes = bugset.get(6)
    >>> print firefox_crashes.title
    Firefox crashes when Save As dialog for a nonexistent window is closed

Or you can use IBugSet.getByNameOrID to get it by its nickname:

    >>> blackhole_bug = bugset.getByNameOrID('blackhole')
    >>> print blackhole_bug.title
    Blackhole Trash folder

If the bug can't be found, a zope.exceptions.NotFoundError will be
raised:

    >>> bugset.get(123456)
    Traceback (most recent call last):
      ...
    NotFoundError: 'Unable to locate bug with ID 123456'

    >>> bugset.getByNameOrID('+bugs')
    Traceback (most recent call last):
      ...
    NotFoundError: 'Unable to locate bug with nickname +bugs'


Searching for Bugs
------------------

To search for bugs matching specific criteria, use IBugSet.searchAsUser:

    >>> from canonical.database.sqlbase import flush_database_updates
    >>> from canonical.launchpad.interfaces import ILaunchBag

    >>> def current_user():
    ...     return getUtility(ILaunchBag).user

    >>> login("foo.bar@canonical.com")

    >>> firefox_test_bug = bugset.get(3)
    >>> firefox_test_bug.duplicateof = firefox_crashes.id
    >>> flush_database_updates()

    >>> dups_of_bug_six = bugset.searchAsUser(
    ...     duplicateof=firefox_crashes, user=current_user())
    >>> print dups_of_bug_six.count()
    1
    >>> dups_of_bug_six[0].id
    3

    >>> firefox_test_bug.duplicateof = None
    >>> flush_database_updates()
    >>> dups_of_bug_six = bugset.searchAsUser(
    ...     duplicateof=firefox_crashes, user=current_user())
    >>> print dups_of_bug_six.count()
    0

    >>> login(ANONYMOUS)

Absolute URLs
-------------

For things like bug notification emails, it's handy to be able to
include a URL to the bug inside the email.

    >>> from canonical.launchpad.webapp import canonical_url
    >>> print canonical_url(firefox_crashes)
    http://.../bugs/6

Bug Privacy
===========

A Bug has a "private" field. If Bug.private is False, the bug is publicly
visible. If Bug.private is True, only people who are explicitly subscribed to
the bug can see it. Launchpad admins can always view and modify private bugs.

Marking Bugs Private
--------------------

For the purposes of demonstration, we'll make the firefox crashing bug
private. A bug cannot be made private by an anonymous user.

    >>> firefox_crashes.private = True
    Traceback (most recent call last):
      ...
    Unauthorized: (..., 'private', 'launchpad.Edit')

We have to be logged in, so let's do that:

    >>> login("test@canonical.com")

There are currently no people subscribed to this bug:

    >>> print firefox_crashes.subscriptions.count()
    0 

he rule with private bugs is that only explicit subscribers can view the
bug after it's been marked private. So, if Sample Person is to mark the
firefox_crashes bug private, we must first ensure that Sample Person is
subscribed to the bug!

    >>> sample_person = current_user()
    >>> subscription = firefox_crashes.subscribe(sample_person)

Now we can mark bug #6 private:

    >>> from zope.event import notify
    >>> from canonical.launchpad.event import (
    ...     SQLObjectModifiedEvent, SQLObjectToBeModifiedEvent,
    ...     SQLObjectCreatedEvent)
    >>> from canonical.launchpad.interfaces import (
    ...     IPersonSet, IBug)
    >>> from canonical.launchpad.helpers import Snapshot

    >>> new_values = {"private" : True}
    >>> bug_will_be_set_private = SQLObjectToBeModifiedEvent(
    ...     firefox_crashes, new_values)

    >>> notify(bug_will_be_set_private)

    >>> old_state = Snapshot(firefox_crashes, providing=IBug)
    >>> firefox_crashes.private = True
    >>> bug_set_private = SQLObjectModifiedEvent(
    ...     firefox_crashes, old_state,
    ...     ["id", "title", "private"])

    >>> notify(bug_set_private)
    >>> flush_database_updates()

How Privacy Affects Access to a Bug
-----------------------------------

Once a bug is made private, it can only be accessed by the users that are
explicitly subscribed to the bug and Launchpad admins.

So, remembering that we're still logged in as Sample Person (ID 12 in
the Person table), and that Sample Person is an explicit subscriber to
the firefox_crashes bug, we can still access properties of this bug:

    >>> firefox_crashes.title
    u'Firefox crashes when Save As dialog for a nonexistent window is closed'

Note that a search will return all the bugs, as well:

    >>> all_bugs = bugset.searchAsUser(
    ...     user=current_user(), orderBy="id")
    >>> [bug.id for bug in all_bugs]
    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

Likewise Foo Bar, an admin, can access the bug.

    >>> login("foo.bar@canonical.com")

    >>> old_title = firefox_crashes.title
    >>> firefox_crashes.title = "new title"
    >>> firefox_crashes.title
    u'new title'
    >>> firefox_crashes.title = old_title
    >>> firefox_crashes.title
    u'Firefox crashes when Save As dialog for a nonexistent window is closed'

Bug #6 is returned by the search results for an admin as well:

    >>> all_bugs = bugset.searchAsUser(
    ...     user=current_user(), orderBy="id")
    >>> [bug.id for bug in all_bugs]
    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

As one would expect, the permissions are team aware. So, let's retrieve a bug
and set it private (as Foo Bar again who, of course, is an admin.)

    >>> blackhole_trash_folder = bugset.get(2)

And again, let's fake setting the bug private:

    >>> new_values = {"private" : True}
    >>> bug_will_be_set_private = SQLObjectToBeModifiedEvent(
    ...     blackhole_trash_folder, new_values)

    >>> notify(bug_will_be_set_private)

    >>> old_state = Snapshot(blackhole_trash_folder, providing=IBug)
    >>> blackhole_trash_folder.private = True
    >>> bug_set_private = SQLObjectModifiedEvent(
    ...     blackhole_trash_folder, old_state,
    ...     ["id", "title", "private"])

    >>> notify(bug_set_private)
    >>> flush_database_updates()

Then let's permit the Ubuntu Team to access this bug by adding them to
the Cc list:

    >>> from canonical.launchpad.interfaces import IPersonSet
    >>> personset = getUtility(IPersonSet)

    >>> ubuntu_team = personset.get(17)
    >>> subscription = blackhole_trash_folder.subscribe(ubuntu_team)

Jeff Waugh, a member of the Ubuntu Team, is able to access this bug:

    >>> login("jeff.waugh@ubuntulinux.com")

    >>> old_title = blackhole_trash_folder.title
    >>> blackhole_trash_folder.title = "new title"
    >>> blackhole_trash_folder.title
    u'new title'
    >>> blackhole_trash_folder.title = old_title
    >>> blackhole_trash_folder.title
    u'Blackhole Trash folder'

and see it (bug #2) in searches:

    >>> all_bugs = bugset.searchAsUser(
    ...     user=current_user(), orderBy="id")
    >>> [bug.id for bug in all_bugs]
    [1, 2, 3, 4, 5, 7, 8, 9, 10]

If we login as someone who *isn't* a member of the Ubuntu Team (and
isn't otherwise someone who should be allowed to access the properties
of this bug) though:

    >>> login("no-priv@canonical.com")

Trying to access a property of this bug will again raise an
Unauthorized:

    >>> blackhole_trash_folder.title
    Traceback (most recent call last):
      ...
    Unauthorized: (..., 'title', 'launchpad.View')

And, as you might have guessed, is once again invisible in searches
(notice that bug #6 is also invisible to No Privileges Person):

    >>> all_bugs = bugset.searchAsUser(
    ...     user=current_user(), orderBy="id")
    >>> [bug.id for bug in all_bugs]
    [1, 3, 4, 5, 7, 8, 9, 10]

Filing Public vs. Private Bugs
------------------------------

Let's log back in as Foo Bar to continue our examples:

    >>> login("foo.bar@canonical.com")

When a public bug is filed:

>>> from canonical.launchpad.interfaces import IProductSet
>>> from canonical.launchpad.interfaces import IBugSet
>>> productset = getUtility(IProductSet)
>>> bugset = getUtility(IBugSet)

>>> firefox = productset.get(4)
>>> foobar = personset.get(16)
>>> added_bug = getUtility(IBugSet).createBug(
...     product=firefox, title="test firefox bug",
...     comment="blah blah blah", owner=foobar)
>>> notify(SQLObjectCreatedEvent(added_bug))
>>> public_bug = bugset.get(added_bug.id)

the submitter and the maintainer are explicitly subscribed. Note that
passing both a comment /and/ a msg would have raised an
AssertionError:

>>> added_bug = getUtility(IBugSet).createBug(
...     product=firefox, title="test firefox bug",
...     comment="blah blah blah", msg="foo foo foo",
...     owner=foobar)
Traceback (most recent call last):
  ...
AssertionError: Expected either a comment or a msg, but got both


So, let's continue:

>>> print [subscription.person.id for subscription in public_bug.subscriptions]
[16, 12]

The first comment made (this is submitted in the bug report) is set to
the description of the bug:

>>> public_bug.description
u'blah blah blah'

The bug description can also be accessed through the task:

>>> public_bug.bugtasks[0].bug.description
u'blah blah blah'
>>> public_bug.description = 'a new description'
>>> public_bug.bugtasks[0].bug.description
u'a new description'

When a private bug is filed:

>>> added_bug = getUtility(IBugSet).createBug(
...     product=firefox, title="test firefox bug",
...     comment="blah blah blah", owner=foobar, private=True)
>>> notify(SQLObjectCreatedEvent(added_bug))
>>> private_bug = bugset.get(added_bug.id)

*only* the submitter is explicitly subscribed:

>>> print [subscription.person.id for subscription in private_bug.subscriptions]
[16]

It's up to the submitter to explicitly subscribe the maintainer, if
they so choose.

This works similarly for distributions; in this case the
"maintainer" is considered the person who maintains the applicable
sourcepackage. E.g.

>>> from canonical.launchpad.interfaces import (
...     IDistributionSet, ISourcePackageNameSet)
>>> distributionset = getUtility(IDistributionSet)
>>> spnset = getUtility(ISourcePackageNameSet)
>>> ubuntu = distributionset.get(1)
>>> evolution = spnset.get(9)
>>> added_bug = getUtility(IBugSet).createBug(
...     distribution=ubuntu, sourcepackagename=evolution,
...     title="test firefox bug", comment="blah blah blah",
...     owner=foobar, private=True)
>>> notify(SQLObjectCreatedEvent(added_bug))
>>> private_bug = bugset.get(added_bug.id)
>>> print [subscription.person.id for subscription in private_bug.subscriptions]
[16]

There are some IBugTargets that don't allow bugs to be directly filed on
them, e.g. IDistroRelease and ISourcePackage.

>>> from canonical.launchpad.interfaces import IDistroReleaseSet

>>> ubuntu_warty = getUtility(IDistroReleaseSet).get(1)
>>> ubuntu_warty_firefox = ubuntu_warty.getSourcePackage("mozilla-firefox")
>>> ubuntu_warty.createBug(
...     owner=current_user(), title="test", comment="test")
Traceback (most recent call last):
  ...
NotImplementedError: A new bug cannot be filed directly on a distribution release, because releases are meant for "targeting" a fix to a specific release. It's possible that we may change this behaviour to allow filing a bug on a distribution release in the not-too-distant future. For now, you probably meant to file the bug on the distribution instead.
>>> ubuntu_warty_firefox.createBug(
...     owner=current_user(), title="test", comment="test")
Traceback (most recent call last):
  ...
NotImplementedError: A new bug cannot be filed directly on a source package in a specific distribution release, because releases are meant for "targeting" a fix to a specific release. It's possible that we may change this behaviour to allow filing a bug on a distribution release source package in the not-too-distant future. For now, you probably meant to file the bug on the distro-wide (i.e. not release-specific) source package.

Date Last Updated
-----------------

Malone tracks the last time a change was made to a
bug. IBug.date_last_updated stores the date when anything is changed or
added to a bug, i.e., an IBug or IBugTask is added or changed, or an
IHasBug object is added or changed. The sole exception to this is
subscribing/unsubscribing (which create/delete IBugSubscription
objects.) Let's look at an example of each.

When a bug is created, its date_last_updated is set right away, to
ensure that new bugs sort appropriately.

  >>> firefox_bug = firefox.createBug(
  ...     title="a test firefox bug",
  ...     comment="a description of the bug",
  ...     owner=current_user())

  >>> firefox_bug.datecreated == firefox_bug.date_last_updated
  True

Adding a comment.

  >>> current_date_last_updated = firefox_bug.date_last_updated

  >>> comment = firefox_bug.newMessage(
  ...     owner=current_user(),
  ...     subject="blah blah blah",
  ...     content="blah blah blah")

  >>> firefox_bug.date_last_updated > current_date_last_updated
  True

Changing the bug summary.

  >>> from canonical.launchpad.interfaces import IBug

  >>> bug_before_modification = Snapshot(firefox_bug, providing=IBug)

  >>> firefox_bug.title = "a new title"

  >>> bug_summary_changed = SQLObjectModifiedEvent(
  ...     firefox_bug, bug_before_modification, ["title"])

  >>> current_date_last_updated = firefox_bug.date_last_updated

  >>> notify(bug_summary_changed)

  >>> firefox_bug.date_last_updated > current_date_last_updated
  True

Changing the description.

  >>> bug_before_modification = Snapshot(firefox_bug, providing=IBug)

  >>> firefox_bug.description = "a new description"

  >>> bug_description_changed = SQLObjectModifiedEvent(
  ...     firefox_bug, bug_before_modification, ["description"])

  >>> current_date_last_updated = firefox_bug.date_last_updated

  >>> notify(bug_description_changed)

  >>> firefox_bug.date_last_updated > current_date_last_updated
  True

Modifying a bugtask will update IBug.date_last_updated.

  >>> from canonical.lp.dbschema import BugTaskStatus, BugTaskSeverity
  >>> from canonical.launchpad.interfaces import IUpstreamBugTask

  >>> firefox_task = firefox_bug.bugtasks[0]

  >>> print firefox_task.targetname
  firefox (upstream)

  >>> print firefox_task.severity.title
  Normal
  >>> print firefox_task.status.title
  Unconfirmed

  >>> bugtask_before_modification = Snapshot(
  ...     firefox_task, providing=IUpstreamBugTask)

  >>> firefox_task.severity = BugTaskSeverity.CRITICAL
  >>> firefox_task.transitionToStatus(BugTaskStatus.CONFIRMED)

  >>> bugtask_modified = SQLObjectModifiedEvent(
  ...     firefox_task, bugtask_before_modification,
  ...     ["status", "severity"])

  >>> current_date_last_updated = firefox_bug.date_last_updated

  >>> notify(bugtask_modified)

  >>> firefox_bug.date_last_updated > current_date_last_updated
  True

Adding a new task.

  >>> from canonical.launchpad.interfaces import IBugTaskSet

  >>> thunderbird = productset.getByName("thunderbird")

  >>> print thunderbird.name
  thunderbird

  >>> thunderbird_task = getUtility(IBugTaskSet).createTask(
  ...     bug=firefox_bug, owner=foobar, product=thunderbird)

  >>> current_date_last_updated = firefox_bug.date_last_updated

  >>> notify(SQLObjectCreatedEvent(thunderbird_task))

  >>> firefox_bug.date_last_updated > current_date_last_updated
  True

Changing bug visibility.

  >>> bug_before_modification = Snapshot(firefox_bug, providing=IBug)

  >>> firefox_bug.private
  False
  >>> firefox_bug.private = True

  >>> bug_visibility_changed = SQLObjectModifiedEvent(
  ...     firefox_bug, bug_before_modification, ["private"])

  >>> current_date_last_updated = firefox_bug.date_last_updated

  >>> notify(bug_visibility_changed)

  >>> firefox_bug.date_last_updated > current_date_last_updated
  True

Changing bug security.

  >>> bug_before_modification = Snapshot(firefox_bug, providing=IBug)

  >>> firefox_bug.security_related
  False
  >>> firefox_bug.security_related = True

  >>> bug_security_changed = SQLObjectModifiedEvent(
  ...     firefox_bug, bug_before_modification, ["security_related"])

  >>> current_date_last_updated = firefox_bug.date_last_updated

  >>> notify(bug_security_changed)

  >>> firefox_bug.date_last_updated > current_date_last_updated
  True

Marking as duplicate.

  >>> bug_before_modification = Snapshot(firefox_bug, providing=IBug)

  >>> print firefox_bug.duplicateof
  None
  >>> firefox_bug.duplicateof = firefox_crashes

  >>> bug_duplicateof_changed = SQLObjectModifiedEvent(
  ...     firefox_bug, bug_before_modification, ["duplicateof"])

  >>> current_date_last_updated = firefox_bug.date_last_updated

  >>> notify(bug_duplicateof_changed)

  >>> firefox_bug.date_last_updated > current_date_last_updated
  True

Adding an attachment.

  >>> from StringIO import StringIO
  >>> from canonical.librarian.ftests.harness import LibrarianTestSetup
  >>> from canonical.launchpad.interfaces import (
  ...     IBugAttachmentSet, IMessageSet, IBugMessageSet, ILibraryFileAliasSet)

  >>> firefox_bug.attachments.count()
  0

(Upload a file to the Librarian.)

  >>> LibrarianTestSetup().setUp()
  >>> filecontent = 'Some useful information.'
  >>> filealias = getUtility(ILibraryFileAliasSet).create(
  ...     name='foo.txt', size=len(filecontent),
  ...     file=StringIO(filecontent), contentType='text/plain')

(Attach it to the bug.)

  >>> message = getUtility(IMessageSet).fromText(
  ...     subject="title", content="added an attachment.")
  >>> attachmentset = getUtility(IBugAttachmentSet)
  >>> attachment = attachmentset.create(
  ...     bug=firefox_bug, filealias=filealias, title='Some info.',
  ...     message=message)

  >>> current_date_last_updated = firefox_bug.date_last_updated

  >>> notify(SQLObjectCreatedEvent(attachment))

  >>> firefox_bug.attachments.count()
  1

  >>> firefox_bug.date_last_updated > current_date_last_updated
  True

Editing an attachment.

  >>> from canonical.launchpad.interfaces import IBugAttachment

  >>> attachment_before_modification = Snapshot(
  ...     attachment, providing=IBugAttachment)

  >>> attachment.title = "a new title"

  >>> attachment_changed = SQLObjectModifiedEvent(
  ...     attachment, attachment_before_modification,
  ...     ["title"])

  >>> current_date_last_updated = firefox_bug.date_last_updated

  >>> notify(attachment_changed)

  >>> firefox_bug.date_last_updated > current_date_last_updated
  True

Adding a branch.

  >>> from canonical.launchpad.interfaces import IBranchSet

  >>> firefox_bug.bug_branches.count()
  0

  >>> branch_one = getUtility(IBranchSet).get(1)
  >>> bug_branch = firefox_bug.addBranch(branch_one)

  >>> current_date_last_updated = firefox_bug.date_last_updated

  >>> notify(SQLObjectCreatedEvent(bug_branch))

  >>> firefox_bug.bug_branches.count()
  1
  >>> firefox_bug.date_last_updated > current_date_last_updated
  True

Editing a branch.

  >>> from canonical.launchpad.interfaces import IBugBranch
  >>> from canonical.lp.dbschema import BugBranchStatus

  >>> branch_before_modification = Snapshot(
  ...     bug_branch, providing=IBugBranch)

  >>> print bug_branch.status.title
  Fix In Progress

  >>> bug_branch.status = BugBranchStatus.BESTFIX

  >>> bug_branch_changed = SQLObjectModifiedEvent(
  ...     bug_branch, branch_before_modification, ["status"])

  >>> current_date_last_updated = firefox_bug.date_last_updated

  >>> notify(bug_branch_changed)

  >>> firefox_bug.date_last_updated > current_date_last_updated
  True

Linking to a CVE.

  >>> from canonical.launchpad.interfaces import ICveSet

  >>> firefox_bug.cve_links.count()
  0

  >>> cveref = getUtility(ICveSet)["1999-8979"]
  >>> bug_cveref = firefox_bug.linkCVE(cveref)

  >>> current_date_last_updated = firefox_bug.date_last_updated

  >>> notify(SQLObjectCreatedEvent(bug_cveref))

  >>> firefox_bug.cve_links.count()
  1

  >>> firefox_bug.date_last_updated > current_date_last_updated
  True

Linking to an external bug tracker.

  >>> from canonical.launchpad.interfaces import (
  ...     IBugWatchSet, IBugTrackerSet)

  >>> firefox_bug.watches.count()
  0

  >>> mozilla_bugtracker = getUtility(IBugTrackerSet)['mozilla.org']
  >>> bugwatch = getUtility(IBugWatchSet).createBugWatch(
  ...     bug=firefox_bug, owner=current_user(), bugtracker=mozilla_bugtracker,
  ...     remotebug='1234')

  >>> current_date_last_updated = firefox_bug.date_last_updated

  >>> notify(SQLObjectCreatedEvent(bugwatch))

  >>> firefox_bug.watches.count()
  1

  >>> firefox_bug.date_last_updated > current_date_last_updated
  True

Editing the external bug watch.

  >>> from canonical.launchpad.interfaces import IBugWatch

  >>> bugwatch_before_modification = Snapshot(
  ...     bugwatch, providing=IBugWatch)

  >>> print bugwatch.remotebug
  1234

  >>> bugwatch.remotebug = '5678'

  >>> bugwatch_changed = SQLObjectModifiedEvent(
  ...     bugwatch, bugwatch_before_modification, ["remotebug"])

  >>> current_date_last_updated = firefox_bug.date_last_updated

  >>> notify(bugwatch_changed)

  >>> firefox_bug.date_last_updated > current_date_last_updated
  True

Subscribing and unsubscribing does *not* trigger an update of
IBug.date_last_updated.

  >>> firefox_bug.isSubscribed(ubuntu_team)
  False

  >>> subscription = firefox_bug.subscribe(ubuntu_team)

  >>> current_date_last_updated = firefox_bug.date_last_updated

  >>> notify(SQLObjectCreatedEvent(subscription))

  >>> firefox_bug.date_last_updated == current_date_last_updated
  True

  >>> firefox_bug.unsubscribe(ubuntu_team)

  >>> firefox_bug.date_last_updated == current_date_last_updated
  True
