= ArchiveSubscriber =

This content class represents a subscription by a person to an IArchive.
The subscription represents that person's ability to download items from
the archive's repository.  The subscription is granted by a person who
has upload permission to the archive.  Once created the subscription is only
viewable by other uploaders and the person in the subscription.

See also archiveauthtoken.txt.


== Creating new subscriptions ==

New subscriptions are created using IArchive.newSubscription()

Operations with subscriptions are security protected, so to start with we'll
log in as an unprivileged user.

    >>> login("no-priv@canonical.com")

We can create a new subscription for name12 to access cprov's PPA like this:

    >>> from canonical.launchpad.interfaces.person import IPersonSet
    >>> cprov = getUtility(IPersonSet).getByName("cprov")
    >>> name12 = getUtility(IPersonSet).getByName("name12")

    >>> new_sub = cprov.archive.newSubscription(name12, cprov)
    Traceback (most recent call last):
    ...
    Unauthorized:...

That failed because only people who have launchpad.Append (basically, upload
access) on the context archive are allowed to create subscriptions.

Users cannot create their own subscriptions either.  Log in as name12:

    >>> login("test@canonical.com")
    >>> new_token = cprov.archive.newSubscription(name12, cprov)
    Traceback (most recent call last):
    ...
    Unauthorized:...

If we log in as cprov it will work:

    >>> login("celso.providelo@canonical.com")
    >>> new_sub = cprov.archive.newSubscription(
    ...     name12, cprov, description=u"subscription for name12")

The new subscription is returned and reflects the data:

    >>> print new_sub.archive.title
    PPA for Celso Providelo

    >>> print new_sub.subscriber.name
    name12

    >>> print new_sub.registrant.name
    cprov

    >>> print new_sub.description
    subscription for name12

    >>> print new_sub.status.name
    ACTIVE

Add another subscription for the test user, this time to sabdfl's ppa:

    >>> login("mark@hbd.com")
    >>> sabdfl = getUtility(IPersonSet).getByName("sabdfl")
    >>> new_sub_to_sabdfl_ppa = sabdfl.archive.newSubscription(
    ...     name12, sabdfl, description=u"subscription for name12")

Commit the new subscriptions to the database.

    >>> from storm.store import Store
    >>> Store.of(new_sub).commit()

Subscriptions also contain some date information:

    >>> new_sub.date_created is not None
    True

    >>> print new_sub.date_expires
    None


== Retrieving existing subscriptions ==

The ArchiveSubscriberSet utility allows you to retrieve subscriptions by
subscriber and archive.  To access subscriptions you need launchpad.View
privilege which applies to the person in the subscriptions and launchpad
admins.

    >>> from canonical.launchpad.interfaces.archivesubscriber import (
    ...     ArchiveSubscriberStatus, IArchiveSubscriberSet)
    >>> sub_set = getUtility(IArchiveSubscriberSet)

    >>> login("no-priv@canonical.com")

    >>> sub = sub_set.getBySubscriber(new_sub.subscriber)
    Traceback (most recent call last):
    ...
    Unauthorized:...

Log in as name12, who is the person in the subscription.

    >>> login("test@canonical.com")

And retrieve the subscription by subscriber and archive:

    >>> print sub_set.getBySubscriber(new_sub.subscriber)[0].archive.title
    PPA for Celso Providelo

    >>> print sub_set.getByArchive(new_sub.archive)[0].subscriber.name
    name12

The getBySubscriber() method takes an optional archive parameter for
finding a subscription for a particular user in a particular archive:

    >>> print sub_set.getBySubscriber(
    ...     new_sub.subscriber, new_sub.archive)[0].archive.title
    PPA for Celso Providelo

By default the getBySubscriber() and getByArchive() methods return
all active subscriptions:

    >>> sub_set.getBySubscriber(new_sub.subscriber).count()
    2
    >>> sub_set.getByArchive(sabdfl.archive).count()
    1

If we cancel one of the subscriptions:

    >>> login("mark@hbd.com")
    >>> new_sub_to_sabdfl_ppa.status = ArchiveSubscriberStatus.CANCELLED
    >>> login("test@canonical.com")

then the cancelled subscription longer appears in the results
of getBySubscriber() and getByArchive():

    >>> sub_set.getBySubscriber(new_sub.subscriber).count()
    1
    >>> sub_set.getByArchive(sabdfl.archive).count()
    0

Unless we explicitly ask for all subscriptions - not just the active ones:

    >>> sub_set.getBySubscriber(
    ...     new_sub.subscriber, active_only=False).count()
    2
    >>> sub_set.getByArchive(sabdfl.archive, active_only=False).count()
    1

== Amending Subscriptions ==

Some of the properties of subscriptions can change after they are created.
To do this, the changer needs to have launchpad.Edit on the subscription,
or be an admin.

Trying to set the properties as the subscribed person will fail:

    >>> from canonical.database.constants import UTC_NOW
    >>> new_sub.date_expires = UTC_NOW
    Traceback (most recent call last):
    ...
    Unauthorized:...

Log in as someone with launchpad.Edit and it will work:

    >>> login("celso.providelo@canonical.com")
    >>> new_sub.date_expires = UTC_NOW

Other properties that might get modified later are status and description.
We can also do this as an admin.

    >>> login("admin@canonical.com")
    >>> new_sub.description = u"changed by admin"
    >>> from canonical.launchpad.interfaces.archivesubscriber import (
    ...     ArchiveSubscriberStatus)
    >>> new_sub.status = ArchiveSubscriberStatus.EXPIRED


== Cancelling subscriptions ==

Subscriptions can only be cancelled after they are created.  The calling user
also needs launchpad.Edit on the subscription, which means either someone with
IArchive launchpad.Append (as for creating new tokens) or an admin.

    >>> login("no-priv@canonical.com")
    >>> new_sub.cancel()
    Traceback (most recent call last):
    ...
    Unauthorized:...

    >>> login("celso.providelo@canonical.com")
    >>> new_sub.cancel(cprov)

Cancelling sets the date_cancelled value to the current date/time
and cancelled_by to the supplied person.  The status also changes to
CANCELLED.

    >>> new_sub.date_cancelled is not None
    True

    >>> print new_sub.cancelled_by.name
    cprov

    >>> print new_sub.status.name
    CANCELLED

We can do this as an admin too:

    >>> login("admin@canonical.com")
    >>> new_sub.cancel(cprov)
