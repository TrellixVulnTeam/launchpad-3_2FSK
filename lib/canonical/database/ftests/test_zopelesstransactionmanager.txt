Doctests moved from ZopelessTransactionManager.

>>> from canonical.launchpad.ftests.harness import LaunchpadTestSetup
>>> dbname = LaunchpadTestSetup().dbname
>>> dbname
'launchpad_ftest'
>>> from canonical.database.sqlbase import ZopelessTransactionManager
>>> ztm = ZopelessTransactionManager('postgres:///' + dbname)

The _connection attribute of SQLBase should now be a descriptor that returns
sqlobject.dbconnection.Transaction instances.

>>> from sqlobject.dbconnection import Transaction
>>> from canonical.database.sqlbase import SQLBase
>>> t1 = SQLBase._connection
>>> isinstance(t1, Transaction)
True

And it should give the same connection to the same thread over multiple
accesses.

>>> t2 = SQLBase._connection
>>> t1 is t2
True

And different in different threads:

>>> from threading import Thread, Lock, Event
>>> l = []
>>> e = Event()
>>> def target():
...     l.append(SQLBase._connection)
>>> t = Thread(target=target)
>>> t.start()
>>> t.join(20)

>>> l[0] is not t1
True

 
XXX: ddaa 2005-05-10: This bit is overly dependent on the db...
Show that concurrent transactions in different threads work correctly

>>> from sqlobject import StringCol
>>> from canonical.launchpad.database import Person
>>> mark = Person.selectOneBy(displayname='Mark Shuttleworth')
>>> mark.id == 1
True
>>> mark.givenname = 'Markk'
>>> mark.givenname = 'Mark'
>>> ztm.commit()
>>> ztm.commit()
 
>>> event = Event()
>>> event2 = Event()
>>> def foo(Person=Person, ztm=ztm, event=event, event2=event2):
...     andrew = Person.selectOneBy(displayname='Andrew Bennetts')
...     
...     andrew.givenname = 'Andreww'
...     andrew.givenname = 'Andrew'
...     event.set()
...     event2.wait()
...     ztm.commit()
...
>>> t = Thread(target=foo)
>>> t.start()
>>> event.wait()
>>> mark = Person.selectOneBy(displayname='Mark Shuttleworth')
>>> mark.id == 1
True
>>> mark.givenname = 'Markk'
>>> mark.givenname = 'Mark'
>>> ztm.commit()
>>> event2.set()
>>> t.join(20)

A failed commit, e.g. due to a transaction conflict or integrity error, will
raise an exception, but still make it possible to begin a new transaction.

>>> from psycopg import DatabaseError
>>> import sys
>>> ztm.begin()
>>> andrew = Person.byName('spiv')
>>> andrew.name = 'sabdfl'
>>> try: ztm.commit()
... except DatabaseError: print sys.exc_value
ERROR:  duplicate key violates unique constraint "person_name_key"
<BLANKLINE>
UPDATE Person SET name = 'sabdfl' WHERE id = 7
>>> ztm.begin()
>>> ztm.abort()

Cleanup -- make sure this doctest leaves things in the same state it found
them.

>>> ztm.uninstall()
>>> from canonical.testing import DatabaseLayer
>>> DatabaseLayer.force_dirty_database()

