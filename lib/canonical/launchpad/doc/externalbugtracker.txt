= Generic ExternalBugTracker Tests =

ExternalBugTracker instances are used to communicate with remote bug
trackers. This document tests those features that are common to all
ExternalBugTracker instances.

== Updating bug watches ==

All the ExternalBugTrackers know how to update the status of a bug
watch. The method that updates the bug watches is
BugWatchUpdater.updateBugWatches(), which expects an IExternalBugTracker
and the bug watches to update. Before updating the bug watches, the
initializeRemoteBugDB() method on the ExternalBugTracker is called. It
gets the information for the bug watches from the external bug tracker,
and it's called outside a DB transaction, since it doesn't need DB
access.

    >>> class FakeExternalBugTracker:
    ...     baseurl = 'http://example.com/'
    ...     batch_size = None
    ...     def info(self, msg):
    ...         pass
    ...     def initializeRemoteBugDB(self, remote_bug_ids):
    ...         print "initializeRemoteBugDB() called"

    >>> class FakeTransaction:
    ...     """Transaction class to track transaction boundaries."""
    ...     def commit(self):
    ...         print "COMMIT"
    ...     def abort(self):
    ...         print "ABORT"
    ...     def begin(self):
    ...         print "BEGIN"

    >>> from canonical.launchpad.scripts.checkwatches import BugWatchUpdater
    >>> bug_watch_updater = BugWatchUpdater(FakeTransaction())
    >>> bug_watch_updater.updateBugWatches(FakeExternalBugTracker(), [])
    COMMIT
    initializeRemoteBugDB() called
    BEGIN


== Configuration Options ==

All ExternalBugTrackers have a batch_query_threshold attribute which is
set by configuration options in launchpad.conf. This attribute is used
to decide whether or not bugs are exported from the remote server as a
batch (where possible) or individually.

The batch_query_threshold for a vanilla ExternalBugTracker should be the
same as that specified in launchpad.conf. We use a test version of
ExternalBugTracker here that doesn't actually do anything besides
fulfill the implementation requirements of IExternalBugTracker.

    >>> from canonical.config import config
    >>> from canonical.launchpad.ftests.externalbugtracker import (
    ...     TestExternalBugTracker)
    >>> tracker = TestExternalBugTracker('http://example.com/')
    >>> (tracker.batch_query_threshold ==
    ...     config.checkwatches.batch_query_threshold)
    True


== Error Handling ==

When an error occurs during the updating of bug watches it will be
recorded against the bug watches themselves so that it can be displayed
to users. We can test this by using a test version of
ExternalBugTracker.

    >>> import transaction
    >>> from canonical.launchpad.ftests.externalbugtracker import (
    ...     TestBrokenExternalBugTracker)
    >>> external_bugtracker = TestBrokenExternalBugTracker(
    ...     'http://example.com')
    >>> bug_watch_updater = BugWatchUpdater(transaction)

We'll create an example bug watch with which to test this. This will
be passed to external_bugtracker's updateBugWatches() method and should
have errors recorded against it. We log in as Sample Person to make
these changes since there's no particular need to use one Person over
another.

    >>> from canonical.launchpad.database import BugTracker
    >>> from canonical.launchpad.interfaces import (
    ...     BugTrackerType, IBugSet, IPersonSet)

    >>> sample_person = getUtility(IPersonSet).getByEmail(
    ...     'test@canonical.com')

    >>> example_bug_tracker = BugTracker(
    ...     name="example-bugs",
    ...     title="Example.com Bug Tracker",
    ...     bugtrackertype=BugTrackerType.BUGZILLA,
    ...     baseurl="http://bugs.example.com",
    ...     summary="Contains bugs for Example.com",
    ...     contactdetails="foo.bar@example.com",
    ...     owner=sample_person)

    >>> login('test@canonical.com')

    >>> example_bug = getUtility(IBugSet).get(10)
    >>> example_bugwatch = example_bug.addWatch(
    ...     example_bug_tracker, 1, sample_person)

    >>> from canonical.launchpad.components.externalbugtracker import (
    ...     BugNotFound, BugTrackerConnectError, InvalidBugId,
    ...     UnparseableBugData, UnparseableBugTrackerVersion)

TestBrokenExternalBugTracker allows us to force errors to occur, so we
can use it to check that bug watches' last_error_types are being set
correctly.

We start with those errors that may be raised by
ExternalBugTracker.initializeRemoteBugDB(). We supress exceptions
because the bug watch's last error field will contain the data we need
for this test.

The bug watch's lastchecked field will also be updated, since not doing
so would mean that error-prone bug watches would be checked every time
checkwatches ran instead of just once every 24 hours like any other bug
watch.

    >>> for error in [BugTrackerConnectError, UnparseableBugData,
    ...               UnparseableBugTrackerVersion, Exception]:
    ...     example_bugwatch.lastchecked = None
    ...     external_bugtracker.initialize_remote_bugdb_error = error
    ...     try:
    ...         bug_watch_updater.updateBugWatches(
    ...             external_bugtracker, [example_bugwatch])
    ...     except error:
    ...         pass
    ...     print "%s: %s" % (example_bugwatch.last_error_type.title,
    ...         example_bugwatch.lastchecked is not None)
    Connection Error: True
    Unparsable Bug: True
    Unparsable Bug Tracker Version: True
    Unknown: True

We can run the same test on getRemoteStatus(), which can raise different
errors. We temporarily silence the logging from this function because
we're not interested in it. Again, the watch's lastchecked field also be
updated. Errors in getRemoteStatus() will produce OOPS reports.

    >>> from canonical.launchpad.ftests.externalbugtracker import oops_hook
    >>> oops_hook.install()

    >>> from canonical.launchpad.scripts import log
    >>> loglevel = log._log.level
    >>> external_bugtracker.initialize_remote_bugdb_error = None
    >>> try:
    ...     log._log.setLevel(100)
    ...     for error in [BugNotFound, InvalidBugId, UnparseableBugData,
    ...                   Exception]:
    ...         example_bugwatch.lastchecked = None
    ...         external_bugtracker.get_remote_status_error = error
    ...         bug_watch_updater.updateBugWatches(
    ...             external_bugtracker, [example_bugwatch])
    ...         print "%s: %s (%s)" % (
    ...             example_bugwatch.last_error_type.title,
    ...             example_bugwatch.lastchecked is not None,
    ...             oops_hook.oops_info.oopsid)
    ... finally:
    ...     log._log.setLevel(loglevel)
    Bug Not Found: True (OOPS-...)
    Invalid Bug ID: True (OOPS-...)
    Unparsable Bug: True (OOPS-...)
    Unknown: True (OOPS-...)

    >>> oops_hook.uninstall()
