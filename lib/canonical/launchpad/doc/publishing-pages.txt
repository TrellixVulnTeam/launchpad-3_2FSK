= Source Package Publishing Views =

The default view for SourcePackagePublishingHistory offers a
convenience property that can be used to display files that are
related to that publication; this includes binary and source
files. The property returns a sorted list of dictionaries with URLs,
filenames and filesizes.

    >>> from zope.component import getMultiAdapter
    >>> from canonical.launchpad.webapp.servers import LaunchpadTestRequest

We'll retrieve the last SourcePackagePublishingHistory entry for
alsa-utils and foobar in ubuntu as sample data:

    >>> from zope.component import getUtility
    >>> from canonical.launchpad.interfaces import IDistributionSet

    >>> ubuntu = getUtility(IDistributionSet).getByName("ubuntu")
    >>> alsa_utils = ubuntu.getSourcePackage('alsa-utils')
    >>> alsa_pub = alsa_utils.publishing_history[0]
    >>> foobar = ubuntu.getSourcePackage('foobar')
    >>> foo_pub = foobar.publishing_history[0]

The base class BasePublishingRecordView provides a few helper methods
and properties for querying the publishing history record:

    >>> view = getMultiAdapter(
    ...    (foo_pub, LaunchpadTestRequest()), name="+listing-compact")
    >>> view.wasDeleted()
    True
    >>> view.context.removal_comment
    u'I do not like it.'
    >>> view.removal_comment
    u'I do not like it.'

If the publishing record does not include a removal comment, then
the view property returns 'None provided.' (Note, setting the removal
comment requires going through the secure record and flushing before
it will be reflected in the normal record)

    >>> login('foo.bar@canonical.com')
    >>> foo_pub.secure_record.removal_comment = None
    >>> from canonical.database.sqlbase import flush_database_caches
    >>> flush_database_caches()

    >>> print view.context.removal_comment
    None
    >>> view.removal_comment
    u'None provided.'


The SourcePackagePublishingView implements the
'published_source_and_binary_files' property which returns a list of
dictionaries containing:

 * url: the librarian file url;
 * filesize: the filesize stored in librarian;
 * filename: the filename to be presented to user;

for each file related with the alsa-utils source publication in ubuntu.

    >>> view = getMultiAdapter(
    ...    (alsa_pub, LaunchpadTestRequest()), name="+listing-ppa-detailed")

    >>> view.published_source_and_binary_files
    [{'url': 'http://.../alsa-utils_1.0.9a-4ubuntu1.dsc',
     'filesize': 3,
     'filename': u'alsa-utils_1.0.9a-4ubuntu1.dsc'}]

'iceweasel' source in Celso's PPA contains binary files that can be
inspected.

    >>> from canonical.launchpad.interfaces import IPersonSet
    >>> cprov = getUtility(IPersonSet).getByName("cprov")

    >>> iceweasel_source_pub = cprov.archive.getPublishedSources(
    ...     'iceweasel')[0]

    >>> ppa_source_view = getMultiAdapter(
    ...     (iceweasel_source_pub, LaunchpadTestRequest()),
    ...     name="+listing-ppa-detailed")

    >>> ppa_source_view.published_source_and_binary_files
    [{'url': 'http://localhost:58000/3/firefox-0.9.2.orig.tar.gz',
      'filesize': 9922560,
      'filename': u'firefox-0.9.2.orig.tar.gz'},
     {'url': 'http://localhost:58000/62/iceweasel-1.0.dsc',
      'filesize': 123,
      'filename': u'iceweasel-1.0.dsc'},
     {'url': 'http://localhost:58000/40/mozilla-firefox_0.9_i386.deb',
      'filesize': 3,
      'filename': u'mozilla-firefox_0.9_i386.deb'}]

Yet using SourcePackagePublishingView classes we can verify how it
allows the template to find out if it is a source or a binary
publication.

Continuing to use the 'iceweasel' source publication in Celso's PPA.

    >>> source_details_view = getMultiAdapter(
    ...     (iceweasel_source_pub, LaunchpadTestRequest()),
    ...     name="+record-details")

We probe the 'is_source' and 'is_binary' properties.

    >>> print source_details_view.is_source
    True

    >>> print source_details_view.is_binary
    False

Similarly, we use one of the 'iceweasel' binaries published in Celso's
PPA to see how the same mechanism works for
BinaryPackagePublishingHistoryView.

    >>> iceweasel_binary_pub = iceweasel_source_pub.getPublishedBinaries()[0]

    >>> binary_details_view = getMultiAdapter(
    ...     (iceweasel_binary_pub, LaunchpadTestRequest()),
    ...     name="+record-details")

    >>> print binary_details_view.is_source
    False

    >>> print binary_details_view.is_binary
    True

Make sure the 'timestamp_map' class attribute in BasePublishingRecordView
covers all PackagePublishingStatus values.
This test will fail if we add a new value to the PackagePublishingStatus
enumeration but neglect to update BasePublishingRecordView.timestamp_map
accordingly.

    >>> from canonical.launchpad.interfaces import PackagePublishingStatus
    >>> from canonical.launchpad.browser.publishing import (
    ...     BasePublishingRecordView)
    >>> for pps in PackagePublishingStatus.items:
    ...     print '%s -> %s' % (
    ...         pps, BasePublishingRecordView.timestamp_map[pps])
    Pending -> datecreated
    Published -> datepublished
    Superseded -> datesuperseded
    Deleted -> dateremoved
    Obsolete -> scheduleddeletiondate

Any key that's not in the PackagePublishingStatus enumeration will cause an
exception to be thrown.

    >>> print BasePublishingRecordView.timestamp_map['key_not_there']
    Traceback (most recent call last):
    ...
    KeyError: 'key_not_there'
