The Build table
^^^^^^^^^^^^^^^

The build table contains the information pertaining to a given build
of a sourcepackagerelease on a distroarchrelease.

The build record may have many BinaryPackageRelease records pointing
at it and it may reference a build log if the build was done on a
launchpad build daemon.

  >>> from zope.interface.verify import verifyObject
  >>> from canonical.launchpad.database import Build, BuildSet, DistributionSet
  >>> from canonical.launchpad.database import DistroRelease
  >>> from canonical.lp.dbschema import BuildStatus

  >>> ubuntu = DistributionSet()['ubuntu']
  >>> warty = DistroRelease.get(6)
  >>> hoary = DistroRelease.get(3)


First up, can we get the builds out of the sample data?

  >>> firefox_build = Build.get(2)
  >>> pmount_build = Build.get(7)

Let's check the complex properties of a build object.

  >>> firefox_build.distrorelease.name
  u'warty'

  >>> firefox_build.title
  u'i386 build of mozilla-firefox 0.9 in ubuntu warty'

  >>> firefox_build.was_built
  True

  >>> firefox_build.build_icon
  '/++resource++build-success'

  >>> firefox_build.buildlog = 34
  >>> firefox_build.buildlog.url
  'http://localhost:58000/34/evolution-2.2-test.pot'

Test "reset" functionality:

  >>> firefox_build.can_be_reset
  False

  >>> resetable_build = Build.get(9)

  >>> resetable_build.title
  u'i386 build of pmount 0.1-1 in ubuntu warty'

  >>> resetable_build.buildstate.title
  'Failed to build'

  >>> resetable_build.can_be_reset
  True

  >>> resetable_build.builder.name
  u'bob'

Save previous state:

  >>> changes = resetable_build.changes
  >>> datebuilt = resetable_build.datebuilt
  >>> builder = resetable_build.builder
  >>> buildduration = resetable_build.buildduration

Reset Build record in question:

  >>> resetable_build.reset()

Build record has no history and is NEEDSBUILD:

  >>> resetable_build.builder is None
  True

  >>> resetable_build.changes is None
  True

  >>> resetable_build.buildstate.value is 0
  True

Restore Build(9) to previous state to avoid mess with other tests.

  >>> resetable_build.buildstate = BuildStatus.FAILEDTOBUILD
  >>> resetable_build.changes = changes
  >>> resetable_build.datebuilt = datebuilt
  >>> resetable_build.builder = builder
  >>> resetable_build.buildduration = buildduration


Initialize all the required arguments to create a binary package for a
given build record entry.

  >>> from canonical.launchpad.interfaces import IBinaryPackageNameSet
  >>> binarypackagename = getUtility(IBinaryPackageNameSet).ensure('demo').id
  >>> version = '0.0.1-demo'
  >>> summary = 'Summmmmmmmary'
  >>> description = 'Descripppppppption'
  >>> from canonical.lp import dbschema
  >>> binpackageformat = dbschema.BinaryPackageFormat.DEB
  >>> component = firefox_build.sourcepackagerelease.component.id
  >>> section = firefox_build.sourcepackagerelease.section.id
  >>> priority = dbschema.PackagePublishingPriority.STANDARD
  >>> shlibdeps = None
  >>> depends = None
  >>> recommends = None
  >>> suggests = None
  >>> conflicts = None
  >>> replaces = None
  >>> provides = None
  >>> essential = False
  >>> installedsize = 0
  >>> copyright = None
  >>> licence = None
  >>> architecturespecific = False

Invoke createBinaryPackageRelease with all required arguments.

  >>> bin = pmount_build.createBinaryPackageRelease(
  ...                                 binarypackagename, version,
  ...                                 summary, description,
  ...                                 binpackageformat, component,
  ...                                 section, priority, shlibdeps,
  ...                                 depends, recommends, suggests,
  ...                                 conflicts, replaces, provides,
  ...                                 essential, installedsize,
  ...                                 copyright, licence,
  ...                                 architecturespecific)

  >>> from canonical.launchpad.interfaces import IBinaryPackageRelease
  >>> assert verifyObject(IBinaryPackageRelease, bin) is True


Commit previous transaction, data we want to preserv:

  >>> import transaction
  >>> transaction.commit()

Check binarypackages property:

  >>> for b in pmount_build.binarypackages:
  ...     b.version
  u'0.0.1-demo'
  u'0.1-1'

Emulate a huge list of binaries for 'pmount':

  >>> bpnameset = getUtility(IBinaryPackageNameSet)
  >>> for i in range(15):
  ...     version = "%d" % i
  ...     bpname = bpnameset.ensure("test-%d" % i).id
  ...     b = pmount_build.createBinaryPackageRelease(
  ...                                 bpname, version,
  ...                                 summary, description,
  ...                                 binpackageformat, component,
  ...                                 section, priority, shlibdeps,
  ...                                 depends, recommends, suggests,
  ...                                 conflicts, replaces, provides,
  ...                                 essential, installedsize,
  ...                                 copyright, licence,
  ...                                 architecturespecific)


Check if the property still working:

  >>> len(pmount_build.binarypackages)
  17

Ensure the list is ordered by 'name'

  >>> for b in pmount_build.binarypackages:
  ...     b.name, b.version
  (u'demo', u'0.0.1-demo')
  (u'pmount', u'0.1-1')
  (u'test-0', u'0')
  (u'test-1', u'1')
  (u'test-10', u'10')
  (u'test-11', u'11')
  (u'test-12', u'12')
  (u'test-13', u'13')
  (u'test-14', u'14')
  (u'test-2', u'2')
  (u'test-3', u'3')
  (u'test-4', u'4')
  (u'test-5', u'5')
  (u'test-6', u'6')
  (u'test-7', u'7')
  (u'test-8', u'8')
  (u'test-9', u'9')

Rollback transaction to no disturb the other tests:

  >>> transaction.abort()



The BuildSet class gives us some useful ways to consider the
collection of builds.

  >>> bs = BuildSet()

We can find builds given a source package release and architecture tag.

  >>> bs.getBuildBySRAndArchtag(20,'i386').count()
  2

We can find recent and pending builds for a given distrorelease.

  >>> hoary.getBuildRecords().count()
  2

Or for a given distroarchrelease.

  >>> hoaryi386 = hoary.architectures[0]
  >>> hoaryi386.title
  u'The Hoary Hedgehog Release for i386 (x86)'

  >>> hoaryi386.getBuildRecords().count()
  2

And we can find builds for a given distribution by type.

  >>> ubuntu.getBuildRecords().count()
  4

  >>> L = list(ubuntu.getBuildRecords(status=BuildStatus.FULLYBUILT))
  >>> len(L)
  2
  >>> L[0].buildstate
  <Item FULLYBUILT (1) from <class 'canonical.lp.dbschema.BuildStatus'>>
  >>> L[1].buildstate
  <Item FULLYBUILT (1) from <class 'canonical.lp.dbschema.BuildStatus'>>


  >>> ubuntu.getBuildRecords(status=BuildStatus.NEEDSBUILD).count()
  1

  >>> firefox_build.buildstate = BuildStatus.NEEDSBUILD
  >>> firefox_build.syncUpdate()
  >>> L = list(ubuntu.getBuildRecords(status=BuildStatus.NEEDSBUILD))
  >>> len(L)
  2
  >>> L[0].buildstate
  <Item NEEDSBUILD (0) from <class 'canonical.lp.dbschema.BuildStatus'>>
