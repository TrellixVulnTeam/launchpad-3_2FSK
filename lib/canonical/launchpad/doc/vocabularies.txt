Introduction
============

Vocabularies are lists of terms. In Launchpad's Component Architecture
(CA), a vocabulary is a list of terms that a widget (normally a selection
style widget) "speaks", i.e., its allowed values.

    >>> from canonical.launchpad.ftests import login
    >>> from canonical.launchpad.interfaces import IPersonSet, IEmailAddressSet
    >>> from canonical.lp.dbschema import EmailAddressStatus
    >>> from canonical.database.sqlbase import flush_database_updates
    >>> login('foo.bar@canonical.com')


Values, Tokens, and Titles
==========================

In Launchpad, we generally use "tokenized vocabularies." Each term in
a vocabulary has a value, token and title. A term is rendered in a
select widget like this:

<option value="$token">$title</option>

The $token is probably the data you would store in your DB. The Token is
used to uniquely identify a Term, and the Title is the thing you display
to the user.


Launchpad Vocabularies
======================

There are two kinds of vocabularies in Launchpad: enumerable and
non-enumerable. Enumerable vocabularies are short enough to render in a
select widget. Non-enumerable vocabularies require a query interface to make
it easy to choose just one or a couple of options from several hundred,
several thousand, or more.

Vocabularies should not be imported - they can be retrieved from the
vocabulary registry.

    >>> from zope.component import getUtility
    >>> from zope.schema.vocabulary import getVocabularyRegistry
    >>> vocabulary_registry = getVocabularyRegistry()
    >>> product_vocabulary = vocabulary_registry.get(None, "Product")
    >>> product_vocabulary.displayname
    'Select a Product'


Enumerable Vocabularies
=======================

Creating a new Enumeratable Vocabulary based on an existent dbschema
constant:

    >>> from canonical.lp import dbschema
    >>> from canonical.launchpad.vocabularies import vocab_factory
    >>> PackagingVocabulary = vocab_factory(dbschema.PackagingType)

The right place to do it is in the file vocabularies/dbschema.py.
Note: don't forget to registry your brand new instance for zope lookup
in configure.zcml.

o PackagingVocabulary - reflects the available constants for
  Packaging.packaging field.

In cases where we won't have many rows, some of the database
vocabularies can be enumerated over.

o DistroReleaseVocabulary - reflects the available distribution releases.
  Results are ordered by `name`

    >>> distrorelease_vocabulary = vocabulary_registry.get(
    ...     None,"DistroRelease")
    >>> for term in distrorelease_vocabulary:
    ...     print "%30s %s" % (term.token, term.title)
            ubuntu/breezy-autotest Breezy Badger Autotest
                     ubuntu/grumpy The Grumpy Groundhog Release
                      ubuntu/hoary The Hoary Hedgehog Release
                      ubuntu/warty The Warty Warthog Release
                      debian/sarge Sarge
                        debian/sid Sid
                      debian/woody WOODY
                    guadalinex/2k5 Guada 2005
                    kubuntu/krunch The Krunchy Kangaroo
                        redhat/7.0 Seven
                        redhat/six Six Six Six
        ubuntutest/breezy-autotest Breezy Badger Autotest
             ubuntutest/hoary-test Mock Hoary

    >>> distrorelease_vocabulary.getTermByToken('ubuntu/hoary').value.title
    u'The Hoary Hedgehog Release'

    >>> def getTerms(vocab, search_text):
    ...     [vocab.toTerm(item) for item in vocab.search(search_text)]

    >>> getTerms(distrorelease_vocabulary, 'woody')
    >>> getTerms(distrorelease_vocabulary, 'debian')
    >>> getTerms(distrorelease_vocabulary, 'invalid')
    >>> getTerms(distrorelease_vocabulary, '')

    >> [term.token for term in distrorelease_vocabulary.search('woody')]
    ['debian/woody']
    >> [term.token for term in distrorelease_vocabulary.search('debian')]
    ['debian/sarge', 'debian/sid', 'debian/woody']
    >> [term.token for term in distrorelease_vocabulary.search('invalid')]
    []
    >> [term.token for term in distrorelease_vocabulary.search('')]
    []

o DistributionUsingMaloneVocabulary - all the distributions that use
  Malone as their main bug tracker.

    >>> using_malone_vocabulary = vocabulary_registry.get(
    ...     None, 'DistributionUsingMalone')
    >>> len(using_malone_vocabulary)
    2
    >>> for term in using_malone_vocabulary:
    ...     print term.token, term.value.displayname, term.title
    gentoo Gentoo Gentoo
    ubuntu Ubuntu Ubuntu

    >>> from canonical.launchpad.interfaces import ILaunchpadCelebrities
    >>> ubuntu = getUtility(ILaunchpadCelebrities).ubuntu
    >>> ubuntu in using_malone_vocabulary
    True
    >>> debian = getUtility(ILaunchpadCelebrities).debian
    >>> debian in using_malone_vocabulary
    False

    >>> using_malone_vocabulary.getQuery() is None
    True

    >>> term = using_malone_vocabulary.getTerm(ubuntu)
    >>> print term.token, term.value.displayname, term.title
    ubuntu Ubuntu Ubuntu

    >>> term = using_malone_vocabulary.getTerm(debian)
    Traceback (most recent call last):
    ...
    LookupError:...

    >>> term = using_malone_vocabulary.getTermByToken('ubuntu')
    >>> print term.token, term.value.displayname, term.title
    ubuntu Ubuntu Ubuntu

    >>> term = using_malone_vocabulary.getTermByToken('debian')
    Traceback (most recent call last):
    ...
    LookupError:...

o PersonActiveMembership - all the teams the person is an active member of.

    >>> foo_bar = getUtility(IPersonSet).getByEmail('foo.bar@canonical.com')
    >>> person_active_membership = vocabulary_registry.get(
    ...     foo_bar, 'PersonActiveMembership')
    >>> len(person_active_membership)
    7
    >>> for term in person_active_membership:
    ...     print term.token, term.value.displayname, term.title
    admins Launchpad Administrators Launchpad Administrators
    launchpad-buildd-admins Launchpad Buildd Admins Launchpad Buildd Admins
    launchpad Launchpad Developers Launchpad Developers
    name18 Ubuntu Gnome Team Ubuntu Gnome Team
    ubuntu-team Ubuntu Team Ubuntu Team
    vcs-imports VCS imports VCS imports
    testing-spanish-team testing Spanish team testing Spanish team

    >>> launchpad_team = getUtility(IPersonSet).getByName('launchpad')
    >>> launchpad_team in person_active_membership
    True
    >>> mirrors_admins = getUtility(IPersonSet).getByName('mirrors-admins')
    >>> mirrors_admins in person_active_membership
    False

    >>> person_active_membership.getQuery() is None
    True

    >>> term = person_active_membership.getTerm(launchpad_team)
    >>> print term.token, term.value.displayname, term.title
    launchpad Launchpad Developers Launchpad Developers

    >>> term = person_active_membership.getTerm(mirrors_admins)
    Traceback (most recent call last):
    ...
    LookupError:...

    >>> term = person_active_membership.getTermByToken('launchpad')
    >>> print term.token, term.value.displayname, term.title
    launchpad Launchpad Developers Launchpad Developers

    >>> term = person_active_membership.getTermByToken('mirrors-admins')
    Traceback (most recent call last):
    ...
    LookupError:...



Non-Enumerable Vocabularies
===========================

Iterating over non-enumerable vocabularies, while possible, will
probably kill the database. Instead, these vocabularies are
search-driven.

o BinaryAndSourcePackageNameVocabulary - the list of binary and source
  package names, ordered by name.

    >>> package_name_vocabulary = vocabulary_registry.get(
    ...     None, "BinaryAndSourcePackageName")
    >>> package_name_vocabulary.displayname
    'Select a Package'

When a package name matches both a binary package name and a source
package of the exact same name, the binary package name is
returned. This allows us, in bug reporting for example, to collect the
most specific information possible.

Let's demonstrate by searching for "mozilla-firefox", for which there is
both a source and binary package of that name.

    >>> from canonical.launchpad.interfaces import (
    ...     ISourcePackageName, IBinaryPackageName)

    >>> package_name_terms = package_name_vocabulary.search("mozilla-firefox")
    >>> package_name_terms.count()
    1
    >>> package_name_terms[0].name
    u'mozilla-firefox'

Searching for "mozilla" should return the binary package name above, and
the source package named "mozilla".

    >>> package_name_terms = package_name_vocabulary.search("mozilla")
    >>> package_name_terms.count()
    2
    >>> [package_name_term.name for package_name_term in package_name_terms]
    [u'mozilla', u'mozilla-firefox']

The search does a case-insensitive, substring match.

    >>> package_name_terms = package_name_vocabulary.search("mOzIl")
    >>> package_name_terms.count()
    2
    >>> [package_name_term.name for package_name_term in package_name_terms]
    [u'mozilla', u'mozilla-firefox']

o LanguageVocabulary - all the languages know by Launchpad

    >>> from canonical.launchpad.interfaces import ILanguageSet
    >>> language_set = getUtility(ILanguageSet)

    >>> language_vocabulary = vocabulary_registry.get(
    ...     None, 'Language')
    >>> len(language_vocabulary)
    559

    >>> es = language_set['es']
    >>> term = language_vocabulary.getTerm(es)
    >>> print term.token, term.value.displayname, term.title
    es Spanish (es) Spanish (es)

    >>> pt_BR = language_set['pt_BR']
    >>> term = language_vocabulary.getTerm(pt_BR)
    >>> print term.token, term.value.displayname, term.title
    pt_BR Portuguese (Brazil) (pt_BR) Portuguese (Brazil) (pt_BR)

    >>> term = language_vocabulary.getTermByToken('es')
    >>> print term.token, term.value.displayname, term.title
    es Spanish (es) Spanish (es)

    >>> term = language_vocabulary.getTermByToken('pt_BR')
    >>> print term.token, term.value.displayname, term.title
    pt_BR Portuguese (Brazil) (pt_BR) Portuguese (Brazil) (pt_BR)

    >>> language_vocabulary.getTermByToken('foo')
    Traceback (most recent call last):
    ...
    LookupError:...

o ProductBranchVocabulary - the list of bzr branches registered in
  Launchpad. Searchable by branch name or URL, and searched within the
  context of a product.

    >>> from canonical.launchpad.interfaces import IProductSet

    >>> firefox = getUtility(IProductSet)["firefox"]
    >>> gnome_terminal = getUtility(IProductSet)["gnome-terminal"]

    >>> branch_vocabulary = vocabulary_registry.get(firefox, "ProductBranch")

    >>> branches = branch_vocabulary.search(
    ...     "http://bazaar.example.com/mozilla@arch.ubuntu.com/"
    ...     "mozilla--release--0.9.2")

    >>> [branch.unique_name for branch in branches]
    [u'~sabdfl/firefox/release-0.9.2']

    >>> branches = branch_vocabulary.search(
    ...     "release-0.9.2")

    >>> [branch.unique_name for branch in branches]
    [u'~sabdfl/firefox/release-0.9.2']

The search will not match branches in another product:

    >>> branches = branch_vocabulary.search("slowness")
    >>> [branch for branch in branches]
    []

Now, when we search in gnome-terminal, we'll find the "slowness"
branch:

    >>> branch_vocabulary = vocabulary_registry.get(
    ...     gnome_terminal, "ProductBranch")
    >>> branches = branch_vocabulary.search("slowness")
    >>> [branch.name for branch in branches]
    [u'slowness']

We can also specify a context of None, meaning "search all product
branches".

    >>> branch_vocabulary = vocabulary_registry.get(None, "ProductBranch")
    >>> branches = branch_vocabulary.search("slowness")
    >>> [branch.name for branch in branches]
    [u'slowness']

When the context is anything other than an IProduct, the search behaves
as though no product were passed. This happens, for example, when adding
a branch off the bugtask page; in this case, the context is an IBugTask:

    >>> from canonical.launchpad.interfaces import IBugTaskSet
    >>> bugtask = getUtility(IBugTaskSet).get(2)
    >>> branch_vocabulary = vocabulary_registry.get(bugtask, "ProductBranch")
    >>> branches = branch_vocabulary.search("slowness")
    >>> [branch.name for branch in branches]
    [u'slowness']

o ProjectVocabulary - the list of selectable projects. The results are
  ordered by displayname.

    >>> project_vocabulary = vocabulary_registry.get(None, "Project")
    >>> project_vocabulary.displayname
    'Select a Project'

    >>> [p.title for p in project_vocabulary.search('mozilla')]
    [u'The Mozilla Project']
    >>> mozilla = project_vocabulary.getTermByToken('mozilla')
    >>> mozilla.title
    u'The Mozilla Project'

  The ProjectVocabulary does not list inactive projects.

    >>> from canonical.launchpad.interfaces import IProjectSet
    >>> moz_project = getUtility(IProjectSet)['mozilla']
    >>> moz_project in project_vocabulary
    True

    >>> [p.title for p in project_vocabulary.search('mozilla')]
    [u'The Mozilla Project']
    >>> moz_project.active = False
    >>> flush_database_updates()
    >>> moz_project in project_vocabulary
    False

    >>> [p.title for p in project_vocabulary.search('mozilla')]
    []
    >>> moz_project.active = True
    >>> flush_database_updates()

o ProductVocabulary - the list of selectable products. Results are
  ordered by displayname.

    >>> product_vocabulary = vocabulary_registry.get(None, "Product")
    >>> product_vocabulary.displayname
    'Select a Product'

    >>> list(product_vocabulary.search(None))
    []
    >>> gnome_products = product_vocabulary.search("gnome")
    >>> l = [product_term.title for product_term in gnome_products]
    >>> l[:2]
    [u'The Evolution Groupware Application', u'The GNOME Terminal Emulator']
    >>> l[2:]
    [u'The Gnome Panel Applets', u'Ubuntu', u'Gnome Baker']
    >>> arch = product_vocabulary.getTermByToken("arch-mirrors")
    >>> arch.title 
    u'Arch archive mirrors'

  The ProductVocabulary does not list inactive products.

    >>> arch.value in product_vocabulary
    True

    >>> arch_product = getUtility(IProductSet)['arch-mirrors']
    >>> arch_product in product_vocabulary
    True

    >>> [t.title for t in product_vocabulary.search('arch and archive')]
    [u'Arch archive mirrors']
    >>> arch_product.active = False
    >>> flush_database_updates()
    >>> arch_product in product_vocabulary
    False
    >>> [t.title for t in product_vocabulary.search('arch and archive')]
    []
    >>> arch_product.active = True
    >>> flush_database_updates()

o ProductReleaseVocabulary - the list of selectable products releases.

    >>> productrelease_vocabulary = vocabulary_registry.get(None,
    ...                                                     "ProductRelease")
    >>> productrelease_vocabulary.displayname
    'Select a Product Release'

    >>> list(productrelease_vocabulary.search(None))
    []
    >>> evolution_releases = productrelease_vocabulary.search("evolution")
    >>> l = [release_term.title for release_term in evolution_releases]
    >>> release = productrelease_vocabulary.getTermByToken(
    ...     "evolution/trunk/2.1.6")
    >>> release.title
    u'evolution trunk 2.1.6'

o PersonAccountToMergeVocabulary - all non-merged people. This vocabulary
  is meant to be used only in the people merge form.

    >>> vocab = vocabulary_registry.get(None, "PersonAccountToMerge")
    >>> vocab.displayname
    'Select a Person to Merge'

    Searching for None returns an empty list.
    >>> list(vocab.search(None))
    []

    Searching for 'team' will return an empty list, because teams are not part
    of this vocabulary.
    >>> list(vocab.search('team'))
    []

    A search using part of the email address of a team will also return an 
    empty list.
    >>> list(vocab.search('support'))
    []

    Searching for a person without a preferred email will return that person's
    name.
    >>> [person.name for person in vocab.search('salgado')]
    [u'salgado']

    A search using the beginning of a person's preferred email will return 
    that person that owns that email.
    >>> [(person.name, person.preferredemail.email) 
    ...  for person in vocab.search('foo.bar')]
    [(u'name16', u'foo.bar@canonical.com')]

    A search using part of the host of an email address will not return
    anything, as we only match against the beginning of an email address.
    >>> list(vocab.search('canonical'))
    []

    A person with a single and unvalidated email address can be merged.
    >>> fooperson, email = getUtility(IPersonSet).createPersonAndEmail(
    ...     'foobaz@bar.com', name='foobaz', displayname='foo baz')
    >>> fooperson in vocab
    True

    But any person without a single email address can't.
    >>> email.destroySelf()
    >>> fooperson in vocab
    False

    Any person that's already merged is not part of this vocabulary:
    # XXX: Here we cheat because IPerson.merged is a readonly attribute.
    >>> from zope.security.proxy import removeSecurityProxy
    >>> removeSecurityProxy(fooperson).merged = 1
    >>> flush_database_updates()
    >>> fooperson in vocab
    False

o ValidPersonOrTeam - all 'valid' persons or teams. This is currently defined
  as people with a password, a preferred email address and not merged
  (Person.merged is None) or any team.

    >>> vocab = vocabulary_registry.get(None, "ValidPersonOrTeam")
    >>> vocab.displayname
    'Select a Person or Team'

    >>> list(vocab.search(None))
    []

    Almost all teams have the word 'team' as part of their names, so a search
    for 'team' should give us some of them.
    >>> sorted(person.name for person in vocab.search('team'))
    [u'name18', u'name19', u'name20', u'name21', u'testing-spanish-team', u'ubuntu-team']

    A search for 'support' will give us only the persons which have support
    as part of their name or displayname, or the beginning of
    one of its email addresses.
    >>> sorted(person.name for person in vocab.search('support'))
    [u'ubuntu-team']

    Dave hasn't validated his email address; he's not a valid Person.
    >>> sorted(person.name for person in vocab.search('dave.miller'))
    []

    'foo.bar@canonical.com' is a valid Person.
    >>> [person.name for person in vocab.search('foo.bar')]
    [u'name16']

o ValidOwner - all valid persons and teams are also valid owners.

    >>> vocab = vocabulary_registry.get(None, "ValidOwner")
    >>> vocab.displayname
    'Select a Person or Team'

    >>> list(vocab.search(None))
    []

    Almost all teams have the word 'team' as part of their names, so a search
    for 'team' should give us some of them.
    >>> sorted(person.name for person in vocab.search('team'))
    [u'name18', u'name19', u'name20', u'name21', u'testing-spanish-team', u'ubuntu-team']

o ValidTeamMember - With the exception of all teams that have this team as a
  member and the team itself, all valid persons and teams are valid
  members.

    >>> team = getUtility(IPersonSet).getByName('ubuntu-team')
    >>> team2 = getUtility(IPersonSet).getByName('guadamen')
    >>> person = getUtility(IPersonSet).getByName('name16')

    ValidTeamMember needs a context.
    >>> vocab = vocabulary_registry.get(None, "ValidTeamMember")
    Traceback (most recent call last):
    ...
    AssertionError: ...

    ValidTeamMember's context must implement ITeam.
    >>> vocab = vocabulary_registry.get(person, "ValidTeamMember")
    Traceback (most recent call last):
    ...
    AssertionError: ...

    'name16' is a valid member for 'ubuntu-team'
    >>> vocab = vocabulary_registry.get(team, "ValidTeamMember")
    >>> vocab.displayname
    'Select a Person or Team'

    >>> person in vocab
    True
    >>> [person.name for person in vocab.search('foo.bar')]
    [u'name16']

    'ubuntu-team' is not a valid member for itself
    >>> team in vocab
    False
    >>> [person.name for person in vocab.search('ubuntu-team')]
    [u'name18']

    'ubuntu-team' is a member of 'guadamen', so 'guadamen' can't be a member of
    'ubuntu-team'.
    >>> team2 in vocab
    False
    >>> [person.name for person in vocab.search('guadamen')]
    []

o ValidTeamOwner - With the exception of the team itself and all teams owned
  by that team, all valid persons and teams are valid owners for the team
  in context.

    ValidTeamOwner needs a context.
    >>> vocab = vocabulary_registry.get(None, "ValidTeamOwner")
    Traceback (most recent call last):
    ...
    AssertionError: ...

    ValidTeamOwner's context must be a team.

    >>> person = getUtility(IPersonSet).getByName('name16')
    >>> vocab = vocabulary_registry.get(person, "ValidTeamOwner")
    Traceback (most recent call last):
    ...
    AssertionError: ...

    'ubuntu-team' is not a valid owner for itself.
    >>> vocab = vocabulary_registry.get(team, "ValidTeamOwner")
    >>> vocab.displayname
    'Select a Person or Team'

    >>> team in vocab
    False
    >>> [person.name for person in vocab.search('ubuntu-team')]
    [u'name18']

    'name16' is a valid owner for 'ubuntu-team'.
    >>> person in vocab
    True
    >>> [person.name for person in vocab.search('foo.bar')]
    [u'name16']

o Processor - all processors type available in Launchpad.

    >>> vocab = vocabulary_registry.get(None, "Processor")
    >>> vocab.displayname
    'Select a Processor'

    >>> [processor.name for processor in vocab.search('386')]
    [u'386']

o SchemaVocabulary - launchpad Schema Vocabulary..

    >>> vocabulary = vocabulary_registry.get(None,"Schema")
    >>> vocabulary.displayname
    'Select a Schema'

    >>> list(vocabulary.search(None))
    []
    >>> [schema.name for schema in vocabulary.search("m")]
    [u'enema', u'mark', u'schema', u'trema']

o BugWatchVocabulary - all bug watches associated with a bugtask's bug

    >>> from canonical.launchpad.interfaces import IBugSet
    >>> bug_one = getUtility(IBugSet).get(1)
    >>> bugtask = bug_one.bugtasks[0]
    >>> vocab = vocabulary_registry.get(bugtask, "BugWatch")
    >>> for term in vocab:
    ...     print term.title
    The Mozilla.org Bug Tracker <a...>#123543</a>
    The Mozilla.org Bug Tracker <a...>#2000</a>
    The Mozilla.org Bug Tracker <a...>#42</a>
    Debian Bug tracker <a...>#304014</a>

XXX: document more vocabularies here, particularly when they break!
