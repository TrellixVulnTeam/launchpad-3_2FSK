= decorates module =

The decorates module provides helpers to convert adapter classes into
decorator classes.


== decorates() ==

The decorates function makes a class decorate another class to
implement an interface. It can be used in situations where a class
that implements a child interface wants to defer to another class that
implements the parent interface. So while the interfaces use an
inheritance mechanism, the classes use a composition mechanism.

For example we can define two interfaces IFoo0 <- IFoo...

    >>> from canonical.lazr import decorates
    >>> from zope.interface import Interface, Attribute
    >>> class IFoo0(Interface):
    ...     spoo = Attribute('attribute in IFoo0')

    >>> class IFoo(IFoo0):
    ...     def bar():
    ...         "some method"
    ...     baz = Attribute("some attribute")

And two classes (BaseFoo0 <- BaseFoo) that do something interesting.

    >>> class BaseFoo0:
    ...     spoo = 'some spoo'

    >>> class BaseFoo(BaseFoo0):
    ...     def bar(self):
    ...         return 'bar'
    ...     baz = 'hi baz!'

SomeClass can implement (decorate) IFoo using and instance of BaseFoo
as the context of the adaption. Note that decorates takes the interface
as the argument. The worker class is the context.

    >>> class SomeClass(object):
    ...     decorates(IFoo)
    ...     def __init__(self, context):
    ...         self.context = context

    >>> f = BaseFoo()
    >>> s = SomeClass(f)
    >>> s.bar()
    'bar'

    >>> s.baz
    'hi baz!'

    >>> s.spoo
    'some spoo'

    >>> IFoo.providedBy(s)
    True

The decorates function takes an optional keyword argument to assign
the decorated class to one of the decoratee's attributes other than
context. So an existing class, such as SomeOtherClass, can assign
the name of the attribute that is the decoratee, to state the
interface it implements.

    >>> class SomeOtherClass(object):
    ...     decorates(IFoo, context='myfoo')
    ...     def __init__(self, foo):
    ...         self.myfoo = foo
    ...     spoo = 'spoo from SomeOtherClass'

    >>> f = BaseFoo()
    >>> s = SomeOtherClass(f)
    >>> s.bar()
    'bar'

    >>> s.baz
    'hi baz!'

    >>> s.spoo
    'spoo from SomeOtherClass'

    >>> s.baz = 'fish'
    >>> s.baz
    'fish'

    >>> f.baz
    'fish'

The decorates() function can only be used in new-style classes. An
error is raised when a classic-style class is modified to implement an
interface.

    >>> class SomeClassicClass:
    ...     decorates(IFoo)
    Traceback (most recent call last):
    ...
    TypeError: Cannot use decorates() on a classic
        class: __builtin__.SomeClassicClass.

The decorates function cannot be used out side of a class definition,
such as in a module or in a function.

    >>> decorates(IFoo)
    Traceback (most recent call last):
    ...
    TypeError: Decorates can be used only from a class definition.


== Passthrough ==

The Passthrough class is the implementation machinery of decorates.
It takes two arguments, the name of an attribute or method that is
being adapted, and the name of the class attribute that holds the
instance that provides the aforementioned attribute or class.

To illustrate, p and p2 are two Passthrough instances that use the
instance assigned to 'mycontext' to call the 'foo' attribute and
the 'clsmethod' method.

    >>> from canonical.lazr import Passthrough
    >>> p = Passthrough('foo', 'mycontext')
    >>> p2 = Passthrough('clsmethod', 'mycontext')

Base is a class the implements both 'foo' and 'clsmethod'.

    >>> class Base:
    ...     foo = 'foo from Base'
    ...     def clsmethod(cls):
    ...         return str(cls)
    ...     clsmethod = classmethod(clsmethod)

Adapter is a class that has an instance of Base assigned to the
attribute 'mycontext'.

    >>> base = Base()

    >>> class Adapter:
    ...     mycontext = base

    >>> adapter = Adapter()

The Passthrough instances can get and set their prescribed attributes
when passed an instance of adapter.

    >>> p.__get__(adapter)
    'foo from Base'

    >>> p.__get__(None, Adapter) is p
    True

    >>> p2.__get__(adapter)()
    '__builtin__.Base'

    >>> p.__set__(adapter, 'new value')
    >>> base.foo
    'new value'

Passthrough does not implement __delete__. An error is raised if
it is called.

    >>> p.__delete__(adapter)
    Traceback (most recent call last):
    ...
    NotImplementedError

