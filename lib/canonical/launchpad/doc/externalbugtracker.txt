= Generic ExternalBugTracker Tests =

ExternalBugTracker instances are used to communicate with remote bug
trackers. This document tests those features that are common to all
ExternalBugTracker instances.

== Updating bug watches ==

All the ExternalBugTrackers know how to update the status of a bug
watch. The method that updates the bug watches is
BugWatchUpdater.updateBugWatches(), which expects an IExternalBugTracker
and the bug watches to update.


=== Initializing ===

Before updating the bug watches, the initializeRemoteBugDB() method on
the ExternalBugTracker is called. It gets the information for the bug
watches from the external bug tracker, and it's called outside a DB
transaction, since it doesn't need DB access.

    >>> from canonical.launchpad.ftests.externalbugtracker import (
    ...     TestExternalBugTracker)
    >>> class InitializingExternalBugTracker(TestExternalBugTracker):
    ...
    ...     def initializeRemoteBugDB(self, remote_bug_ids):
    ...         print "initializeRemoteBugDB() called: %r" % (
    ...             remote_bug_ids, )

    >>> class FakeTransaction:
    ...     """Transaction class to track transaction boundaries."""
    ...     def commit(self):
    ...         print "COMMIT"
    ...     def abort(self):
    ...         print "ABORT"
    ...     def begin(self):
    ...         print "BEGIN"

    >>> from canonical.launchpad.scripts.checkwatches import BugWatchUpdater
    >>> bug_watch_updater = BugWatchUpdater(FakeTransaction())
    >>> bug_watch_updater.updateBugWatches(
    ...     InitializingExternalBugTracker(), [])
    COMMIT
    initializeRemoteBugDB() called: []
    BEGIN


=== Choosing another ExternalBugTracker instance ===

Sometimes there are more than one ExternalBugTracker instance for a
single bug tracker type. For example, for different versions, for
intances having our Launchpad plugin installed, and so on. This is done
with the getExternalBugTrackerToUse() method, which returns the correct
instance.  Usually there is only one version, so the default is to
return itself.

    >>> from canonical.launchpad.components.externalbugtracker import (
    ...     ExternalBugTracker)
    >>> external_bugtracker = ExternalBugTracker('http://example.com/')
    >>> chosen_bugtracker = external_bugtracker.getExternalBugTrackerToUse()
    >>> chosen_bugtracker is external_bugtracker
    True

BugWatchUpdater.updateBugWatches will call this method and replace the
ExternalBugTracker used, before calling getCurrentDBTime(), and all the
other methods.

    >>> class MoreSpecificExternalBugTracker(TestExternalBugTracker):
    ...     def getCurrentDBTime(self):
    ...         print "Using more specific ExternalBugTracker implementation."

    >>> class GeneralExternalBugTracker:
    ...     def getExternalBugTrackerToUse(self):
    ...         return MoreSpecificExternalBugTracker('http://example.com')

    >>> bug_watch_updater.updateBugWatches(GeneralExternalBugTracker(), [])
    COMMIT
    Using more specific ExternalBugTracker implementation.
    BEGIN


=== Checking the server DB time ===

Before initializeRemoteBugDB is called and we start importing
information from the remote bug tracker, we check what the bug tracker
thinks the current time is. Returning None means that we don't know what
the time is.

    >>> class TimeUnknownExternalBugTracker(InitializingExternalBugTracker):
    ...
    ...     def getCurrentDBTime(self):
    ...         print "getCurrentDBTime() called"
    ...         return None

    >>> bug_watch_updater.updateBugWatches(
    ...     TimeUnknownExternalBugTracker(), [])
    COMMIT
    getCurrentDBTime() called
    initializeRemoteBugDB() called: []
    BEGIN

If the difference between what we and the remote system think the time
is, an error is raised.

    >>> import pytz
    >>> from datetime import datetime, timedelta
    >>> utc_now = datetime.now(pytz.timezone('UTC'))
    >>> class PositiveTimeSkewExternalBugTracker(TestExternalBugTracker):
    ...
    ...     def getCurrentDBTime(self):
    ...         return utc_now + timedelta(minutes=20)

    >>> bug_watch_updater.updateBugWatches(
    ...     PositiveTimeSkewExternalBugTracker(), [], now=utc_now)
    Traceback (most recent call last):
    ...
    TooMuchTimeSkew: ...

    >>> class NegativeTimeSkewExternalBugTracker(TestExternalBugTracker):
    ...
    ...     def getCurrentDBTime(self):
    ...         return utc_now - timedelta(minutes=20)

    >>> bug_watch_updater.updateBugWatches(
    ...     NegativeTimeSkewExternalBugTracker(), [], now=utc_now)
    Traceback (most recent call last):
    ...
    TooMuchTimeSkew: ...

If it's only a little skewed, it won't raise an error.

    >>> class CorrectTimeExternalBugTracker(TestExternalBugTracker):
    ...
    ...     def getCurrentDBTime(self):
    ...         return utc_now + timedelta(minutes=1)
    >>> bug_watch_updater.updateBugWatches(
    ...     CorrectTimeExternalBugTracker(), [], now=utc_now)
    COMMIT
    BEGIN

If the timezone is known, the local time time should be returned, rather
than the UTC time.

    >>> class LocalTimeExternalBugTracker(TestExternalBugTracker):
    ...
    ...     def getCurrentDBTime(self):
    ...         local_time = utc_now.astimezone(pytz.timezone('US/Eastern'))
    ...         return local_time + timedelta(minutes=1)
    >>> bug_watch_updater.updateBugWatches(
    ...     LocalTimeExternalBugTracker(), [], now=utc_now)
    COMMIT
    BEGIN

If the remote server time is unknown, we will refuse to import any
comments from it. Bug watches will still be updated, but a warning is
logged saying that comments won't be imported.

    >>> from zope.interface import implements
    >>> from canonical.launchpad.interfaces import ISupportsCommentImport
    >>> class CommentImportExternalBugTracker(TimeUnknownExternalBugTracker):
    ...     implements(ISupportsCommentImport)
    ...     import_comments = True
    >>> bug_watch_updater.updateBugWatches(
    ...     CommentImportExternalBugTracker(), [], now=utc_now)
    COMMIT
    getCurrentDBTime() called
    initializeRemoteBugDB() called: []
    BEGIN
    WARNING:...:Comment importing supported, but server time can't be
                trusted. No comments will be imported.


=== Limiting which bug watches to update ===

In order to reduce the amount of data we have to transfer over the
network, each IExternalBugTracker has the ability to filter out bugs
that haven't been modified. The method responsible for this is
getModifiedRemoteBugs(), which accepts the set of bugs that should be
checked, as well as the oldest time any of the bugs were last checked.
The getModifiedRemoteBugs() is only called for bug trackers where we
know that their time is similar to ours.

    >>> class CheckModifiedExternalBugTracker(InitializingExternalBugTracker):
    ...     def getCurrentDBTime(self):
    ...         return datetime.now(pytz.timezone('UTC'))
    ...     def getModifiedRemoteBugs(self, remote_bug_ids, last_checked):
    ...         print "last_checked: %s" % last_checked
    ...         print "getModifiedRemoteBugs() called: %r" % (
    ...             remote_bug_ids, )
    ...         return [remote_bug_ids[0], remote_bug_ids[-1]]
    ...     def getRemoteStatus(self, bug_id):
    ...         print "getRemoteStatus() called: %r" % bug_id
    ...         return 'UNKNOWN'

Only bugs that haven't been checked before are passed on to
getModifiedRemoteBugs(). I.e., if we have a set of newly created bug
watches, the getModifiedRemoteBugs() method won't be called.

    >>> from canonical.launchpad.database import BugTracker
    >>> from canonical.launchpad.interfaces import (
    ...     BugTrackerType, IBugSet, IBugWatchSet, IPersonSet)

    >>> sample_person = getUtility(IPersonSet).getByEmail(
    ...     'test@canonical.com')

    >>> example_bug_tracker = BugTracker(
    ...     name="example-bugs",
    ...     title="Example.com Bug Tracker",
    ...     bugtrackertype=BugTrackerType.BUGZILLA,
    ...     baseurl="http://bugs.example.com",
    ...     summary="Contains bugs for Example.com",
    ...     contactdetails="foo.bar@example.com",
    ...     owner=sample_person)
    >>> example_bug = getUtility(IBugSet).get(10)

    >>> bug_watches = [
    ...     getUtility(IBugWatchSet).createBugWatch(
    ...         example_bug, sample_person, example_bug_tracker, bug_id)
    ...     for bug_id in ['1', '2', '3', '4']]
    >>> bug_watch_ids = [bug_watch.id for bug_watch in bug_watches]
    >>> [bug_watch.lastchecked for bug_watch in bug_watches
    ...  if bug_watch.lastchecked is not None]
    []

    >>> bug_watch_updater.updateBugWatches(
    ...     CheckModifiedExternalBugTracker('http://example.com/'),
    ...     bug_watches)
    COMMIT
    initializeRemoteBugDB() called: [u'1', u'2', u'3', u'4']
    BEGIN
    getRemoteStatus() called: u'1'
    getRemoteStatus() called: u'2'
    getRemoteStatus() called: u'3'
    getRemoteStatus() called: u'4'

If the bug watches have the lastchecked attribute set, they will be
passed to getModifiedRemoteBugs(). Only the bugs that have been modified
will then be passed on to initializeRemoteBugDB().

    >>> some_time_ago = datetime(
    ...     2007, 03, 17, 16, 00, tzinfo=pytz.timezone('UTC'))
    >>> bug_watches = [
    ...     getUtility(IBugWatchSet).get(bug_watch_id)
    ...     for bug_watch_id in bug_watch_ids]
    >>> for bug_watch in bug_watches:
    ...     bug_watch.lastchecked = some_time_ago
    >>> flush_database_updates()

    >>> bug_watch_updater.updateBugWatches(
    ...     CheckModifiedExternalBugTracker('http://example.com/'),
    ...     bug_watches)
    COMMIT
    last_checked: 2007-03-17 15:...:...
    getModifiedRemoteBugs() called: [u'1', u'2', u'3', u'4']
    initializeRemoteBugDB() called: [u'1', u'4']
    BEGIN
    getRemoteStatus() called: u'1'
    getRemoteStatus() called: u'4'

The bug watches that are deemed as not being modified are still marked
as being checked.

    >>> bug_watches = [
    ...     getUtility(IBugWatchSet).get(bug_watch_id)
    ...     for bug_watch_id in bug_watch_ids]
    >>> for bug_watch in bug_watches:
    ...     if bug_watch.lastchecked > some_time_ago:
    ...         print "Bug %s was marked checked" % bug_watch.remotebug
    ...     else:
    ...         print "Bug %s was NOT marked checked" % bug_watch.remotebug
    Bug 1 was marked checked
    Bug 2 was marked checked
    Bug 3 was marked checked
    Bug 4 was marked checked

The time being passed to getModifiedRemoteBugs() is the oldest one of the
bug watches' lastchecked attribute, minus the acceptable time skew, and
then some more just to be safe.

    >>> bug_watches[0].lastchecked = some_time_ago
    >>> bug_watches[1].lastchecked = some_time_ago + timedelta(days=1)
    >>> bug_watches[2].lastchecked = some_time_ago - timedelta(hours=1)
    >>> bug_watches[3].lastchecked = some_time_ago - timedelta(days=1)
    >>> flush_database_updates()

    >>> bug_watch_updater.updateBugWatches(
    ...     CheckModifiedExternalBugTracker(), bug_watches)
    COMMIT
    last_checked: 2007-03-16 15:...:...

If some of the bug watches are new, they won't be passed on to
getModifiedRemoteBugs(), but they will still be passed to
initializeRemoteBugDB() since we do need to update them.

    >>> bug_watches[0].lastchecked = some_time_ago
    >>> bug_watches[1].lastchecked = None
    >>> bug_watches[2].lastchecked = None
    >>> bug_watches[3].lastchecked = some_time_ago - timedelta(days=1)
    >>> flush_database_updates()
    >>> bug_watch_updater.updateBugWatches(
    ...     CheckModifiedExternalBugTracker(), bug_watches)
    COMMIT
    last_checked: 2007-03-16 15:...:...
    getModifiedRemoteBugs() called: [u'1', u'4']
    initializeRemoteBugDB() called: [u'1', u'2', u'3', u'4']
    BEGIN
    getRemoteStatus() called: u'1'
    getRemoteStatus() called: u'2'
    getRemoteStatus() called: u'3'
    getRemoteStatus() called: u'4'

As mentioned earlier, getModifiedRemoteBugs() is only called if we can
get the current time of the remote system. If the time is unknown, we
always update all the bug watches.

    >>> class TimeUnknownExternalBugTracker(CheckModifiedExternalBugTracker):
    ...     def getCurrentDBTime(self):
    ...         return None
    >>> for bug_watch in bug_watches:
    ...     bug_watch.lastchecked = some_time_ago
    >>> flush_database_updates()
    >>> bug_watch_updater.updateBugWatches(
    ...     TimeUnknownExternalBugTracker(), bug_watches)
    COMMIT
    initializeRemoteBugDB() called: [u'1', u'2', u'3', u'4']
    BEGIN
    getRemoteStatus() called: u'1'
    getRemoteStatus() called: u'2'
    getRemoteStatus() called: u'3'
    getRemoteStatus() called: u'4'


=== Converting statuses ===

Once it has retrieved the bugs from the remote server, BugWatchUpdater
attempts to convert their statuses into Launchpad BugTaskStatuses by
calling the convertRemoteStatus() method on the ExternalBugTracker via
its own _convertRemoteStatus() method.

ExternalBugTracker.convertRemoteStatus() will either return a
BugTaskStatus or will raise an UnknownRemoteStatusError.

    >>> from canonical.launchpad.interfaces import BugTaskStatus
    >>> from canonical.launchpad.components.externalbugtracker import (
    ...     UnknownRemoteStatusError)
    >>> class StatusConvertingExternalBugTracker(TestExternalBugTracker):
    ...
    ...     def convertRemoteStatus(self, remote_status):
    ...         if remote_status == 'new':
    ...             return BugTaskStatus.NEW
    ...         else:
    ...             raise UnknownRemoteStatusError()

BugWatchUpdater._convertRemoteStatus() will handle these errors and will
return BugTaskStatus.UNKNOWN when they occur. It will also log a
warning.

    >>> status = bug_watch_updater._convertRemoteStatus(
    ...     StatusConvertingExternalBugTracker(), 'new')
    >>> print status.title
    New

    >>> status = bug_watch_updater._convertRemoteStatus(
    ...     StatusConvertingExternalBugTracker(), 'spam')
    WARNING...Unknown remote status 'spam'.
    >>> print status.title
    Unknown


== Configuration Options ==

All ExternalBugTrackers have a batch_query_threshold attribute which is
set by configuration options in launchpad.conf. This attribute is used
to decide whether or not bugs are exported from the remote server as a
batch (where possible) or individually.

The batch_query_threshold for a vanilla ExternalBugTracker should be the
same as that specified in launchpad.conf. We use a test version of
ExternalBugTracker here that doesn't actually do anything besides
fulfill the implementation requirements of IExternalBugTracker.

    >>> from canonical.config import config
    >>> from canonical.launchpad.ftests.externalbugtracker import (
    ...     TestExternalBugTracker)
    >>> tracker = TestExternalBugTracker('http://example.com/')
    >>> (tracker.batch_query_threshold ==
    ...     config.checkwatches.batch_query_threshold)
    True


== Error Handling ==

When an error occurs during the updating of bug watches it will be
recorded against the bug watches themselves so that it can be displayed
to users. We can test this by using a test version of
ExternalBugTracker.

    >>> import transaction
    >>> from canonical.launchpad.ftests.externalbugtracker import (
    ...     TestBrokenExternalBugTracker)
    >>> external_bugtracker = TestBrokenExternalBugTracker(
    ...     'http://example.com')
    >>> bug_watch_updater = BugWatchUpdater(transaction)

We'll create an example bug watch with which to test this. This will
be passed to external_bugtracker's updateBugWatches() method and should
have errors recorded against it. We log in as Sample Person to make
these changes since there's no particular need to use one Person over
another.

    >>> login('test@canonical.com')

    >>> example_bugwatch = example_bug.addWatch(
    ...     example_bug_tracker, 1, sample_person)

    >>> from canonical.launchpad.components.externalbugtracker import (
    ...     BugNotFound, BugTrackerConnectError, InvalidBugId,
    ...     UnparseableBugData, UnparseableBugTrackerVersion)

TestBrokenExternalBugTracker allows us to force errors to occur, so we
can use it to check that bug watches' last_error_types are being set
correctly.

We start with those errors that may be raised by
ExternalBugTracker.initializeRemoteBugDB(). We supress exceptions
because the bug watch's last error field will contain the data we need
for this test.

The bug watch's lastchecked field will also be updated, since not doing
so would mean that error-prone bug watches would be checked every time
checkwatches ran instead of just once every 24 hours like any other bug
watch.

    >>> for error in [BugTrackerConnectError, UnparseableBugData,
    ...               UnparseableBugTrackerVersion, Exception]:
    ...     example_bugwatch.lastchecked = None
    ...     external_bugtracker.initialize_remote_bugdb_error = error
    ...     try:
    ...         bug_watch_updater.updateBugWatches(
    ...             external_bugtracker, [example_bugwatch])
    ...     except error:
    ...         pass
    ...     print "%s: %s" % (example_bugwatch.last_error_type.title,
    ...         example_bugwatch.lastchecked is not None)
    Connection Error: True
    Unparsable Bug: True
    Unparsable Bug Tracker Version: True
    Unknown: True

We can run the same test on getRemoteStatus(), which can raise different
errors. We temporarily silence the logging from this function because
we're not interested in it. Again, the watch's lastchecked field also be
updated. Errors in getRemoteStatus() will produce OOPS reports.

    >>> from canonical.launchpad.ftests.externalbugtracker import oops_hook
    >>> oops_hook.install()

    >>> from canonical.launchpad.scripts import log
    >>> loglevel = log._log.level
    >>> external_bugtracker.initialize_remote_bugdb_error = None
    >>> try:
    ...     log._log.setLevel(100)
    ...     for error in [BugNotFound, InvalidBugId, UnparseableBugData,
    ...                   Exception]:
    ...         example_bugwatch.lastchecked = None
    ...         external_bugtracker.get_remote_status_error = error
    ...         bug_watch_updater.updateBugWatches(
    ...             external_bugtracker, [example_bugwatch])
    ...         print "%s: %s (%s)" % (
    ...             example_bugwatch.last_error_type.title,
    ...             example_bugwatch.lastchecked is not None,
    ...             oops_hook.oops_info.oopsid)
    ... finally:
    ...     log._log.setLevel(loglevel)
    Bug Not Found: True (OOPS-...)
    Invalid Bug ID: True (OOPS-...)
    Unparsable Bug: True (OOPS-...)
    Unknown: True (OOPS-...)

    >>> oops_hook.uninstall()
