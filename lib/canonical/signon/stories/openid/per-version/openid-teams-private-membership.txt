= Launchpad OpenID Teams Extension Restrictions on Private Teams =

The Launchpad OpenID Teams Extension provides a way for relying
parties to check a user's team membership.  Launchpad also supports
the concept of private membership teams.  We do not want Launchpad's
OpenID code to disclose details of private membership teams to
unauthorized RPs.

The sample data contains a private team called "myteam", which has a
member called "member":

    >>> from zope.component import getUtility
    >>> from canonical.launchpad.ftests import ANONYMOUS, login, logout
    >>> from canonical.launchpad.interfaces import IPersonSet

    >>> login(ANONYMOUS)
    >>> myteam = getUtility(IPersonSet).getByName('myteam')
    >>> member = getUtility(IPersonSet).getByName('member')
    >>> print myteam.visibility.name
    PRIVATE_MEMBERSHIP
    >>> print member.inTeam(myteam)
    True

The user-specific portion of member's OpenID URL is cCGE3LA:

    # Only admins and the person may access an openid_identifier.
    >>> login('foo.bar@canonical.com')
    >>> print member.account.openid_identifier
    cCGE3LA

    >>> logout()

Now let's set up an OpenID authentication request for this user,
checking to see whether they are a member of "myteam".  First we'll
set up the consumer:

    >>> from openid.consumer.consumer import Consumer
    >>> from openid.fetchers import setDefaultFetcher
    >>> from openid.store.memstore import MemoryStore
    >>> from canonical.signon.testing.openidhelpers import (
    ...     complete_from_browser, make_endpoint, PublisherFetcher)
    >>> setDefaultFetcher(PublisherFetcher())

    >>> openid_store = MemoryStore()
    >>> consumer = Consumer(session={}, store=openid_store)

Now perform the authentication request, using the teams extension to
query membership of "myteam":

    >>> endpoint = make_endpoint(
    ...     PROTOCOL_URI, 'http://openid.launchpad.dev/+id/cCGE3LA')
    >>> request = consumer.beginWithoutDiscovery(endpoint)

    >>> from canonical.signon.browser.openidserver import (
    ...     LAUNCHPAD_TEAMS_NS)
    >>> request.message.namespaces.addAlias(LAUNCHPAD_TEAMS_NS, 'lp')
    'lp'
    >>> request.addExtensionArg(
    ...     LAUNCHPAD_TEAMS_NS, 'query_membership', 'myteam')

    >>> browser.addHeader('Authorization', 'Basic member@canonical.com:test')
    >>> browser.open(request.redirectURL(
    ...     'http://launchpad.dev/', 'http://launchpad.dev/+openid-consumer'))
    >>> browser.getControl('Sign In', index=0).click()
    >>> print browser.url
    http://launchpad.dev/+openid-consumer?...

The authentication request is successful:

    >>> info = complete_from_browser(consumer, browser)
    >>> print info.status
    success

The authentication response includes a list of the teams the user is a
member of.  As "myteam" is private, Launchpad has not disclosed the
user's membership to the RP:

    >>> info.getSigned(LAUNCHPAD_TEAMS_NS, 'is_member')
    ''


== Trusted RPs ==

If the RP is known to Launchpad by having an OpenIDRPConfig and flagged
as being able to query private team membership (the 
IOpenIDRPConfig.can_query_any_team flag), then it is allowed to do so.
To test this, lets create an RP config:

    >>> from lp.services.openid.interfaces.openidrpconfig import (
    ...     IOpenIDRPConfigSet)
    >>> login('foo.bar@canonical.com')
    >>> rpconfig = getUtility(IOpenIDRPConfigSet).new(
    ...     trust_root='http://launchpad.dev/',
    ...     displayname='Test RP', description='A test RP')
    >>> logout()

Now perform a second authentication request:

    >>> endpoint = make_endpoint(
    ...     PROTOCOL_URI, 'http://openid.launchpad.dev/+id/cCGE3LA')
    >>> request = consumer.beginWithoutDiscovery(endpoint)
    >>> request.message.namespaces.addAlias(LAUNCHPAD_TEAMS_NS, 'lp')
    'lp'
    >>> request.addExtensionArg(
    ...     LAUNCHPAD_TEAMS_NS, 'query_membership', 'myteam')

    >>> browser.open(request.redirectURL(
    ...     'http://launchpad.dev/', 'http://launchpad.dev/+openid-consumer'))
    >>> browser.getControl('Sign In', index=0).click()
    >>> print browser.url
    http://launchpad.dev/+openid-consumer?...

The authentication request is successful:

    >>> info = complete_from_browser(consumer, browser)
    >>> print info.status
    success

However, even though the RP is known, it hasn't been given permission
to query private teams:

    >>> info.getSigned(LAUNCHPAD_TEAMS_NS, 'is_member')
    ''

So lets set the can_query_any_team flag on our RP config:

    >>> login('foo.bar@canonical.com')
    >>> rpconfig = getUtility(IOpenIDRPConfigSet).getByTrustRoot(
    ...     'http://launchpad.dev/')
    >>> rpconfig.can_query_any_team = True
    >>> logout()

Now if we authenticate again, Launchpad will informed us that
"member" is a member of "myteam":

    >>> endpoint = make_endpoint(
    ...     PROTOCOL_URI, 'http://openid.launchpad.dev/+id/cCGE3LA')
    >>> request = consumer.beginWithoutDiscovery(endpoint)
    >>> request.message.namespaces.addAlias(LAUNCHPAD_TEAMS_NS, 'lp')
    'lp'
    >>> request.addExtensionArg(
    ...     LAUNCHPAD_TEAMS_NS, 'query_membership', 'myteam')

    >>> browser.open(request.redirectURL(
    ...     'http://launchpad.dev/', 'http://launchpad.dev/+openid-consumer'))
    >>> browser.getControl('Sign In', index=0).click()
    >>> info = complete_from_browser(consumer, browser)
    >>> print info.status
    success

    >>> info.getSigned(LAUNCHPAD_TEAMS_NS, 'is_member')
    'myteam'


== Cleanup ==

    >>> setDefaultFetcher(None)
